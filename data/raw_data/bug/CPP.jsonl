{"question_id": "CPP/1", "category": "Syntax", "subtype": "illegal_comment", "level": "easy", "example": "* Examples:\n * >>> process_request(1)\n * 1\n * >>> process_request(10)\n * 6266", "docstring": "* Calculates the factorial of N modulo 10007.\n * \n * Parameters:\n * - N (int): An integer representing the input value (N <= 10000).\n * \n * Returns:\n * int: The result after calculating the factorial of N and\n * taking the modulo 10007.\n *", "canonical_solution": "#include <cassert>\n#include <cmath>\n#include <cstdio>\n#include <cstring>\n\nint process_request(int n)\n\n{\n    int a[10010];\n    a[0] = 1;\n    a[1] = 1;\n    for (register int i = 2; i <= 10000; i++) {\n        a[i] = (a[i - 1] * i) % 10007;\n    }\n    return a[n];\n}", "buggy_code": "#include <cassert>\n#include <cmath>\n#include <cstdio>\n#include <cstring>\nint process_request(int n)\n{\n    int a[10010];\n    a[0] = 1;\n    a[1] = 1;\n    # find the factorial\n    for (register int i = 2; i <= 10000; i++) {\n        a[i] = (a[i - 1] * i) % 10007;\n    }\n    return a[n];\n}", "bug_with_line_numbers": "   1 | #include <cassert>\n   2 | #include <cmath>\n   3 | #include <cstdio>\n   4 | #include <cstring>\n   5 | int process_request(int n)\n   6 | {\n   7 |     int a[10010];\n   8 |     a[0] = 1;\n   9 |     a[1] = 1;\n  10 |     # find the factorial\n  11 |     for (register int i = 2; i <= 10000; i++) {\n  12 |         a[i] = (a[i - 1] * i) % 10007;\n  13 |     }\n  14 |     return a[n];\n  15 | }", "fragment_lines": [10], "fragment_content": ["# find the factorial"], "test": "int main()\n{\n    assert(process_request(0) == 1); // Added test for boundary condition\n    assert(process_request(1) == 1);\n    assert(process_request(2) == 2);\n    assert(process_request(3) == 6);\n    assert(process_request(4) == 24);\n    assert(process_request(10) == 6266); // 10! % 10007 = 3628800 % 10007 = 6266\n    assert(process_request(10000) == 6991); // Added a test for upper boundary condition\n    // printf(\"All tests passed.\\n\");\n    return 0;\n}", "instruction": "Observe the following faulty CPP code\n```cpp\n#include <cassert>\n#include <cmath>\n#include <cstdio>\n#include <cstring>\nint process_request(int n)\n{\n    int a[10010];\n    a[0] = 1;\n    a[1] = 1;\n    # find the factorial\n    for (register int i = 2; i <= 10000; i++) {\n        a[i] = (a[i - 1] * i) % 10007;\n    }\n    return a[n];\n}\n```\nFix bugs in the given code snippet. The fixed code must be placed between ```cpp```. Do not generate any test, main,example usage or check code!\n"}
{"question_id": "CPP/2", "category": "Syntax", "subtype": "illegal_comment", "level": "easy", "example": "* Example Usage:\n * \n * create_id(\"fish\", \"cat\") returns \"ftiasch\"\n * create_id(\"icpc\", \"acm\") returns \"imccpac\"", "docstring": "* Generates a unique identifier by interweaving two words in a specified pattern.\n * @param word1 The first word to be used in the ID creation process.\n * @param word2 The second word to be used in the ID creation process.\n * @return A unique identifier formed by alternating characters from the second word,\n *         reversed, with characters from the first word.", "canonical_solution": "#include <iostream>\n#include <string>\n#include <cassert>\n\nstd::string create_id(const std::string& word1, const std::string& word2)\n\n{\n    std::string id;\n    int j = 0, k = word2.length() - 1;\n    for (int i = 0; i < word1.length() + word2.length(); ++i) {\n        if (i % 2 == 0) {\n            id += word1[j++];\n        } else {\n            id += word2[k--];\n        }\n    }\n    return id;\n}", "buggy_code": "#include <iostream>\n#include <string>\n#include <cassert>\nstd::string create_id(const std::string& word1, const std::string& word2)\n{\n    std::string id;\n    int j = 0, k = word2.length() - 1;\n    for (int i = 0; i < word1.length() + word2.length(); ++i) {\n        if (i % 2 == 0) {\n            id += word1[j++];\n        } else {\n            id += word2[k--];   ## Take character from word2 in reverse\n        }\n    }\n    return id;\n}", "bug_with_line_numbers": "   1 | #include <iostream>\n   2 | #include <string>\n   3 | #include <cassert>\n   4 | std::string create_id(const std::string& word1, const std::string& word2)\n   5 | {\n   6 |     std::string id;\n   7 |     int j = 0, k = word2.length() - 1;\n   8 |     for (int i = 0; i < word1.length() + word2.length(); ++i) {\n   9 |         if (i % 2 == 0) {\n  10 |             id += word1[j++];\n  11 |         } else {\n  12 |             id += word2[k--];   ## Take character from word2 in reverse\n  13 |         }\n  14 |     }\n  15 |     return id;\n  16 | }", "fragment_lines": [12], "fragment_content": ["id += word2[k--];   ## Take character from word2 in reverse"], "test": "int main() {\n    std::string id; // To hold the results from create_id\n\n    id = create_id(\"fish\", \"cat\");\n    assert(id.compare(\"ftiasch\") == 0);\n\n    id = create_id(\"icpc\", \"acm\");\n    assert(id.compare(\"imccpac\") == 0);\n\n    id = create_id(\"oo\", \"w\");\n    assert(id.compare(\"owo\") == 0);\n\n    // Add more test samples\n    id = create_id(\"hello\", \"world\");\n    assert(id.compare(\"hdellrloow\") == 0);\n\n    id = create_id(\"abc\", \"def\");\n    assert(id.compare(\"afbecd\") == 0);\n\n    id = create_id(\"buaanb\", \"nbbuaa\");\n    assert(id.compare(\"bauaauabnbbn\") == 0);\n\n    id = create_id(\"xtuisgood\", \"ilovextu\");\n    assert(id.compare(\"xuttuxiesvgooloid\") == 0);\n\n    // std::cout << \"All tests passed!\" << std::endl;\n\n    return 0;\n}", "instruction": "Observe the following faulty CPP code\n```cpp\n#include <iostream>\n#include <string>\n#include <cassert>\nstd::string create_id(const std::string& word1, const std::string& word2)\n{\n    std::string id;\n    int j = 0, k = word2.length() - 1;\n    for (int i = 0; i < word1.length() + word2.length(); ++i) {\n        if (i % 2 == 0) {\n            id += word1[j++];\n        } else {\n            id += word2[k--];   ## Take character from word2 in reverse\n        }\n    }\n    return id;\n}\n```\nFix bugs in the given code snippet. The fixed code must be placed between ```cpp```. Do not generate any test, main,example usage or check code!\n"}
{"question_id": "CPP/3", "category": "Syntax", "subtype": "illegal_separation", "level": "easy", "example": ">>> hamming_distance(1,2)\n\t2", "docstring": "Calculate the Hamming distance between two integers in binary representation.\n​    Parameters:\n- x (int): The first positive integer (x <= 1,000,000,000).\n- y (int): The second positive integer (y <= 1,000,000,000).\n​    Returns:\n​    int: The Hamming distance between x and y, i.e., the number of bits that need to be flipped\n​         to transform x into y in binary.", "canonical_solution": "#include <bits/stdc++.h>\n\nint hamming_distance(int x, int y)\n\n{\n    int distance = 0;\n    int xor_result = x ^ y;\n    while (xor_result) {\n        if (xor_result & 1) {\n            distance++;\n        }\n        xor_result >>= 1;\n    }\n    return distance;\n}", "buggy_code": "#include <bits/stdc++.h>\nint hamming_distance(int x, int y)\n{\n    int distance = 0;\n    int xor_result = x ^ y;\n    while (xor_result) {\n        if (xor_result & 1) {\n            distance++;\n        }\n    }\n    xor_result >>= 1;\n    \n    return distance;\n}", "bug_with_line_numbers": "   1 | #include <bits/stdc++.h>\n   2 | int hamming_distance(int x, int y)\n   3 | {\n   4 |     int distance = 0;\n   5 |     int xor_result = x ^ y;\n   6 |     while (xor_result) {\n   7 |         if (xor_result & 1) {\n   8 |             distance++;\n   9 |         }\n  10 |     }\n  11 |     xor_result >>= 1;\n  12 |     \n  13 |     return distance;\n  14 | }", "fragment_lines": [-1], "fragment_content": ["missing critical code snippet"], "test": "int main() {\n    assert(hamming_distance(1, 2) == 2); // 01 and 10 have 2 different bits\n    assert(hamming_distance(4, 7) == 2); // 100 and 111 have 2 different bits\n    assert(hamming_distance(25, 30) == 3); // Additional test: 11001 and 11110 have 3 different bits\n    assert(hamming_distance(0, 0) == 0); // Additional test: Same numbers have 0 different bits\n    assert(hamming_distance(0xFFFFFFF, 0x0000000) == 28); // Additional test: Max unsigned int and 0 have 32 different bits\n    return 0;\n}", "instruction": "Observe the following faulty CPP code\n```cpp\n#include <bits/stdc++.h>\nint hamming_distance(int x, int y)\n{\n    int distance = 0;\n    int xor_result = x ^ y;\n    while (xor_result) {\n        if (xor_result & 1) {\n            distance++;\n        }\n    }\n    xor_result >>= 1;\n    \n    return distance;\n}\n```\nFix bugs in the given code snippet. The fixed code must be placed between ```cpp```. Do not generate any test, main,example usage or check code!\n"}
{"question_id": "CPP/4", "category": "Syntax", "subtype": "illegal_separation", "level": "medium", "example": "* Example:\n *    >>> Is_Square({9})\n *    true", "docstring": "* Determines if it is possible to assemble the wooden squares from n buckets\n * into a single larger square, where each bucket contains squares with a side length of 1.\n * \n * Input: vector of numbers\n * \n * @param squares Vector containing the count of squares in each bucket.\n * @return True if it is possible to form a larger square, False otherwise.", "canonical_solution": "#include <cassert>\n#include <cmath>\n#include <vector>\n\nbool Is_Square(std::vector<int> squares)\n\n{\n    long long sum = 0;\n    for (int square : squares) {\n        sum += square; \n    }\n    int root = static_cast<int>(std::sqrt(sum));\n    return root * root == sum;\n}", "buggy_code": "#include <cassert>\n#include <cmath>\n#include <vector>\nbool Is_Square(std::vector<int> squares)\n{\n    long long sum = 0;\n    for (int square : squares) {\n        sum += square; \n        int root = static_cast<int>(std::sqrt(sum));\n    }\n    return root * root == sum;\n}", "bug_with_line_numbers": "   1 | #include <cassert>\n   2 | #include <cmath>\n   3 | #include <vector>\n   4 | bool Is_Square(std::vector<int> squares)\n   5 | {\n   6 |     long long sum = 0;\n   7 |     for (int square : squares) {\n   8 |         sum += square; \n   9 |         int root = static_cast<int>(std::sqrt(sum));\n  10 |     }\n  11 |     return root * root == sum;\n  12 | }", "fragment_lines": [10], "fragment_content": ["}"], "test": "int main() {\n    assert(Is_Square({9}) == true);\n    assert(Is_Square({14, 2}) == true);\n    assert(Is_Square({7, 7}) == false);\n    assert(Is_Square({1, 2, 3, 4, 5, 6, 7}) == false);\n    assert(Is_Square({1, 3, 5, 7, 9, 11}) == true);\n    assert(Is_Square({2, 2, 2, 2}) == false);\n\n    // Additional test cases\n    assert(Is_Square({4, 5, 6}) == false);\n    assert(Is_Square({16, 9, 4, 1}) == false);\n    assert(Is_Square({1, 1, 1, 1, 1}) == false);\n    assert(Is_Square({25, 25}) == false);\n    assert(Is_Square({10, 10, 5}) == true);\n\n    // All tests passed\n    return 0;\n}", "instruction": "Observe the following faulty CPP code\n```cpp\n#include <cassert>\n#include <cmath>\n#include <vector>\nbool Is_Square(std::vector<int> squares)\n{\n    long long sum = 0;\n    for (int square : squares) {\n        sum += square; \n        int root = static_cast<int>(std::sqrt(sum));\n    }\n    return root * root == sum;\n}\n```\nFix bugs in the given code snippet. The fixed code must be placed between ```cpp```. Do not generate any test, main,example usage or check code!\n"}
{"question_id": "CPP/5", "category": "Syntax", "subtype": "missing_colons", "level": "easy", "example": ">>> Example call: \nint max, min;\nfind_max_min(1,2,3, &max, &min);\nassert(max == 3 && min == 1);", "docstring": "Find the maximum and minimum of three distinct integers.\nParameters:\na (int): The first integer.\nb (int): The second integer.\nc (int): The third integer.\n\nReturns:\nTuple[int, int]: A tuple is not a concept in C; instead, we will return by Reference.", "canonical_solution": "#include <cassert>\n#include <cstdio>\n\nvoid find_max_min(int a, int b, int c, int *max, int *min)\n\n{\n    if (a > b) {\n        if (a > c) {\n            *max = a;\n            *min = (b < c) ? b : c;\n        } else {\n            *max = c;\n            *min = b;\n        }\n    } else if (b > c) {\n        *max = b;\n        *min = (a < c) ? a : c;\n    } else {\n        *max = c;\n        *min = a;\n    }\n}", "buggy_code": "#include <cassert>\n#include <cstdio>\nvoid find_max_min(int a, int b, int c, int *max, int *min)\n{\n    if (a > b) {\n        if (a > c) {\n            *max = a;\n            *min = (b < c) ? b c;\n        } else {\n            *max = c;\n            *min = b;\n        }\n    } else if (b > c) {\n        *max = b;\n        *min = (a < c) ? a : c;\n    } else {\n        *max = c;\n        *min = a;\n    }\n}", "bug_with_line_numbers": "   1 | #include <cassert>\n   2 | #include <cstdio>\n   3 | void find_max_min(int a, int b, int c, int *max, int *min)\n   4 | {\n   5 |     if (a > b) {\n   6 |         if (a > c) {\n   7 |             *max = a;\n   8 |             *min = (b < c) ? b c;\n   9 |         } else {\n  10 |             *max = c;\n  11 |             *min = b;\n  12 |         }\n  13 |     } else if (b > c) {\n  14 |         *max = b;\n  15 |         *min = (a < c) ? a : c;\n  16 |     } else {\n  17 |         *max = c;\n  18 |         *min = a;\n  19 |     }\n  20 | }", "fragment_lines": [8], "fragment_content": ["*min = (b < c) ? b c;"], "test": "int main() {\n    int max, min;\n\n    // Test with a set of values\n    find_max_min(1, 2, 3, &max, &min);\n    assert(max == 3 && min == 1);\n\n    // Additional tests\n    find_max_min(5, 3, 4, &max, &min);\n    assert(max == 5 && min == 3);\n\n    find_max_min(10, -2, 7, &max, &min);\n    assert(max == 10 && min == -2);\n\n    find_max_min(-1, -3, -2, &max, &min);\n    assert(max == -1 && min == -3);\n\n    return 0;\n}", "instruction": "Observe the following faulty CPP code\n```cpp\n#include <cassert>\n#include <cstdio>\nvoid find_max_min(int a, int b, int c, int *max, int *min)\n{\n    if (a > b) {\n        if (a > c) {\n            *max = a;\n            *min = (b < c) ? b c;\n        } else {\n            *max = c;\n            *min = b;\n        }\n    } else if (b > c) {\n        *max = b;\n        *min = (a < c) ? a : c;\n    } else {\n        *max = c;\n        *min = a;\n    }\n}\n```\nFix bugs in the given code snippet. The fixed code must be placed between ```cpp```. Do not generate any test, main,example usage or check code!\n"}
{"question_id": "CPP/6", "category": "Syntax", "subtype": "missing_colons", "level": "easy", "example": ">>> Example call: \nint max, min;\nfind_max_min(1,2,3, &max, &min);\nassert(max == 3 && min == 1);", "docstring": "Find the maximum and minimum of three distinct integers.\nParameters:\na (int): The first integer.\nb (int): The second integer.\nc (int): The third integer.\n\nReturns:\nTuple[int, int]: A tuple is not a concept in C; instead, we will return by Reference.", "canonical_solution": "#include <cassert>\n#include <cstdio>\n\nvoid find_max_min(int a, int b, int c, int *max, int *min)\n\n{\n    if (a > b) {\n        if (a > c) {\n            *max = a;\n            *min = (b < c) ? b : c;\n        } else {\n            *max = c;\n            *min = b;\n        }\n    } else if (b > c) {\n        *max = b;\n        *min = (a < c) ? a : c;\n    } else {\n        *max = c;\n        *min = a;\n    }\n}", "buggy_code": "#include <cassert>\n#include <cstdio>\nvoid find_max_min(int a, int b, int c, int *max, int *min)\n{\n    if (a > b) {\n        if (a > c) {\n            *max = a;\n            *min = (b < c) ? b : c;\n        } else {\n            *max = c;\n            *min = b;\n        }\n    } else if (b > c) {\n        *max = b;\n        *min = (a < c) ? a c;\n    } else {\n        *max = c;\n        *min = a;\n    }\n}", "bug_with_line_numbers": "   1 | #include <cassert>\n   2 | #include <cstdio>\n   3 | void find_max_min(int a, int b, int c, int *max, int *min)\n   4 | {\n   5 |     if (a > b) {\n   6 |         if (a > c) {\n   7 |             *max = a;\n   8 |             *min = (b < c) ? b : c;\n   9 |         } else {\n  10 |             *max = c;\n  11 |             *min = b;\n  12 |         }\n  13 |     } else if (b > c) {\n  14 |         *max = b;\n  15 |         *min = (a < c) ? a c;\n  16 |     } else {\n  17 |         *max = c;\n  18 |         *min = a;\n  19 |     }\n  20 | }", "fragment_lines": [15], "fragment_content": ["*min = (a < c) ? a c;"], "test": "int main() {\n    int max, min;\n\n    // Test with a set of values\n    find_max_min(1, 2, 3, &max, &min);\n    assert(max == 3 && min == 1);\n\n    // Additional tests\n    find_max_min(5, 3, 4, &max, &min);\n    assert(max == 5 && min == 3);\n\n    find_max_min(10, -2, 7, &max, &min);\n    assert(max == 10 && min == -2);\n\n    find_max_min(-1, -3, -2, &max, &min);\n    assert(max == -1 && min == -3);\n\n    return 0;\n}", "instruction": "Observe the following faulty CPP code\n```cpp\n#include <cassert>\n#include <cstdio>\nvoid find_max_min(int a, int b, int c, int *max, int *min)\n{\n    if (a > b) {\n        if (a > c) {\n            *max = a;\n            *min = (b < c) ? b : c;\n        } else {\n            *max = c;\n            *min = b;\n        }\n    } else if (b > c) {\n        *max = b;\n        *min = (a < c) ? a c;\n    } else {\n        *max = c;\n        *min = a;\n    }\n}\n```\nFix bugs in the given code snippet. The fixed code must be placed between ```cpp```. Do not generate any test, main,example usage or check code!\n"}
{"question_id": "CPP/7", "category": "Syntax", "subtype": "misused ==and=", "level": "easy", "example": "* Usage:\n *   count_odd_numbers(5, 1, 4, 3, 2, 5) should return 3", "docstring": "* Count the number of odd integers in a given list of numbers.\n * Parameters:\n * - count (int): The number of integers to evaluate.\n * - ... (int): A sequence of integers.\n * Returns:\n *   int: The count of odd numbers in the input list.", "canonical_solution": "#include <assert.h>\n#include <stdarg.h>\n\n\nint count_odd_numbers(int count, ...)\n\n{\n    va_list args;\n    va_start(args, count);\n    int ans = 0;\n    for (int i = 0; i < count; i++) {\n        int num = va_arg(args, int);\n        if (num & 1) {\n            ans++;\n        }\n    }\n    va_end(args);\n    return ans;\n}", "buggy_code": "#include <assert.h>\n#include <stdarg.h>\nint count_odd_numbers(int count, ...)\n{\n    va_list args;\n    va_start(args, count);\n    int ans == 0;\n    for (int i = 0; i < count; i++) {\n        int num = va_arg(args, int);\n        if (num & 1) {\n            ans++;\n        }\n    }\n    va_end(args);\n    return ans;\n}", "bug_with_line_numbers": "   1 | #include <assert.h>\n   2 | #include <stdarg.h>\n   3 | int count_odd_numbers(int count, ...)\n   4 | {\n   5 |     va_list args;\n   6 |     va_start(args, count);\n   7 |     int ans == 0;\n   8 |     for (int i = 0; i < count; i++) {\n   9 |         int num = va_arg(args, int);\n  10 |         if (num & 1) {\n  11 |             ans++;\n  12 |         }\n  13 |     }\n  14 |     va_end(args);\n  15 |     return ans;\n  16 | }", "fragment_lines": [7], "fragment_content": ["int ans == 0;"], "test": "int main() {\n    assert(count_odd_numbers(5, 1, 4, 3, 2, 5) == 3);\n    assert(count_odd_numbers(4, 2, 2, 0, 0) == 0);\n    assert(count_odd_numbers(6, 7, 7, 8, 1, 9, 10) == 4); // Additional Test Sample\n    // Uncomment the following line to print a success message\n    // std::printf(\"All tests passed!\\n\");\n    return 0;\n}", "instruction": "Observe the following faulty CPP code\n```cpp\n#include <assert.h>\n#include <stdarg.h>\nint count_odd_numbers(int count, ...)\n{\n    va_list args;\n    va_start(args, count);\n    int ans == 0;\n    for (int i = 0; i < count; i++) {\n        int num = va_arg(args, int);\n        if (num & 1) {\n            ans++;\n        }\n    }\n    va_end(args);\n    return ans;\n}\n```\nFix bugs in the given code snippet. The fixed code must be placed between ```cpp```. Do not generate any test, main,example usage or check code!\n"}
{"question_id": "CPP/8", "category": "Syntax", "subtype": "misused ==and=", "level": "easy", "example": "Examples:\n>>> count_acute_triangles(4, 1, 1, 1, 1)\n4", "docstring": "Count the number of acute-angled triangles that can be formed by selecting any 3 edges out of\na given set of edges.\n  \nArgs:\n- edges_count: The number of edges passed.\n- An arbitrary number of integer arguments representing the lengths of the edges.\n  \nReturns:\nint: The count of distinct acute-angled triangles that can be formed.", "canonical_solution": "#include <cassert>\n#include <cmath>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cstdarg>\n\nint count_acute_triangles(int edges_count, ...)\n\n{\n    va_list args;\n    va_start(args, edges_count);\n\n    int* edges = (int*) malloc(edges_count * sizeof(int));\n    for (int i = 0; i < edges_count; i++) {\n        edges[i] = va_arg(args, int);\n    }\n    va_end(args);\n\n    qsort(edges, edges_count, sizeof(int), (int (*)(const void *, const void *)) strcmp);\n\n\n    int sum = 0;\n    for (int i = 0; i < edges_count - 2; i++) {\n        for (int j = i + 1; j < edges_count - 1; j++) {\n            for (int k = j + 1; k < edges_count; k++) {\n                int x = edges[i], y = edges[j], z = edges[k];\n                if (x + y > z && x * x + y * y > z * z) {\n                    sum++;\n                }\n            }\n        }\n    }\n\n    free(edges);\n    return sum;\n}", "buggy_code": "#include <cassert>\n#include <cmath>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cstdarg>\nint count_acute_triangles(int edges_count, ...)\n{\n    va_list args;\n    va_start(args, edges_count);\n    int* edges = (int*) malloc(edges_count * sizeof(int));\n    for (int i = 0; i < edges_count; i++) {\n        edges[i] = va_arg(args, int);\n    }\n    va_end(args);\n    qsort(edges, edges_count, sizeof(int), (int (*)(const void *, const void *)) strcmp);\n    int sum = 0;\n    for (int i = 0; i < edges_count - 2; i++) {\n        for (int j == i + 1; j < edges_count - 1; j++) {\n            for (int k = j + 1; k < edges_count; k++) {\n                int x = edges[i], y = edges[j], z = edges[k];\n                if (x + y > z && x * x + y * y > z * z) {\n                    sum++;\n                }\n            }\n        }\n    }\n    free(edges);\n    return sum;\n}", "bug_with_line_numbers": "   1 | #include <cassert>\n   2 | #include <cmath>\n   3 | #include <cstdio>\n   4 | #include <cstdlib>\n   5 | #include <cstring>\n   6 | #include <cstdarg>\n   7 | int count_acute_triangles(int edges_count, ...)\n   8 | {\n   9 |     va_list args;\n  10 |     va_start(args, edges_count);\n  11 |     int* edges = (int*) malloc(edges_count * sizeof(int));\n  12 |     for (int i = 0; i < edges_count; i++) {\n  13 |         edges[i] = va_arg(args, int);\n  14 |     }\n  15 |     va_end(args);\n  16 |     qsort(edges, edges_count, sizeof(int), (int (*)(const void *, const void *)) strcmp);\n  17 |     int sum = 0;\n  18 |     for (int i = 0; i < edges_count - 2; i++) {\n  19 |         for (int j == i + 1; j < edges_count - 1; j++) {\n  20 |             for (int k = j + 1; k < edges_count; k++) {\n  21 |                 int x = edges[i], y = edges[j], z = edges[k];\n  22 |                 if (x + y > z && x * x + y * y > z * z) {\n  23 |                     sum++;\n  24 |                 }\n  25 |             }\n  26 |         }\n  27 |     }\n  28 |     free(edges);\n  29 |     return sum;\n  30 | }", "fragment_lines": [19], "fragment_content": ["for (int j == i + 1; j < edges_count - 1; j++) {"], "test": "int main() {\n    assert(count_acute_triangles(4, 1, 1, 1, 1) == 4);\n    assert(count_acute_triangles(3, 1, 2, 3) == 0);\n    // Additional tests to ensure correctness\n    assert(count_acute_triangles(5, 3, 4, 5, 7, 10) == 0);\n    assert(count_acute_triangles(6, 6, 8, 10, 5, 5, 5) == 4);\n    return 0;\n}", "instruction": "Observe the following faulty CPP code\n```cpp\n#include <cassert>\n#include <cmath>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cstdarg>\nint count_acute_triangles(int edges_count, ...)\n{\n    va_list args;\n    va_start(args, edges_count);\n    int* edges = (int*) malloc(edges_count * sizeof(int));\n    for (int i = 0; i < edges_count; i++) {\n        edges[i] = va_arg(args, int);\n    }\n    va_end(args);\n    qsort(edges, edges_count, sizeof(int), (int (*)(const void *, const void *)) strcmp);\n    int sum = 0;\n    for (int i = 0; i < edges_count - 2; i++) {\n        for (int j == i + 1; j < edges_count - 1; j++) {\n            for (int k = j + 1; k < edges_count; k++) {\n                int x = edges[i], y = edges[j], z = edges[k];\n                if (x + y > z && x * x + y * y > z * z) {\n                    sum++;\n                }\n            }\n        }\n    }\n    free(edges);\n    return sum;\n}\n```\nFix bugs in the given code snippet. The fixed code must be placed between ```cpp```. Do not generate any test, main,example usage or check code!\n"}
{"question_id": "CPP/9", "category": "Syntax", "subtype": "unclosed_parentheses", "level": "easy", "example": "Example usage:\nassert(decode_numbers(\"0000\") == 4);", "docstring": "Decode a series of numbers to reveal the pattern and understand the actual values \neach digit represents.\n\nEquations provided for Reference:\n0000=4 8888=8 1234=1 5678=3 9012=2 1357=0 2468=4\n\nParameters:\n- data_str: A constant character array (C-style string) representing a series of numbers. Length does not exceed 100.\n\nReturns:\nint: The result of each data string corresponding to the right-hand side of the equation.", "canonical_solution": "#include <cassert>\n#include <cstring>\n#include <iostream>\n\nint decode_numbers(const char* data_str)\n\n{\n    int a[] = {1, 0, 0, 0, 1, 0, 1, 0, 2, 1};\n    int ans = 0;\n    for(int i = 0; i < std::strlen(data_str); i++) {\n        ans += a[data_str[i] - '0'];\n    }\n    return ans;\n}", "buggy_code": "#include <cassert>\n#include <cstring>\n#include <iostream>\nint decode_numbers(const char* data_str)\n{\n    int a[] = {1, 0, 0, 0, 1, 0, 1, 0, 2, 1};\n    int ans = 0;\n    for(int i = 0; i < std::strlen(data_str; i++) {\n        ans += a[data_str[i] - '0'];\n    }\n    return ans;\n}", "bug_with_line_numbers": "   1 | #include <cassert>\n   2 | #include <cstring>\n   3 | #include <iostream>\n   4 | int decode_numbers(const char* data_str)\n   5 | {\n   6 |     int a[] = {1, 0, 0, 0, 1, 0, 1, 0, 2, 1};\n   7 |     int ans = 0;\n   8 |     for(int i = 0; i < std::strlen(data_str; i++) {\n   9 |         ans += a[data_str[i] - '0'];\n  10 |     }\n  11 |     return ans;\n  12 | }", "fragment_lines": [8], "fragment_content": ["for(int i = 0; i < std::strlen(data_str; i++) {"], "test": "int main() {\n    // Assert basic provided test cases\n    assert(decode_numbers(\"0000\") == 4);\n    assert(decode_numbers(\"8888\") == 8);\n    assert(decode_numbers(\"1234\") == 1);\n    assert(decode_numbers(\"5678\") == 3);\n    assert(decode_numbers(\"9012\") == 2);\n    assert(decode_numbers(\"1357\") == 0);\n    assert(decode_numbers(\"2468\") == 4);\n\n    // Assert additional test cases\n    assert(decode_numbers(\"9999\") == 4);\n    assert(decode_numbers(\"1111\") == 0);\n    assert(decode_numbers(\"2222\") == 0);\n    assert(decode_numbers(\"3333\") == 0);\n    assert(decode_numbers(\"4444\") == 4);\n    assert(decode_numbers(\"5555\") == 0);\n    assert(decode_numbers(\"6666\") == 4);\n    assert(decode_numbers(\"7777\") == 0);\n    assert(decode_numbers(\"0001\") == 3);\n    assert(decode_numbers(\"2301\") == 1);\n\n    // Indicate that all tests passed\n    // std::cout << \"All tests passed successfully!\" << std::endl;\n\n    return 0;\n}", "instruction": "Observe the following faulty CPP code\n```cpp\n#include <cassert>\n#include <cstring>\n#include <iostream>\nint decode_numbers(const char* data_str)\n{\n    int a[] = {1, 0, 0, 0, 1, 0, 1, 0, 2, 1};\n    int ans = 0;\n    for(int i = 0; i < std::strlen(data_str; i++) {\n        ans += a[data_str[i] - '0'];\n    }\n    return ans;\n}\n```\nFix bugs in the given code snippet. The fixed code must be placed between ```cpp```. Do not generate any test, main,example usage or check code!\n"}
{"question_id": "CPP/10", "category": "Syntax", "subtype": "unclosed_parentheses", "level": "easy", "example": "* Examples:\n *   >>> isPalindrome(\"racecar\")\n *   true\n *   >>> isPalindrome(\"hello\")\n *   false", "docstring": "* Determine if a given string is a palindrome. A palindrome is a word, phrase,\n * number, or other sequence of characters that reads the same forward and\n * backward (ignoring spaces, punctuation, and capitalization).", "canonical_solution": "#include <cassert>\n#include <cctype> \n#include <cstring>\n\nbool isPalindrome(const char* str)\n\n{\n    int start = 0;\n    int end = strlen(str) - 1;\n    \n    while (start < end) {\n        while (!isalnum(str[start]) && start < end) start++;\n        while (!isalnum(str[end]) && start < end) end--;\n        if (tolower(str[start]) != tolower(str[end]))\n            return false;\n        start++;\n        end--;\n    }\n    return true;\n}", "buggy_code": "#include <cassert>\n#include <cctype> \n#include <cstring>\nbool isPalindrome(const char* str)\n{\n    int start = 0;\n    int end = strlen(str) - 1;\n    \n    while (start < end) {\n        while (!isalnum(str[start]) && start < end) start++;\n        while (!isalnum(str[end]) && start < end) end--;\n        if (tolower(str[start]) != tolower(str[end]))\n            return false;\n        start++;\n        end--;\n    \n    return true;\n}", "bug_with_line_numbers": "   1 | #include <cassert>\n   2 | #include <cctype> \n   3 | #include <cstring>\n   4 | bool isPalindrome(const char* str)\n   5 | {\n   6 |     int start = 0;\n   7 |     int end = strlen(str) - 1;\n   8 |     \n   9 |     while (start < end) {\n  10 |         while (!isalnum(str[start]) && start < end) start++;\n  11 |         while (!isalnum(str[end]) && start < end) end--;\n  12 |         if (tolower(str[start]) != tolower(str[end]))\n  13 |             return false;\n  14 |         start++;\n  15 |         end--;\n  16 |     \n  17 |     return true;\n  18 | }", "fragment_lines": [-1], "fragment_content": ["missing critical code snippet"], "test": "int main()\n{\n    assert(isPalindrome(\"A man a plan a canal Panama\") == true);\n    assert(isPalindrome(\"No lemon, no melon\") == true);\n    assert(isPalindrome(\"Was it a car or a cat I saw\") == true);\n    assert(isPalindrome(\"Madam, in Eden, I'm Adam\") == true);\n    assert(isPalindrome(\"Never odd or even\") == true);\n    assert(isPalindrome(\"Eva, can I see bees in a cave\") == true);\n    assert(isPalindrome(\"hello\") == false);\n    assert(isPalindrome(\"GitHub\") == false);\n    assert(isPalindrome(\"programming\") == false);\n    \n    return 0;\n}", "instruction": "Observe the following faulty CPP code\n```cpp\n#include <cassert>\n#include <cctype> \n#include <cstring>\nbool isPalindrome(const char* str)\n{\n    int start = 0;\n    int end = strlen(str) - 1;\n    \n    while (start < end) {\n        while (!isalnum(str[start]) && start < end) start++;\n        while (!isalnum(str[end]) && start < end) end--;\n        if (tolower(str[start]) != tolower(str[end]))\n            return false;\n        start++;\n        end--;\n    \n    return true;\n}\n```\nFix bugs in the given code snippet. The fixed code must be placed between ```cpp```. Do not generate any test, main,example usage or check code!\n"}
{"question_id": "CPP/11", "category": "Syntax", "subtype": "unclosed_string", "level": "easy", "example": ">>> shift_characters(\"NS BFW, JAJSYX TK NRUTWYFSHJ FWJ YMJ WJXZQY TK YWNANFQ HFZXJX\")\n\"IN WAR, EVENTS OF IMPORTANCE ARE THE RESULT OF TRIVIAL CAUSES\"", "docstring": "Shifts all characters by 5 positions in alphabetical order. Only letters are replaced,\nand all letters are in uppercase.\n\nParameters:\ntext (std::string&): The input text to be processed, modified in place.\n\nReturns:\nstd::string&: The transformed text with characters shifted by 5 positions.", "canonical_solution": "#include <bits/stdc++.h>\n\nstd::string& shift_characters(std::string& text)\n\n{\n    size_t len = text.length();\n    for (size_t i = 0; i < len; ++i) {\n        if ('A' <= text[i] && text[i] <= 'E') {\n            text[i] = text[i] + 'V' - 'A';\n        } else if ('F' <= text[i] && text[i] <= 'Z') {\n            text[i] = text[i] + 'A' - 'F';\n        }\n    }\n    return text;\n}", "buggy_code": "#include <bits/stdc++.h>\nstd::string& shift_characters(std::string& text)\n{\n    size_t len = text.length();\n    for (size_t i = 0; i < len; ++i) {\n        if ('A' <= text[i] && text[i] <= 'E) {\n            text[i] = text[i] + 'V' - 'A';\n        } else if ('F' <= text[i] && text[i] <= 'Z') {\n            text[i] = text[i] + 'A' - 'F';\n        }\n    }\n    return text;\n}", "bug_with_line_numbers": "   1 | #include <bits/stdc++.h>\n   2 | std::string& shift_characters(std::string& text)\n   3 | {\n   4 |     size_t len = text.length();\n   5 |     for (size_t i = 0; i < len; ++i) {\n   6 |         if ('A' <= text[i] && text[i] <= 'E) {\n   7 |             text[i] = text[i] + 'V' - 'A';\n   8 |         } else if ('F' <= text[i] && text[i] <= 'Z') {\n   9 |             text[i] = text[i] + 'A' - 'F';\n  10 |         }\n  11 |     }\n  12 |     return text;\n  13 | }", "fragment_lines": [6], "fragment_content": ["if ('A' <= text[i] && text[i] <= 'E) {"], "test": "int main()\n{\n    std::string test1 = \"NS BFW, JAJSYX TK NRUTWYFSHJ FWJ YMJ WJXZQY TK YWNANFQ HFZXJX\";\n    std::string test2 = \"N BTZQI WFYMJW GJ KNWXY NS F QNYYQJ NGJWNFS ANQQFLJ YMFS XJHTSI NS WTRJ\";\n    std::string test3 = \"IFSLJW PSTBX KZQQ BJQQ YMFY HFJXFW NX RTWJ IFSLJWTZX YMFS MJ\";\n\n    assert(shift_characters(test1) == \"IN WAR, EVENTS OF IMPORTANCE ARE THE RESULT OF TRIVIAL CAUSES\");\n    assert(shift_characters(test2) == \"I WOULD RATHER BE FIRST IN A LITTLE IBERIAN VILLAGE THAN SECOND IN ROME\");\n    assert(shift_characters(test3) == \"DANGER KNOWS FULL WELL THAT CAESAR IS MORE DANGEROUS THAN HE\");\n    return 0;\n}", "instruction": "Observe the following faulty CPP code\n```cpp\n#include <bits/stdc++.h>\nstd::string& shift_characters(std::string& text)\n{\n    size_t len = text.length();\n    for (size_t i = 0; i < len; ++i) {\n        if ('A' <= text[i] && text[i] <= 'E) {\n            text[i] = text[i] + 'V' - 'A';\n        } else if ('F' <= text[i] && text[i] <= 'Z') {\n            text[i] = text[i] + 'A' - 'F';\n        }\n    }\n    return text;\n}\n```\nFix bugs in the given code snippet. The fixed code must be placed between ```cpp```. Do not generate any test, main,example usage or check code!\n"}
{"question_id": "CPP/12", "category": "Syntax", "subtype": "unclosed_string", "level": "medium", "example": "* Examples:\n * >>> minRoundsToSameChar(\"aab\")\n * 1\n * >>> minRoundsToSameChar(\"abc\")\n * 2\n * >>> minRoundsToSameChar(\"aaa\")\n * 0", "docstring": "* Given a string consisting of lowercase English letters, in each round you can change\n * one of the characters to another character. The question is: what is the minimum\n * number of rounds needed to make the string composed of the same character?\n *", "canonical_solution": "#include <cassert>\n#include <cstring>\n#include <iostream>\n\nint minRoundsToSameChar(const char* s)\n\n{\n    int charCount[26] = {0};\n    for (int i = 0; i < 26; i++) {\n        charCount[i] = 0;\n    }\n    while (*s) {\n        charCount[*s - 'a']++;\n        s++;\n    }\n    int maxCount = 0;\n    for (int i = 0; i < 26; i++) {\n        if (charCount[i] != 0 ) {\n            maxCount ++;\n        }\n    }\n\n    return maxCount - 1;\n}", "buggy_code": "#include <cassert>\n#include <cstring>\n#include <iostream>\nint minRoundsToSameChar(const char* s)\n{\n    int charCount[26] = {0};\n    for (int i = 0; i < 26; i++) {\n        charCount[i] = 0;\n    }\n    while (*s) {\n        charCount[*s - 'a]++;\n        s++;\n    }\n    int maxCount = 0;\n    for (int i = 0; i < 26; i++) {\n        if (charCount[i] != 0 ) {\n            maxCount ++;\n        }\n    }\n    return maxCount - 1;\n}", "bug_with_line_numbers": "   1 | #include <cassert>\n   2 | #include <cstring>\n   3 | #include <iostream>\n   4 | int minRoundsToSameChar(const char* s)\n   5 | {\n   6 |     int charCount[26] = {0};\n   7 |     for (int i = 0; i < 26; i++) {\n   8 |         charCount[i] = 0;\n   9 |     }\n  10 |     while (*s) {\n  11 |         charCount[*s - 'a]++;\n  12 |         s++;\n  13 |     }\n  14 |     int maxCount = 0;\n  15 |     for (int i = 0; i < 26; i++) {\n  16 |         if (charCount[i] != 0 ) {\n  17 |             maxCount ++;\n  18 |         }\n  19 |     }\n  20 |     return maxCount - 1;\n  21 | }", "fragment_lines": [11], "fragment_content": ["charCount[*s - 'a]++;"], "test": "int main() {\n    assert(minRoundsToSameChar(\"aab\") == 1);\n    assert(minRoundsToSameChar(\"abc\") == 2);\n    assert(minRoundsToSameChar(\"aaa\") == 0);\n    assert(minRoundsToSameChar(\"abab\") == 1);\n    assert(minRoundsToSameChar(\"zzzzz\") == 0);\n\n    return 0;\n}", "instruction": "Observe the following faulty CPP code\n```cpp\n#include <cassert>\n#include <cstring>\n#include <iostream>\nint minRoundsToSameChar(const char* s)\n{\n    int charCount[26] = {0};\n    for (int i = 0; i < 26; i++) {\n        charCount[i] = 0;\n    }\n    while (*s) {\n        charCount[*s - 'a]++;\n        s++;\n    }\n    int maxCount = 0;\n    for (int i = 0; i < 26; i++) {\n        if (charCount[i] != 0 ) {\n            maxCount ++;\n        }\n    }\n    return maxCount - 1;\n}\n```\nFix bugs in the given code snippet. The fixed code must be placed between ```cpp```. Do not generate any test, main,example usage or check code!\n"}
{"question_id": "CPP/13", "category": "Reference", "subtype": "faulty_indexing", "level": "medium", "example": "* Examples:\n * count_coloring_methods(1,1) returns 1\n * count_coloring_methods(2,2) returns 2", "docstring": "* Counts the number of different coloring methods for n squares with m colors,\n * considering the requirement that adjacent squares and the first/last squares\n * must have different colors.\n * \n * @param n The number of squares.\n * @param m The number of colors.\n * @return The count of different coloring methods satisfying the specified conditions.\n *         The result is modulo 1000003.\n *", "canonical_solution": "#include <cassert>\n#include <iostream>\n\nint count_coloring_methods(int n, int m)\n\n{\n    int f[1111];\n    if (n == 1) return m;\n    if (n == 2) return static_cast<long long>(m) * (m - 1) % 1000003;\n    f[1] = m;\n    f[2] = static_cast<long long>(m) * (m - 1) % 1000003;\n    f[3] = static_cast<long long>(f[2]) * (m - 2) % 1000003;\n    for(int i = 4; i <= n; ++i) {\n        f[i] = (static_cast<long long>(f[i - 1]) * (m - 2) % 1000003 +\n                static_cast<long long>(f[i - 2]) * (m - 1) % 1000003) % 1000003;\n    }\n    return f[n];\n}", "buggy_code": "#include <cassert>\n#include <iostream>\nint count_coloring_methods(int n, int m)\n{\n    int f[1111];\n    if (n == 1) return m;\n    if (n == 2) return static_cast<long long>(m) * (m - 1) % 1000003;\n    f[1] = m;\n    f[2] = static_cast<long long>(m) * (m - 1) % 1000003;\n    f[3] = static_cast<long long>(f[2]) * (m - 2) % 1000003;\n    for(int i = 4; i <= n; ++i) {\n        f[i-1] = (static_cast<long long>(f[i - 1]) * (m - 2) % 1000003 +\n                static_cast<long long>(f[i - 2]) * (m - 1) % 1000003) % 1000003;\n    }\n    return f[n];\n}", "bug_with_line_numbers": "   1 | #include <cassert>\n   2 | #include <iostream>\n   3 | int count_coloring_methods(int n, int m)\n   4 | {\n   5 |     int f[1111];\n   6 |     if (n == 1) return m;\n   7 |     if (n == 2) return static_cast<long long>(m) * (m - 1) % 1000003;\n   8 |     f[1] = m;\n   9 |     f[2] = static_cast<long long>(m) * (m - 1) % 1000003;\n  10 |     f[3] = static_cast<long long>(f[2]) * (m - 2) % 1000003;\n  11 |     for(int i = 4; i <= n; ++i) {\n  12 |         f[i-1] = (static_cast<long long>(f[i - 1]) * (m - 2) % 1000003 +\n  13 |                 static_cast<long long>(f[i - 2]) * (m - 1) % 1000003) % 1000003;\n  14 |     }\n  15 |     return f[n];\n  16 | }", "fragment_lines": [12], "fragment_content": ["f[i-1] = (static_cast<long long>(f[i - 1]) * (m - 2) % 1000003 +"], "test": "int main() {\n    assert(count_coloring_methods(1, 1) == 1);\n    assert(count_coloring_methods(2, 2) == 2);\n    assert(count_coloring_methods(3, 3) == 6);\n    assert(count_coloring_methods(4, 2) == 2);\n    assert(count_coloring_methods(1000, 10) == 566585); // We don't have the expected result for this case\n\n    // Additional test cases\n    assert(count_coloring_methods(2, 3) == 6);\n    assert(count_coloring_methods(1000, 1000) == 67911);\n    assert(count_coloring_methods(999, 66) == 501817);\n    assert(count_coloring_methods(5, 3) == 30); // Example of an expected output\n\n    // std::cout << \"All tests passed!\\n\";\n    return 0;\n}", "instruction": "Observe the following faulty CPP code\n```cpp\n#include <cassert>\n#include <iostream>\nint count_coloring_methods(int n, int m)\n{\n    int f[1111];\n    if (n == 1) return m;\n    if (n == 2) return static_cast<long long>(m) * (m - 1) % 1000003;\n    f[1] = m;\n    f[2] = static_cast<long long>(m) * (m - 1) % 1000003;\n    f[3] = static_cast<long long>(f[2]) * (m - 2) % 1000003;\n    for(int i = 4; i <= n; ++i) {\n        f[i-1] = (static_cast<long long>(f[i - 1]) * (m - 2) % 1000003 +\n                static_cast<long long>(f[i - 2]) * (m - 1) % 1000003) % 1000003;\n    }\n    return f[n];\n}\n```\nFix bugs in the given code snippet. The fixed code must be placed between ```cpp```. Do not generate any test, main,example usage or check code!\n"}
{"question_id": "CPP/14", "category": "Reference", "subtype": "faulty_indexing", "level": "hard", "example": "* Examples:\n *    >>> makeEqualAgain(3, (int[]){1, 2, 1})\n *    1\n *    >>> makeEqualAgain(5, (int[]){5, 5, 1, 5, 5})\n *    1", "docstring": "* You are given an array a of n integers. You can perform at most one operation where you\n * select three integers i, j, x (1 <= i <= j <= n) and replace all elements from a[i] to a[j] with x,\n * at a cost of (j - i + 1). Find the minimum cost to make all elements in the array equal.\n *", "canonical_solution": "#include <cstdio>\n#include <cassert>\n\nint makeEqualAgain(int n, int a[])\n\n{\n    int j = 0, p = 1, q = 0, c, d;\n    int k = n;\n    for (p = 1; p < k; p++) {\n        if (a[p] != a[p - 1])\n            break;\n    }\n    for (q = k - 1; q > p; q--) {\n        if (a[q] != a[p - 1])\n            break;\n    }\n    for (d = k - 2; d >= 0; d--) {\n        if (a[d] != a[d + 1])\n            break;\n    }\n    for (c = 0; c < d; c++) {\n        if (a[c] != a[c + 1])\n            break;\n    }\n    if (q - p + 1 < d - c + 1)\n        return q - p + 1;\n    else\n        return d - c + 1;\n}", "buggy_code": "#include <cstdio>\n#include <cassert>\nint makeEqualAgain(int n, int a[])\n{\n    int j = 0, p = 1, q = 0, c, d;\n    int k = n;\n    for (p = 1; p < k; p++) {\n        if (a[p] != a[p - 1])\n            break;\n    }\n    for (q = k - 1; q > p; q--) {\n        if (a[q-1] != a[p - 1])\n            break;\n    }\n    for (d = k - 2; d >= 0; d--) {\n        if (a[d] != a[d + 1])\n            break;\n    }\n    for (c = 0; c < d; c++) {\n        if (a[c] != a[c + 1])\n            break;\n    }\n    if (q - p + 1 < d - c + 1)\n        return q - p + 1;\n    else\n        return d - c + 1;\n}", "bug_with_line_numbers": "   1 | #include <cstdio>\n   2 | #include <cassert>\n   3 | int makeEqualAgain(int n, int a[])\n   4 | {\n   5 |     int j = 0, p = 1, q = 0, c, d;\n   6 |     int k = n;\n   7 |     for (p = 1; p < k; p++) {\n   8 |         if (a[p] != a[p - 1])\n   9 |             break;\n  10 |     }\n  11 |     for (q = k - 1; q > p; q--) {\n  12 |         if (a[q-1] != a[p - 1])\n  13 |             break;\n  14 |     }\n  15 |     for (d = k - 2; d >= 0; d--) {\n  16 |         if (a[d] != a[d + 1])\n  17 |             break;\n  18 |     }\n  19 |     for (c = 0; c < d; c++) {\n  20 |         if (a[c] != a[c + 1])\n  21 |             break;\n  22 |     }\n  23 |     if (q - p + 1 < d - c + 1)\n  24 |         return q - p + 1;\n  25 |     else\n  26 |         return d - c + 1;\n  27 | }", "fragment_lines": [12], "fragment_content": ["if (a[q-1] != a[p - 1])"], "test": "int main() {\n    int a1[] = {1,2,3,4,5,1};\n    int a2[] = {1,1,1,1,1,1,1};\n    int a3[] = {8,8,8,1,2,8,8,8};\n    int a4[] = {1,2,3};\n    int a5[] = {4,3,2,7,1,1,3};\n    int a6[] = {9,9,2,9,2,5,5,5,3};\n    \n    assert(makeEqualAgain(6, a1) == 4);\n    assert(makeEqualAgain(7, a2) == 0);\n    assert(makeEqualAgain(8, a3) == 2);\n    assert(makeEqualAgain(3, a4) == 2);\n    assert(makeEqualAgain(7, a5) == 6);\n    assert(makeEqualAgain(9, a6) == 7);\n\n    int a7[] = {1, 2, 1};\n    int a8[] = {5, 5, 1, 5, 5};\n    int a9[] = {1, 1, 1, 1};\n    int a10[] = {2, 2, 2, 3, 2, 2};\n    int a11[] = {1};\n    int a12[] = {1, 2};\n    int a13[] = {1, 2, 2, 1};\n    int a14[] = {4, 4, 4, 3, 3, 4, 4};\n    int a15[] = {5, 4, 4, 4, 5, 5};\n    int a16[] = {1, 2, 1, 2, 1, 2, 1};\n    // Additional provided tests\n    assert(makeEqualAgain(3, a7) == 1);\n    assert(makeEqualAgain(5, a8) == 1);\n    assert(makeEqualAgain(4, a9) == 0);\n    assert(makeEqualAgain(6, a10) == 1);\n    assert(makeEqualAgain(1, a11) == 0);\n    assert(makeEqualAgain(2, a12) == 1);\n    assert(makeEqualAgain(4, a13) == 2);\n    assert(makeEqualAgain(7, a14) == 2);\n    assert(makeEqualAgain(6, a15) == 3);\n    assert(makeEqualAgain(7, a16) == 5);\n    \n    return 0;\n}", "instruction": "Observe the following faulty CPP code\n```cpp\n#include <cstdio>\n#include <cassert>\nint makeEqualAgain(int n, int a[])\n{\n    int j = 0, p = 1, q = 0, c, d;\n    int k = n;\n    for (p = 1; p < k; p++) {\n        if (a[p] != a[p - 1])\n            break;\n    }\n    for (q = k - 1; q > p; q--) {\n        if (a[q-1] != a[p - 1])\n            break;\n    }\n    for (d = k - 2; d >= 0; d--) {\n        if (a[d] != a[d + 1])\n            break;\n    }\n    for (c = 0; c < d; c++) {\n        if (a[c] != a[c + 1])\n            break;\n    }\n    if (q - p + 1 < d - c + 1)\n        return q - p + 1;\n    else\n        return d - c + 1;\n}\n```\nFix bugs in the given code snippet. The fixed code must be placed between ```cpp```. Do not generate any test, main,example usage or check code!\n"}
{"question_id": "CPP/15", "category": "Reference", "subtype": "function_error", "level": "easy", "example": "* Examples:\n *   count_valid_coin_toss_sequences(1) returns 2\n *   count_valid_coin_toss_sequences(2) returns 3", "docstring": "* Count the number of valid coin toss sequences with no consecutive heads in n tosses.\n *\n * Parameters:\n * - n (int): The number of coin tosses.\n *\n * Returns:\n * - unsigned long long: The count of valid sequences.\n *", "canonical_solution": "#include <cassert>\n#include <cmath>\n#include <cstdio>\n#include <cstring>\n\nunsigned long long count_valid_coin_toss_sequences(int n)\n\n{\n    unsigned long long a[41][2];\n    a[1][0] = a[1][1] = 1;\n\n    for(int i = 2; i <= n; i++){\n        a[i][0] = a[i - 1][1] + a[i - 1][0];\n        a[i][1] = a[i - 1][0];\n    }\n\n    return a[n][0] + a[n][1];\n}", "buggy_code": "#include <cassert>\n#include <cmath>\n#include <cstdio>\n#include <cstring>\nunsigned long long count_valid_coin_toss_sequences(int *n)\n{\n    unsigned long long a[41][2];\n    a[1][0] = a[1][1] = 1;\n    for(int i = 2; i <= n; i++){\n        a[i][0] = a[i - 1][1] + a[i - 1][0];\n        a[i][1] = a[i - 1][0];\n    }\n    return a[n][0] + a[n][1];\n}", "bug_with_line_numbers": "   1 | #include <cassert>\n   2 | #include <cmath>\n   3 | #include <cstdio>\n   4 | #include <cstring>\n   5 | unsigned long long count_valid_coin_toss_sequences(int *n)\n   6 | {\n   7 |     unsigned long long a[41][2];\n   8 |     a[1][0] = a[1][1] = 1;\n   9 |     for(int i = 2; i <= n; i++){\n  10 |         a[i][0] = a[i - 1][1] + a[i - 1][0];\n  11 |         a[i][1] = a[i - 1][0];\n  12 |     }\n  13 |     return a[n][0] + a[n][1];\n  14 | }", "fragment_lines": [5], "fragment_content": ["unsigned long long count_valid_coin_toss_sequences(int *n)"], "test": "int main() {\n    assert(count_valid_coin_toss_sequences(1) == 2);\n    assert(count_valid_coin_toss_sequences(2) == 3);\n    assert(count_valid_coin_toss_sequences(3) == 5);\n    assert(count_valid_coin_toss_sequences(4) == 8); // Additional test\n    assert(count_valid_coin_toss_sequences(5) == 13); // Additional test\n    // Feel free to add more tests here\n    assert(count_valid_coin_toss_sequences(40) == 267914296ULL); // Additional test\n    assert(count_valid_coin_toss_sequences(39) == 165580141ULL);\n    assert(count_valid_coin_toss_sequences(38) == 102334155ULL);\n    // printf(\"All tests passed!\\n\");\n    return 0;\n}", "instruction": "Observe the following faulty CPP code\n```cpp\n#include <cassert>\n#include <cmath>\n#include <cstdio>\n#include <cstring>\nunsigned long long count_valid_coin_toss_sequences(int *n)\n{\n    unsigned long long a[41][2];\n    a[1][0] = a[1][1] = 1;\n    for(int i = 2; i <= n; i++){\n        a[i][0] = a[i - 1][1] + a[i - 1][0];\n        a[i][1] = a[i - 1][0];\n    }\n    return a[n][0] + a[n][1];\n}\n```\nFix bugs in the given code snippet. The fixed code must be placed between ```cpp```. Do not generate any test, main,example usage or check code!\n"}
{"question_id": "CPP/16", "category": "Reference", "subtype": "function_error", "level": "hard", "example": "* Example:\n * >>> maxModeSum(3, {1, 2, 3})\n * 17\n * A sequence that reaches its maximum value is (3,2,3,1,2,2).", "docstring": "* Given n positive integers representing the count of each number from 1 to n,\n * find the maximum sum of the mode (most frequent element) for all prefixes of\n * a sequence constructed from these numbers. The mode is the largest number among\n * the most frequent elements in a sequence.\n *", "canonical_solution": "#include <cassert>\n#include <cstdio>\n\nlong long maxModeSum(int n, const int* counts)\n\n{\n    long long ans = 0;\n    int mx = 0;\n    long long f[100000];\n    for (int i = 0; i <= n; ++i) f[i] = 0;\n\n    for (int i = n; i > 0; --i) {\n        while (mx < counts[i - 1]) {\n            mx++;\n            f[mx] = f[mx - 1] + i;\n        }\n        ans += f[counts[i - 1]];\n    }\n    return ans;\n}", "buggy_code": "#include <cassert>\n#include <cstdio>\nlong long maxModeSum(int n, const int counts)\n{\n    long long ans = 0;\n    int mx = 0;\n    long long f[100000];\n    for (int i = 0; i <= n; ++i) f[i] = 0;\n    for (int i = n; i > 0; --i) {\n        while (mx < counts[i - 1]) {\n            mx++;\n            f[mx] = f[mx - 1] + i;\n        }\n        ans += f[counts[i - 1]];\n    }\n    return ans;\n}", "bug_with_line_numbers": "   1 | #include <cassert>\n   2 | #include <cstdio>\n   3 | long long maxModeSum(int n, const int counts)\n   4 | {\n   5 |     long long ans = 0;\n   6 |     int mx = 0;\n   7 |     long long f[100000];\n   8 |     for (int i = 0; i <= n; ++i) f[i] = 0;\n   9 |     for (int i = n; i > 0; --i) {\n  10 |         while (mx < counts[i - 1]) {\n  11 |             mx++;\n  12 |             f[mx] = f[mx - 1] + i;\n  13 |         }\n  14 |         ans += f[counts[i - 1]];\n  15 |     }\n  16 |     return ans;\n  17 | }", "fragment_lines": [3], "fragment_content": ["long long maxModeSum(int n, const int counts)"], "test": "int main() {\n    int a1[] = {1, 3, 2};\n    int a2[] = {4, 1, 2, 3};\n    int a3[] = {1, 1};\n    int a4[] = {1, 2, 3, 4, 5};\n    int a5[] = {100000};\n    int a6[] = {5, 3, 2, 4, 1};\n    int a7[] = {100000, 100000, 100000};\n    int a8[] = {2, 2, 5};\n    int a9[] = {4, 4, 4, 4};\n    int a10[] = {1, 2, 3, 4, 5, 6};\n    int a11[] = {3, 1, 2};\n\n    assert(maxModeSum(3, a1) == 17);\n    assert(maxModeSum(4, a2) == 37);\n    assert(maxModeSum(2, a3) == 4);\n    assert(maxModeSum(5, a4) == 75);\n    assert(maxModeSum(1, a5) == 100000);\n    assert(maxModeSum(5, a6) == 62);\n    assert(maxModeSum(3, a7) == 900000);\n    assert(maxModeSum(3, a8) == 27);\n    assert(maxModeSum(4, a9) == 64);\n    assert(maxModeSum(6, a10) == 126);\n    assert(maxModeSum(3, a11) == 16);\n    return 0;\n}", "instruction": "Observe the following faulty CPP code\n```cpp\n#include <cassert>\n#include <cstdio>\nlong long maxModeSum(int n, const int counts)\n{\n    long long ans = 0;\n    int mx = 0;\n    long long f[100000];\n    for (int i = 0; i <= n; ++i) f[i] = 0;\n    for (int i = n; i > 0; --i) {\n        while (mx < counts[i - 1]) {\n            mx++;\n            f[mx] = f[mx - 1] + i;\n        }\n        ans += f[counts[i - 1]];\n    }\n    return ans;\n}\n```\nFix bugs in the given code snippet. The fixed code must be placed between ```cpp```. Do not generate any test, main,example usage or check code!\n"}
{"question_id": "CPP/17", "category": "Reference", "subtype": "illegal_keyword", "level": "easy", "example": "* Examples:\n *   >>> find_longest_consecutive_ones_length(7)\n *   3", "docstring": "* Find the length of the longest consecutive sequence of 1s in the binary \n * representation of a non-negative integer.\n *\n * Parameters:\n * - n (unsigned long long): A non-negative integer (0 ≤ n ≤ 2^64 - 1).\n *\n * Returns:\n * - int: The length of the longest consecutive sequence of 1s in the binary \n *        representation of the given integer.\n *", "canonical_solution": "#include <cassert>\n#include <cmath>\n#include <cstdio>\n#include <cstring>\n\nint find_longest_consecutive_ones_length(unsigned long long n)\n\n{\n    int max_length = 0;\n    int current_length = 0;\n    while (n) {\n        if (n & 1) {\n            current_length++;\n        } else {\n            if (current_length > max_length) {\n                max_length = current_length;\n            }\n            current_length = 0;\n        }\n        n >>= 1;\n    }\n    if (current_length > max_length) {\n        max_length = current_length;\n    }\n    return max_length;\n}", "buggy_code": "#include <cassert>\n#include <cmath>\n#include <cstdio>\n#include <cstring>\nint find_longest_consecutive_ones_length(unsigned long long n)\n{\n    int max_length = 0;\n    int return = 0;\n    while (n) {\n        if (n & 1) {\n            current_length++;\n        } else {\n            if (current_length > max_length) {\n                max_length = current_length;\n            }\n            current_length = 0;\n        }\n        n >>= 1;\n    }\n    if (current_length > max_length) {\n        max_length = current_length;\n    }\n    return max_length;\n}", "bug_with_line_numbers": "   1 | #include <cassert>\n   2 | #include <cmath>\n   3 | #include <cstdio>\n   4 | #include <cstring>\n   5 | int find_longest_consecutive_ones_length(unsigned long long n)\n   6 | {\n   7 |     int max_length = 0;\n   8 |     int return = 0;\n   9 |     while (n) {\n  10 |         if (n & 1) {\n  11 |             current_length++;\n  12 |         } else {\n  13 |             if (current_length > max_length) {\n  14 |                 max_length = current_length;\n  15 |             }\n  16 |             current_length = 0;\n  17 |         }\n  18 |         n >>= 1;\n  19 |     }\n  20 |     if (current_length > max_length) {\n  21 |         max_length = current_length;\n  22 |     }\n  23 |     return max_length;\n  24 | }", "fragment_lines": [8], "fragment_content": ["int return = 0;"], "test": "int main()\n{\n    assert(find_longest_consecutive_ones_length(7) == 3);\n    assert(find_longest_consecutive_ones_length(13) == 2);\n    assert(find_longest_consecutive_ones_length(12345) == 3); // New test sample\n    assert(find_longest_consecutive_ones_length(0b11011101111) == 4); // New test sample using binary literal for clarity\n    assert(find_longest_consecutive_ones_length(0xFFFFFFFF) == 32); // New test sample: all ones for a 32-bit number\n    assert(find_longest_consecutive_ones_length(0) == 0); // New test sample: no ones in a zero\n\n    // printf(\"All tests passed!\\n\"); // In C++, you might use std::cout, but it is commented out as per the original code.\n    return 0;\n}", "instruction": "Observe the following faulty CPP code\n```cpp\n#include <cassert>\n#include <cmath>\n#include <cstdio>\n#include <cstring>\nint find_longest_consecutive_ones_length(unsigned long long n)\n{\n    int max_length = 0;\n    int return = 0;\n    while (n) {\n        if (n & 1) {\n            current_length++;\n        } else {\n            if (current_length > max_length) {\n                max_length = current_length;\n            }\n            current_length = 0;\n        }\n        n >>= 1;\n    }\n    if (current_length > max_length) {\n        max_length = current_length;\n    }\n    return max_length;\n}\n```\nFix bugs in the given code snippet. The fixed code must be placed between ```cpp```. Do not generate any test, main,example usage or check code!\n"}
{"question_id": "CPP/18", "category": "Reference", "subtype": "illegal_keyword", "level": "medium", "example": "For example:\n    >>> countBalancedSubsequences(2, 2, 2)\n    2", "docstring": "Given three integers n, m, and k, find the number of sequences consisting of n '(' and m ')',\nsuch that the longest balanced subsequence is of length 2 * k. The result should be calculated modulo 1,000,000,007 (10^9 + 7).", "canonical_solution": "#include <cassert>\n\nlong long countBalancedSubsequences(long long n, long long m, long long k)\n\n{\n    const long long P = static_cast<long long>(1e9) + 7;\n    static long long C[4001][4001] = {0};\n\n    if (C[0][0] == 0) {\n        for (long long i = 0; i <= 4000; i++) C[i][0] = 1;\n        for (long long i = 1; i <= 4000; i++)\n            for (long long j = 1; j <= i; j++)\n                C[i][j] = (C[i - 1][j - 1] + C[i - 1][j]) % P;\n    }\n\n    if (k > n || k > m) return 0;\n    return (C[n + m][k] - C[n + m][k - 1] + P) % P;\n}", "buggy_code": "#include <cassert>\nlong long countBalancedSubsequences(long long n, long long m, long long k)\n{\n    const long long P = static_cast<long long>(1e9) + 7;\n    static long long const[4001][4001] = {0};\n    if (C[0][0] == 0) {\n        for (long long i = 0; i <= 4000; i++) C[i][0] = 1;\n        for (long long i = 1; i <= 4000; i++)\n            for (long long j = 1; j <= i; j++)\n                C[i][j] = (C[i - 1][j - 1] + C[i - 1][j]) % P;\n    }\n    if (k > n || k > m) return 0;\n    return (C[n + m][k] - C[n + m][k - 1] + P) % P;\n}", "bug_with_line_numbers": "   1 | #include <cassert>\n   2 | long long countBalancedSubsequences(long long n, long long m, long long k)\n   3 | {\n   4 |     const long long P = static_cast<long long>(1e9) + 7;\n   5 |     static long long const[4001][4001] = {0};\n   6 |     if (C[0][0] == 0) {\n   7 |         for (long long i = 0; i <= 4000; i++) C[i][0] = 1;\n   8 |         for (long long i = 1; i <= 4000; i++)\n   9 |             for (long long j = 1; j <= i; j++)\n  10 |                 C[i][j] = (C[i - 1][j - 1] + C[i - 1][j]) % P;\n  11 |     }\n  12 |     if (k > n || k > m) return 0;\n  13 |     return (C[n + m][k] - C[n + m][k - 1] + P) % P;\n  14 | }", "fragment_lines": [5], "fragment_content": ["static long long const[4001][4001] = {0};"], "test": "int main() {\n    assert(countBalancedSubsequences(2, 2, 2) == 2);\n    assert(countBalancedSubsequences(3, 2, 3) == 0);\n    assert(countBalancedSubsequences(3, 2, 1) == 4);\n    assert(countBalancedSubsequences(4, 3, 2) == 14);\n    assert(countBalancedSubsequences(5, 5, 2) == 35);\n    assert(countBalancedSubsequences(6, 1, 1) == 6);\n    assert(countBalancedSubsequences(1, 6, 1) == 6);\n    assert(countBalancedSubsequences(7, 2, 2) == 27);\n    assert(countBalancedSubsequences(8, 3, 3) == 110);\n    assert(countBalancedSubsequences(10, 10, 5) == 10659);\n    assert(countBalancedSubsequences(20, 20, 10) == 574221648);\n    assert(countBalancedSubsequences(2000, 2000, 1000) == 854104531);\n    assert(countBalancedSubsequences(2000, 1999, 1000) == 334874485);\n    assert(countBalancedSubsequences(2000, 2000, 1999) == 259428024);\n    return 0;\n}", "instruction": "Observe the following faulty CPP code\n```cpp\n#include <cassert>\nlong long countBalancedSubsequences(long long n, long long m, long long k)\n{\n    const long long P = static_cast<long long>(1e9) + 7;\n    static long long const[4001][4001] = {0};\n    if (C[0][0] == 0) {\n        for (long long i = 0; i <= 4000; i++) C[i][0] = 1;\n        for (long long i = 1; i <= 4000; i++)\n            for (long long j = 1; j <= i; j++)\n                C[i][j] = (C[i - 1][j - 1] + C[i - 1][j]) % P;\n    }\n    if (k > n || k > m) return 0;\n    return (C[n + m][k] - C[n + m][k - 1] + P) % P;\n}\n```\nFix bugs in the given code snippet. The fixed code must be placed between ```cpp```. Do not generate any test, main,example usage or check code!\n"}
{"question_id": "CPP/19", "category": "Reference", "subtype": "undefined_methods", "level": "hard", "example": ">>> countPermutations(2, 1, [1, 2])\n    2", "docstring": "Given a permutation q of n elements and an integer k, find the number of permutations p of n elements such that f(p) = q, where f(p) is the lexicographically smallest permutation that can be obtained by dividing p into exactly k non-empty contiguous segments and sorting each segment (i.e., choose k-1 breakpoints 1 <= x_1 < x_2 < ... < x_{k-1} < n, and divide it into [1, x_1], (x_1, x_2], ..., (x_{k-1}, n]). The result should be modulo 998244353.", "canonical_solution": "#include <bits/stdc++.h>\n\nint countPermutations(int n, int k, int qq[])\n\n{\n    const int N = 505, P = 998244353;\n    int q[N], m, dp[N][N], jc[N], f[N], ans;\n    memset(q, 0, sizeof(q));\n    memset(dp, 0, sizeof(dp));\n    memset(jc, 0, sizeof(jc));\n    memset(f, 0, sizeof(f));\n    ans = 0;\n\n    for (int i = 1; i <= n; i++)\n        q[i] = qq[i - 1];\n    dp[0][0] = f[0] = 1;\n    for (int i = jc[0] = 1; i <= n; i++)\n        jc[i] = 1LL * jc[i - 1] * i % P;\n    for (int i = 1; i <= n; i++)\n    {\n        f[i] = jc[i];\n        for (int j = 1; j < i; j++)\n            f[i] = (f[i] + P - 1LL * f[j] * jc[i - j] % P) % P;\n    }\n    for (int i = 1; i <= n; i++)\n    {\n        for (int j = 0; j < i; j++)\n            for (int k = 1; k <= n; k++)\n                dp[i][k] = (dp[i][k] + dp[j][k - 1] * 1LL * f[i - j] % P) % P;\n    }\n    m = 0;\n    for (int i = 1; i <= n; i++)\n        if (q[i] > q[i + 1])\n        {\n            m = i;\n            break;\n        }\n    if (m == n)\n    {\n        for (int i = k; i <= n; i++)\n            ans = (ans + dp[n][i]) % P;\n    }\n    else\n    {\n        for (int i = m + 1; i <= n; i++)\n        {\n            if (i != m + 1 && (q[i - 1] > q[i] || q[i] < q[m]))\n                break;\n            int c = k + i - n - 1;\n            if (c >= 0)\n                ans = (ans + dp[m][c] * 1LL * jc[i - m - 1] % P) % P;\n        }\n    }\n    return ans;\n}", "buggy_code": "int countPermutations(int n, int k, int qq[])\n{\n    const int N = 505, P = 998244353;\n    int q[N], m, dp[N][N], jc[N], f[N], ans;\n    memset(q, 0, sizeof(q));\n    memset(dp, 0, sizeof(dp));\n    memset(jc, 0, sizeof(jc));\n    memset(f, 0, sizeof(f));\n    ans = 0;\n    for (int i = 1; i <= n; i++)\n        q[i] = qq[i - 1];\n    dp[0][0] = f[0] = 1;\n    for (int i = jc[0] = 1; i <= n; i++)\n        jc[i] = 1LL * jc[i - 1] * i % P;\n    for (int i = 1; i <= n; i++)\n    {\n        f[i] = jc[i];\n        for (int j = 1; j < i; j++)\n            f[i] = (f[i] + P - 1LL * f[j] * jc[i - j] % P) % P;\n    }\n    for (int i = 1; i <= n; i++)\n    {\n        for (int j = 0; j < i; j++)\n            for (int k = 1; k <= n; k++)\n                dp[i][k] = (dp[i][k] + dp[j][k - 1] * 1LL * f[i - j] % P) % P;\n    }\n    m = 0;\n    for (int i = 1; i <= n; i++)\n        if (q[i] > q[i + 1])\n        {\n            m = i;\n            break;\n        }\n    if (m == n)\n    {\n        for (int i = k; i <= n; i++)\n            ans = (ans + dp[n][i]) % P;\n    }\n    else\n    {\n        for (int i = m + 1; i <= n; i++)\n        {\n            if (i != m + 1 && (q[i - 1] > q[i] || q[i] < q[m]))\n                break;\n            int c = k + i - n - 1;\n            if (c >= 0)\n                ans = (ans + dp[m][c] * 1LL * jc[i - m - 1] % P) % P;\n        }\n    }\n    return ans;\n}", "bug_with_line_numbers": "   1 | int countPermutations(int n, int k, int qq[])\n   2 | {\n   3 |     const int N = 505, P = 998244353;\n   4 |     int q[N], m, dp[N][N], jc[N], f[N], ans;\n   5 |     memset(q, 0, sizeof(q));\n   6 |     memset(dp, 0, sizeof(dp));\n   7 |     memset(jc, 0, sizeof(jc));\n   8 |     memset(f, 0, sizeof(f));\n   9 |     ans = 0;\n  10 |     for (int i = 1; i <= n; i++)\n  11 |         q[i] = qq[i - 1];\n  12 |     dp[0][0] = f[0] = 1;\n  13 |     for (int i = jc[0] = 1; i <= n; i++)\n  14 |         jc[i] = 1LL * jc[i - 1] * i % P;\n  15 |     for (int i = 1; i <= n; i++)\n  16 |     {\n  17 |         f[i] = jc[i];\n  18 |         for (int j = 1; j < i; j++)\n  19 |             f[i] = (f[i] + P - 1LL * f[j] * jc[i - j] % P) % P;\n  20 |     }\n  21 |     for (int i = 1; i <= n; i++)\n  22 |     {\n  23 |         for (int j = 0; j < i; j++)\n  24 |             for (int k = 1; k <= n; k++)\n  25 |                 dp[i][k] = (dp[i][k] + dp[j][k - 1] * 1LL * f[i - j] % P) % P;\n  26 |     }\n  27 |     m = 0;\n  28 |     for (int i = 1; i <= n; i++)\n  29 |         if (q[i] > q[i + 1])\n  30 |         {\n  31 |             m = i;\n  32 |             break;\n  33 |         }\n  34 |     if (m == n)\n  35 |     {\n  36 |         for (int i = k; i <= n; i++)\n  37 |             ans = (ans + dp[n][i]) % P;\n  38 |     }\n  39 |     else\n  40 |     {\n  41 |         for (int i = m + 1; i <= n; i++)\n  42 |         {\n  43 |             if (i != m + 1 && (q[i - 1] > q[i] || q[i] < q[m]))\n  44 |                 break;\n  45 |             int c = k + i - n - 1;\n  46 |             if (c >= 0)\n  47 |                 ans = (ans + dp[m][c] * 1LL * jc[i - m - 1] % P) % P;\n  48 |         }\n  49 |     }\n  50 |     return ans;\n  51 | }", "fragment_lines": [-1], "fragment_content": ["missing critical code snippet"], "test": "int main() {\n    int q1[] = {1, 2};\n    assert(countPermutations(2, 1, q1) == 2);\n\n    int q2[] = {3, 1, 2};\n    assert(countPermutations(3, 3, q2) == 1);\n\n    int q3[] = {1, 2, 3, 6, 5, 4};\n    assert(countPermutations(6, 3, q3) == 13);\n\n    int q4[] = {1, 2, 3, 4, 5, 6};\n    assert(countPermutations(6, 1, q4) == 720);\n\n    int q5[] = {1, 2, 5, 3, 4, 5};\n    assert(countPermutations(6, 3, q5) == 0);\n\n    int q6[] = {1, 2, 3, 4, 5, 6, 7, 8, 9};\n    assert(countPermutations(9, 9, q6) == 1);\n\n    int q7[] = {1, 2, 3, 4, 5, 6, 7, 9, 8};\n    assert(countPermutations(9, 2, q7) == 29093);\n    return 0;}", "instruction": "Observe the following faulty CPP code\n```cpp\nint countPermutations(int n, int k, int qq[])\n{\n    const int N = 505, P = 998244353;\n    int q[N], m, dp[N][N], jc[N], f[N], ans;\n    memset(q, 0, sizeof(q));\n    memset(dp, 0, sizeof(dp));\n    memset(jc, 0, sizeof(jc));\n    memset(f, 0, sizeof(f));\n    ans = 0;\n    for (int i = 1; i <= n; i++)\n        q[i] = qq[i - 1];\n    dp[0][0] = f[0] = 1;\n    for (int i = jc[0] = 1; i <= n; i++)\n        jc[i] = 1LL * jc[i - 1] * i % P;\n    for (int i = 1; i <= n; i++)\n    {\n        f[i] = jc[i];\n        for (int j = 1; j < i; j++)\n            f[i] = (f[i] + P - 1LL * f[j] * jc[i - j] % P) % P;\n    }\n    for (int i = 1; i <= n; i++)\n    {\n        for (int j = 0; j < i; j++)\n            for (int k = 1; k <= n; k++)\n                dp[i][k] = (dp[i][k] + dp[j][k - 1] * 1LL * f[i - j] % P) % P;\n    }\n    m = 0;\n    for (int i = 1; i <= n; i++)\n        if (q[i] > q[i + 1])\n        {\n            m = i;\n            break;\n        }\n    if (m == n)\n    {\n        for (int i = k; i <= n; i++)\n            ans = (ans + dp[n][i]) % P;\n    }\n    else\n    {\n        for (int i = m + 1; i <= n; i++)\n        {\n            if (i != m + 1 && (q[i - 1] > q[i] || q[i] < q[m]))\n                break;\n            int c = k + i - n - 1;\n            if (c >= 0)\n                ans = (ans + dp[m][c] * 1LL * jc[i - m - 1] % P) % P;\n        }\n    }\n    return ans;\n}\n```\nFix bugs in the given code snippet. The fixed code must be placed between ```cpp```. Do not generate any test, main,example usage or check code!\n"}
{"question_id": "CPP/20", "category": "Reference", "subtype": "undefined_objects", "level": "medium", "example": ">>> countPermutations(2, 1, [1, 2])\n    2", "docstring": "Given a permutation q of n elements and an integer k, find the number of permutations p of n elements such that f(p) = q, where f(p) is the lexicographically smallest permutation that can be obtained by dividing p into exactly k non-empty contiguous segments and sorting each segment (i.e., choose k-1 breakpoints 1 <= x_1 < x_2 < ... < x_{k-1} < n, and divide it into [1, x_1], (x_1, x_2], ..., (x_{k-1}, n]). The result should be modulo 998244353.", "canonical_solution": "#include <bits/stdc++.h>\n\nint countPermutations(int n, int k, int qq[])\n\n{\n    const int N = 505, P = 998244353;\n    int q[N], m, dp[N][N], jc[N], f[N], ans;\n    memset(q, 0, sizeof(q));\n    memset(dp, 0, sizeof(dp));\n    memset(jc, 0, sizeof(jc));\n    memset(f, 0, sizeof(f));\n    ans = 0;\n\n    for (int i = 1; i <= n; i++)\n        q[i] = qq[i - 1];\n    dp[0][0] = f[0] = 1;\n    for (int i = jc[0] = 1; i <= n; i++)\n        jc[i] = 1LL * jc[i - 1] * i % P;\n    for (int i = 1; i <= n; i++)\n    {\n        f[i] = jc[i];\n        for (int j = 1; j < i; j++)\n            f[i] = (f[i] + P - 1LL * f[j] * jc[i - j] % P) % P;\n    }\n    for (int i = 1; i <= n; i++)\n    {\n        for (int j = 0; j < i; j++)\n            for (int k = 1; k <= n; k++)\n                dp[i][k] = (dp[i][k] + dp[j][k - 1] * 1LL * f[i - j] % P) % P;\n    }\n    m = 0;\n    for (int i = 1; i <= n; i++)\n        if (q[i] > q[i + 1])\n        {\n            m = i;\n            break;\n        }\n    if (m == n)\n    {\n        for (int i = k; i <= n; i++)\n            ans = (ans + dp[n][i]) % P;\n    }\n    else\n    {\n        for (int i = m + 1; i <= n; i++)\n        {\n            if (i != m + 1 && (q[i - 1] > q[i] || q[i] < q[m]))\n                break;\n            int c = k + i - n - 1;\n            if (c >= 0)\n                ans = (ans + dp[m][c] * 1LL * jc[i - m - 1] % P) % P;\n        }\n    }\n    return ans;\n}", "buggy_code": "#include <bits/stdc++.h>\nint countPermutations(int n, int k, int qq[])\n{\n    int q[N], m, dp[N][N], jc[N], f[N], ans;\n    memset(q, 0, sizeof(q));\n    memset(dp, 0, sizeof(dp));\n    memset(jc, 0, sizeof(jc));\n    memset(f, 0, sizeof(f));\n    ans = 0;\n    for (int i = 1; i <= n; i++)\n        q[i] = qq[i - 1];\n    dp[0][0] = f[0] = 1;\n    for (int i = jc[0] = 1; i <= n; i++)\n        jc[i] = 1LL * jc[i - 1] * i % P;\n    for (int i = 1; i <= n; i++)\n    {\n        f[i] = jc[i];\n        for (int j = 1; j < i; j++)\n            f[i] = (f[i] + P - 1LL * f[j] * jc[i - j] % P) % P;\n    }\n    for (int i = 1; i <= n; i++)\n    {\n        for (int j = 0; j < i; j++)\n            for (int k = 1; k <= n; k++)\n                dp[i][k] = (dp[i][k] + dp[j][k - 1] * 1LL * f[i - j] % P) % P;\n    }\n    m = 0;\n    for (int i = 1; i <= n; i++)\n        if (q[i] > q[i + 1])\n        {\n            m = i;\n            break;\n        }\n    if (m == n)\n    {\n        for (int i = k; i <= n; i++)\n            ans = (ans + dp[n][i]) % P;\n    }\n    else\n    {\n        for (int i = m + 1; i <= n; i++)\n        {\n            if (i != m + 1 && (q[i - 1] > q[i] || q[i] < q[m]))\n                break;\n            int c = k + i - n - 1;\n            if (c >= 0)\n                ans = (ans + dp[m][c] * 1LL * jc[i - m - 1] % P) % P;\n        }\n    }\n    return ans;\n}", "bug_with_line_numbers": "   1 | #include <bits/stdc++.h>\n   2 | int countPermutations(int n, int k, int qq[])\n   3 | {\n   4 |     int q[N], m, dp[N][N], jc[N], f[N], ans;\n   5 |     memset(q, 0, sizeof(q));\n   6 |     memset(dp, 0, sizeof(dp));\n   7 |     memset(jc, 0, sizeof(jc));\n   8 |     memset(f, 0, sizeof(f));\n   9 |     ans = 0;\n  10 |     for (int i = 1; i <= n; i++)\n  11 |         q[i] = qq[i - 1];\n  12 |     dp[0][0] = f[0] = 1;\n  13 |     for (int i = jc[0] = 1; i <= n; i++)\n  14 |         jc[i] = 1LL * jc[i - 1] * i % P;\n  15 |     for (int i = 1; i <= n; i++)\n  16 |     {\n  17 |         f[i] = jc[i];\n  18 |         for (int j = 1; j < i; j++)\n  19 |             f[i] = (f[i] + P - 1LL * f[j] * jc[i - j] % P) % P;\n  20 |     }\n  21 |     for (int i = 1; i <= n; i++)\n  22 |     {\n  23 |         for (int j = 0; j < i; j++)\n  24 |             for (int k = 1; k <= n; k++)\n  25 |                 dp[i][k] = (dp[i][k] + dp[j][k - 1] * 1LL * f[i - j] % P) % P;\n  26 |     }\n  27 |     m = 0;\n  28 |     for (int i = 1; i <= n; i++)\n  29 |         if (q[i] > q[i + 1])\n  30 |         {\n  31 |             m = i;\n  32 |             break;\n  33 |         }\n  34 |     if (m == n)\n  35 |     {\n  36 |         for (int i = k; i <= n; i++)\n  37 |             ans = (ans + dp[n][i]) % P;\n  38 |     }\n  39 |     else\n  40 |     {\n  41 |         for (int i = m + 1; i <= n; i++)\n  42 |         {\n  43 |             if (i != m + 1 && (q[i - 1] > q[i] || q[i] < q[m]))\n  44 |                 break;\n  45 |             int c = k + i - n - 1;\n  46 |             if (c >= 0)\n  47 |                 ans = (ans + dp[m][c] * 1LL * jc[i - m - 1] % P) % P;\n  48 |         }\n  49 |     }\n  50 |     return ans;\n  51 | }", "fragment_lines": [-1], "fragment_content": ["missing critical code snippet"], "test": "int main() {\n    int q1[] = {1, 2};\n    assert(countPermutations(2, 1, q1) == 2);\n\n    int q2[] = {3, 1, 2};\n    assert(countPermutations(3, 3, q2) == 1);\n\n    int q3[] = {1, 2, 3, 6, 5, 4};\n    assert(countPermutations(6, 3, q3) == 13);\n\n    int q4[] = {1, 2, 3, 4, 5, 6};\n    assert(countPermutations(6, 1, q4) == 720);\n\n    int q5[] = {1, 2, 5, 3, 4, 5};\n    assert(countPermutations(6, 3, q5) == 0);\n\n    int q6[] = {1, 2, 3, 4, 5, 6, 7, 8, 9};\n    assert(countPermutations(9, 9, q6) == 1);\n\n    int q7[] = {1, 2, 3, 4, 5, 6, 7, 9, 8};\n    assert(countPermutations(9, 2, q7) == 29093);\n    return 0;}", "instruction": "Observe the following faulty CPP code\n```cpp\n#include <bits/stdc++.h>\nint countPermutations(int n, int k, int qq[])\n{\n    int q[N], m, dp[N][N], jc[N], f[N], ans;\n    memset(q, 0, sizeof(q));\n    memset(dp, 0, sizeof(dp));\n    memset(jc, 0, sizeof(jc));\n    memset(f, 0, sizeof(f));\n    ans = 0;\n    for (int i = 1; i <= n; i++)\n        q[i] = qq[i - 1];\n    dp[0][0] = f[0] = 1;\n    for (int i = jc[0] = 1; i <= n; i++)\n        jc[i] = 1LL * jc[i - 1] * i % P;\n    for (int i = 1; i <= n; i++)\n    {\n        f[i] = jc[i];\n        for (int j = 1; j < i; j++)\n            f[i] = (f[i] + P - 1LL * f[j] * jc[i - j] % P) % P;\n    }\n    for (int i = 1; i <= n; i++)\n    {\n        for (int j = 0; j < i; j++)\n            for (int k = 1; k <= n; k++)\n                dp[i][k] = (dp[i][k] + dp[j][k - 1] * 1LL * f[i - j] % P) % P;\n    }\n    m = 0;\n    for (int i = 1; i <= n; i++)\n        if (q[i] > q[i + 1])\n        {\n            m = i;\n            break;\n        }\n    if (m == n)\n    {\n        for (int i = k; i <= n; i++)\n            ans = (ans + dp[n][i]) % P;\n    }\n    else\n    {\n        for (int i = m + 1; i <= n; i++)\n        {\n            if (i != m + 1 && (q[i - 1] > q[i] || q[i] < q[m]))\n                break;\n            int c = k + i - n - 1;\n            if (c >= 0)\n                ans = (ans + dp[m][c] * 1LL * jc[i - m - 1] % P) % P;\n        }\n    }\n    return ans;\n}\n```\nFix bugs in the given code snippet. The fixed code must be placed between ```cpp```. Do not generate any test, main,example usage or check code!\n"}
{"question_id": "CPP/21", "category": "Logic", "subtype": "algorithm_error", "level": "hard", "example": "* Examples:\n * >>> process_request(1)\n * 1\n * >>> process_request(10)\n * 6266", "docstring": "* Calculates the factorial of N modulo 10007.\n * \n * Parameters:\n * - N (int): An integer representing the input value (N <= 10000).\n * \n * Returns:\n * int: The result after calculating the factorial of N and\n * taking the modulo 10007.\n *", "canonical_solution": "#include <cassert>\n#include <cmath>\n#include <cstdio>\n#include <cstring>\n\nint process_request(int n)\n\n{\n    int a[10010];\n    a[0] = 1;\n    a[1] = 1;\n    for (register int i = 2; i <= 10000; i++) {\n        a[i] = (a[i - 1] * i) % 10007;\n    }\n    return a[n];\n}", "buggy_code": "#include <cassert>\n#include <cmath>\n#include <cstdio>\n#include <cstring>\nint process_request(int n)\n{\n    int a[10010];\n    a[0] = 1;\n    a[1] = 1;\n    for (register int i = 2; i <= 10000; i++) {\n        a[i] = (a[i-1] + i) % 10007;\n    }\n    return a[n];\n}", "bug_with_line_numbers": "   1 | #include <cassert>\n   2 | #include <cmath>\n   3 | #include <cstdio>\n   4 | #include <cstring>\n   5 | int process_request(int n)\n   6 | {\n   7 |     int a[10010];\n   8 |     a[0] = 1;\n   9 |     a[1] = 1;\n  10 |     for (register int i = 2; i <= 10000; i++) {\n  11 |         a[i] = (a[i-1] + i) % 10007;\n  12 |     }\n  13 |     return a[n];\n  14 | }", "fragment_lines": [11], "fragment_content": ["a[i] = (a[i-1] + i) % 10007;"], "test": "int main()\n{\n    assert(process_request(0) == 1); // Added test for boundary condition\n    assert(process_request(1) == 1);\n    assert(process_request(2) == 2);\n    assert(process_request(3) == 6);\n    assert(process_request(4) == 24);\n    assert(process_request(10) == 6266); // 10! % 10007 = 3628800 % 10007 = 6266\n    assert(process_request(10000) == 6991); // Added a test for upper boundary condition\n    // printf(\"All tests passed.\\n\");\n    return 0;\n}", "instruction": "Observe the following faulty CPP code\n```cpp\n#include <cassert>\n#include <cmath>\n#include <cstdio>\n#include <cstring>\nint process_request(int n)\n{\n    int a[10010];\n    a[0] = 1;\n    a[1] = 1;\n    for (register int i = 2; i <= 10000; i++) {\n        a[i] = (a[i-1] + i) % 10007;\n    }\n    return a[n];\n}\n```\nFix bugs in the given code snippet. The fixed code must be placed between ```cpp```. Do not generate any test, main,example usage or check code!\n"}
{"question_id": "CPP/22", "category": "Logic", "subtype": "algorithm_error", "level": "easy", "example": ">>> hamming_distance(1,2)\n\t2", "docstring": "Calculate the Hamming distance between two integers in binary representation.\n​    Parameters:\n- x (int): The first positive integer (x <= 1,000,000,000).\n- y (int): The second positive integer (y <= 1,000,000,000).\n​    Returns:\n​    int: The Hamming distance between x and y, i.e., the number of bits that need to be flipped\n​         to transform x into y in binary.", "canonical_solution": "#include <bits/stdc++.h>\n\nint hamming_distance(int x, int y)\n\n{\n    int distance = 0;\n    int xor_result = x ^ y;\n    while (xor_result) {\n        if (xor_result & 1) {\n            distance++;\n        }\n        xor_result >>= 1;\n    }\n    return distance;\n}", "buggy_code": "#include <bits/stdc++.h>\nint hamming_distance(int x, int y)\n{\n    int distance = 1;\n    int xor_result = x ^ y;\n    while (xor_result) {\n        if (xor_result & 1) {\n            distance++;\n        }\n        xor_result >>= 1;\n    }\n    return distance;\n}", "bug_with_line_numbers": "   1 | #include <bits/stdc++.h>\n   2 | int hamming_distance(int x, int y)\n   3 | {\n   4 |     int distance = 1;\n   5 |     int xor_result = x ^ y;\n   6 |     while (xor_result) {\n   7 |         if (xor_result & 1) {\n   8 |             distance++;\n   9 |         }\n  10 |         xor_result >>= 1;\n  11 |     }\n  12 |     return distance;\n  13 | }", "fragment_lines": [4], "fragment_content": ["int distance = 1;"], "test": "int main() {\n    assert(hamming_distance(1, 2) == 2); // 01 and 10 have 2 different bits\n    assert(hamming_distance(4, 7) == 2); // 100 and 111 have 2 different bits\n    assert(hamming_distance(25, 30) == 3); // Additional test: 11001 and 11110 have 3 different bits\n    assert(hamming_distance(0, 0) == 0); // Additional test: Same numbers have 0 different bits\n    assert(hamming_distance(0xFFFFFFF, 0x0000000) == 28); // Additional test: Max unsigned int and 0 have 32 different bits\n    return 0;\n}", "instruction": "Observe the following faulty CPP code\n```cpp\n#include <bits/stdc++.h>\nint hamming_distance(int x, int y)\n{\n    int distance = 1;\n    int xor_result = x ^ y;\n    while (xor_result) {\n        if (xor_result & 1) {\n            distance++;\n        }\n        xor_result >>= 1;\n    }\n    return distance;\n}\n```\nFix bugs in the given code snippet. The fixed code must be placed between ```cpp```. Do not generate any test, main,example usage or check code!\n"}
{"question_id": "CPP/23", "category": "Logic", "subtype": "algorithm_error", "level": "medium", "example": "* Usage:\n *   count_odd_numbers(5, 1, 4, 3, 2, 5) should return 3", "docstring": "* Count the number of odd integers in a given list of numbers.\n * Parameters:\n * - count (int): The number of integers to evaluate.\n * - ... (int): A sequence of integers.\n * Returns:\n *   int: The count of odd numbers in the input list.", "canonical_solution": "#include <assert.h>\n#include <stdarg.h>\n\n\nint count_odd_numbers(int count, ...)\n\n{\n    va_list args;\n    va_start(args, count);\n    int ans = 0;\n    for (int i = 0; i < count; i++) {\n        int num = va_arg(args, int);\n        if (num & 1) {\n            ans++;\n        }\n    }\n    va_end(args);\n    return ans;\n}", "buggy_code": "#include <assert.h>\n#include <stdarg.h>\nint count_odd_numbers(int count, ...)\n{\n    va_list args;\n    va_start(args, count);\n    int ans = 0;\n    for (int i = 1; i < count; i++) {\n        int num = va_arg(args, int);\n        if (num & 1) {\n            ans++;\n        }\n    }\n    va_end(args);\n    return ans;\n}", "bug_with_line_numbers": "   1 | #include <assert.h>\n   2 | #include <stdarg.h>\n   3 | int count_odd_numbers(int count, ...)\n   4 | {\n   5 |     va_list args;\n   6 |     va_start(args, count);\n   7 |     int ans = 0;\n   8 |     for (int i = 1; i < count; i++) {\n   9 |         int num = va_arg(args, int);\n  10 |         if (num & 1) {\n  11 |             ans++;\n  12 |         }\n  13 |     }\n  14 |     va_end(args);\n  15 |     return ans;\n  16 | }", "fragment_lines": [8], "fragment_content": ["for (int i = 1; i < count; i++) {"], "test": "int main() {\n    assert(count_odd_numbers(5, 1, 4, 3, 2, 5) == 3);\n    assert(count_odd_numbers(4, 2, 2, 0, 0) == 0);\n    assert(count_odd_numbers(6, 7, 7, 8, 1, 9, 10) == 4); // Additional Test Sample\n    // Uncomment the following line to print a success message\n    // std::printf(\"All tests passed!\\n\");\n    return 0;\n}", "instruction": "Observe the following faulty CPP code\n```cpp\n#include <assert.h>\n#include <stdarg.h>\nint count_odd_numbers(int count, ...)\n{\n    va_list args;\n    va_start(args, count);\n    int ans = 0;\n    for (int i = 1; i < count; i++) {\n        int num = va_arg(args, int);\n        if (num & 1) {\n            ans++;\n        }\n    }\n    va_end(args);\n    return ans;\n}\n```\nFix bugs in the given code snippet. The fixed code must be placed between ```cpp```. Do not generate any test, main,example usage or check code!\n"}
{"question_id": "CPP/24", "category": "Logic", "subtype": "algorithm_error", "level": "medium", "example": "Example usage:\nassert(decode_numbers(\"0000\") == 4);", "docstring": "Decode a series of numbers to reveal the pattern and understand the actual values \neach digit represents.\n\nEquations provided for Reference:\n0000=4 8888=8 1234=1 5678=3 9012=2 1357=0 2468=4\n\nParameters:\n- data_str: A constant character array (C-style string) representing a series of numbers. Length does not exceed 100.\n\nReturns:\nint: The result of each data string corresponding to the right-hand side of the equation.", "canonical_solution": "#include <cassert>\n#include <cstring>\n#include <iostream>\n\nint decode_numbers(const char* data_str)\n\n{\n    int a[] = {1, 0, 0, 0, 1, 0, 1, 0, 2, 1};\n    int ans = 0;\n    for(int i = 0; i < std::strlen(data_str); i++) {\n        ans += a[data_str[i] - '0'];\n    }\n    return ans;\n}", "buggy_code": "#include <cassert>\n#include <cstring>\n#include <iostream>\nint decode_numbers(const char* data_str)\n{\n    int a[] = {1, 0, 0, 0, 1, 0, 1, 0, 2, 1};\n    int ans = 0;\n    for(int i = 1; i < std::strlen(data_str); i++) {\n        ans += a[data_str[i] - '0'];\n    }\n    return ans;\n}", "bug_with_line_numbers": "   1 | #include <cassert>\n   2 | #include <cstring>\n   3 | #include <iostream>\n   4 | int decode_numbers(const char* data_str)\n   5 | {\n   6 |     int a[] = {1, 0, 0, 0, 1, 0, 1, 0, 2, 1};\n   7 |     int ans = 0;\n   8 |     for(int i = 1; i < std::strlen(data_str); i++) {\n   9 |         ans += a[data_str[i] - '0'];\n  10 |     }\n  11 |     return ans;\n  12 | }", "fragment_lines": [8], "fragment_content": ["for(int i = 1; i < std::strlen(data_str); i++) {"], "test": "int main() {\n    // Assert basic provided test cases\n    assert(decode_numbers(\"0000\") == 4);\n    assert(decode_numbers(\"8888\") == 8);\n    assert(decode_numbers(\"1234\") == 1);\n    assert(decode_numbers(\"5678\") == 3);\n    assert(decode_numbers(\"9012\") == 2);\n    assert(decode_numbers(\"1357\") == 0);\n    assert(decode_numbers(\"2468\") == 4);\n\n    // Assert additional test cases\n    assert(decode_numbers(\"9999\") == 4);\n    assert(decode_numbers(\"1111\") == 0);\n    assert(decode_numbers(\"2222\") == 0);\n    assert(decode_numbers(\"3333\") == 0);\n    assert(decode_numbers(\"4444\") == 4);\n    assert(decode_numbers(\"5555\") == 0);\n    assert(decode_numbers(\"6666\") == 4);\n    assert(decode_numbers(\"7777\") == 0);\n    assert(decode_numbers(\"0001\") == 3);\n    assert(decode_numbers(\"2301\") == 1);\n\n    // Indicate that all tests passed\n    // std::cout << \"All tests passed successfully!\" << std::endl;\n\n    return 0;\n}", "instruction": "Observe the following faulty CPP code\n```cpp\n#include <cassert>\n#include <cstring>\n#include <iostream>\nint decode_numbers(const char* data_str)\n{\n    int a[] = {1, 0, 0, 0, 1, 0, 1, 0, 2, 1};\n    int ans = 0;\n    for(int i = 1; i < std::strlen(data_str); i++) {\n        ans += a[data_str[i] - '0'];\n    }\n    return ans;\n}\n```\nFix bugs in the given code snippet. The fixed code must be placed between ```cpp```. Do not generate any test, main,example usage or check code!\n"}
{"question_id": "CPP/25", "category": "Logic", "subtype": "algorithm_error", "level": "hard", "example": ">>> shift_characters(\"NS BFW, JAJSYX TK NRUTWYFSHJ FWJ YMJ WJXZQY TK YWNANFQ HFZXJX\")\n\"IN WAR, EVENTS OF IMPORTANCE ARE THE RESULT OF TRIVIAL CAUSES\"", "docstring": "Shifts all characters by 5 positions in alphabetical order. Only letters are replaced,\nand all letters are in uppercase.\n\nParameters:\ntext (std::string&): The input text to be processed, modified in place.\n\nReturns:\nstd::string&: The transformed text with characters shifted by 5 positions.", "canonical_solution": "#include <bits/stdc++.h>\n\nstd::string& shift_characters(std::string& text)\n\n{\n    size_t len = text.length();\n    for (size_t i = 0; i < len; ++i) {\n        if ('A' <= text[i] && text[i] <= 'E') {\n            text[i] = text[i] + 'V' - 'A';\n        } else if ('F' <= text[i] && text[i] <= 'Z') {\n            text[i] = text[i] + 'A' - 'F';\n        }\n    }\n    return text;\n}", "buggy_code": "#include <bits/stdc++.h>\nstd::string& shift_characters(std::string& text)\n{\n    size_t len = text.length();\n    for (size_t i = 0; i < len; ++i) {\n        if ('A' <= text[i] && text[i] <= 'E') {\n            text[i] = text[i] + 'V' - 'A';\n        } else if ('F' <= text[i] && text[i] <= 'Z') {\n            text[i] = text[i] + 'V' - 'A';\n        }\n    }\n    return text;\n}", "bug_with_line_numbers": "   1 | #include <bits/stdc++.h>\n   2 | std::string& shift_characters(std::string& text)\n   3 | {\n   4 |     size_t len = text.length();\n   5 |     for (size_t i = 0; i < len; ++i) {\n   6 |         if ('A' <= text[i] && text[i] <= 'E') {\n   7 |             text[i] = text[i] + 'V' - 'A';\n   8 |         } else if ('F' <= text[i] && text[i] <= 'Z') {\n   9 |             text[i] = text[i] + 'V' - 'A';\n  10 |         }\n  11 |     }\n  12 |     return text;\n  13 | }", "fragment_lines": [9], "fragment_content": ["text[i] = text[i] + 'V' - 'A';"], "test": "int main()\n{\n    std::string test1 = \"NS BFW, JAJSYX TK NRUTWYFSHJ FWJ YMJ WJXZQY TK YWNANFQ HFZXJX\";\n    std::string test2 = \"N BTZQI WFYMJW GJ KNWXY NS F QNYYQJ NGJWNFS ANQQFLJ YMFS XJHTSI NS WTRJ\";\n    std::string test3 = \"IFSLJW PSTBX KZQQ BJQQ YMFY HFJXFW NX RTWJ IFSLJWTZX YMFS MJ\";\n\n    assert(shift_characters(test1) == \"IN WAR, EVENTS OF IMPORTANCE ARE THE RESULT OF TRIVIAL CAUSES\");\n    assert(shift_characters(test2) == \"I WOULD RATHER BE FIRST IN A LITTLE IBERIAN VILLAGE THAN SECOND IN ROME\");\n    assert(shift_characters(test3) == \"DANGER KNOWS FULL WELL THAT CAESAR IS MORE DANGEROUS THAN HE\");\n    return 0;\n}", "instruction": "Observe the following faulty CPP code\n```cpp\n#include <bits/stdc++.h>\nstd::string& shift_characters(std::string& text)\n{\n    size_t len = text.length();\n    for (size_t i = 0; i < len; ++i) {\n        if ('A' <= text[i] && text[i] <= 'E') {\n            text[i] = text[i] + 'V' - 'A';\n        } else if ('F' <= text[i] && text[i] <= 'Z') {\n            text[i] = text[i] + 'V' - 'A';\n        }\n    }\n    return text;\n}\n```\nFix bugs in the given code snippet. The fixed code must be placed between ```cpp```. Do not generate any test, main,example usage or check code!\n"}
{"question_id": "CPP/26", "category": "Logic", "subtype": "condition_error", "level": "medium", "example": "* Examples:\n * count_coloring_methods(1,1) returns 1\n * count_coloring_methods(2,2) returns 2", "docstring": "* Counts the number of different coloring methods for n squares with m colors,\n * considering the requirement that adjacent squares and the first/last squares\n * must have different colors.\n * \n * @param n The number of squares.\n * @param m The number of colors.\n * @return The count of different coloring methods satisfying the specified conditions.\n *         The result is modulo 1000003.\n *", "canonical_solution": "#include <cassert>\n#include <iostream>\n\nint count_coloring_methods(int n, int m)\n\n{\n    int f[1111];\n    if (n == 1) return m;\n    if (n == 2) return static_cast<long long>(m) * (m - 1) % 1000003;\n    f[1] = m;\n    f[2] = static_cast<long long>(m) * (m - 1) % 1000003;\n    f[3] = static_cast<long long>(f[2]) * (m - 2) % 1000003;\n    for(int i = 4; i <= n; ++i) {\n        f[i] = (static_cast<long long>(f[i - 1]) * (m - 2) % 1000003 +\n                static_cast<long long>(f[i - 2]) * (m - 1) % 1000003) % 1000003;\n    }\n    return f[n];\n}", "buggy_code": "#include <cassert>\n#include <iostream>\nint count_coloring_methods(int n, int m)\n{\n    int f[1111];\n    if (n == 1) return m;\n    if (n == 2) return static_cast<long long>(m) * (m - 1) % 1000003;\n    f[1] = m;\n    f[2] = static_cast<long long>(m) * (m - 1) % 1000003;\n    f[3] = static_cast<long long>(f[2]) * (m - 2) % 1000003;\n    for(int i = 4; i < n; ++i) {\n        f[i] = (static_cast<long long>(f[i - 1]) * (m - 2) % 1000003 +\n                static_cast<long long>(f[i - 2]) * (m - 1) % 1000003) % 1000003;\n    }\n    return f[n];\n}", "bug_with_line_numbers": "   1 | #include <cassert>\n   2 | #include <iostream>\n   3 | int count_coloring_methods(int n, int m)\n   4 | {\n   5 |     int f[1111];\n   6 |     if (n == 1) return m;\n   7 |     if (n == 2) return static_cast<long long>(m) * (m - 1) % 1000003;\n   8 |     f[1] = m;\n   9 |     f[2] = static_cast<long long>(m) * (m - 1) % 1000003;\n  10 |     f[3] = static_cast<long long>(f[2]) * (m - 2) % 1000003;\n  11 |     for(int i = 4; i < n; ++i) {\n  12 |         f[i] = (static_cast<long long>(f[i - 1]) * (m - 2) % 1000003 +\n  13 |                 static_cast<long long>(f[i - 2]) * (m - 1) % 1000003) % 1000003;\n  14 |     }\n  15 |     return f[n];\n  16 | }", "fragment_lines": [11], "fragment_content": ["for(int i = 4; i < n; ++i) {"], "test": "int main() {\n    assert(count_coloring_methods(1, 1) == 1);\n    assert(count_coloring_methods(2, 2) == 2);\n    assert(count_coloring_methods(3, 3) == 6);\n    assert(count_coloring_methods(4, 2) == 2);\n    assert(count_coloring_methods(1000, 10) == 566585); // We don't have the expected result for this case\n\n    // Additional test cases\n    assert(count_coloring_methods(2, 3) == 6);\n    assert(count_coloring_methods(1000, 1000) == 67911);\n    assert(count_coloring_methods(999, 66) == 501817);\n    assert(count_coloring_methods(5, 3) == 30); // Example of an expected output\n\n    // std::cout << \"All tests passed!\\n\";\n    return 0;\n}", "instruction": "Observe the following faulty CPP code\n```cpp\n#include <cassert>\n#include <iostream>\nint count_coloring_methods(int n, int m)\n{\n    int f[1111];\n    if (n == 1) return m;\n    if (n == 2) return static_cast<long long>(m) * (m - 1) % 1000003;\n    f[1] = m;\n    f[2] = static_cast<long long>(m) * (m - 1) % 1000003;\n    f[3] = static_cast<long long>(f[2]) * (m - 2) % 1000003;\n    for(int i = 4; i < n; ++i) {\n        f[i] = (static_cast<long long>(f[i - 1]) * (m - 2) % 1000003 +\n                static_cast<long long>(f[i - 2]) * (m - 1) % 1000003) % 1000003;\n    }\n    return f[n];\n}\n```\nFix bugs in the given code snippet. The fixed code must be placed between ```cpp```. Do not generate any test, main,example usage or check code!\n"}
{"question_id": "CPP/27", "category": "Logic", "subtype": "condition_error", "level": "easy", "example": "* Examples:\n *   count_valid_coin_toss_sequences(1) returns 2\n *   count_valid_coin_toss_sequences(2) returns 3", "docstring": "* Count the number of valid coin toss sequences with no consecutive heads in n tosses.\n *\n * Parameters:\n * - n (int): The number of coin tosses.\n *\n * Returns:\n * - unsigned long long: The count of valid sequences.\n *", "canonical_solution": "#include <cassert>\n#include <cmath>\n#include <cstdio>\n#include <cstring>\n\nunsigned long long count_valid_coin_toss_sequences(int n)\n\n{\n    unsigned long long a[41][2];\n    a[1][0] = a[1][1] = 1;\n\n    for(int i = 2; i <= n; i++){\n        a[i][0] = a[i - 1][1] + a[i - 1][0];\n        a[i][1] = a[i - 1][0];\n    }\n\n    return a[n][0] + a[n][1];\n}", "buggy_code": "#include <cassert>\n#include <cmath>\n#include <cstdio>\n#include <cstring>\nunsigned long long count_valid_coin_toss_sequences(int n)\n{\n    unsigned long long a[41][2];\n    a[1][0] = a[1][1] = 1;\n    for(int i = 2; i < n; i++){\n        a[i][0] = a[i - 1][1] + a[i - 1][0];\n        a[i][1] = a[i - 1][0];\n    }\n    return a[n][0] + a[n][1];\n}", "bug_with_line_numbers": "   1 | #include <cassert>\n   2 | #include <cmath>\n   3 | #include <cstdio>\n   4 | #include <cstring>\n   5 | unsigned long long count_valid_coin_toss_sequences(int n)\n   6 | {\n   7 |     unsigned long long a[41][2];\n   8 |     a[1][0] = a[1][1] = 1;\n   9 |     for(int i = 2; i < n; i++){\n  10 |         a[i][0] = a[i - 1][1] + a[i - 1][0];\n  11 |         a[i][1] = a[i - 1][0];\n  12 |     }\n  13 |     return a[n][0] + a[n][1];\n  14 | }", "fragment_lines": [9], "fragment_content": ["for(int i = 2; i < n; i++){"], "test": "int main() {\n    assert(count_valid_coin_toss_sequences(1) == 2);\n    assert(count_valid_coin_toss_sequences(2) == 3);\n    assert(count_valid_coin_toss_sequences(3) == 5);\n    assert(count_valid_coin_toss_sequences(4) == 8); // Additional test\n    assert(count_valid_coin_toss_sequences(5) == 13); // Additional test\n    // Feel free to add more tests here\n    assert(count_valid_coin_toss_sequences(40) == 267914296ULL); // Additional test\n    assert(count_valid_coin_toss_sequences(39) == 165580141ULL);\n    assert(count_valid_coin_toss_sequences(38) == 102334155ULL);\n    // printf(\"All tests passed!\\n\");\n    return 0;\n}", "instruction": "Observe the following faulty CPP code\n```cpp\n#include <cassert>\n#include <cmath>\n#include <cstdio>\n#include <cstring>\nunsigned long long count_valid_coin_toss_sequences(int n)\n{\n    unsigned long long a[41][2];\n    a[1][0] = a[1][1] = 1;\n    for(int i = 2; i < n; i++){\n        a[i][0] = a[i - 1][1] + a[i - 1][0];\n        a[i][1] = a[i - 1][0];\n    }\n    return a[n][0] + a[n][1];\n}\n```\nFix bugs in the given code snippet. The fixed code must be placed between ```cpp```. Do not generate any test, main,example usage or check code!\n"}
{"question_id": "CPP/28", "category": "Logic", "subtype": "condition_error", "level": "easy", "example": "* Examples:\n *   >>> find_longest_consecutive_ones_length(7)\n *   3", "docstring": "* Find the length of the longest consecutive sequence of 1s in the binary \n * representation of a non-negative integer.\n *\n * Parameters:\n * - n (unsigned long long): A non-negative integer (0 ≤ n ≤ 2^64 - 1).\n *\n * Returns:\n * - int: The length of the longest consecutive sequence of 1s in the binary \n *        representation of the given integer.\n *", "canonical_solution": "#include <cassert>\n#include <cmath>\n#include <cstdio>\n#include <cstring>\n\nint find_longest_consecutive_ones_length(unsigned long long n)\n\n{\n    int max_length = 0;\n    int current_length = 0;\n    while (n) {\n        if (n & 1) {\n            current_length++;\n        } else {\n            if (current_length > max_length) {\n                max_length = current_length;\n            }\n            current_length = 0;\n        }\n        n >>= 1;\n    }\n    if (current_length > max_length) {\n        max_length = current_length;\n    }\n    return max_length;\n}", "buggy_code": "#include <cassert>\n#include <cmath>\n#include <cstdio>\n#include <cstring>\nint find_longest_consecutive_ones_length(unsigned long long n)\n{\n    int max_length = 0;\n    int current_length = 0;\n    while (n) {\n        if (n & 1) {\n            current_length++;\n        } else {\n            if (current_length < max_length) {\n                max_length = current_length;\n            }\n            current_length = 0;\n        }\n        n >>= 1;\n    }\n    if (current_length > max_length) {\n        max_length = current_length;\n    }\n    return max_length;\n}", "bug_with_line_numbers": "   1 | #include <cassert>\n   2 | #include <cmath>\n   3 | #include <cstdio>\n   4 | #include <cstring>\n   5 | int find_longest_consecutive_ones_length(unsigned long long n)\n   6 | {\n   7 |     int max_length = 0;\n   8 |     int current_length = 0;\n   9 |     while (n) {\n  10 |         if (n & 1) {\n  11 |             current_length++;\n  12 |         } else {\n  13 |             if (current_length < max_length) {\n  14 |                 max_length = current_length;\n  15 |             }\n  16 |             current_length = 0;\n  17 |         }\n  18 |         n >>= 1;\n  19 |     }\n  20 |     if (current_length > max_length) {\n  21 |         max_length = current_length;\n  22 |     }\n  23 |     return max_length;\n  24 | }", "fragment_lines": [13], "fragment_content": ["if (current_length < max_length) {"], "test": "int main()\n{\n    assert(find_longest_consecutive_ones_length(7) == 3);\n    assert(find_longest_consecutive_ones_length(13) == 2);\n    assert(find_longest_consecutive_ones_length(12345) == 3); // New test sample\n    assert(find_longest_consecutive_ones_length(0b11011101111) == 4); // New test sample using binary literal for clarity\n    assert(find_longest_consecutive_ones_length(0xFFFFFFFF) == 32); // New test sample: all ones for a 32-bit number\n    assert(find_longest_consecutive_ones_length(0) == 0); // New test sample: no ones in a zero\n\n    // printf(\"All tests passed!\\n\"); // In C++, you might use std::cout, but it is commented out as per the original code.\n    return 0;\n}", "instruction": "Observe the following faulty CPP code\n```cpp\n#include <cassert>\n#include <cmath>\n#include <cstdio>\n#include <cstring>\nint find_longest_consecutive_ones_length(unsigned long long n)\n{\n    int max_length = 0;\n    int current_length = 0;\n    while (n) {\n        if (n & 1) {\n            current_length++;\n        } else {\n            if (current_length < max_length) {\n                max_length = current_length;\n            }\n            current_length = 0;\n        }\n        n >>= 1;\n    }\n    if (current_length > max_length) {\n        max_length = current_length;\n    }\n    return max_length;\n}\n```\nFix bugs in the given code snippet. The fixed code must be placed between ```cpp```. Do not generate any test, main,example usage or check code!\n"}
{"question_id": "CPP/29", "category": "Logic", "subtype": "condition_error", "level": "easy", "example": "* Example Usage:\n * \n * create_id(\"fish\", \"cat\") returns \"ftiasch\"\n * create_id(\"icpc\", \"acm\") returns \"imccpac\"", "docstring": "* Generates a unique identifier by interweaving two words in a specified pattern.\n * @param word1 The first word to be used in the ID creation process.\n * @param word2 The second word to be used in the ID creation process.\n * @return A unique identifier formed by alternating characters from the second word,\n *         reversed, with characters from the first word.", "canonical_solution": "#include <iostream>\n#include <string>\n#include <cassert>\n\nstd::string create_id(const std::string& word1, const std::string& word2)\n\n{\n    std::string id;\n    int j = 0, k = word2.length() - 1;\n    for (int i = 0; i < word1.length() + word2.length(); ++i) {\n        if (i % 2 == 0) {\n            id += word1[j++];\n        } else {\n            id += word2[k--];\n        }\n    }\n    return id;\n}", "buggy_code": "#include <iostream>\n#include <string>\n#include <cassert>\nstd::string create_id(const std::string& word1, const std::string& word2)\n{\n    std::string id;\n    int j = 0, k = word2.length();\n    for (int i = 0; i <= word1.length() + word2.length(); ++i) {\n        if (i % 2 == 0) {\n            id += word1[j++];\n        } else {\n            id += word2[k--];\n        }\n    }\n    return id;\n}", "bug_with_line_numbers": "   1 | #include <iostream>\n   2 | #include <string>\n   3 | #include <cassert>\n   4 | std::string create_id(const std::string& word1, const std::string& word2)\n   5 | {\n   6 |     std::string id;\n   7 |     int j = 0, k = word2.length();\n   8 |     for (int i = 0; i <= word1.length() + word2.length(); ++i) {\n   9 |         if (i % 2 == 0) {\n  10 |             id += word1[j++];\n  11 |         } else {\n  12 |             id += word2[k--];\n  13 |         }\n  14 |     }\n  15 |     return id;\n  16 | }", "fragment_lines": [7], "fragment_content": ["int j = 0, k = word2.length();"], "test": "int main() {\n    std::string id; // To hold the results from create_id\n\n    id = create_id(\"fish\", \"cat\");\n    assert(id.compare(\"ftiasch\") == 0);\n\n    id = create_id(\"icpc\", \"acm\");\n    assert(id.compare(\"imccpac\") == 0);\n\n    id = create_id(\"oo\", \"w\");\n    assert(id.compare(\"owo\") == 0);\n\n    // Add more test samples\n    id = create_id(\"hello\", \"world\");\n    assert(id.compare(\"hdellrloow\") == 0);\n\n    id = create_id(\"abc\", \"def\");\n    assert(id.compare(\"afbecd\") == 0);\n\n    id = create_id(\"buaanb\", \"nbbuaa\");\n    assert(id.compare(\"bauaauabnbbn\") == 0);\n\n    id = create_id(\"xtuisgood\", \"ilovextu\");\n    assert(id.compare(\"xuttuxiesvgooloid\") == 0);\n\n    // std::cout << \"All tests passed!\" << std::endl;\n\n    return 0;\n}", "instruction": "Observe the following faulty CPP code\n```cpp\n#include <iostream>\n#include <string>\n#include <cassert>\nstd::string create_id(const std::string& word1, const std::string& word2)\n{\n    std::string id;\n    int j = 0, k = word2.length();\n    for (int i = 0; i <= word1.length() + word2.length(); ++i) {\n        if (i % 2 == 0) {\n            id += word1[j++];\n        } else {\n            id += word2[k--];\n        }\n    }\n    return id;\n}\n```\nFix bugs in the given code snippet. The fixed code must be placed between ```cpp```. Do not generate any test, main,example usage or check code!\n"}
{"question_id": "CPP/30", "category": "Logic", "subtype": "operation_error", "level": "easy", "example": "* Example:\n *    >>> Is_Square({9})\n *    true", "docstring": "* Determines if it is possible to assemble the wooden squares from n buckets\n * into a single larger square, where each bucket contains squares with a side length of 1.\n * \n * Input: vector of numbers\n * \n * @param squares Vector containing the count of squares in each bucket.\n * @return True if it is possible to form a larger square, False otherwise.", "canonical_solution": "#include <cassert>\n#include <cmath>\n#include <vector>\n\nbool Is_Square(std::vector<int> squares)\n\n{\n    long long sum = 0;\n    for (int square : squares) {\n        sum += square; \n    }\n    int root = static_cast<int>(std::sqrt(sum));\n    return root * root == sum;\n}", "buggy_code": "#include <cassert>\n#include <cmath>\n#include <vector>\nbool Is_Square(std::vector<int> squares)\n{\n    long long sum = 0;\n    for (int square : squares) {\n        sum -= square; \n    }\n    int root = static_cast<int>(std::sqrt(sum));\n    return root * root == sum;\n}", "bug_with_line_numbers": "   1 | #include <cassert>\n   2 | #include <cmath>\n   3 | #include <vector>\n   4 | bool Is_Square(std::vector<int> squares)\n   5 | {\n   6 |     long long sum = 0;\n   7 |     for (int square : squares) {\n   8 |         sum -= square; \n   9 |     }\n  10 |     int root = static_cast<int>(std::sqrt(sum));\n  11 |     return root * root == sum;\n  12 | }", "fragment_lines": [8], "fragment_content": ["sum -= square;"], "test": "int main() {\n    assert(Is_Square({9}) == true);\n    assert(Is_Square({14, 2}) == true);\n    assert(Is_Square({7, 7}) == false);\n    assert(Is_Square({1, 2, 3, 4, 5, 6, 7}) == false);\n    assert(Is_Square({1, 3, 5, 7, 9, 11}) == true);\n    assert(Is_Square({2, 2, 2, 2}) == false);\n\n    // Additional test cases\n    assert(Is_Square({4, 5, 6}) == false);\n    assert(Is_Square({16, 9, 4, 1}) == false);\n    assert(Is_Square({1, 1, 1, 1, 1}) == false);\n    assert(Is_Square({25, 25}) == false);\n    assert(Is_Square({10, 10, 5}) == true);\n\n    // All tests passed\n    return 0;\n}", "instruction": "Observe the following faulty CPP code\n```cpp\n#include <cassert>\n#include <cmath>\n#include <vector>\nbool Is_Square(std::vector<int> squares)\n{\n    long long sum = 0;\n    for (int square : squares) {\n        sum -= square; \n    }\n    int root = static_cast<int>(std::sqrt(sum));\n    return root * root == sum;\n}\n```\nFix bugs in the given code snippet. The fixed code must be placed between ```cpp```. Do not generate any test, main,example usage or check code!\n"}
{"question_id": "CPP/31", "category": "Logic", "subtype": "operation_error", "level": "medium", "example": "Examples:\n>>> count_acute_triangles(4, 1, 1, 1, 1)\n4", "docstring": "Count the number of acute-angled triangles that can be formed by selecting any 3 edges out of\na given set of edges.\n  \nArgs:\n- edges_count: The number of edges passed.\n- An arbitrary number of integer arguments representing the lengths of the edges.\n  \nReturns:\nint: The count of distinct acute-angled triangles that can be formed.", "canonical_solution": "#include <cassert>\n#include <cmath>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cstdarg>\n\nint count_acute_triangles(int edges_count, ...)\n\n{\n    va_list args;\n    va_start(args, edges_count);\n\n    int* edges = (int*) malloc(edges_count * sizeof(int));\n    for (int i = 0; i < edges_count; i++) {\n        edges[i] = va_arg(args, int);\n    }\n    va_end(args);\n\n    qsort(edges, edges_count, sizeof(int), (int (*)(const void *, const void *)) strcmp);\n\n\n    int sum = 0;\n    for (int i = 0; i < edges_count - 2; i++) {\n        for (int j = i + 1; j < edges_count - 1; j++) {\n            for (int k = j + 1; k < edges_count; k++) {\n                int x = edges[i], y = edges[j], z = edges[k];\n                if (x + y > z && x * x + y * y > z * z) {\n                    sum++;\n                }\n            }\n        }\n    }\n\n    free(edges);\n    return sum;\n}", "buggy_code": "#include <cassert>\n#include <cmath>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cstdarg>\nint count_acute_triangles(int edges_count, ...)\n{\n    va_list args;\n    va_start(args, edges_count);\n    int* edges = (int*) malloc(edges_count * sizeof(int));\n    for (int i = 0; i < edges_count; i++) {\n        edges[i] = va_arg(args, int);\n    }\n    va_end(args);\n    qsort(edges, edges_count, sizeof(int), (int (*)(const void *, const void *)) strcmp);\n    int sum = 0;\n    for (int i = 0; i < edges_count - 2; i++) {\n        for (int j = i + 1; j < edges_count - 1; j++) {\n            for (int k = j + 1; k < edges_count; k++) {\n                int x = edges[i], y = edges[j], z = edges[k];\n                if (x + y > z || x * x + y * y > z * z) {\n                    sum++;\n                }\n            }\n        }\n    }\n    free(edges);\n    return sum;\n}", "bug_with_line_numbers": "   1 | #include <cassert>\n   2 | #include <cmath>\n   3 | #include <cstdio>\n   4 | #include <cstdlib>\n   5 | #include <cstring>\n   6 | #include <cstdarg>\n   7 | int count_acute_triangles(int edges_count, ...)\n   8 | {\n   9 |     va_list args;\n  10 |     va_start(args, edges_count);\n  11 |     int* edges = (int*) malloc(edges_count * sizeof(int));\n  12 |     for (int i = 0; i < edges_count; i++) {\n  13 |         edges[i] = va_arg(args, int);\n  14 |     }\n  15 |     va_end(args);\n  16 |     qsort(edges, edges_count, sizeof(int), (int (*)(const void *, const void *)) strcmp);\n  17 |     int sum = 0;\n  18 |     for (int i = 0; i < edges_count - 2; i++) {\n  19 |         for (int j = i + 1; j < edges_count - 1; j++) {\n  20 |             for (int k = j + 1; k < edges_count; k++) {\n  21 |                 int x = edges[i], y = edges[j], z = edges[k];\n  22 |                 if (x + y > z || x * x + y * y > z * z) {\n  23 |                     sum++;\n  24 |                 }\n  25 |             }\n  26 |         }\n  27 |     }\n  28 |     free(edges);\n  29 |     return sum;\n  30 | }", "fragment_lines": [22], "fragment_content": ["if (x + y > z || x * x + y * y > z * z) {"], "test": "int main() {\n    assert(count_acute_triangles(4, 1, 1, 1, 1) == 4);\n    assert(count_acute_triangles(3, 1, 2, 3) == 0);\n    // Additional tests to ensure correctness\n    assert(count_acute_triangles(5, 3, 4, 5, 7, 10) == 0);\n    assert(count_acute_triangles(6, 6, 8, 10, 5, 5, 5) == 4);\n    return 0;\n}", "instruction": "Observe the following faulty CPP code\n```cpp\n#include <cassert>\n#include <cmath>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cstdarg>\nint count_acute_triangles(int edges_count, ...)\n{\n    va_list args;\n    va_start(args, edges_count);\n    int* edges = (int*) malloc(edges_count * sizeof(int));\n    for (int i = 0; i < edges_count; i++) {\n        edges[i] = va_arg(args, int);\n    }\n    va_end(args);\n    qsort(edges, edges_count, sizeof(int), (int (*)(const void *, const void *)) strcmp);\n    int sum = 0;\n    for (int i = 0; i < edges_count - 2; i++) {\n        for (int j = i + 1; j < edges_count - 1; j++) {\n            for (int k = j + 1; k < edges_count; k++) {\n                int x = edges[i], y = edges[j], z = edges[k];\n                if (x + y > z || x * x + y * y > z * z) {\n                    sum++;\n                }\n            }\n        }\n    }\n    free(edges);\n    return sum;\n}\n```\nFix bugs in the given code snippet. The fixed code must be placed between ```cpp```. Do not generate any test, main,example usage or check code!\n"}
{"question_id": "CPP/32", "category": "Logic", "subtype": "operation_error", "level": "medium", "example": "* Examples:\n * >>> minRoundsToSameChar(\"aab\")\n * 1\n * >>> minRoundsToSameChar(\"abc\")\n * 2\n * >>> minRoundsToSameChar(\"aaa\")\n * 0", "docstring": "* Given a string consisting of lowercase English letters, in each round you can change\n * one of the characters to another character. The question is: what is the minimum\n * number of rounds needed to make the string composed of the same character?\n *", "canonical_solution": "#include <cassert>\n#include <cstring>\n#include <iostream>\n\nint minRoundsToSameChar(const char* s)\n\n{\n    int charCount[26] = {0};\n    for (int i = 0; i < 26; i++) {\n        charCount[i] = 0;\n    }\n    while (*s) {\n        charCount[*s - 'a']++;\n        s++;\n    }\n    int maxCount = 0;\n    for (int i = 0; i < 26; i++) {\n        if (charCount[i] != 0 ) {\n            maxCount ++;\n        }\n    }\n\n    return maxCount - 1;\n}", "buggy_code": "#include <cassert>\n#include <cstring>\n#include <iostream>\nint minRoundsToSameChar(const char* s)\n{\n    int charCount[26] = {0};\n    for (int i = 0; i < 26; i++) {\n        charCount[i] = 0;\n    }\n    while (*s) {\n        charCount[*s + 'a']++;\n        s++;\n    }\n    int maxCount = 0;\n    for (int i = 0; i < 26; i++) {\n        if (charCount[i] != 0 ) {\n            maxCount ++;\n        }\n    }\n    return maxCount - 1;\n}", "bug_with_line_numbers": "   1 | #include <cassert>\n   2 | #include <cstring>\n   3 | #include <iostream>\n   4 | int minRoundsToSameChar(const char* s)\n   5 | {\n   6 |     int charCount[26] = {0};\n   7 |     for (int i = 0; i < 26; i++) {\n   8 |         charCount[i] = 0;\n   9 |     }\n  10 |     while (*s) {\n  11 |         charCount[*s + 'a']++;\n  12 |         s++;\n  13 |     }\n  14 |     int maxCount = 0;\n  15 |     for (int i = 0; i < 26; i++) {\n  16 |         if (charCount[i] != 0 ) {\n  17 |             maxCount ++;\n  18 |         }\n  19 |     }\n  20 |     return maxCount - 1;\n  21 | }", "fragment_lines": [11], "fragment_content": ["charCount[*s + 'a']++;"], "test": "int main() {\n    assert(minRoundsToSameChar(\"aab\") == 1);\n    assert(minRoundsToSameChar(\"abc\") == 2);\n    assert(minRoundsToSameChar(\"aaa\") == 0);\n    assert(minRoundsToSameChar(\"abab\") == 1);\n    assert(minRoundsToSameChar(\"zzzzz\") == 0);\n\n    return 0;\n}", "instruction": "Observe the following faulty CPP code\n```cpp\n#include <cassert>\n#include <cstring>\n#include <iostream>\nint minRoundsToSameChar(const char* s)\n{\n    int charCount[26] = {0};\n    for (int i = 0; i < 26; i++) {\n        charCount[i] = 0;\n    }\n    while (*s) {\n        charCount[*s + 'a']++;\n        s++;\n    }\n    int maxCount = 0;\n    for (int i = 0; i < 26; i++) {\n        if (charCount[i] != 0 ) {\n            maxCount ++;\n        }\n    }\n    return maxCount - 1;\n}\n```\nFix bugs in the given code snippet. The fixed code must be placed between ```cpp```. Do not generate any test, main,example usage or check code!\n"}
{"question_id": "CPP/33", "category": "Logic", "subtype": "operation_error", "level": "hard", "example": "* Examples:\n *    >>> makeEqualAgain(3, (int[]){1, 2, 1})\n *    1\n *    >>> makeEqualAgain(5, (int[]){5, 5, 1, 5, 5})\n *    1", "docstring": "* You are given an array a of n integers. You can perform at most one operation where you\n * select three integers i, j, x (1 <= i <= j <= n) and replace all elements from a[i] to a[j] with x,\n * at a cost of (j - i + 1). Find the minimum cost to make all elements in the array equal.\n *", "canonical_solution": "#include <cstdio>\n#include <cassert>\n\nint makeEqualAgain(int n, int a[])\n\n{\n    int j = 0, p = 1, q = 0, c, d;\n    int k = n;\n    for (p = 1; p < k; p++) {\n        if (a[p] != a[p - 1])\n            break;\n    }\n    for (q = k - 1; q > p; q--) {\n        if (a[q] != a[p - 1])\n            break;\n    }\n    for (d = k - 2; d >= 0; d--) {\n        if (a[d] != a[d + 1])\n            break;\n    }\n    for (c = 0; c < d; c++) {\n        if (a[c] != a[c + 1])\n            break;\n    }\n    if (q - p + 1 < d - c + 1)\n        return q - p + 1;\n    else\n        return d - c + 1;\n}", "buggy_code": "#include <cstdio>\n#include <cassert>\nint makeEqualAgain(int n, int a[])\n{\n    int j = 0, p = 1, q = 0, c, d;\n    int k = n;\n    for (p = 1; p < k; p++) {\n        if (a[p] != a[p - 1])\n            break;\n    }\n    for (q = k - 1; q > p; q--) {\n        if (a[q] != a[p - 1])\n            break;\n    }\n    for (d = k - 2; d >= 0; d--) {\n        if (a[d] != a[d + 1])\n            break;\n    }\n    for (c = 0; c < d; c++) {\n        if (a[c] != a[c + 1])\n            break;\n    }\n    if (q - p + 1 < d - c + 1)\n        return q - p * 1;\n    else\n        return d - c + 1;\n}", "bug_with_line_numbers": "   1 | #include <cstdio>\n   2 | #include <cassert>\n   3 | int makeEqualAgain(int n, int a[])\n   4 | {\n   5 |     int j = 0, p = 1, q = 0, c, d;\n   6 |     int k = n;\n   7 |     for (p = 1; p < k; p++) {\n   8 |         if (a[p] != a[p - 1])\n   9 |             break;\n  10 |     }\n  11 |     for (q = k - 1; q > p; q--) {\n  12 |         if (a[q] != a[p - 1])\n  13 |             break;\n  14 |     }\n  15 |     for (d = k - 2; d >= 0; d--) {\n  16 |         if (a[d] != a[d + 1])\n  17 |             break;\n  18 |     }\n  19 |     for (c = 0; c < d; c++) {\n  20 |         if (a[c] != a[c + 1])\n  21 |             break;\n  22 |     }\n  23 |     if (q - p + 1 < d - c + 1)\n  24 |         return q - p * 1;\n  25 |     else\n  26 |         return d - c + 1;\n  27 | }", "fragment_lines": [24], "fragment_content": ["return q - p * 1;"], "test": "int main() {\n    int a1[] = {1,2,3,4,5,1};\n    int a2[] = {1,1,1,1,1,1,1};\n    int a3[] = {8,8,8,1,2,8,8,8};\n    int a4[] = {1,2,3};\n    int a5[] = {4,3,2,7,1,1,3};\n    int a6[] = {9,9,2,9,2,5,5,5,3};\n    \n    assert(makeEqualAgain(6, a1) == 4);\n    assert(makeEqualAgain(7, a2) == 0);\n    assert(makeEqualAgain(8, a3) == 2);\n    assert(makeEqualAgain(3, a4) == 2);\n    assert(makeEqualAgain(7, a5) == 6);\n    assert(makeEqualAgain(9, a6) == 7);\n\n    int a7[] = {1, 2, 1};\n    int a8[] = {5, 5, 1, 5, 5};\n    int a9[] = {1, 1, 1, 1};\n    int a10[] = {2, 2, 2, 3, 2, 2};\n    int a11[] = {1};\n    int a12[] = {1, 2};\n    int a13[] = {1, 2, 2, 1};\n    int a14[] = {4, 4, 4, 3, 3, 4, 4};\n    int a15[] = {5, 4, 4, 4, 5, 5};\n    int a16[] = {1, 2, 1, 2, 1, 2, 1};\n    // Additional provided tests\n    assert(makeEqualAgain(3, a7) == 1);\n    assert(makeEqualAgain(5, a8) == 1);\n    assert(makeEqualAgain(4, a9) == 0);\n    assert(makeEqualAgain(6, a10) == 1);\n    assert(makeEqualAgain(1, a11) == 0);\n    assert(makeEqualAgain(2, a12) == 1);\n    assert(makeEqualAgain(4, a13) == 2);\n    assert(makeEqualAgain(7, a14) == 2);\n    assert(makeEqualAgain(6, a15) == 3);\n    assert(makeEqualAgain(7, a16) == 5);\n    \n    return 0;\n}", "instruction": "Observe the following faulty CPP code\n```cpp\n#include <cstdio>\n#include <cassert>\nint makeEqualAgain(int n, int a[])\n{\n    int j = 0, p = 1, q = 0, c, d;\n    int k = n;\n    for (p = 1; p < k; p++) {\n        if (a[p] != a[p - 1])\n            break;\n    }\n    for (q = k - 1; q > p; q--) {\n        if (a[q] != a[p - 1])\n            break;\n    }\n    for (d = k - 2; d >= 0; d--) {\n        if (a[d] != a[d + 1])\n            break;\n    }\n    for (c = 0; c < d; c++) {\n        if (a[c] != a[c + 1])\n            break;\n    }\n    if (q - p + 1 < d - c + 1)\n        return q - p * 1;\n    else\n        return d - c + 1;\n}\n```\nFix bugs in the given code snippet. The fixed code must be placed between ```cpp```. Do not generate any test, main,example usage or check code!\n"}
{"question_id": "CPP/34", "category": "Logic", "subtype": "operation_error", "level": "medium", "example": "* Example:\n * >>> maxModeSum(3, {1, 2, 3})\n * 17\n * A sequence that reaches its maximum value is (3,2,3,1,2,2).", "docstring": "* Given n positive integers representing the count of each number from 1 to n,\n * find the maximum sum of the mode (most frequent element) for all prefixes of\n * a sequence constructed from these numbers. The mode is the largest number among\n * the most frequent elements in a sequence.\n *", "canonical_solution": "#include <cassert>\n#include <cstdio>\n\nlong long maxModeSum(int n, const int* counts)\n\n{\n    long long ans = 0;\n    int mx = 0;\n    long long f[100000];\n    for (int i = 0; i <= n; ++i) f[i] = 0;\n\n    for (int i = n; i > 0; --i) {\n        while (mx < counts[i - 1]) {\n            mx++;\n            f[mx] = f[mx - 1] + i;\n        }\n        ans += f[counts[i - 1]];\n    }\n    return ans;\n}", "buggy_code": "#include <cassert>\n#include <cstdio>\nlong long maxModeSum(int n, const int* counts)\n{\n    long long ans = 0;\n    int mx = 0;\n    long long f[100000];\n    for (int i = 0; i <= n; --i) f[i] = 0;\n    for (int i = n; i > 0; --i) {\n        while (mx < counts[i - 1]) {\n            mx++;\n            f[mx] = f[mx - 1] + i;\n        }\n        ans += f[counts[i - 1]];\n    }\n    return ans;\n}", "bug_with_line_numbers": "   1 | #include <cassert>\n   2 | #include <cstdio>\n   3 | long long maxModeSum(int n, const int* counts)\n   4 | {\n   5 |     long long ans = 0;\n   6 |     int mx = 0;\n   7 |     long long f[100000];\n   8 |     for (int i = 0; i <= n; --i) f[i] = 0;\n   9 |     for (int i = n; i > 0; --i) {\n  10 |         while (mx < counts[i - 1]) {\n  11 |             mx++;\n  12 |             f[mx] = f[mx - 1] + i;\n  13 |         }\n  14 |         ans += f[counts[i - 1]];\n  15 |     }\n  16 |     return ans;\n  17 | }", "fragment_lines": [8], "fragment_content": ["for (int i = 0; i <= n; --i) f[i] = 0;"], "test": "int main() {\n    int a1[] = {1, 3, 2};\n    int a2[] = {4, 1, 2, 3};\n    int a3[] = {1, 1};\n    int a4[] = {1, 2, 3, 4, 5};\n    int a5[] = {100000};\n    int a6[] = {5, 3, 2, 4, 1};\n    int a7[] = {100000, 100000, 100000};\n    int a8[] = {2, 2, 5};\n    int a9[] = {4, 4, 4, 4};\n    int a10[] = {1, 2, 3, 4, 5, 6};\n    int a11[] = {3, 1, 2};\n\n    assert(maxModeSum(3, a1) == 17);\n    assert(maxModeSum(4, a2) == 37);\n    assert(maxModeSum(2, a3) == 4);\n    assert(maxModeSum(5, a4) == 75);\n    assert(maxModeSum(1, a5) == 100000);\n    assert(maxModeSum(5, a6) == 62);\n    assert(maxModeSum(3, a7) == 900000);\n    assert(maxModeSum(3, a8) == 27);\n    assert(maxModeSum(4, a9) == 64);\n    assert(maxModeSum(6, a10) == 126);\n    assert(maxModeSum(3, a11) == 16);\n    return 0;\n}", "instruction": "Observe the following faulty CPP code\n```cpp\n#include <cassert>\n#include <cstdio>\nlong long maxModeSum(int n, const int* counts)\n{\n    long long ans = 0;\n    int mx = 0;\n    long long f[100000];\n    for (int i = 0; i <= n; --i) f[i] = 0;\n    for (int i = n; i > 0; --i) {\n        while (mx < counts[i - 1]) {\n            mx++;\n            f[mx] = f[mx - 1] + i;\n        }\n        ans += f[counts[i - 1]];\n    }\n    return ans;\n}\n```\nFix bugs in the given code snippet. The fixed code must be placed between ```cpp```. Do not generate any test, main,example usage or check code!\n"}
{"question_id": "CPP/35", "category": "Logic", "subtype": "operation_error", "level": "hard", "example": "For example:\n    >>> countBalancedSubsequences(2, 2, 2)\n    2", "docstring": "Given three integers n, m, and k, find the number of sequences consisting of n '(' and m ')',\nsuch that the longest balanced subsequence is of length 2 * k. The result should be calculated modulo 1,000,000,007 (10^9 + 7).", "canonical_solution": "#include <cassert>\n\nlong long countBalancedSubsequences(long long n, long long m, long long k)\n\n{\n    const long long P = static_cast<long long>(1e9) + 7;\n    static long long C[4001][4001] = {0};\n\n    if (C[0][0] == 0) {\n        for (long long i = 0; i <= 4000; i++) C[i][0] = 1;\n        for (long long i = 1; i <= 4000; i++)\n            for (long long j = 1; j <= i; j++)\n                C[i][j] = (C[i - 1][j - 1] + C[i - 1][j]) % P;\n    }\n\n    if (k > n || k > m) return 0;\n    return (C[n + m][k] - C[n + m][k - 1] + P) % P;\n}", "buggy_code": "#include <cassert>\nlong long countBalancedSubsequences(long long n, long long m, long long k)\n{\n    const long long P = static_cast<long long>(1e9) + 7;\n    static long long C[4001][4001] = {0};\n    if (C[0][0] == 0) {\n        for (long long i = 0; i <= 4000; i++) C[i][0] = 1;\n        for (long long i = 1; i <= 4000; i++)\n            for (long long j = 1; j <= i; j++)\n                C[i][j] = (C[i - 1][j - 1] + C[i - 1][j]) % P;\n    }\n    if (k < n || k > m) return 0;\n    return (C[n + m][k] - C[n + m][k - 1] + P) % P;\n}", "bug_with_line_numbers": "   1 | #include <cassert>\n   2 | long long countBalancedSubsequences(long long n, long long m, long long k)\n   3 | {\n   4 |     const long long P = static_cast<long long>(1e9) + 7;\n   5 |     static long long C[4001][4001] = {0};\n   6 |     if (C[0][0] == 0) {\n   7 |         for (long long i = 0; i <= 4000; i++) C[i][0] = 1;\n   8 |         for (long long i = 1; i <= 4000; i++)\n   9 |             for (long long j = 1; j <= i; j++)\n  10 |                 C[i][j] = (C[i - 1][j - 1] + C[i - 1][j]) % P;\n  11 |     }\n  12 |     if (k < n || k > m) return 0;\n  13 |     return (C[n + m][k] - C[n + m][k - 1] + P) % P;\n  14 | }", "fragment_lines": [12], "fragment_content": ["if (k < n || k > m) return 0;"], "test": "int main() {\n    assert(countBalancedSubsequences(2, 2, 2) == 2);\n    assert(countBalancedSubsequences(3, 2, 3) == 0);\n    assert(countBalancedSubsequences(3, 2, 1) == 4);\n    assert(countBalancedSubsequences(4, 3, 2) == 14);\n    assert(countBalancedSubsequences(5, 5, 2) == 35);\n    assert(countBalancedSubsequences(6, 1, 1) == 6);\n    assert(countBalancedSubsequences(1, 6, 1) == 6);\n    assert(countBalancedSubsequences(7, 2, 2) == 27);\n    assert(countBalancedSubsequences(8, 3, 3) == 110);\n    assert(countBalancedSubsequences(10, 10, 5) == 10659);\n    assert(countBalancedSubsequences(20, 20, 10) == 574221648);\n    assert(countBalancedSubsequences(2000, 2000, 1000) == 854104531);\n    assert(countBalancedSubsequences(2000, 1999, 1000) == 334874485);\n    assert(countBalancedSubsequences(2000, 2000, 1999) == 259428024);\n    return 0;\n}", "instruction": "Observe the following faulty CPP code\n```cpp\n#include <cassert>\nlong long countBalancedSubsequences(long long n, long long m, long long k)\n{\n    const long long P = static_cast<long long>(1e9) + 7;\n    static long long C[4001][4001] = {0};\n    if (C[0][0] == 0) {\n        for (long long i = 0; i <= 4000; i++) C[i][0] = 1;\n        for (long long i = 1; i <= 4000; i++)\n            for (long long j = 1; j <= i; j++)\n                C[i][j] = (C[i - 1][j - 1] + C[i - 1][j]) % P;\n    }\n    if (k < n || k > m) return 0;\n    return (C[n + m][k] - C[n + m][k - 1] + P) % P;\n}\n```\nFix bugs in the given code snippet. The fixed code must be placed between ```cpp```. Do not generate any test, main,example usage or check code!\n"}
{"question_id": "CPP/36", "category": "Logic", "subtype": "type_error", "level": "medium", "example": ">>> countPermutations(2, 1, [1, 2])\n    2", "docstring": "Given a permutation q of n elements and an integer k, find the number of permutations p of n elements such that f(p) = q, where f(p) is the lexicographically smallest permutation that can be obtained by dividing p into exactly k non-empty contiguous segments and sorting each segment (i.e., choose k-1 breakpoints 1 <= x_1 < x_2 < ... < x_{k-1} < n, and divide it into [1, x_1], (x_1, x_2], ..., (x_{k-1}, n]). The result should be modulo 998244353.", "canonical_solution": "#include <bits/stdc++.h>\n\nint countPermutations(int n, int k, int qq[])\n\n{\n    const int N = 505, P = 998244353;\n    int q[N], m, dp[N][N], jc[N], f[N], ans;\n    memset(q, 0, sizeof(q));\n    memset(dp, 0, sizeof(dp));\n    memset(jc, 0, sizeof(jc));\n    memset(f, 0, sizeof(f));\n    ans = 0;\n\n    for (int i = 1; i <= n; i++)\n        q[i] = qq[i - 1];\n    dp[0][0] = f[0] = 1;\n    for (int i = jc[0] = 1; i <= n; i++)\n        jc[i] = 1LL * jc[i - 1] * i % P;\n    for (int i = 1; i <= n; i++)\n    {\n        f[i] = jc[i];\n        for (int j = 1; j < i; j++)\n            f[i] = (f[i] + P - 1LL * f[j] * jc[i - j] % P) % P;\n    }\n    for (int i = 1; i <= n; i++)\n    {\n        for (int j = 0; j < i; j++)\n            for (int k = 1; k <= n; k++)\n                dp[i][k] = (dp[i][k] + dp[j][k - 1] * 1LL * f[i - j] % P) % P;\n    }\n    m = 0;\n    for (int i = 1; i <= n; i++)\n        if (q[i] > q[i + 1])\n        {\n            m = i;\n            break;\n        }\n    if (m == n)\n    {\n        for (int i = k; i <= n; i++)\n            ans = (ans + dp[n][i]) % P;\n    }\n    else\n    {\n        for (int i = m + 1; i <= n; i++)\n        {\n            if (i != m + 1 && (q[i - 1] > q[i] || q[i] < q[m]))\n                break;\n            int c = k + i - n - 1;\n            if (c >= 0)\n                ans = (ans + dp[m][c] * 1LL * jc[i - m - 1] % P) % P;\n        }\n    }\n    return ans;\n}", "buggy_code": "#include <bits/stdc++.h>\nint countPermutations(int n, int k, int qq[])\n{\n    char N = 505, P = 998244353;\n    int q[N], m, dp[N][N], jc[N], f[N], ans;\n    memset(q, 0, sizeof(q));\n    memset(dp, 0, sizeof(dp));\n    memset(jc, 0, sizeof(jc));\n    memset(f, 0, sizeof(f));\n    ans = 0;\n    for (int i = 1; i <= n; i++)\n        q[i] = qq[i - 1];\n    dp[0][0] = f[0] = 1;\n    for (int i = jc[0] = 1; i <= n; i++)\n        jc[i] = 1LL * jc[i - 1] * i % P;\n    for (int i = 1; i <= n; i++)\n    {\n        f[i] = jc[i];\n        for (int j = 1; j < i; j++)\n            f[i] = (f[i] + P - 1LL * f[j] * jc[i - j] % P) % P;\n    }\n    for (int i = 1; i <= n; i++)\n    {\n        for (int j = 0; j < i; j++)\n            for (int k = 1; k <= n; k++)\n                dp[i][k] = (dp[i][k] + dp[j][k - 1] * 1LL * f[i - j] % P) % P;\n    }\n    m = 0;\n    for (int i = 1; i <= n; i++)\n        if (q[i] > q[i + 1])\n        {\n            m = i;\n            break;\n        }\n    if (m == n)\n    {\n        for (int i = k; i <= n; i++)\n            ans = (ans + dp[n][i]) % P;\n    }\n    else\n    {\n        for (int i = m + 1; i <= n; i++)\n        {\n            if (i != m + 1 && (q[i - 1] > q[i] || q[i] < q[m]))\n                break;\n            int c = k + i - n - 1;\n            if (c >= 0)\n                ans = (ans + dp[m][c] * 1LL * jc[i - m - 1] % P) % P;\n        }\n    }\n    return ans;\n}", "bug_with_line_numbers": "   1 | #include <bits/stdc++.h>\n   2 | int countPermutations(int n, int k, int qq[])\n   3 | {\n   4 |     char N = 505, P = 998244353;\n   5 |     int q[N], m, dp[N][N], jc[N], f[N], ans;\n   6 |     memset(q, 0, sizeof(q));\n   7 |     memset(dp, 0, sizeof(dp));\n   8 |     memset(jc, 0, sizeof(jc));\n   9 |     memset(f, 0, sizeof(f));\n  10 |     ans = 0;\n  11 |     for (int i = 1; i <= n; i++)\n  12 |         q[i] = qq[i - 1];\n  13 |     dp[0][0] = f[0] = 1;\n  14 |     for (int i = jc[0] = 1; i <= n; i++)\n  15 |         jc[i] = 1LL * jc[i - 1] * i % P;\n  16 |     for (int i = 1; i <= n; i++)\n  17 |     {\n  18 |         f[i] = jc[i];\n  19 |         for (int j = 1; j < i; j++)\n  20 |             f[i] = (f[i] + P - 1LL * f[j] * jc[i - j] % P) % P;\n  21 |     }\n  22 |     for (int i = 1; i <= n; i++)\n  23 |     {\n  24 |         for (int j = 0; j < i; j++)\n  25 |             for (int k = 1; k <= n; k++)\n  26 |                 dp[i][k] = (dp[i][k] + dp[j][k - 1] * 1LL * f[i - j] % P) % P;\n  27 |     }\n  28 |     m = 0;\n  29 |     for (int i = 1; i <= n; i++)\n  30 |         if (q[i] > q[i + 1])\n  31 |         {\n  32 |             m = i;\n  33 |             break;\n  34 |         }\n  35 |     if (m == n)\n  36 |     {\n  37 |         for (int i = k; i <= n; i++)\n  38 |             ans = (ans + dp[n][i]) % P;\n  39 |     }\n  40 |     else\n  41 |     {\n  42 |         for (int i = m + 1; i <= n; i++)\n  43 |         {\n  44 |             if (i != m + 1 && (q[i - 1] > q[i] || q[i] < q[m]))\n  45 |                 break;\n  46 |             int c = k + i - n - 1;\n  47 |             if (c >= 0)\n  48 |                 ans = (ans + dp[m][c] * 1LL * jc[i - m - 1] % P) % P;\n  49 |         }\n  50 |     }\n  51 |     return ans;\n  52 | }", "fragment_lines": [4], "fragment_content": ["char N = 505, P = 998244353;"], "test": "int main() {\n    int q1[] = {1, 2};\n    assert(countPermutations(2, 1, q1) == 2);\n\n    int q2[] = {3, 1, 2};\n    assert(countPermutations(3, 3, q2) == 1);\n\n    int q3[] = {1, 2, 3, 6, 5, 4};\n    assert(countPermutations(6, 3, q3) == 13);\n\n    int q4[] = {1, 2, 3, 4, 5, 6};\n    assert(countPermutations(6, 1, q4) == 720);\n\n    int q5[] = {1, 2, 5, 3, 4, 5};\n    assert(countPermutations(6, 3, q5) == 0);\n\n    int q6[] = {1, 2, 3, 4, 5, 6, 7, 8, 9};\n    assert(countPermutations(9, 9, q6) == 1);\n\n    int q7[] = {1, 2, 3, 4, 5, 6, 7, 9, 8};\n    assert(countPermutations(9, 2, q7) == 29093);\n    return 0;}", "instruction": "Observe the following faulty CPP code\n```cpp\n#include <bits/stdc++.h>\nint countPermutations(int n, int k, int qq[])\n{\n    char N = 505, P = 998244353;\n    int q[N], m, dp[N][N], jc[N], f[N], ans;\n    memset(q, 0, sizeof(q));\n    memset(dp, 0, sizeof(dp));\n    memset(jc, 0, sizeof(jc));\n    memset(f, 0, sizeof(f));\n    ans = 0;\n    for (int i = 1; i <= n; i++)\n        q[i] = qq[i - 1];\n    dp[0][0] = f[0] = 1;\n    for (int i = jc[0] = 1; i <= n; i++)\n        jc[i] = 1LL * jc[i - 1] * i % P;\n    for (int i = 1; i <= n; i++)\n    {\n        f[i] = jc[i];\n        for (int j = 1; j < i; j++)\n            f[i] = (f[i] + P - 1LL * f[j] * jc[i - j] % P) % P;\n    }\n    for (int i = 1; i <= n; i++)\n    {\n        for (int j = 0; j < i; j++)\n            for (int k = 1; k <= n; k++)\n                dp[i][k] = (dp[i][k] + dp[j][k - 1] * 1LL * f[i - j] % P) % P;\n    }\n    m = 0;\n    for (int i = 1; i <= n; i++)\n        if (q[i] > q[i + 1])\n        {\n            m = i;\n            break;\n        }\n    if (m == n)\n    {\n        for (int i = k; i <= n; i++)\n            ans = (ans + dp[n][i]) % P;\n    }\n    else\n    {\n        for (int i = m + 1; i <= n; i++)\n        {\n            if (i != m + 1 && (q[i - 1] > q[i] || q[i] < q[m]))\n                break;\n            int c = k + i - n - 1;\n            if (c >= 0)\n                ans = (ans + dp[m][c] * 1LL * jc[i - m - 1] % P) % P;\n        }\n    }\n    return ans;\n}\n```\nFix bugs in the given code snippet. The fixed code must be placed between ```cpp```. Do not generate any test, main,example usage or check code!\n"}
{"question_id": "CPP/37", "category": "Logic", "subtype": "type_error", "level": "medium", "example": "* For example:\n *     >>> expectedCuts(3, 3, 4)\n *     3\n *     >>> expectedCuts(5, 5, 12)\n *     2", "docstring": "* Given a rectangle paper of size n x m placed on a plane Cartesian coordinate \n * system with its bottom-left corner at (0,0) and top-right corner at (n,m), \n * you need to calculate the expected number of operations to cut the paper such that \n * the remaining area is less than k. In each operation, a line is randomly chosen \n * that is parallel to the axes, passes through points with integer coordinates, \n * and cuts through (not just touching the edge) the paper. The bottom or right part \n * of the paper along this line is then discarded. The answer should be modulo 10^9+7.\n *", "canonical_solution": "#include <cassert>\n#include <cstdio>\n\nlong long expectedCuts(int n, int m, long long k)\n\n{\n    const int MD = 1000000007;\n    const int N = 1000000;\n    int vv[N * 2 + 1], i, j;\n    long long ans = 1;\n\n    vv[1] = 1;\n    for (i = 2; i <= N * 2; i++)\n        vv[i] = (long long)vv[i - MD % i] * (MD / i + 1) % MD;\n\n    if (k > (long long)n * m) {\n        return 0;\n    }\n\n    for (i = (k + m - 1) / m; i < n; i++)\n        ans = (ans + vv[i + (k + i - 1) / i - 1]) % MD;\n    for (j = (k + n - 1) / n; j < m; j++)\n        ans = (ans + vv[(k + j - 1) / j + j - 1]) % MD;\n\n    return ans;\n}", "buggy_code": "#include <cassert>\n#include <cstdio>\nlong long expectedCuts(int n, int m, long long k)\n{\n    const int MD = 1000000007;\n    const int N = 1000000;\n    int vv[N * 2 + 1], i, j;\n    char ans = 1;\n    vv[1] = 1;\n    for (i = 2; i <= N * 2; i++)\n        vv[i] = (long long)vv[i - MD % i] * (MD / i + 1) % MD;\n    if (k > (long long)n * m) {\n        return 0;\n    }\n    for (i = (k + m - 1) / m; i < n; i++)\n        ans = (ans + vv[i + (k + i - 1) / i - 1]) % MD;\n    for (j = (k + n - 1) / n; j < m; j++)\n        ans = (ans + vv[(k + j - 1) / j + j - 1]) % MD;\n    return ans;\n}", "bug_with_line_numbers": "   1 | #include <cassert>\n   2 | #include <cstdio>\n   3 | long long expectedCuts(int n, int m, long long k)\n   4 | {\n   5 |     const int MD = 1000000007;\n   6 |     const int N = 1000000;\n   7 |     int vv[N * 2 + 1], i, j;\n   8 |     char ans = 1;\n   9 |     vv[1] = 1;\n  10 |     for (i = 2; i <= N * 2; i++)\n  11 |         vv[i] = (long long)vv[i - MD % i] * (MD / i + 1) % MD;\n  12 |     if (k > (long long)n * m) {\n  13 |         return 0;\n  14 |     }\n  15 |     for (i = (k + m - 1) / m; i < n; i++)\n  16 |         ans = (ans + vv[i + (k + i - 1) / i - 1]) % MD;\n  17 |     for (j = (k + n - 1) / n; j < m; j++)\n  18 |         ans = (ans + vv[(k + j - 1) / j + j - 1]) % MD;\n  19 |     return ans;\n  20 | }", "fragment_lines": [8], "fragment_content": ["char ans = 1;"], "test": "int main() {\n    assert(expectedCuts(2, 4, 10) == 0);\n    assert(expectedCuts(2, 4, 8) == 1);\n    assert(expectedCuts(2, 4, 2) == 833333342);\n    assert(expectedCuts(2, 4, 6) == 250000003);\n    assert(expectedCuts(3, 3, 4) == 666666673);\n    assert(expectedCuts(5, 5, 12) == 666666673);\n    assert(expectedCuts(6, 7, 20) == 722222229);\n    assert(expectedCuts(8, 8, 30) == 72727275);\n    assert(expectedCuts(10, 10, 50) == 714285721);\n    assert(expectedCuts(1, 10, 5) == 945634929);\n    assert(expectedCuts(10, 1, 5) == 945634929);\n    return 0;\n}", "instruction": "Observe the following faulty CPP code\n```cpp\n#include <cassert>\n#include <cstdio>\nlong long expectedCuts(int n, int m, long long k)\n{\n    const int MD = 1000000007;\n    const int N = 1000000;\n    int vv[N * 2 + 1], i, j;\n    char ans = 1;\n    vv[1] = 1;\n    for (i = 2; i <= N * 2; i++)\n        vv[i] = (long long)vv[i - MD % i] * (MD / i + 1) % MD;\n    if (k > (long long)n * m) {\n        return 0;\n    }\n    for (i = (k + m - 1) / m; i < n; i++)\n        ans = (ans + vv[i + (k + i - 1) / i - 1]) % MD;\n    for (j = (k + n - 1) / n; j < m; j++)\n        ans = (ans + vv[(k + j - 1) / j + j - 1]) % MD;\n    return ans;\n}\n```\nFix bugs in the given code snippet. The fixed code must be placed between ```cpp```. Do not generate any test, main,example usage or check code!\n"}
{"question_id": "CPP/38", "category": "Logic", "subtype": "type_error", "level": "hard", "example": "* For example:\n *     >>> expectedCuts(3, 3, 4)\n *     3\n *     >>> expectedCuts(5, 5, 12)\n *     2", "docstring": "* Given a rectangle paper of size n x m placed on a plane Cartesian coordinate \n * system with its bottom-left corner at (0,0) and top-right corner at (n,m), \n * you need to calculate the expected number of operations to cut the paper such that \n * the remaining area is less than k. In each operation, a line is randomly chosen \n * that is parallel to the axes, passes through points with integer coordinates, \n * and cuts through (not just touching the edge) the paper. The bottom or right part \n * of the paper along this line is then discarded. The answer should be modulo 10^9+7.\n *", "canonical_solution": "#include <cassert>\n#include <cstdio>\n\nlong long expectedCuts(int n, int m, long long k)\n\n{\n    const int MD = 1000000007;\n    const int N = 1000000;\n    int vv[N * 2 + 1], i, j;\n    long long ans = 1;\n\n    vv[1] = 1;\n    for (i = 2; i <= N * 2; i++)\n        vv[i] = (long long)vv[i - MD % i] * (MD / i + 1) % MD;\n\n    if (k > (long long)n * m) {\n        return 0;\n    }\n\n    for (i = (k + m - 1) / m; i < n; i++)\n        ans = (ans + vv[i + (k + i - 1) / i - 1]) % MD;\n    for (j = (k + n - 1) / n; j < m; j++)\n        ans = (ans + vv[(k + j - 1) / j + j - 1]) % MD;\n\n    return ans;\n}", "buggy_code": "#include <cassert>\n#include <cstdio>\nlong long expectedCuts(int n, int m, long long k)\n{\n    const int MD = 1000000007;\n    const int N = 1000000;\n    const int vv[N * 2 + 1], i, j;\n    long long ans = 1;\n    vv[1] = 1;\n    for (i = 2; i <= N * 2; i++)\n        vv[i] = (long long)vv[i - MD % i] * (MD / i + 1) % MD;\n    if (k > (long long)n * m) {\n        return 0;\n    }\n    for (i = (k + m - 1) / m; i < n; i++)\n        ans = (ans + vv[i + (k + i - 1) / i - 1]) % MD;\n    for (j = (k + n - 1) / n; j < m; j++)\n        ans = (ans + vv[(k + j - 1) / j + j - 1]) % MD;\n    return ans;\n}", "bug_with_line_numbers": "   1 | #include <cassert>\n   2 | #include <cstdio>\n   3 | long long expectedCuts(int n, int m, long long k)\n   4 | {\n   5 |     const int MD = 1000000007;\n   6 |     const int N = 1000000;\n   7 |     const int vv[N * 2 + 1], i, j;\n   8 |     long long ans = 1;\n   9 |     vv[1] = 1;\n  10 |     for (i = 2; i <= N * 2; i++)\n  11 |         vv[i] = (long long)vv[i - MD % i] * (MD / i + 1) % MD;\n  12 |     if (k > (long long)n * m) {\n  13 |         return 0;\n  14 |     }\n  15 |     for (i = (k + m - 1) / m; i < n; i++)\n  16 |         ans = (ans + vv[i + (k + i - 1) / i - 1]) % MD;\n  17 |     for (j = (k + n - 1) / n; j < m; j++)\n  18 |         ans = (ans + vv[(k + j - 1) / j + j - 1]) % MD;\n  19 |     return ans;\n  20 | }", "fragment_lines": [7], "fragment_content": ["const int vv[N * 2 + 1], i, j;"], "test": "int main() {\n    assert(expectedCuts(2, 4, 10) == 0);\n    assert(expectedCuts(2, 4, 8) == 1);\n    assert(expectedCuts(2, 4, 2) == 833333342);\n    assert(expectedCuts(2, 4, 6) == 250000003);\n    assert(expectedCuts(3, 3, 4) == 666666673);\n    assert(expectedCuts(5, 5, 12) == 666666673);\n    assert(expectedCuts(6, 7, 20) == 722222229);\n    assert(expectedCuts(8, 8, 30) == 72727275);\n    assert(expectedCuts(10, 10, 50) == 714285721);\n    assert(expectedCuts(1, 10, 5) == 945634929);\n    assert(expectedCuts(10, 1, 5) == 945634929);\n    return 0;\n}", "instruction": "Observe the following faulty CPP code\n```cpp\n#include <cassert>\n#include <cstdio>\nlong long expectedCuts(int n, int m, long long k)\n{\n    const int MD = 1000000007;\n    const int N = 1000000;\n    const int vv[N * 2 + 1], i, j;\n    long long ans = 1;\n    vv[1] = 1;\n    for (i = 2; i <= N * 2; i++)\n        vv[i] = (long long)vv[i - MD % i] * (MD / i + 1) % MD;\n    if (k > (long long)n * m) {\n        return 0;\n    }\n    for (i = (k + m - 1) / m; i < n; i++)\n        ans = (ans + vv[i + (k + i - 1) / i - 1]) % MD;\n    for (j = (k + n - 1) / n; j < m; j++)\n        ans = (ans + vv[(k + j - 1) / j + j - 1]) % MD;\n    return ans;\n}\n```\nFix bugs in the given code snippet. The fixed code must be placed between ```cpp```. Do not generate any test, main,example usage or check code!\n"}
{"question_id": "CPP/39", "category": "Logic", "subtype": "type_error", "level": "hard", "example": "* For example:\n *     >>> expectedCuts(3, 3, 4)\n *     3\n *     >>> expectedCuts(5, 5, 12)\n *     2", "docstring": "* Given a rectangle paper of size n x m placed on a plane Cartesian coordinate \n * system with its bottom-left corner at (0,0) and top-right corner at (n,m), \n * you need to calculate the expected number of operations to cut the paper such that \n * the remaining area is less than k. In each operation, a line is randomly chosen \n * that is parallel to the axes, passes through points with integer coordinates, \n * and cuts through (not just touching the edge) the paper. The bottom or right part \n * of the paper along this line is then discarded. The answer should be modulo 10^9+7.\n *", "canonical_solution": "#include <cassert>\n#include <cstdio>\n\nlong long expectedCuts(int n, int m, long long k)\n\n{\n    const int MD = 1000000007;\n    const int N = 1000000;\n    int vv[N * 2 + 1], i, j;\n    long long ans = 1;\n\n    vv[1] = 1;\n    for (i = 2; i <= N * 2; i++)\n        vv[i] = (long long)vv[i - MD % i] * (MD / i + 1) % MD;\n\n    if (k > (long long)n * m) {\n        return 0;\n    }\n\n    for (i = (k + m - 1) / m; i < n; i++)\n        ans = (ans + vv[i + (k + i - 1) / i - 1]) % MD;\n    for (j = (k + n - 1) / n; j < m; j++)\n        ans = (ans + vv[(k + j - 1) / j + j - 1]) % MD;\n\n    return ans;\n}", "buggy_code": "#include <cassert>\n#include <cstdio>\nlong long expectedCuts(int n, int m, long long k)\n{\n    const int MD = 1000000007;\n    float N = 1000000;\n    int vv[N * 2 + 1], i, j;\n    long long ans = 1;\n    vv[1] = 1;\n    for (i = 2; i <= N * 2; i++)\n        vv[i] = (long long)vv[i - MD % i] * (MD / i + 1) % MD;\n    if (k > (long long)n * m) {\n        return 0;\n    }\n    for (i = (k + m - 1) / m; i < n; i++)\n        ans = (ans + vv[i + (k + i - 1) / i - 1]) % MD;\n    for (j = (k + n - 1) / n; j < m; j++)\n        ans = (ans + vv[(k + j - 1) / j + j - 1]) % MD;\n    return ans;\n}", "bug_with_line_numbers": "   1 | #include <cassert>\n   2 | #include <cstdio>\n   3 | long long expectedCuts(int n, int m, long long k)\n   4 | {\n   5 |     const int MD = 1000000007;\n   6 |     float N = 1000000;\n   7 |     int vv[N * 2 + 1], i, j;\n   8 |     long long ans = 1;\n   9 |     vv[1] = 1;\n  10 |     for (i = 2; i <= N * 2; i++)\n  11 |         vv[i] = (long long)vv[i - MD % i] * (MD / i + 1) % MD;\n  12 |     if (k > (long long)n * m) {\n  13 |         return 0;\n  14 |     }\n  15 |     for (i = (k + m - 1) / m; i < n; i++)\n  16 |         ans = (ans + vv[i + (k + i - 1) / i - 1]) % MD;\n  17 |     for (j = (k + n - 1) / n; j < m; j++)\n  18 |         ans = (ans + vv[(k + j - 1) / j + j - 1]) % MD;\n  19 |     return ans;\n  20 | }", "fragment_lines": [6], "fragment_content": ["float N = 1000000;"], "test": "int main() {\n    assert(expectedCuts(2, 4, 10) == 0);\n    assert(expectedCuts(2, 4, 8) == 1);\n    assert(expectedCuts(2, 4, 2) == 833333342);\n    assert(expectedCuts(2, 4, 6) == 250000003);\n    assert(expectedCuts(3, 3, 4) == 666666673);\n    assert(expectedCuts(5, 5, 12) == 666666673);\n    assert(expectedCuts(6, 7, 20) == 722222229);\n    assert(expectedCuts(8, 8, 30) == 72727275);\n    assert(expectedCuts(10, 10, 50) == 714285721);\n    assert(expectedCuts(1, 10, 5) == 945634929);\n    assert(expectedCuts(10, 1, 5) == 945634929);\n    return 0;\n}", "instruction": "Observe the following faulty CPP code\n```cpp\n#include <cassert>\n#include <cstdio>\nlong long expectedCuts(int n, int m, long long k)\n{\n    const int MD = 1000000007;\n    float N = 1000000;\n    int vv[N * 2 + 1], i, j;\n    long long ans = 1;\n    vv[1] = 1;\n    for (i = 2; i <= N * 2; i++)\n        vv[i] = (long long)vv[i - MD % i] * (MD / i + 1) % MD;\n    if (k > (long long)n * m) {\n        return 0;\n    }\n    for (i = (k + m - 1) / m; i < n; i++)\n        ans = (ans + vv[i + (k + i - 1) / i - 1]) % MD;\n    for (j = (k + n - 1) / n; j < m; j++)\n        ans = (ans + vv[(k + j - 1) / j + j - 1]) % MD;\n    return ans;\n}\n```\nFix bugs in the given code snippet. The fixed code must be placed between ```cpp```. Do not generate any test, main,example usage or check code!\n"}
{"question_id": "CPP/40", "category": "Logic", "subtype": "type_error", "level": "medium", "example": "* Examples:\n *   minOperations(5, {1, 2, 3, 2, 1}) -> 2", "docstring": "* You are given a 1 by n pixel image, where each pixel has a color \n * represented by an integer. You can perform an operation where you \n * pick a color and change all connected pixels of the same color to \n * the chosen color. Two pixels are connected if they are adjacent \n * and have the same color. Find the minimum number of operations \n * required to make all pixels the same color.\n *\n * Note: For each color, there are at most 20 pixels of that color.\n *", "canonical_solution": "#include <cassert>\n#include <cstdio>\n\nint minOperations(int n, int* pixels)\n\n{\n    int pre[n+1], u[n+1], f[n+1][n+1];\n    for (int i = 1; i <= n; i++) {\n        pre[i] = u[i] = 0;\n    }\n    for (int i = 1; i <= n; i++) {\n        pre[i] = u[pixels[i-1]];\n        u[pixels[i-1]] = i;\n    }\n    for (int i = 1; i <= n; i++) {\n        for (int j = 1; j <= n; j++) {\n            if (i != j) f[i][j] = 1000000000;\n            else f[i][j] = 0;\n        }\n    }\n    for (int len = 2; len <= n; len++) {\n        for (int i = 1; i <= n - len + 1; i++) {\n            int j = i + len - 1;\n            f[i][j] = f[i][j - 1] + 1;\n            for (int l = pre[j]; l >= i; l = pre[l]) {\n                f[i][j] = f[i][j] < f[i][l] + f[l + 1][j] ? f[i][j] : f[i][l] + f[l + 1][j];\n            }\n        }\n    }\n    return f[1][n];\n}", "buggy_code": "#include <cassert>\n#include <cstdio>\nint minOperations(int n, int* pixels)\n{\n    int* pre[n+1], u[n+1], f[n+1][n+1];\n    for (int i = 1; i <= n; i++) {\n        pre[i] = u[i] = 0;\n    }\n    for (int i = 1; i <= n; i++) {\n        pre[i] = u[pixels[i-1]];\n        u[pixels[i-1]] = i;\n    }\n    for (int i = 1; i <= n; i++) {\n        for (int j = 1; j <= n; j++) {\n            if (i != j) f[i][j] = 1000000000;\n            else f[i][j] = 0;\n        }\n    }\n    for (int len = 2; len <= n; len++) {\n        for (int i = 1; i <= n - len + 1; i++) {\n            int j = i + len - 1;\n            f[i][j] = f[i][j - 1] + 1;\n            for (int l = pre[j]; l >= i; l = pre[l]) {\n                f[i][j] = f[i][j] < f[i][l] + f[l + 1][j] ? f[i][j] : f[i][l] + f[l + 1][j];\n            }\n        }\n    }\n    return f[1][n];\n}", "bug_with_line_numbers": "   1 | #include <cassert>\n   2 | #include <cstdio>\n   3 | int minOperations(int n, int* pixels)\n   4 | {\n   5 |     int* pre[n+1], u[n+1], f[n+1][n+1];\n   6 |     for (int i = 1; i <= n; i++) {\n   7 |         pre[i] = u[i] = 0;\n   8 |     }\n   9 |     for (int i = 1; i <= n; i++) {\n  10 |         pre[i] = u[pixels[i-1]];\n  11 |         u[pixels[i-1]] = i;\n  12 |     }\n  13 |     for (int i = 1; i <= n; i++) {\n  14 |         for (int j = 1; j <= n; j++) {\n  15 |             if (i != j) f[i][j] = 1000000000;\n  16 |             else f[i][j] = 0;\n  17 |         }\n  18 |     }\n  19 |     for (int len = 2; len <= n; len++) {\n  20 |         for (int i = 1; i <= n - len + 1; i++) {\n  21 |             int j = i + len - 1;\n  22 |             f[i][j] = f[i][j - 1] + 1;\n  23 |             for (int l = pre[j]; l >= i; l = pre[l]) {\n  24 |                 f[i][j] = f[i][j] < f[i][l] + f[l + 1][j] ? f[i][j] : f[i][l] + f[l + 1][j];\n  25 |             }\n  26 |         }\n  27 |     }\n  28 |     return f[1][n];\n  29 | }", "fragment_lines": [5], "fragment_content": ["int* pre[n+1], u[n+1], f[n+1][n+1];"], "test": "int main() {\n    int a1[] = {1, 2, 3, 2, 1};\n    int a2[] = {1, 1, 2, 2};\n    int a3[] = {1, 2, 1, 4, 2};\n    int a4[] = {5, 5, 5, 5, 5};\n    int a5[] = {1, 1, 1, 2, 2, 2};\n    int a6[] = {1, 3, 3, 3, 2, 2, 2};\n    int a7[] = {4, 4, 4, 4, 3, 3, 3, 3};\n    int a8[] = {1, 2, 3, 4, 5, 6, 7, 8, 9};\n    int a9[] = {1, 2, 1, 2, 1, 2, 1, 2, 1, 2};\n    int a10[] = {3, 3, 3};\n    int a11[] = {2, 1, 1, 2};\n    assert(minOperations(5, a1) == 2);\n    assert(minOperations(4, a2) == 1);\n    assert(minOperations(5, a3) == 3);\n    assert(minOperations(5, a4) == 0);\n    assert(minOperations(6, a5) == 1);\n    assert(minOperations(7, a6) == 2);\n    assert(minOperations(8, a7) == 1);\n    assert(minOperations(9, a8) == 8);\n    assert(minOperations(10, a9) == 5);\n    assert(minOperations(3, a10) == 0);\n    assert(minOperations(4, a11) == 1);\n    return 0;\n}", "instruction": "Observe the following faulty CPP code\n```cpp\n#include <cassert>\n#include <cstdio>\nint minOperations(int n, int* pixels)\n{\n    int* pre[n+1], u[n+1], f[n+1][n+1];\n    for (int i = 1; i <= n; i++) {\n        pre[i] = u[i] = 0;\n    }\n    for (int i = 1; i <= n; i++) {\n        pre[i] = u[pixels[i-1]];\n        u[pixels[i-1]] = i;\n    }\n    for (int i = 1; i <= n; i++) {\n        for (int j = 1; j <= n; j++) {\n            if (i != j) f[i][j] = 1000000000;\n            else f[i][j] = 0;\n        }\n    }\n    for (int len = 2; len <= n; len++) {\n        for (int i = 1; i <= n - len + 1; i++) {\n            int j = i + len - 1;\n            f[i][j] = f[i][j - 1] + 1;\n            for (int l = pre[j]; l >= i; l = pre[l]) {\n                f[i][j] = f[i][j] < f[i][l] + f[l + 1][j] ? f[i][j] : f[i][l] + f[l + 1][j];\n            }\n        }\n    }\n    return f[1][n];\n}\n```\nFix bugs in the given code snippet. The fixed code must be placed between ```cpp```. Do not generate any test, main,example usage or check code!\n"}
{"question_id": "CPP/41", "category": "Logic", "subtype": "variable_error", "level": "medium", "example": "* Examples:\n *   minOperations(5, {1, 2, 3, 2, 1}) -> 2", "docstring": "* You are given a 1 by n pixel image, where each pixel has a color \n * represented by an integer. You can perform an operation where you \n * pick a color and change all connected pixels of the same color to \n * the chosen color. Two pixels are connected if they are adjacent \n * and have the same color. Find the minimum number of operations \n * required to make all pixels the same color.\n *\n * Note: For each color, there are at most 20 pixels of that color.\n *", "canonical_solution": "#include <cassert>\n#include <cstdio>\n\nint minOperations(int n, int* pixels)\n\n{\n    int pre[n+1], u[n+1], f[n+1][n+1];\n    for (int i = 1; i <= n; i++) {\n        pre[i] = u[i] = 0;\n    }\n    for (int i = 1; i <= n; i++) {\n        pre[i] = u[pixels[i-1]];\n        u[pixels[i-1]] = i;\n    }\n    for (int i = 1; i <= n; i++) {\n        for (int j = 1; j <= n; j++) {\n            if (i != j) f[i][j] = 1000000000;\n            else f[i][j] = 0;\n        }\n    }\n    for (int len = 2; len <= n; len++) {\n        for (int i = 1; i <= n - len + 1; i++) {\n            int j = i + len - 1;\n            f[i][j] = f[i][j - 1] + 1;\n            for (int l = pre[j]; l >= i; l = pre[l]) {\n                f[i][j] = f[i][j] < f[i][l] + f[l + 1][j] ? f[i][j] : f[i][l] + f[l + 1][j];\n            }\n        }\n    }\n    return f[1][n];\n}", "buggy_code": "#include <cassert>\n#include <cstdio>\nint minOperations(int n, int* pixels)\n{\n    int pre[n+1], u[n+1], f[n+1];\n    for (int i = 1; i <= n; i++) {\n        pre[i] = u[i] = 0;\n    }\n    for (int i = 1; i <= n; i++) {\n        pre[i] = u[pixels[i-1]];\n        u[pixels[i-1]] = i;\n    }\n    for (int i = 1; i <= n; i++) {\n        for (int j = 1; j <= n; j++) {\n            if (i != j) f[i][j] = 1000000000;\n            else f[i][j] = 0;\n        }\n    }\n    for (int len = 2; len <= n; len++) {\n        for (int i = 1; i <= n - len + 1; i++) {\n            int j = i + len - 1;\n            f[i][j] = f[i][j - 1] + 1;\n            for (int l = pre[j]; l >= i; l = pre[l]) {\n                f[i][j] = f[i][j] < f[i][l] + f[l + 1][j] ? f[i][j] : f[i][l] + f[l + 1][j];\n            }\n        }\n    }\n    return f[1][n];\n}", "bug_with_line_numbers": "   1 | #include <cassert>\n   2 | #include <cstdio>\n   3 | int minOperations(int n, int* pixels)\n   4 | {\n   5 |     int pre[n+1], u[n+1], f[n+1];\n   6 |     for (int i = 1; i <= n; i++) {\n   7 |         pre[i] = u[i] = 0;\n   8 |     }\n   9 |     for (int i = 1; i <= n; i++) {\n  10 |         pre[i] = u[pixels[i-1]];\n  11 |         u[pixels[i-1]] = i;\n  12 |     }\n  13 |     for (int i = 1; i <= n; i++) {\n  14 |         for (int j = 1; j <= n; j++) {\n  15 |             if (i != j) f[i][j] = 1000000000;\n  16 |             else f[i][j] = 0;\n  17 |         }\n  18 |     }\n  19 |     for (int len = 2; len <= n; len++) {\n  20 |         for (int i = 1; i <= n - len + 1; i++) {\n  21 |             int j = i + len - 1;\n  22 |             f[i][j] = f[i][j - 1] + 1;\n  23 |             for (int l = pre[j]; l >= i; l = pre[l]) {\n  24 |                 f[i][j] = f[i][j] < f[i][l] + f[l + 1][j] ? f[i][j] : f[i][l] + f[l + 1][j];\n  25 |             }\n  26 |         }\n  27 |     }\n  28 |     return f[1][n];\n  29 | }", "fragment_lines": [5], "fragment_content": ["int pre[n+1], u[n+1], f[n+1];"], "test": "int main() {\n    int a1[] = {1, 2, 3, 2, 1};\n    int a2[] = {1, 1, 2, 2};\n    int a3[] = {1, 2, 1, 4, 2};\n    int a4[] = {5, 5, 5, 5, 5};\n    int a5[] = {1, 1, 1, 2, 2, 2};\n    int a6[] = {1, 3, 3, 3, 2, 2, 2};\n    int a7[] = {4, 4, 4, 4, 3, 3, 3, 3};\n    int a8[] = {1, 2, 3, 4, 5, 6, 7, 8, 9};\n    int a9[] = {1, 2, 1, 2, 1, 2, 1, 2, 1, 2};\n    int a10[] = {3, 3, 3};\n    int a11[] = {2, 1, 1, 2};\n    assert(minOperations(5, a1) == 2);\n    assert(minOperations(4, a2) == 1);\n    assert(minOperations(5, a3) == 3);\n    assert(minOperations(5, a4) == 0);\n    assert(minOperations(6, a5) == 1);\n    assert(minOperations(7, a6) == 2);\n    assert(minOperations(8, a7) == 1);\n    assert(minOperations(9, a8) == 8);\n    assert(minOperations(10, a9) == 5);\n    assert(minOperations(3, a10) == 0);\n    assert(minOperations(4, a11) == 1);\n    return 0;\n}", "instruction": "Observe the following faulty CPP code\n```cpp\n#include <cassert>\n#include <cstdio>\nint minOperations(int n, int* pixels)\n{\n    int pre[n+1], u[n+1], f[n+1];\n    for (int i = 1; i <= n; i++) {\n        pre[i] = u[i] = 0;\n    }\n    for (int i = 1; i <= n; i++) {\n        pre[i] = u[pixels[i-1]];\n        u[pixels[i-1]] = i;\n    }\n    for (int i = 1; i <= n; i++) {\n        for (int j = 1; j <= n; j++) {\n            if (i != j) f[i][j] = 1000000000;\n            else f[i][j] = 0;\n        }\n    }\n    for (int len = 2; len <= n; len++) {\n        for (int i = 1; i <= n - len + 1; i++) {\n            int j = i + len - 1;\n            f[i][j] = f[i][j - 1] + 1;\n            for (int l = pre[j]; l >= i; l = pre[l]) {\n                f[i][j] = f[i][j] < f[i][l] + f[l + 1][j] ? f[i][j] : f[i][l] + f[l + 1][j];\n            }\n        }\n    }\n    return f[1][n];\n}\n```\nFix bugs in the given code snippet. The fixed code must be placed between ```cpp```. Do not generate any test, main,example usage or check code!\n"}
{"question_id": "CPP/42", "category": "Logic", "subtype": "variable_error", "level": "medium", "example": "* Examples:\n *   minOperations(5, {1, 2, 3, 2, 1}) -> 2", "docstring": "* You are given a 1 by n pixel image, where each pixel has a color \n * represented by an integer. You can perform an operation where you \n * pick a color and change all connected pixels of the same color to \n * the chosen color. Two pixels are connected if they are adjacent \n * and have the same color. Find the minimum number of operations \n * required to make all pixels the same color.\n *\n * Note: For each color, there are at most 20 pixels of that color.\n *", "canonical_solution": "#include <cassert>\n#include <cstdio>\n\nint minOperations(int n, int* pixels)\n\n{\n    int pre[n+1], u[n+1], f[n+1][n+1];\n    for (int i = 1; i <= n; i++) {\n        pre[i] = u[i] = 0;\n    }\n    for (int i = 1; i <= n; i++) {\n        pre[i] = u[pixels[i-1]];\n        u[pixels[i-1]] = i;\n    }\n    for (int i = 1; i <= n; i++) {\n        for (int j = 1; j <= n; j++) {\n            if (i != j) f[i][j] = 1000000000;\n            else f[i][j] = 0;\n        }\n    }\n    for (int len = 2; len <= n; len++) {\n        for (int i = 1; i <= n - len + 1; i++) {\n            int j = i + len - 1;\n            f[i][j] = f[i][j - 1] + 1;\n            for (int l = pre[j]; l >= i; l = pre[l]) {\n                f[i][j] = f[i][j] < f[i][l] + f[l + 1][j] ? f[i][j] : f[i][l] + f[l + 1][j];\n            }\n        }\n    }\n    return f[1][n];\n}", "buggy_code": "#include <cassert>\n#include <cstdio>\nint minOperations(int n, int* pixels)\n{\n    int u[n+1], f[n+1][n+1];\n    for (int i = 1; i <= n; i++) {\n        pre[i] = u[i] = 0;\n    }\n    for (int i = 1; i <= n; i++) {\n        pre[i] = u[pixels[i-1]];\n        u[pixels[i-1]] = i;\n    }\n    for (int i = 1; i <= n; i++) {\n        for (int j = 1; j <= n; j++) {\n            if (i != j) f[i][j] = 1000000000;\n            else f[i][j] = 0;\n        }\n    }\n    for (int len = 2; len <= n; len++) {\n        for (int i = 1; i <= n - len + 1; i++) {\n            int j = i + len - 1;\n            f[i][j] = f[i][j - 1] + 1;\n            for (int l = pre[j]; l >= i; l = pre[l]) {\n                f[i][j] = f[i][j] < f[i][l] + f[l + 1][j] ? f[i][j] : f[i][l] + f[l + 1][j];\n            }\n        }\n    }\n    return f[1][n];\n}", "bug_with_line_numbers": "   1 | #include <cassert>\n   2 | #include <cstdio>\n   3 | int minOperations(int n, int* pixels)\n   4 | {\n   5 |     int u[n+1], f[n+1][n+1];\n   6 |     for (int i = 1; i <= n; i++) {\n   7 |         pre[i] = u[i] = 0;\n   8 |     }\n   9 |     for (int i = 1; i <= n; i++) {\n  10 |         pre[i] = u[pixels[i-1]];\n  11 |         u[pixels[i-1]] = i;\n  12 |     }\n  13 |     for (int i = 1; i <= n; i++) {\n  14 |         for (int j = 1; j <= n; j++) {\n  15 |             if (i != j) f[i][j] = 1000000000;\n  16 |             else f[i][j] = 0;\n  17 |         }\n  18 |     }\n  19 |     for (int len = 2; len <= n; len++) {\n  20 |         for (int i = 1; i <= n - len + 1; i++) {\n  21 |             int j = i + len - 1;\n  22 |             f[i][j] = f[i][j - 1] + 1;\n  23 |             for (int l = pre[j]; l >= i; l = pre[l]) {\n  24 |                 f[i][j] = f[i][j] < f[i][l] + f[l + 1][j] ? f[i][j] : f[i][l] + f[l + 1][j];\n  25 |             }\n  26 |         }\n  27 |     }\n  28 |     return f[1][n];\n  29 | }", "fragment_lines": [5], "fragment_content": ["int u[n+1], f[n+1][n+1];"], "test": "int main() {\n    int a1[] = {1, 2, 3, 2, 1};\n    int a2[] = {1, 1, 2, 2};\n    int a3[] = {1, 2, 1, 4, 2};\n    int a4[] = {5, 5, 5, 5, 5};\n    int a5[] = {1, 1, 1, 2, 2, 2};\n    int a6[] = {1, 3, 3, 3, 2, 2, 2};\n    int a7[] = {4, 4, 4, 4, 3, 3, 3, 3};\n    int a8[] = {1, 2, 3, 4, 5, 6, 7, 8, 9};\n    int a9[] = {1, 2, 1, 2, 1, 2, 1, 2, 1, 2};\n    int a10[] = {3, 3, 3};\n    int a11[] = {2, 1, 1, 2};\n    assert(minOperations(5, a1) == 2);\n    assert(minOperations(4, a2) == 1);\n    assert(minOperations(5, a3) == 3);\n    assert(minOperations(5, a4) == 0);\n    assert(minOperations(6, a5) == 1);\n    assert(minOperations(7, a6) == 2);\n    assert(minOperations(8, a7) == 1);\n    assert(minOperations(9, a8) == 8);\n    assert(minOperations(10, a9) == 5);\n    assert(minOperations(3, a10) == 0);\n    assert(minOperations(4, a11) == 1);\n    return 0;\n}", "instruction": "Observe the following faulty CPP code\n```cpp\n#include <cassert>\n#include <cstdio>\nint minOperations(int n, int* pixels)\n{\n    int u[n+1], f[n+1][n+1];\n    for (int i = 1; i <= n; i++) {\n        pre[i] = u[i] = 0;\n    }\n    for (int i = 1; i <= n; i++) {\n        pre[i] = u[pixels[i-1]];\n        u[pixels[i-1]] = i;\n    }\n    for (int i = 1; i <= n; i++) {\n        for (int j = 1; j <= n; j++) {\n            if (i != j) f[i][j] = 1000000000;\n            else f[i][j] = 0;\n        }\n    }\n    for (int len = 2; len <= n; len++) {\n        for (int i = 1; i <= n - len + 1; i++) {\n            int j = i + len - 1;\n            f[i][j] = f[i][j - 1] + 1;\n            for (int l = pre[j]; l >= i; l = pre[l]) {\n                f[i][j] = f[i][j] < f[i][l] + f[l + 1][j] ? f[i][j] : f[i][l] + f[l + 1][j];\n            }\n        }\n    }\n    return f[1][n];\n}\n```\nFix bugs in the given code snippet. The fixed code must be placed between ```cpp```. Do not generate any test, main,example usage or check code!\n"}
{"question_id": "CPP/43", "category": "Logic", "subtype": "variable_error", "level": "easy", "example": "* Examples:\n *   >>> isPalindrome(\"racecar\")\n *   true\n *   >>> isPalindrome(\"hello\")\n *   false", "docstring": "* Determine if a given string is a palindrome. A palindrome is a word, phrase,\n * number, or other sequence of characters that reads the same forward and\n * backward (ignoring spaces, punctuation, and capitalization).", "canonical_solution": "#include <cassert>\n#include <cctype> \n#include <cstring>\n\nbool isPalindrome(const char* str)\n\n{\n    int start = 0;\n    int end = strlen(str) - 1;\n    \n    while (start < end) {\n        while (!isalnum(str[start]) && start < end) start++;\n        while (!isalnum(str[end]) && start < end) end--;\n        if (tolower(str[start]) != tolower(str[end]))\n            return false;\n        start++;\n        end--;\n    }\n    return true;\n}", "buggy_code": "#include <cassert>\n#include <cctype> \n#include <cstring>\nbool isPalindrome(const char* str)\n{\n    int end = strlen(str) - 1;\n    \n    while (start < end) {\n        while (!isalnum(str[start]) && start < end) start++;\n        while (!isalnum(str[end]) && start < end) end--;\n        if (tolower(str[start]) != tolower(str[end]))\n            return false;\n        start++;\n        end--;\n    }\n    return true;\n}", "bug_with_line_numbers": "   1 | #include <cassert>\n   2 | #include <cctype> \n   3 | #include <cstring>\n   4 | bool isPalindrome(const char* str)\n   5 | {\n   6 |     int end = strlen(str) - 1;\n   7 |     \n   8 |     while (start < end) {\n   9 |         while (!isalnum(str[start]) && start < end) start++;\n  10 |         while (!isalnum(str[end]) && start < end) end--;\n  11 |         if (tolower(str[start]) != tolower(str[end]))\n  12 |             return false;\n  13 |         start++;\n  14 |         end--;\n  15 |     }\n  16 |     return true;\n  17 | }", "fragment_lines": [-1], "fragment_content": ["missing critical code snippet"], "test": "int main()\n{\n    assert(isPalindrome(\"A man a plan a canal Panama\") == true);\n    assert(isPalindrome(\"No lemon, no melon\") == true);\n    assert(isPalindrome(\"Was it a car or a cat I saw\") == true);\n    assert(isPalindrome(\"Madam, in Eden, I'm Adam\") == true);\n    assert(isPalindrome(\"Never odd or even\") == true);\n    assert(isPalindrome(\"Eva, can I see bees in a cave\") == true);\n    assert(isPalindrome(\"hello\") == false);\n    assert(isPalindrome(\"GitHub\") == false);\n    assert(isPalindrome(\"programming\") == false);\n    \n    return 0;\n}", "instruction": "Observe the following faulty CPP code\n```cpp\n#include <cassert>\n#include <cctype> \n#include <cstring>\nbool isPalindrome(const char* str)\n{\n    int end = strlen(str) - 1;\n    \n    while (start < end) {\n        while (!isalnum(str[start]) && start < end) start++;\n        while (!isalnum(str[end]) && start < end) end--;\n        if (tolower(str[start]) != tolower(str[end]))\n            return false;\n        start++;\n        end--;\n    }\n    return true;\n}\n```\nFix bugs in the given code snippet. The fixed code must be placed between ```cpp```. Do not generate any test, main,example usage or check code!\n"}
{"question_id": "CPP/44", "category": "Logic", "subtype": "variable_error", "level": "medium", "example": "* Examples:\n *   >>> isPalindrome(\"racecar\")\n *   true\n *   >>> isPalindrome(\"hello\")\n *   false", "docstring": "* Determine if a given string is a palindrome. A palindrome is a word, phrase,\n * number, or other sequence of characters that reads the same forward and\n * backward (ignoring spaces, punctuation, and capitalization).", "canonical_solution": "#include <cassert>\n#include <cctype> \n#include <cstring>\n\nbool isPalindrome(const char* str)\n\n{\n    int start = 0;\n    int end = strlen(str) - 1;\n    \n    while (start < end) {\n        while (!isalnum(str[start]) && start < end) start++;\n        while (!isalnum(str[end]) && start < end) end--;\n        if (tolower(str[start]) != tolower(str[end]))\n            return false;\n        start++;\n        end--;\n    }\n    return true;\n}", "buggy_code": "#include <cassert>\n#include <cctype> \n#include <cstring>\nbool isPalindrome(const char* str)\n{\n    int start = 0;\n    int end = strlen(str) + 1;\n    \n    while (start < end) {\n        while (!isalnum(str[start]) && start < end) start++;\n        while (!isalnum(str[end]) && start < end) end--;\n        if (tolower(str[start]) != tolower(str[end]))\n            return false;\n        start++;\n        end--;\n    }\n    return true;\n}", "bug_with_line_numbers": "   1 | #include <cassert>\n   2 | #include <cctype> \n   3 | #include <cstring>\n   4 | bool isPalindrome(const char* str)\n   5 | {\n   6 |     int start = 0;\n   7 |     int end = strlen(str) + 1;\n   8 |     \n   9 |     while (start < end) {\n  10 |         while (!isalnum(str[start]) && start < end) start++;\n  11 |         while (!isalnum(str[end]) && start < end) end--;\n  12 |         if (tolower(str[start]) != tolower(str[end]))\n  13 |             return false;\n  14 |         start++;\n  15 |         end--;\n  16 |     }\n  17 |     return true;\n  18 | }", "fragment_lines": [7], "fragment_content": ["int end = strlen(str) + 1;"], "test": "int main()\n{\n    assert(isPalindrome(\"A man a plan a canal Panama\") == true);\n    assert(isPalindrome(\"No lemon, no melon\") == true);\n    assert(isPalindrome(\"Was it a car or a cat I saw\") == true);\n    assert(isPalindrome(\"Madam, in Eden, I'm Adam\") == true);\n    assert(isPalindrome(\"Never odd or even\") == true);\n    assert(isPalindrome(\"Eva, can I see bees in a cave\") == true);\n    assert(isPalindrome(\"hello\") == false);\n    assert(isPalindrome(\"GitHub\") == false);\n    assert(isPalindrome(\"programming\") == false);\n    \n    return 0;\n}", "instruction": "Observe the following faulty CPP code\n```cpp\n#include <cassert>\n#include <cctype> \n#include <cstring>\nbool isPalindrome(const char* str)\n{\n    int start = 0;\n    int end = strlen(str) + 1;\n    \n    while (start < end) {\n        while (!isalnum(str[start]) && start < end) start++;\n        while (!isalnum(str[end]) && start < end) end--;\n        if (tolower(str[start]) != tolower(str[end]))\n            return false;\n        start++;\n        end--;\n    }\n    return true;\n}\n```\nFix bugs in the given code snippet. The fixed code must be placed between ```cpp```. Do not generate any test, main,example usage or check code!\n"}
{"question_id": "CPP/45", "category": "Multiple", "subtype": "double_bug", "level": "hard", "example": ">>> Example call: \nint max, min;\nfind_max_min(1,2,3, &max, &min);\nassert(max == 3 && min == 1);", "docstring": "Find the maximum and minimum of three distinct integers.\nParameters:\na (int): The first integer.\nb (int): The second integer.\nc (int): The third integer.\n\nReturns:\nTuple[int, int]: A tuple is not a concept in C; instead, we will return by Reference.", "canonical_solution": "#include <cassert>\n#include <cstdio>\n\nvoid find_max_min(int a, int b, int c, int *max, int *min)\n\n{\n    if (a > b) {\n        if (a > c) {\n            *max = a;\n            *min = (b < c) ? b : c;\n        } else {\n            *max = c;\n            *min = b;\n        }\n    } else if (b > c) {\n        *max = b;\n        *min = (a < c) ? a : c;\n    } else {\n        *max = c;\n        *min = a;\n    }\n}", "buggy_code": "#include <cassert>\n#include <cstdio>\nvoid find_max_min(int a, int b, int c, int max, int *min)\n{\n    if (a > b) {\n        if (a > c) {\n            *max = a;\n            *min = (b < c) ? b : c;\n        } else {\n            *max = c;\n            *min = b;\n        }\n    } else if (b > c) {\n        *max = b;\n        *min = (a < c) ? a : c;\n    } else {\n        *max = c;\n        *min = b;\n    }\n}", "bug_with_line_numbers": "   1 | #include <cassert>\n   2 | #include <cstdio>\n   3 | void find_max_min(int a, int b, int c, int max, int *min)\n   4 | {\n   5 |     if (a > b) {\n   6 |         if (a > c) {\n   7 |             *max = a;\n   8 |             *min = (b < c) ? b : c;\n   9 |         } else {\n  10 |             *max = c;\n  11 |             *min = b;\n  12 |         }\n  13 |     } else if (b > c) {\n  14 |         *max = b;\n  15 |         *min = (a < c) ? a : c;\n  16 |     } else {\n  17 |         *max = c;\n  18 |         *min = b;\n  19 |     }\n  20 | }", "fragment_lines": [3, 18], "fragment_content": ["void find_max_min(int a, int b, int c, int max, int *min)", "*min = b;"], "test": "int main() {\n    int max, min;\n\n    // Test with a set of values\n    find_max_min(1, 2, 3, &max, &min);\n    assert(max == 3 && min == 1);\n\n    // Additional tests\n    find_max_min(5, 3, 4, &max, &min);\n    assert(max == 5 && min == 3);\n\n    find_max_min(10, -2, 7, &max, &min);\n    assert(max == 10 && min == -2);\n\n    find_max_min(-1, -3, -2, &max, &min);\n    assert(max == -1 && min == -3);\n\n    return 0;\n}", "instruction": "Observe the following faulty CPP code\n```cpp\n#include <cassert>\n#include <cstdio>\nvoid find_max_min(int a, int b, int c, int max, int *min)\n{\n    if (a > b) {\n        if (a > c) {\n            *max = a;\n            *min = (b < c) ? b : c;\n        } else {\n            *max = c;\n            *min = b;\n        }\n    } else if (b > c) {\n        *max = b;\n        *min = (a < c) ? a : c;\n    } else {\n        *max = c;\n        *min = b;\n    }\n}\n```\nFix bugs in the given code snippet. The fixed code must be placed between ```cpp```. Do not generate any test, main,example usage or check code!\n"}
{"question_id": "CPP/46", "category": "Multiple", "subtype": "double_bug", "level": "hard", "example": "* Examples:\n * >>> process_request(1)\n * 1\n * >>> process_request(10)\n * 6266", "docstring": "* Calculates the factorial of N modulo 10007.\n * \n * Parameters:\n * - N (int): An integer representing the input value (N <= 10000).\n * \n * Returns:\n * int: The result after calculating the factorial of N and\n * taking the modulo 10007.\n *", "canonical_solution": "#include <cassert>\n#include <cmath>\n#include <cstdio>\n#include <cstring>\n\nint process_request(int n)\n\n{\n    int a[10010];\n    a[0] = 1;\n    a[1] = 1;\n    for (register int i = 2; i <= 10000; i++) {\n        a[i] = (a[i - 1] * i) % 10007;\n    }\n    return a[n];\n}", "buggy_code": "#include <cassert>\n#include <cmath>\n#include <cstdio>\n#include <cstring>\nint process_request(int n)\n{\n    int a[10010];\n    a[0] = 0;\n    a[1] = 1;\n    for (register int i = 2; i <= 10000; i++) {\n        a[i] = (a[i-1] + i) % 10007;\n    }\n    return a[n];\n}", "bug_with_line_numbers": "   1 | #include <cassert>\n   2 | #include <cmath>\n   3 | #include <cstdio>\n   4 | #include <cstring>\n   5 | int process_request(int n)\n   6 | {\n   7 |     int a[10010];\n   8 |     a[0] = 0;\n   9 |     a[1] = 1;\n  10 |     for (register int i = 2; i <= 10000; i++) {\n  11 |         a[i] = (a[i-1] + i) % 10007;\n  12 |     }\n  13 |     return a[n];\n  14 | }", "fragment_lines": [8, 11], "fragment_content": ["a[0] = 0;", "a[i] = (a[i-1] + i) % 10007;"], "test": "int main()\n{\n    assert(process_request(0) == 1); // Added test for boundary condition\n    assert(process_request(1) == 1);\n    assert(process_request(2) == 2);\n    assert(process_request(3) == 6);\n    assert(process_request(4) == 24);\n    assert(process_request(10) == 6266); // 10! % 10007 = 3628800 % 10007 = 6266\n    assert(process_request(10000) == 6991); // Added a test for upper boundary condition\n    // printf(\"All tests passed.\\n\");\n    return 0;\n}", "instruction": "Observe the following faulty CPP code\n```cpp\n#include <cassert>\n#include <cmath>\n#include <cstdio>\n#include <cstring>\nint process_request(int n)\n{\n    int a[10010];\n    a[0] = 0;\n    a[1] = 1;\n    for (register int i = 2; i <= 10000; i++) {\n        a[i] = (a[i-1] + i) % 10007;\n    }\n    return a[n];\n}\n```\nFix bugs in the given code snippet. The fixed code must be placed between ```cpp```. Do not generate any test, main,example usage or check code!\n"}
{"question_id": "CPP/47", "category": "Multiple", "subtype": "double_bug", "level": "easy", "example": ">>> hamming_distance(1,2)\n\t2", "docstring": "Calculate the Hamming distance between two integers in binary representation.\n​    Parameters:\n- x (int): The first positive integer (x <= 1,000,000,000).\n- y (int): The second positive integer (y <= 1,000,000,000).\n​    Returns:\n​    int: The Hamming distance between x and y, i.e., the number of bits that need to be flipped\n​         to transform x into y in binary.", "canonical_solution": "#include <bits/stdc++.h>\n\nint hamming_distance(int x, int y)\n\n{\n    int distance = 0;\n    int xor_result = x ^ y;\n    while (xor_result) {\n        if (xor_result & 1) {\n            distance++;\n        }\n        xor_result >>= 1;\n    }\n    return distance;\n}", "buggy_code": "#include <bits/stdc++.h>\nint hamming_distance(int x, int y)\n{\n    int distance = 1;\n    int xor_result = x ^ y;\n    while (xor_result) {\n        if (xor_result & 1) {\n            distance++;\n        }\n    }\n    xor_result >>= 1;\n    return distance;\n}", "bug_with_line_numbers": "   1 | #include <bits/stdc++.h>\n   2 | int hamming_distance(int x, int y)\n   3 | {\n   4 |     int distance = 1;\n   5 |     int xor_result = x ^ y;\n   6 |     while (xor_result) {\n   7 |         if (xor_result & 1) {\n   8 |             distance++;\n   9 |         }\n  10 |     }\n  11 |     xor_result >>= 1;\n  12 |     return distance;\n  13 | }", "fragment_lines": [4, -1], "fragment_content": ["int distance = 1;", "missing critical code snippet"], "test": "int main() {\n    assert(hamming_distance(1, 2) == 2); // 01 and 10 have 2 different bits\n    assert(hamming_distance(4, 7) == 2); // 100 and 111 have 2 different bits\n    assert(hamming_distance(25, 30) == 3); // Additional test: 11001 and 11110 have 3 different bits\n    assert(hamming_distance(0, 0) == 0); // Additional test: Same numbers have 0 different bits\n    assert(hamming_distance(0xFFFFFFF, 0x0000000) == 28); // Additional test: Max unsigned int and 0 have 32 different bits\n    return 0;\n}", "instruction": "Observe the following faulty CPP code\n```cpp\n#include <bits/stdc++.h>\nint hamming_distance(int x, int y)\n{\n    int distance = 1;\n    int xor_result = x ^ y;\n    while (xor_result) {\n        if (xor_result & 1) {\n            distance++;\n        }\n    }\n    xor_result >>= 1;\n    return distance;\n}\n```\nFix bugs in the given code snippet. The fixed code must be placed between ```cpp```. Do not generate any test, main,example usage or check code!\n"}
{"question_id": "CPP/48", "category": "Multiple", "subtype": "double_bug", "level": "medium", "example": "* Usage:\n *   count_odd_numbers(5, 1, 4, 3, 2, 5) should return 3", "docstring": "* Count the number of odd integers in a given list of numbers.\n * Parameters:\n * - count (int): The number of integers to evaluate.\n * - ... (int): A sequence of integers.\n * Returns:\n *   int: The count of odd numbers in the input list.", "canonical_solution": "#include <assert.h>\n#include <stdarg.h>\n\n\nint count_odd_numbers(int count, ...)\n\n{\n    va_list args;\n    va_start(args, count);\n    int ans = 0;\n    for (int i = 0; i < count; i++) {\n        int num = va_arg(args, int);\n        if (num & 1) {\n            ans++;\n        }\n    }\n    va_end(args);\n    return ans;\n}", "buggy_code": "#include <assert.h>\n#include <stdarg.h>\nint count_odd_numbers(int count, ...)\n{\n    va_list args;\n    va_start(args, count);\n    int ans = 1;\n    for (int i = 0; i <= count; i++) {\n        int num = va_arg(args, int);\n        if (num & 1) {\n            ans++;\n        }\n    }\n    va_end(args);\n    return ans;\n}", "bug_with_line_numbers": "   1 | #include <assert.h>\n   2 | #include <stdarg.h>\n   3 | int count_odd_numbers(int count, ...)\n   4 | {\n   5 |     va_list args;\n   6 |     va_start(args, count);\n   7 |     int ans = 1;\n   8 |     for (int i = 0; i <= count; i++) {\n   9 |         int num = va_arg(args, int);\n  10 |         if (num & 1) {\n  11 |             ans++;\n  12 |         }\n  13 |     }\n  14 |     va_end(args);\n  15 |     return ans;\n  16 | }", "fragment_lines": [7, 8], "fragment_content": ["int ans = 1;", "for (int i = 0; i <= count; i++) {"], "test": "int main() {\n    assert(count_odd_numbers(5, 1, 4, 3, 2, 5) == 3);\n    assert(count_odd_numbers(4, 2, 2, 0, 0) == 0);\n    assert(count_odd_numbers(6, 7, 7, 8, 1, 9, 10) == 4); // Additional Test Sample\n    // Uncomment the following line to print a success message\n    // std::printf(\"All tests passed!\\n\");\n    return 0;\n}", "instruction": "Observe the following faulty CPP code\n```cpp\n#include <assert.h>\n#include <stdarg.h>\nint count_odd_numbers(int count, ...)\n{\n    va_list args;\n    va_start(args, count);\n    int ans = 1;\n    for (int i = 0; i <= count; i++) {\n        int num = va_arg(args, int);\n        if (num & 1) {\n            ans++;\n        }\n    }\n    va_end(args);\n    return ans;\n}\n```\nFix bugs in the given code snippet. The fixed code must be placed between ```cpp```. Do not generate any test, main,example usage or check code!\n"}
{"question_id": "CPP/49", "category": "Multiple", "subtype": "double_bug", "level": "easy", "example": "Example usage:\nassert(decode_numbers(\"0000\") == 4);", "docstring": "Decode a series of numbers to reveal the pattern and understand the actual values \neach digit represents.\n\nEquations provided for Reference:\n0000=4 8888=8 1234=1 5678=3 9012=2 1357=0 2468=4\n\nParameters:\n- data_str: A constant character array (C-style string) representing a series of numbers. Length does not exceed 100.\n\nReturns:\nint: The result of each data string corresponding to the right-hand side of the equation.", "canonical_solution": "#include <cassert>\n#include <cstring>\n#include <iostream>\n\nint decode_numbers(const char* data_str)\n\n{\n    int a[] = {1, 0, 0, 0, 1, 0, 1, 0, 2, 1};\n    int ans = 0;\n    for(int i = 0; i < std::strlen(data_str); i++) {\n        ans += a[data_str[i] - '0'];\n    }\n    return ans;\n}", "buggy_code": "#include <cassert>\n#include <cstring>\n#include <iostream>\nint decode_numbers(const char* data_str)\n{\n    int a[] = {1, 0, 0, 0, 1, 0, 1, 0, 2, 1};\n    int ans = 0;\n    for(int i = 0; i < std:strlen(data_str); i++) {\n        ans += a[data_str[i] + '0'];\n    }\n    return ans;\n}", "bug_with_line_numbers": "   1 | #include <cassert>\n   2 | #include <cstring>\n   3 | #include <iostream>\n   4 | int decode_numbers(const char* data_str)\n   5 | {\n   6 |     int a[] = {1, 0, 0, 0, 1, 0, 1, 0, 2, 1};\n   7 |     int ans = 0;\n   8 |     for(int i = 0; i < std:strlen(data_str); i++) {\n   9 |         ans += a[data_str[i] + '0'];\n  10 |     }\n  11 |     return ans;\n  12 | }", "fragment_lines": [8, 9], "fragment_content": ["for(int i = 0; i < std:strlen(data_str); i++) {", "ans += a[data_str[i] + '0'];"], "test": "int main() {\n    // Assert basic provided test cases\n    assert(decode_numbers(\"0000\") == 4);\n    assert(decode_numbers(\"8888\") == 8);\n    assert(decode_numbers(\"1234\") == 1);\n    assert(decode_numbers(\"5678\") == 3);\n    assert(decode_numbers(\"9012\") == 2);\n    assert(decode_numbers(\"1357\") == 0);\n    assert(decode_numbers(\"2468\") == 4);\n\n    // Assert additional test cases\n    assert(decode_numbers(\"9999\") == 4);\n    assert(decode_numbers(\"1111\") == 0);\n    assert(decode_numbers(\"2222\") == 0);\n    assert(decode_numbers(\"3333\") == 0);\n    assert(decode_numbers(\"4444\") == 4);\n    assert(decode_numbers(\"5555\") == 0);\n    assert(decode_numbers(\"6666\") == 4);\n    assert(decode_numbers(\"7777\") == 0);\n    assert(decode_numbers(\"0001\") == 3);\n    assert(decode_numbers(\"2301\") == 1);\n\n    // Indicate that all tests passed\n    // std::cout << \"All tests passed successfully!\" << std::endl;\n\n    return 0;\n}", "instruction": "Observe the following faulty CPP code\n```cpp\n#include <cassert>\n#include <cstring>\n#include <iostream>\nint decode_numbers(const char* data_str)\n{\n    int a[] = {1, 0, 0, 0, 1, 0, 1, 0, 2, 1};\n    int ans = 0;\n    for(int i = 0; i < std:strlen(data_str); i++) {\n        ans += a[data_str[i] + '0'];\n    }\n    return ans;\n}\n```\nFix bugs in the given code snippet. The fixed code must be placed between ```cpp```. Do not generate any test, main,example usage or check code!\n"}
{"question_id": "CPP/50", "category": "Multiple", "subtype": "double_bug", "level": "easy", "example": ">>> shift_characters(\"NS BFW, JAJSYX TK NRUTWYFSHJ FWJ YMJ WJXZQY TK YWNANFQ HFZXJX\")\n\"IN WAR, EVENTS OF IMPORTANCE ARE THE RESULT OF TRIVIAL CAUSES\"", "docstring": "Shifts all characters by 5 positions in alphabetical order. Only letters are replaced,\nand all letters are in uppercase.\n\nParameters:\ntext (std::string&): The input text to be processed, modified in place.\n\nReturns:\nstd::string&: The transformed text with characters shifted by 5 positions.", "canonical_solution": "#include <bits/stdc++.h>\n\nstd::string& shift_characters(std::string& text)\n\n{\n    size_t len = text.length();\n    for (size_t i = 0; i < len; ++i) {\n        if ('A' <= text[i] && text[i] <= 'E') {\n            text[i] = text[i] + 'V' - 'A';\n        } else if ('F' <= text[i] && text[i] <= 'Z') {\n            text[i] = text[i] + 'A' - 'F';\n        }\n    }\n    return text;\n}", "buggy_code": "#include <bits/stdc++.h>\nstd::string& shift_characters(std::string& text)\n{\n    size_t len = text.length;\n    for (size_t i = 0; i < len; ++i) {\n        if ('A' <= text[i] && text[i] <= 'E') {\n            text[i] = text[i] + 'V' - 'A';\n        } else if ('F' <= text[i] || text[i] <= 'Z') {\n            text[i] = text[i] + 'A' - 'F';\n        }\n    }\n    return text;\n}", "bug_with_line_numbers": "   1 | #include <bits/stdc++.h>\n   2 | std::string& shift_characters(std::string& text)\n   3 | {\n   4 |     size_t len = text.length;\n   5 |     for (size_t i = 0; i < len; ++i) {\n   6 |         if ('A' <= text[i] && text[i] <= 'E') {\n   7 |             text[i] = text[i] + 'V' - 'A';\n   8 |         } else if ('F' <= text[i] || text[i] <= 'Z') {\n   9 |             text[i] = text[i] + 'A' - 'F';\n  10 |         }\n  11 |     }\n  12 |     return text;\n  13 | }", "fragment_lines": [4, 8], "fragment_content": ["size_t len = text.length;", "} else if ('F' <= text[i] || text[i] <= 'Z') {"], "test": "int main()\n{\n    std::string test1 = \"NS BFW, JAJSYX TK NRUTWYFSHJ FWJ YMJ WJXZQY TK YWNANFQ HFZXJX\";\n    std::string test2 = \"N BTZQI WFYMJW GJ KNWXY NS F QNYYQJ NGJWNFS ANQQFLJ YMFS XJHTSI NS WTRJ\";\n    std::string test3 = \"IFSLJW PSTBX KZQQ BJQQ YMFY HFJXFW NX RTWJ IFSLJWTZX YMFS MJ\";\n\n    assert(shift_characters(test1) == \"IN WAR, EVENTS OF IMPORTANCE ARE THE RESULT OF TRIVIAL CAUSES\");\n    assert(shift_characters(test2) == \"I WOULD RATHER BE FIRST IN A LITTLE IBERIAN VILLAGE THAN SECOND IN ROME\");\n    assert(shift_characters(test3) == \"DANGER KNOWS FULL WELL THAT CAESAR IS MORE DANGEROUS THAN HE\");\n    return 0;\n}", "instruction": "Observe the following faulty CPP code\n```cpp\n#include <bits/stdc++.h>\nstd::string& shift_characters(std::string& text)\n{\n    size_t len = text.length;\n    for (size_t i = 0; i < len; ++i) {\n        if ('A' <= text[i] && text[i] <= 'E') {\n            text[i] = text[i] + 'V' - 'A';\n        } else if ('F' <= text[i] || text[i] <= 'Z') {\n            text[i] = text[i] + 'A' - 'F';\n        }\n    }\n    return text;\n}\n```\nFix bugs in the given code snippet. The fixed code must be placed between ```cpp```. Do not generate any test, main,example usage or check code!\n"}
{"question_id": "CPP/51", "category": "Multiple", "subtype": "triple_bug", "level": "medium", "example": "* Examples:\n * count_coloring_methods(1,1) returns 1\n * count_coloring_methods(2,2) returns 2", "docstring": "* Counts the number of different coloring methods for n squares with m colors,\n * considering the requirement that adjacent squares and the first/last squares\n * must have different colors.\n * \n * @param n The number of squares.\n * @param m The number of colors.\n * @return The count of different coloring methods satisfying the specified conditions.\n *         The result is modulo 1000003.\n *", "canonical_solution": "#include <cassert>\n#include <iostream>\n\nint count_coloring_methods(int n, int m)\n\n{\n    int f[1111];\n    if (n == 1) return m;\n    if (n == 2) return static_cast<long long>(m) * (m - 1) % 1000003;\n    f[1] = m;\n    f[2] = static_cast<long long>(m) * (m - 1) % 1000003;\n    f[3] = static_cast<long long>(f[2]) * (m - 2) % 1000003;\n    for(int i = 4; i <= n; ++i) {\n        f[i] = (static_cast<long long>(f[i - 1]) * (m - 2) % 1000003 +\n                static_cast<long long>(f[i - 2]) * (m - 1) % 1000003) % 1000003;\n    }\n    return f[n];\n}", "buggy_code": "#include <cassert>\n#include <iostream>\nint count_coloring_methods(int n, int m)\n{\n    int f[1111];\n    if (n = 1) return m;\n    if (n == 2) return static_cast<long long>(m) * (m - 1) % 1000003;\n    f[1] = n;\n    f[2] = static_cast<long long>(m) * (m - 1) % 1000003;\n    f[3] = static_cast<long long>(f[2]) * (m - 2) % 1000003;\n    for(int i = 4; i <= n; ++i) {\n        f[i+1] = (static_cast<long long>(f[i - 1]) * (m - 2) % 1000003 +\n                static_cast<long long>(f[i - 2]) * (m - 1) % 1000003) % 1000003;\n    }\n    return f[n];\n}", "bug_with_line_numbers": "   1 | #include <cassert>\n   2 | #include <iostream>\n   3 | int count_coloring_methods(int n, int m)\n   4 | {\n   5 |     int f[1111];\n   6 |     if (n = 1) return m;\n   7 |     if (n == 2) return static_cast<long long>(m) * (m - 1) % 1000003;\n   8 |     f[1] = n;\n   9 |     f[2] = static_cast<long long>(m) * (m - 1) % 1000003;\n  10 |     f[3] = static_cast<long long>(f[2]) * (m - 2) % 1000003;\n  11 |     for(int i = 4; i <= n; ++i) {\n  12 |         f[i+1] = (static_cast<long long>(f[i - 1]) * (m - 2) % 1000003 +\n  13 |                 static_cast<long long>(f[i - 2]) * (m - 1) % 1000003) % 1000003;\n  14 |     }\n  15 |     return f[n];\n  16 | }", "fragment_lines": [6, 8, 12], "fragment_content": ["if (n = 1) return m;", "f[1] = n;", "f[i+1] = (static_cast<long long>(f[i - 1]) * (m - 2) % 1000003 +"], "test": "int main() {\n    assert(count_coloring_methods(1, 1) == 1);\n    assert(count_coloring_methods(2, 2) == 2);\n    assert(count_coloring_methods(3, 3) == 6);\n    assert(count_coloring_methods(4, 2) == 2);\n    assert(count_coloring_methods(1000, 10) == 566585); // We don't have the expected result for this case\n\n    // Additional test cases\n    assert(count_coloring_methods(2, 3) == 6);\n    assert(count_coloring_methods(1000, 1000) == 67911);\n    assert(count_coloring_methods(999, 66) == 501817);\n    assert(count_coloring_methods(5, 3) == 30); // Example of an expected output\n\n    // std::cout << \"All tests passed!\\n\";\n    return 0;\n}", "instruction": "Observe the following faulty CPP code\n```cpp\n#include <cassert>\n#include <iostream>\nint count_coloring_methods(int n, int m)\n{\n    int f[1111];\n    if (n = 1) return m;\n    if (n == 2) return static_cast<long long>(m) * (m - 1) % 1000003;\n    f[1] = n;\n    f[2] = static_cast<long long>(m) * (m - 1) % 1000003;\n    f[3] = static_cast<long long>(f[2]) * (m - 2) % 1000003;\n    for(int i = 4; i <= n; ++i) {\n        f[i+1] = (static_cast<long long>(f[i - 1]) * (m - 2) % 1000003 +\n                static_cast<long long>(f[i - 2]) * (m - 1) % 1000003) % 1000003;\n    }\n    return f[n];\n}\n```\nFix bugs in the given code snippet. The fixed code must be placed between ```cpp```. Do not generate any test, main,example usage or check code!\n"}
{"question_id": "CPP/52", "category": "Multiple", "subtype": "triple_bug", "level": "medium", "example": "* Examples:\n *   count_valid_coin_toss_sequences(1) returns 2\n *   count_valid_coin_toss_sequences(2) returns 3", "docstring": "* Count the number of valid coin toss sequences with no consecutive heads in n tosses.\n *\n * Parameters:\n * - n (int): The number of coin tosses.\n *\n * Returns:\n * - unsigned long long: The count of valid sequences.\n *", "canonical_solution": "#include <cassert>\n#include <cmath>\n#include <cstdio>\n#include <cstring>\n\nunsigned long long count_valid_coin_toss_sequences(int n)\n\n{\n    unsigned long long a[41][2];\n    a[1][0] = a[1][1] = 1;\n\n    for(int i = 2; i <= n; i++){\n        a[i][0] = a[i - 1][1] + a[i - 1][0];\n        a[i][1] = a[i - 1][0];\n    }\n\n    return a[n][0] + a[n][1];\n}", "buggy_code": "#include <cassert>\n#include <cmath>\n#include <cstdio>\n#include <cstring>\nunsigned long long count_valid_coin_toss_sequences(int* n)\n{\n    unsigned long long a[41][2];\n    a[1][0] = a[1][1] = 1;\n    for(int i = 2; i < n; i++){\n        a[i][0] = a[i - 1][0] + a[i - 1][0];\n        a[i][1] = a[i - 1][0];\n    }\n    return a[n][0] + a[n][1];\n}", "bug_with_line_numbers": "   1 | #include <cassert>\n   2 | #include <cmath>\n   3 | #include <cstdio>\n   4 | #include <cstring>\n   5 | unsigned long long count_valid_coin_toss_sequences(int* n)\n   6 | {\n   7 |     unsigned long long a[41][2];\n   8 |     a[1][0] = a[1][1] = 1;\n   9 |     for(int i = 2; i < n; i++){\n  10 |         a[i][0] = a[i - 1][0] + a[i - 1][0];\n  11 |         a[i][1] = a[i - 1][0];\n  12 |     }\n  13 |     return a[n][0] + a[n][1];\n  14 | }", "fragment_lines": [5, 9, 10], "fragment_content": ["unsigned long long count_valid_coin_toss_sequences(int* n)", "for(int i = 2; i < n; i++){", "a[i][0] = a[i - 1][0] + a[i - 1][0];"], "test": "int main() {\n    assert(count_valid_coin_toss_sequences(1) == 2);\n    assert(count_valid_coin_toss_sequences(2) == 3);\n    assert(count_valid_coin_toss_sequences(3) == 5);\n    assert(count_valid_coin_toss_sequences(4) == 8); // Additional test\n    assert(count_valid_coin_toss_sequences(5) == 13); // Additional test\n    // Feel free to add more tests here\n    assert(count_valid_coin_toss_sequences(40) == 267914296ULL); // Additional test\n    assert(count_valid_coin_toss_sequences(39) == 165580141ULL);\n    assert(count_valid_coin_toss_sequences(38) == 102334155ULL);\n    // printf(\"All tests passed!\\n\");\n    return 0;\n}", "instruction": "Observe the following faulty CPP code\n```cpp\n#include <cassert>\n#include <cmath>\n#include <cstdio>\n#include <cstring>\nunsigned long long count_valid_coin_toss_sequences(int* n)\n{\n    unsigned long long a[41][2];\n    a[1][0] = a[1][1] = 1;\n    for(int i = 2; i < n; i++){\n        a[i][0] = a[i - 1][0] + a[i - 1][0];\n        a[i][1] = a[i - 1][0];\n    }\n    return a[n][0] + a[n][1];\n}\n```\nFix bugs in the given code snippet. The fixed code must be placed between ```cpp```. Do not generate any test, main,example usage or check code!\n"}
{"question_id": "CPP/53", "category": "Multiple", "subtype": "triple_bug", "level": "hard", "example": "* Examples:\n *   >>> find_longest_consecutive_ones_length(7)\n *   3", "docstring": "* Find the length of the longest consecutive sequence of 1s in the binary \n * representation of a non-negative integer.\n *\n * Parameters:\n * - n (unsigned long long): A non-negative integer (0 ≤ n ≤ 2^64 - 1).\n *\n * Returns:\n * - int: The length of the longest consecutive sequence of 1s in the binary \n *        representation of the given integer.\n *", "canonical_solution": "#include <cassert>\n#include <cmath>\n#include <cstdio>\n#include <cstring>\n\nint find_longest_consecutive_ones_length(unsigned long long n)\n\n{\n    int max_length = 0;\n    int current_length = 0;\n    while (n) {\n        if (n & 1) {\n            current_length++;\n        } else {\n            if (current_length > max_length) {\n                max_length = current_length;\n            }\n            current_length = 0;\n        }\n        n >>= 1;\n    }\n    if (current_length > max_length) {\n        max_length = current_length;\n    }\n    return max_length;\n}", "buggy_code": "#include <cassert>\n#include <cmath>\n#include <cstdio>\n#include <cstring>\nint find_longest_consecutive_ones_length(int n)\n{\n    int max_length = 0;\n    int current_length = 0;\n    while (n) {\n        if (n | 1) {\n            current_length++;\n        } else {\n            if (current_length > max_length) {\n                max_length = current_length;\n            }\n            current_length = 0;\n        }\n        n >>= 1;\n    }\n    if (current_length < max_length) {\n        max_length = current_length;\n    }\n    return max_length;\n}", "bug_with_line_numbers": "   1 | #include <cassert>\n   2 | #include <cmath>\n   3 | #include <cstdio>\n   4 | #include <cstring>\n   5 | int find_longest_consecutive_ones_length(int n)\n   6 | {\n   7 |     int max_length = 0;\n   8 |     int current_length = 0;\n   9 |     while (n) {\n  10 |         if (n|1) {\n  11 |             current_length++;\n  12 |         } else {\n  13 |             if (current_length > max_length) {\n  14 |                 max_length = current_length;\n  15 |             }\n  16 |             current_length = 0;\n  17 |         }\n  18 |         n >>= 1;\n  19 |     }\n  20 |     if (current_length < max_length) {\n  21 |         max_length = current_length;\n  22 |     }\n  23 |     return max_length;\n  24 | }", "fragment_lines": [5, 10, 20], "fragment_content": ["int find_longest_consecutive_ones_length(int n)", "if (n|1) {", "if (current_length < max_length) {"], "test": "int main()\n{\n    assert(find_longest_consecutive_ones_length(7) == 3);\n    assert(find_longest_consecutive_ones_length(13) == 2);\n    assert(find_longest_consecutive_ones_length(12345) == 3); // New test sample\n    assert(find_longest_consecutive_ones_length(0b11011101111) == 4); // New test sample using binary literal for clarity\n    assert(find_longest_consecutive_ones_length(0xFFFFFFFF) == 32); // New test sample: all ones for a 32-bit number\n    assert(find_longest_consecutive_ones_length(0) == 0); // New test sample: no ones in a zero\n\n    // printf(\"All tests passed!\\n\"); // In C++, you might use std::cout, but it is commented out as per the original code.\n    return 0;\n}", "instruction": "Observe the following faulty CPP code\n```cpp\n#include <cassert>\n#include <cmath>\n#include <cstdio>\n#include <cstring>\nint find_longest_consecutive_ones_length(int n)\n{\n    int max_length = 0;\n    int current_length = 0;\n    while (n) {\n        if (n | 1) {\n            current_length++;\n        } else {\n            if (current_length > max_length) {\n                max_length = current_length;\n            }\n            current_length = 0;\n        }\n        n >>= 1;\n    }\n    if (current_length < max_length) {\n        max_length = current_length;\n    }\n    return max_length;\n}\n```\nFix bugs in the given code snippet. The fixed code must be placed between ```cpp```. Do not generate any test, main,example usage or check code!\n"}
{"question_id": "CPP/54", "category": "Multiple", "subtype": "double_bug", "level": "medium", "example": "* Example Usage:\n * \n * create_id(\"fish\", \"cat\") returns \"ftiasch\"\n * create_id(\"icpc\", \"acm\") returns \"imccpac\"", "docstring": "* Generates a unique identifier by interweaving two words in a specified pattern.\n * @param word1 The first word to be used in the ID creation process.\n * @param word2 The second word to be used in the ID creation process.\n * @return A unique identifier formed by alternating characters from the second word,\n *         reversed, with characters from the first word.", "canonical_solution": "#include <iostream>\n#include <string>\n#include <cassert>\n\nstd::string create_id(const std::string& word1, const std::string& word2)\n\n{\n    std::string id;\n    int j = 0, k = word2.length() - 1;\n    for (int i = 0; i < word1.length() + word2.length(); ++i) {\n        if (i % 2 == 0) {\n            id += word1[j++];\n        } else {\n            id += word2[k--];\n        }\n    }\n    return id;\n}", "buggy_code": "#include <iostream>\n#include <string>\n#include <cassert>\nstd::string create_id(const std::string& word1, const std::string& word2)\n{\n    std:string id;\n    int j = 0, k = word2.length();\n    for (int i = 0; i < word1.length() + word2.length(); ++i) {\n        if (i % 2 == 0) {\n            id += word1[k++];\n        } else {\n            id += word2[k--];\n        }\n    }\n    return id;\n}", "bug_with_line_numbers": "   1 | #include <iostream>\n   2 | #include <string>\n   3 | #include <cassert>\n   4 | std::string create_id(const std::string& word1, const std::string& word2)\n   5 | {\n   6 |     std:string id;\n   7 |     int j = 0, k = word2.length();\n   8 |     for (int i = 0; i < word1.length() + word2.length(); ++i) {\n   9 |         if (i % 2 == 0) {\n  10 |             id += word1[k++];\n  11 |         } else {\n  12 |             id += word2[k--];\n  13 |         }\n  14 |     }\n  15 |     return id;\n  16 | }", "fragment_lines": [6, 7, 10], "fragment_content": ["std:string id;", "int j = 0, k = word2.length();", "id += word1[k++];"], "test": "int main() {\n    std::string id; // To hold the results from create_id\n\n    id = create_id(\"fish\", \"cat\");\n    assert(id.compare(\"ftiasch\") == 0);\n\n    id = create_id(\"icpc\", \"acm\");\n    assert(id.compare(\"imccpac\") == 0);\n\n    id = create_id(\"oo\", \"w\");\n    assert(id.compare(\"owo\") == 0);\n\n    // Add more test samples\n    id = create_id(\"hello\", \"world\");\n    assert(id.compare(\"hdellrloow\") == 0);\n\n    id = create_id(\"abc\", \"def\");\n    assert(id.compare(\"afbecd\") == 0);\n\n    id = create_id(\"buaanb\", \"nbbuaa\");\n    assert(id.compare(\"bauaauabnbbn\") == 0);\n\n    id = create_id(\"xtuisgood\", \"ilovextu\");\n    assert(id.compare(\"xuttuxiesvgooloid\") == 0);\n\n    // std::cout << \"All tests passed!\" << std::endl;\n\n    return 0;\n}", "instruction": "Observe the following faulty CPP code\n```cpp\n#include <iostream>\n#include <string>\n#include <cassert>\nstd::string create_id(const std::string& word1, const std::string& word2)\n{\n    std:string id;\n    int j = 0, k = word2.length();\n    for (int i = 0; i < word1.length() + word2.length(); ++i) {\n        if (i % 2 == 0) {\n            id += word1[k++];\n        } else {\n            id += word2[k--];\n        }\n    }\n    return id;\n}\n```\nFix bugs in the given code snippet. The fixed code must be placed between ```cpp```. Do not generate any test, main,example usage or check code!\n"}
{"question_id": "CPP/55", "category": "Multiple", "subtype": "triple_bug", "level": "easy", "example": "* Example:\n *    >>> Is_Square({9})\n *    true", "docstring": "* Determines if it is possible to assemble the wooden squares from n buckets\n * into a single larger square, where each bucket contains squares with a side length of 1.\n * \n * Input: vector of numbers\n * \n * @param squares Vector containing the count of squares in each bucket.\n * @return True if it is possible to form a larger square, False otherwise.", "canonical_solution": "#include <cassert>\n#include <cmath>\n#include <vector>\n\nbool Is_Square(std::vector<int> squares)\n\n{\n    long long sum = 0;\n    for (int square : squares) {\n        sum += square; \n    }\n    int root = static_cast<int>(std::sqrt(sum));\n    return root * root == sum;\n}", "buggy_code": "#include <cassert>\n#include <cmath>\n#include <vector>\nbool Is_Square(std::vector<int> squares)\n{\n    int g sum = 0;\n    for (int square : squares) {\n        sum += square; \n    }\n    int root = static_cast<int>(std:sqrt(sum));\n    return root * root = sum;\n}", "bug_with_line_numbers": "   1 | #include <cassert>\n   2 | #include <cmath>\n   3 | #include <vector>\n   4 | bool Is_Square(std::vector<int> squares)\n   5 | {\n   6 |     int g sum = 0;\n   7 |     for (int square : squares) {\n   8 |         sum += square; \n   9 |     }\n  10 |     int root = static_cast<int>(std:sqrt(sum));\n  11 |     return root * root = sum;\n  12 | }", "fragment_lines": [6, 10, 11], "fragment_content": ["int g sum = 0;", "int root = static_cast<int>(std:sqrt(sum));", "return root * root = sum;"], "test": "int main() {\n    assert(Is_Square({9}) == true);\n    assert(Is_Square({14, 2}) == true);\n    assert(Is_Square({7, 7}) == false);\n    assert(Is_Square({1, 2, 3, 4, 5, 6, 7}) == false);\n    assert(Is_Square({1, 3, 5, 7, 9, 11}) == true);\n    assert(Is_Square({2, 2, 2, 2}) == false);\n\n    // Additional test cases\n    assert(Is_Square({4, 5, 6}) == false);\n    assert(Is_Square({16, 9, 4, 1}) == false);\n    assert(Is_Square({1, 1, 1, 1, 1}) == false);\n    assert(Is_Square({25, 25}) == false);\n    assert(Is_Square({10, 10, 5}) == true);\n\n    // All tests passed\n    return 0;\n}", "instruction": "Observe the following faulty CPP code\n```cpp\n#include <cassert>\n#include <cmath>\n#include <vector>\nbool Is_Square(std::vector<int> squares)\n{\n    int g sum = 0;\n    for (int square : squares) {\n        sum += square; \n    }\n    int root = static_cast<int>(std:sqrt(sum));\n    return root * root = sum;\n}\n```\nFix bugs in the given code snippet. The fixed code must be placed between ```cpp```. Do not generate any test, main,example usage or check code!\n"}
{"question_id": "CPP/56", "category": "Multiple", "subtype": "quadruple_bug", "level": "easy", "example": "Examples:\n>>> count_acute_triangles(4, 1, 1, 1, 1)\n4", "docstring": "Count the number of acute-angled triangles that can be formed by selecting any 3 edges out of\na given set of edges.\n  \nArgs:\n- edges_count: The number of edges passed.\n- An arbitrary number of integer arguments representing the lengths of the edges.\n  \nReturns:\nint: The count of distinct acute-angled triangles that can be formed.", "canonical_solution": "#include <cassert>\n#include <cmath>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cstdarg>\n\nint count_acute_triangles(int edges_count, ...)\n\n{\n    va_list args;\n    va_start(args, edges_count);\n\n    int* edges = (int*) malloc(edges_count * sizeof(int));\n    for (int i = 0; i < edges_count; i++) {\n        edges[i] = va_arg(args, int);\n    }\n    va_end(args);\n\n    qsort(edges, edges_count, sizeof(int), (int (*)(const void *, const void *)) strcmp);\n\n\n    int sum = 0;\n    for (int i = 0; i < edges_count - 2; i++) {\n        for (int j = i + 1; j < edges_count - 1; j++) {\n            for (int k = j + 1; k < edges_count; k++) {\n                int x = edges[i], y = edges[j], z = edges[k];\n                if (x + y > z && x * x + y * y > z * z) {\n                    sum++;\n                }\n            }\n        }\n    }\n\n    free(edges);\n    return sum;\n}", "buggy_code": "#include <cassert>\n#include <cmath>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cstdarg>\nint count_acute_triangles(int edges_count)\n{\n    va_list args;\n    va_start(args, edges_count);\n    int edges = (int*) malloc(edges_count * sizeof(int));\n    for (int i = 0; i < edges_count; i++) {\n        edges[i] = va_arg(args, int);\n    }\n    va_end(args);\n    qsort(edges, edges_count, sizeof(int), (int (*)(const void *, const void *) strcmp);\n    int sum = 0;\n    for (int i = 0; i < edges_count - 2; i++) {\n        for (int j = i; j < edges_count - 1; j++) {\n            for (int k = j + 1; k < edges_count; k++) {\n                int x = edges[i], y = edges[j], z = edges[k];\n                if (x + y > z && x * x + y * y > z * z) {\n                    sum++;\n                }\n            }\n        }\n    }\n    free(edges);\n    return sum;\n}", "bug_with_line_numbers": "   1 | #include <cassert>\n   2 | #include <cmath>\n   3 | #include <cstdio>\n   4 | #include <cstdlib>\n   5 | #include <cstring>\n   6 | #include <cstdarg>\n   7 | int count_acute_triangles(int edges_count)\n   8 | {\n   9 |     va_list args;\n  10 |     va_start(args, edges_count);\n  11 |     int edges = (int*) malloc(edges_count * sizeof(int));\n  12 |     for (int i = 0; i < edges_count; i++) {\n  13 |         edges[i] = va_arg(args, int);\n  14 |     }\n  15 |     va_end(args);\n  16 |     qsort(edges, edges_count, sizeof(int), (int (*)(const void *, const void *) strcmp);\n  17 |     int sum = 0;\n  18 |     for (int i = 0; i < edges_count - 2; i++) {\n  19 |         for (int j = i; j < edges_count - 1; j++) {\n  20 |             for (int k = j + 1; k < edges_count; k++) {\n  21 |                 int x = edges[i], y = edges[j], z = edges[k];\n  22 |                 if (x + y > z && x * x + y * y > z * z) {\n  23 |                     sum++;\n  24 |                 }\n  25 |             }\n  26 |         }\n  27 |     }\n  28 |     free(edges);\n  29 |     return sum;\n  30 | }", "fragment_lines": [7, 11, 16, 19], "fragment_content": ["int count_acute_triangles(int edges_count)", "int edges = (int*) malloc(edges_count * sizeof(int));", "qsort(edges, edges_count, sizeof(int), (int (*)(const void *, const void *) strcmp);", "for (int j = i; j < edges_count - 1; j++) {"], "test": "int main() {\n    assert(count_acute_triangles(4, 1, 1, 1, 1) == 4);\n    assert(count_acute_triangles(3, 1, 2, 3) == 0);\n    // Additional tests to ensure correctness\n    assert(count_acute_triangles(5, 3, 4, 5, 7, 10) == 0);\n    assert(count_acute_triangles(6, 6, 8, 10, 5, 5, 5) == 4);\n    return 0;\n}", "instruction": "Observe the following faulty CPP code\n```cpp\n#include <cassert>\n#include <cmath>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cstdarg>\nint count_acute_triangles(int edges_count)\n{\n    va_list args;\n    va_start(args, edges_count);\n    int edges = (int*) malloc(edges_count * sizeof(int));\n    for (int i = 0; i < edges_count; i++) {\n        edges[i] = va_arg(args, int);\n    }\n    va_end(args);\n    qsort(edges, edges_count, sizeof(int), (int (*)(const void *, const void *) strcmp);\n    int sum = 0;\n    for (int i = 0; i < edges_count - 2; i++) {\n        for (int j = i; j < edges_count - 1; j++) {\n            for (int k = j + 1; k < edges_count; k++) {\n                int x = edges[i], y = edges[j], z = edges[k];\n                if (x + y > z && x * x + y * y > z * z) {\n                    sum++;\n                }\n            }\n        }\n    }\n    free(edges);\n    return sum;\n}\n```\nFix bugs in the given code snippet. The fixed code must be placed between ```cpp```. Do not generate any test, main,example usage or check code!\n"}
{"question_id": "CPP/57", "category": "Multiple", "subtype": "quadruple_bug", "level": "hard", "example": "* Examples:\n * >>> minRoundsToSameChar(\"aab\")\n * 1\n * >>> minRoundsToSameChar(\"abc\")\n * 2\n * >>> minRoundsToSameChar(\"aaa\")\n * 0", "docstring": "* Given a string consisting of lowercase English letters, in each round you can change\n * one of the characters to another character. The question is: what is the minimum\n * number of rounds needed to make the string composed of the same character?\n *", "canonical_solution": "#include <cassert>\n#include <cstring>\n#include <iostream>\n\nint minRoundsToSameChar(const char* s)\n\n{\n    int charCount[26] = {0};\n    for (int i = 0; i < 26; i++) {\n        charCount[i] = 0;\n    }\n    while (*s) {\n        charCount[*s - 'a']++;\n        s++;\n    }\n    int maxCount = 0;\n    for (int i = 0; i < 26; i++) {\n        if (charCount[i] != 0 ) {\n            maxCount ++;\n        }\n    }\n\n    return maxCount - 1;\n}", "buggy_code": "#include <assert.h>\n#include <stdio.h>\n#include <string.h>\nint minRoundsToSameChar(const char s)\n{\n    char charCount[26] = 0;\n    for (int i = 0; i < 26; i++) {\n        charCount[i] = 0;\n    }\n    while (*s) {\n        charCount[s + 'a']++;\n        s++;\n    }\n    int maxCount = 0;\n    for (int i = 0; i <= 26; i++) {\n        if (charCount[i] == 0 ) {\n            maxCount ++;\n        }\n    }\n    return maxCount;\n}", "bug_with_line_numbers": "   1 | #include <assert.h>\n   2 | #include <stdio.h>\n   3 | #include <string.h>\n   4 | int minRoundsToSameChar(const char s)\n   5 | {\n   6 |     char charCount[26] = 0;\n   7 |     for (int i = 0; i < 26; i++) {\n   8 |         charCount[i] = 0;\n   9 |     }\n  10 |     while (*s) {\n  11 |         charCount[s + 'a']++;\n  12 |         s++;\n  13 |     }\n  14 |     int maxCount = 0;\n  15 |     for (int i = 0; i <= 26; i++) {\n  16 |         if (charCount[i] == 0 ) {\n  17 |             maxCount ++;\n  18 |         }\n  19 |     }\n  20 |     return maxCount;\n  21 | }", "fragment_lines": [6, 11, 15, 20], "fragment_content": ["char charCount[26] = 0;", "charCount[s + 'a']++;", "for (int i = 0; i <= 26; i++) {", "return maxCount;"], "test": "int main() {\n    assert(minRoundsToSameChar(\"aab\") == 1);\n    assert(minRoundsToSameChar(\"abc\") == 2);\n    assert(minRoundsToSameChar(\"aaa\") == 0);\n    assert(minRoundsToSameChar(\"abab\") == 1);\n    assert(minRoundsToSameChar(\"zzzzz\") == 0);\n\n    return 0;\n}", "instruction": "Observe the following faulty CPP code\n```cpp\n#include <assert.h>\n#include <stdio.h>\n#include <string.h>\nint minRoundsToSameChar(const char s)\n{\n    char charCount[26] = 0;\n    for (int i = 0; i < 26; i++) {\n        charCount[i] = 0;\n    }\n    while (*s) {\n        charCount[s + 'a']++;\n        s++;\n    }\n    int maxCount = 0;\n    for (int i = 0; i <= 26; i++) {\n        if (charCount[i] == 0 ) {\n            maxCount ++;\n        }\n    }\n    return maxCount;\n}\n```\nFix bugs in the given code snippet. The fixed code must be placed between ```cpp```. Do not generate any test, main,example usage or check code!\n"}
{"question_id": "CPP/58", "category": "Multiple", "subtype": "quadruple_bug", "level": "hard", "example": "* Examples:\n *    >>> makeEqualAgain(3, (int[]){1, 2, 1})\n *    1\n *    >>> makeEqualAgain(5, (int[]){5, 5, 1, 5, 5})\n *    1", "docstring": "* You are given an array a of n integers. You can perform at most one operation where you\n * select three integers i, j, x (1 <= i <= j <= n) and replace all elements from a[i] to a[j] with x,\n * at a cost of (j - i + 1). Find the minimum cost to make all elements in the array equal.\n *", "canonical_solution": "#include <cstdio>\n#include <cassert>\n\nint makeEqualAgain(int n, int a[])\n\n{\n    int j = 0, p = 1, q = 0, c, d;\n    int k = n;\n    for (p = 1; p < k; p++) {\n        if (a[p] != a[p - 1])\n            break;\n    }\n    for (q = k - 1; q > p; q--) {\n        if (a[q] != a[p - 1])\n            break;\n    }\n    for (d = k - 2; d >= 0; d--) {\n        if (a[d] != a[d + 1])\n            break;\n    }\n    for (c = 0; c < d; c++) {\n        if (a[c] != a[c + 1])\n            break;\n    }\n    if (q - p + 1 < d - c + 1)\n        return q - p + 1;\n    else\n        return d - c + 1;\n}", "buggy_code": "#include <cstdio>\n#include <cassert>\nint makeEqualAgain(int n, int a)\n{\n    int p = 1, q = 0, c, d;\n    int k == n;\n    for (p = 1; p < k; p++) {\n        if (a[p] != a[p - 1])\n            break;\n    }\n    for (q = k - 1; q > p; q++) {\n        if (a[q] != a[p - 1])\n            break;\n    }\n    for (d = k - 2; d >= 0; d--) {\n        if (a[d] != a[d + 1])\n            break;\n    }\n    for (c = 0; c < d; c++) {\n        if (a[c] != a[c + 1])\n            break;\n    }\n    if (q - p + 1 > d - c + 1)\n        return q - p + 1;\n    else\n        return d - c + 1;\n}", "bug_with_line_numbers": "   1 | #include <cstdio>\n   2 | #include <cassert>\n   3 | int makeEqualAgain(int n, int a)\n   4 | {\n   5 |     int p = 1, q = 0, c, d;\n   6 |     int k == n;\n   7 |     for (p = 1; p < k; p++) {\n   8 |         if (a[p] != a[p - 1])\n   9 |             break;\n  10 |     }\n  11 |     for (q = k - 1; q > p; q++) {\n  12 |         if (a[q] != a[p - 1])\n  13 |             break;\n  14 |     }\n  15 |     for (d = k - 2; d >= 0; d--) {\n  16 |         if (a[d] != a[d + 1])\n  17 |             break;\n  18 |     }\n  19 |     for (c = 0; c < d; c++) {\n  20 |         if (a[c] != a[c + 1])\n  21 |             break;\n  22 |     }\n  23 |     if (q - p + 1 > d - c + 1)\n  24 |         return q - p + 1;\n  25 |     else\n  26 |         return d - c + 1;\n  27 | }", "fragment_lines": [3, 6, 11, 23], "fragment_content": ["int makeEqualAgain(int n, int a)", "int k == n;", "for (q = k - 1; q > p; q++) {", "if (q - p + 1 > d - c + 1)"], "test": "int main() {\n    int a1[] = {1,2,3,4,5,1};\n    int a2[] = {1,1,1,1,1,1,1};\n    int a3[] = {8,8,8,1,2,8,8,8};\n    int a4[] = {1,2,3};\n    int a5[] = {4,3,2,7,1,1,3};\n    int a6[] = {9,9,2,9,2,5,5,5,3};\n    \n    assert(makeEqualAgain(6, a1) == 4);\n    assert(makeEqualAgain(7, a2) == 0);\n    assert(makeEqualAgain(8, a3) == 2);\n    assert(makeEqualAgain(3, a4) == 2);\n    assert(makeEqualAgain(7, a5) == 6);\n    assert(makeEqualAgain(9, a6) == 7);\n\n    int a7[] = {1, 2, 1};\n    int a8[] = {5, 5, 1, 5, 5};\n    int a9[] = {1, 1, 1, 1};\n    int a10[] = {2, 2, 2, 3, 2, 2};\n    int a11[] = {1};\n    int a12[] = {1, 2};\n    int a13[] = {1, 2, 2, 1};\n    int a14[] = {4, 4, 4, 3, 3, 4, 4};\n    int a15[] = {5, 4, 4, 4, 5, 5};\n    int a16[] = {1, 2, 1, 2, 1, 2, 1};\n    // Additional provided tests\n    assert(makeEqualAgain(3, a7) == 1);\n    assert(makeEqualAgain(5, a8) == 1);\n    assert(makeEqualAgain(4, a9) == 0);\n    assert(makeEqualAgain(6, a10) == 1);\n    assert(makeEqualAgain(1, a11) == 0);\n    assert(makeEqualAgain(2, a12) == 1);\n    assert(makeEqualAgain(4, a13) == 2);\n    assert(makeEqualAgain(7, a14) == 2);\n    assert(makeEqualAgain(6, a15) == 3);\n    assert(makeEqualAgain(7, a16) == 5);\n    \n    return 0;\n}", "instruction": "Observe the following faulty CPP code\n```cpp\n#include <cstdio>\n#include <cassert>\nint makeEqualAgain(int n, int a)\n{\n    int p = 1, q = 0, c, d;\n    int k == n;\n    for (p = 1; p < k; p++) {\n        if (a[p] != a[p - 1])\n            break;\n    }\n    for (q = k - 1; q > p; q++) {\n        if (a[q] != a[p - 1])\n            break;\n    }\n    for (d = k - 2; d >= 0; d--) {\n        if (a[d] != a[d + 1])\n            break;\n    }\n    for (c = 0; c < d; c++) {\n        if (a[c] != a[c + 1])\n            break;\n    }\n    if (q - p + 1 > d - c + 1)\n        return q - p + 1;\n    else\n        return d - c + 1;\n}\n```\nFix bugs in the given code snippet. The fixed code must be placed between ```cpp```. Do not generate any test, main,example usage or check code!\n"}
{"question_id": "CPP/59", "category": "Multiple", "subtype": "quadruple_bug", "level": "hard", "example": "* Example:\n * >>> maxModeSum(3, {1, 2, 3})\n * 17\n * A sequence that reaches its maximum value is (3,2,3,1,2,2).", "docstring": "* Given n positive integers representing the count of each number from 1 to n,\n * find the maximum sum of the mode (most frequent element) for all prefixes of\n * a sequence constructed from these numbers. The mode is the largest number among\n * the most frequent elements in a sequence.\n *", "canonical_solution": "#include <cassert>\n#include <cstdio>\n\nlong long maxModeSum(int n, const int* counts)\n\n{\n    long long ans = 0;\n    int mx = 0;\n    long long f[100000];\n    for (int i = 0; i <= n; ++i) f[i] = 0;\n\n    for (int i = n; i > 0; --i) {\n        while (mx < counts[i - 1]) {\n            mx++;\n            f[mx] = f[mx - 1] + i;\n        }\n        ans += f[counts[i - 1]];\n    }\n    return ans;\n}", "buggy_code": "#include <cassert>\n#include <cstdio>\nlong long maxModeSum(int n, const int counts)\n{\n    long ans = 0;\n    int mx = 0;\n    long long f[100000];\n    for (int i = 0; i < n; ++i) f[i] = 0;\n    for (int i = n; i > 0; --i) {\n        while (mx < counts[i - 1]) {\n            mx++;\n            f[mx] = f[mx - 1];\n        }\n        ans += f[counts[i - 1]];\n    }\n    return ans;\n}", "bug_with_line_numbers": "   1 | #include <cassert>\n   2 | #include <cstdio>\n   3 | long long maxModeSum(int n, const int counts)\n   4 | {\n   5 |     long ans = 0;\n   6 |     int mx = 0;\n   7 |     long long f[100000];\n   8 |     for (int i = 0; i < n; ++i) f[i] = 0;\n   9 |     for (int i = n; i > 0; --i) {\n  10 |         while (mx < counts[i - 1]) {\n  11 |             mx++;\n  12 |             f[mx] = f[mx - 1];\n  13 |         }\n  14 |         ans += f[counts[i - 1]];\n  15 |     }\n  16 |     return ans;\n  17 | }", "fragment_lines": [3, 5, 8, 12], "fragment_content": ["long long maxModeSum(int n, const int counts)", "long ans = 0;", "for (int i = 0; i < n; ++i) f[i] = 0;", "f[mx] = f[mx - 1];"], "test": "int main() {\n    int a1[] = {1, 3, 2};\n    int a2[] = {4, 1, 2, 3};\n    int a3[] = {1, 1};\n    int a4[] = {1, 2, 3, 4, 5};\n    int a5[] = {100000};\n    int a6[] = {5, 3, 2, 4, 1};\n    int a7[] = {100000, 100000, 100000};\n    int a8[] = {2, 2, 5};\n    int a9[] = {4, 4, 4, 4};\n    int a10[] = {1, 2, 3, 4, 5, 6};\n    int a11[] = {3, 1, 2};\n\n    assert(maxModeSum(3, a1) == 17);\n    assert(maxModeSum(4, a2) == 37);\n    assert(maxModeSum(2, a3) == 4);\n    assert(maxModeSum(5, a4) == 75);\n    assert(maxModeSum(1, a5) == 100000);\n    assert(maxModeSum(5, a6) == 62);\n    assert(maxModeSum(3, a7) == 900000);\n    assert(maxModeSum(3, a8) == 27);\n    assert(maxModeSum(4, a9) == 64);\n    assert(maxModeSum(6, a10) == 126);\n    assert(maxModeSum(3, a11) == 16);\n    return 0;\n}", "instruction": "Observe the following faulty CPP code\n```cpp\n#include <cassert>\n#include <cstdio>\nlong long maxModeSum(int n, const int counts)\n{\n    long ans = 0;\n    int mx = 0;\n    long long f[100000];\n    for (int i = 0; i < n; ++i) f[i] = 0;\n    for (int i = n; i > 0; --i) {\n        while (mx < counts[i - 1]) {\n            mx++;\n            f[mx] = f[mx - 1];\n        }\n        ans += f[counts[i - 1]];\n    }\n    return ans;\n}\n```\nFix bugs in the given code snippet. The fixed code must be placed between ```cpp```. Do not generate any test, main,example usage or check code!\n"}
{"question_id": "CPP/60", "category": "Multiple", "subtype": "quadruple_bug", "level": "medium", "example": "For example:\n    >>> countBalancedSubsequences(2, 2, 2)\n    2", "docstring": "Given three integers n, m, and k, find the number of sequences consisting of n '(' and m ')',\nsuch that the longest balanced subsequence is of length 2 * k. The result should be calculated modulo 1,000,000,007 (10^9 + 7).", "canonical_solution": "#include <cassert>\n\nlong long countBalancedSubsequences(long long n, long long m, long long k)\n\n{\n    const long long P = static_cast<long long>(1e9) + 7;\n    static long long C[4001][4001] = {0};\n\n    if (C[0][0] == 0) {\n        for (long long i = 0; i <= 4000; i++) C[i][0] = 1;\n        for (long long i = 1; i <= 4000; i++)\n            for (long long j = 1; j <= i; j++)\n                C[i][j] = (C[i - 1][j - 1] + C[i - 1][j]) % P;\n    }\n\n    if (k > n || k > m) return 0;\n    return (C[n + m][k] - C[n + m][k - 1] + P) % P;\n}", "buggy_code": "#include <cassert>\nlong long countBalancedSubsequences(long long n, long long m, long long k)\n{\n    const long long P = static_cast<int>(1e9) + 7;\n    static long long const[4001][4001] = {0};\n    if (C[0][0] == 0) {\n        for (long long i = 0; i < 4000; i++) C[i][0] = 1;\n        for (long long i = 1; i <= 4000; i++)\n            for (long long j = 1; j <= i; j++)\n                C[i][j] = (C[i - 1][j - 1] + C[i - 1][j]) % P;\n    }\n    if (k > n && k > m) return 0;\n    return (C[n + m][k] - C[n + m][k - 1] + P) % P;\n}", "bug_with_line_numbers": "   1 | #include <cassert>\n   2 | long long countBalancedSubsequences(long long n, long long m, long long k)\n   3 | {\n   4 |     const long long P = static_cast<int>(1e9) + 7;\n   5 |     static long long const[4001][4001] = {0};\n   6 |     if (C[0][0] == 0) {\n   7 |         for (long long i = 0; i < 4000; i++) C[i][0] = 1;\n   8 |         for (long long i = 1; i <= 4000; i++)\n   9 |             for (long long j = 1; j <= i; j++)\n  10 |                 C[i][j] = (C[i - 1][j - 1] + C[i - 1][j]) % P;\n  11 |     }\n  12 |     if (k > n && k > m) return 0;\n  13 |     return (C[n + m][k] - C[n + m][k - 1] + P) % P;\n  14 | }", "fragment_lines": [4, 5, 7, 12], "fragment_content": ["const long long P = static_cast<int>(1e9) + 7;", "static long long const[4001][4001] = {0};", "for (long long i = 0; i < 4000; i++) C[i][0] = 1;", "if (k > n && k > m) return 0;"], "test": "int main() {\n    assert(countBalancedSubsequences(2, 2, 2) == 2);\n    assert(countBalancedSubsequences(3, 2, 3) == 0);\n    assert(countBalancedSubsequences(3, 2, 1) == 4);\n    assert(countBalancedSubsequences(4, 3, 2) == 14);\n    assert(countBalancedSubsequences(5, 5, 2) == 35);\n    assert(countBalancedSubsequences(6, 1, 1) == 6);\n    assert(countBalancedSubsequences(1, 6, 1) == 6);\n    assert(countBalancedSubsequences(7, 2, 2) == 27);\n    assert(countBalancedSubsequences(8, 3, 3) == 110);\n    assert(countBalancedSubsequences(10, 10, 5) == 10659);\n    assert(countBalancedSubsequences(20, 20, 10) == 574221648);\n    assert(countBalancedSubsequences(2000, 2000, 1000) == 854104531);\n    assert(countBalancedSubsequences(2000, 1999, 1000) == 334874485);\n    assert(countBalancedSubsequences(2000, 2000, 1999) == 259428024);\n    return 0;\n}", "instruction": "Observe the following faulty CPP code\n```cpp\n#include <cassert>\nlong long countBalancedSubsequences(long long n, long long m, long long k)\n{\n    const long long P = static_cast<int>(1e9) + 7;\n    static long long const[4001][4001] = {0};\n    if (C[0][0] == 0) {\n        for (long long i = 0; i < 4000; i++) C[i][0] = 1;\n        for (long long i = 1; i <= 4000; i++)\n            for (long long j = 1; j <= i; j++)\n                C[i][j] = (C[i - 1][j - 1] + C[i - 1][j]) % P;\n    }\n    if (k > n && k > m) return 0;\n    return (C[n + m][k] - C[n + m][k - 1] + P) % P;\n}\n```\nFix bugs in the given code snippet. The fixed code must be placed between ```cpp```. Do not generate any test, main,example usage or check code!\n"}
{"question_id": "CPP/61", "category": "Special", "subtype": "Misused Macro Definition", "level": "medium", "example": "shift_characters(\"NS BFW, JAJSYX TK NRUTWYFSHJ FWJ YMJ WJXZQY TK YWNANFQ HFZXJX\")\n\"IN WAR, EVENTS OF IMPORTANCE ARE THE RESULT OF TRIVIAL CAUSES\"\n", "docstring": "Shifts all characters by 5 positions in alphabetical order. Only letters are replaced, and all letters are in uppercase.\n\nParameters:\ntext (std::string&): The input text to be processed, modified in place.\n\nReturns:\nstd::string&: The transformed text with characters shifted by 5 positions.\n", "canonical_solution": "#include <bits/stdc++.h>\n/*\nShifts all characters by 5 positions in alphabetical order. Only letters are replaced,\nand all letters are in uppercase.\n\nParameters:\ntext (std::string&): The input text to be processed, modified in place.\n\nReturns:\nstd::string&: The transformed text with characters shifted by 5 positions.\n\n>>> shift_characters(\"NS BFW, JAJSYX TK NRUTWYFSHJ FWJ YMJ WJXZQY TK YWNANFQ HFZXJX\")\n\"IN WAR, EVENTS OF IMPORTANCE ARE THE RESULT OF TRIVIAL CAUSES\"\n*/\nstd::string& shift_characters(std::string& text)\n\n{\n    size_t len = text.length();\n    for (size_t i = 0; i < len; ++i) {\n        if ('A' <= text[i] && text[i] <= 'E') {\n            text[i] = text[i] + 'V' - 'A';\n        } else if ('F' <= text[i] && text[i] <= 'Z') {\n            text[i] = text[i] + 'A' - 'F';\n        }\n    }\n    return text;\n}", "buggy_code": "#include <bits/stdc++.h>\n\nstd::string& shift_characters(std::string& text)\n{\n    size_t len = text.length();\n    for (size_t i = 0; i < len; ++i) {\n        if ('A' <= text[i] && text[i] <= 'E') {\n            text[i] = text[i] + 'V' - 'A';\n        } else if ('F' <= text[i] && text[i] <= 'Z') {\n            text[i] = text[i] + 'A' - 'F';\n        }\n    }\n    return text;\n}\n\n#define 'A' 'F'", "bug_with_line_numbers": "   1 | #include <bits/stdc++.h>\n   2 | std::string& shift_characters(std::string& text)\n   3 | {\n   4 |     size_t len = text.length();\n   5 |     for (size_t i = 0; i < len; ++i) {\n   6 |         if ('A' <= text[i] && text[i] <= 'E') {\n   7 |             text[i] = text[i] + 'V' - 'A';\n   8 |         } else if ('F' <= text[i] && text[i] <= 'Z') {\n   9 |             text[i] = text[i] + 'A' - 'F';\n  10 |         }\n  11 |     }\n  12 |     return text;\n  13 | }\n  14 | #define 'A' 'F'", "fragment_lines": [14], "fragment_content": ["#define 'A' 'F'"], "test": "int main()\n{\n    std::string test1 = \"NS BFW, JAJSYX TK NRUTWYFSHJ FWJ YMJ WJXZQY TK YWNANFQ HFZXJX\";\n    std::string test2 = \"N BTZQI WFYMJW GJ KNWXY NS F QNYYQJ NGJWNFS ANQQFLJ YMFS XJHTSI NS WTRJ\";\n    std::string test3 = \"IFSLJW PSTBX KZQQ BJQQ YMFY HFJXFW NX RTWJ IFSLJWTZX YMFS MJ\";\n\n    assert(shift_characters(test1) == \"IN WAR, EVENTS OF IMPORTANCE ARE THE RESULT OF TRIVIAL CAUSES\");\n    assert(shift_characters(test2) == \"I WOULD RATHER BE FIRST IN A LITTLE IBERIAN VILLAGE THAN SECOND IN ROME\");\n    assert(shift_characters(test3) == \"DANGER KNOWS FULL WELL THAT CAESAR IS MORE DANGEROUS THAN HE\");\n    return 0;\n}", "instruction": "Observe the following faulty CPP code\n```cpp\n#include <bits/stdc++.h>\n\nstd::string& shift_characters(std::string& text)\n{\n    size_t len = text.length();\n    for (size_t i = 0; i < len; ++i) {\n        if ('A' <= text[i] && text[i] <= 'E') {\n            text[i] = text[i] + 'V' - 'A';\n        } else if ('F' <= text[i] && text[i] <= 'Z') {\n            text[i] = text[i] + 'A' - 'F';\n        }\n    }\n    return text;\n}\n\n#define 'A' 'F'\n```\nFix bugs in the given code snippet. The fixed code must be placed between ```cpp```. Do not generate any test, main,example usage or check code!\n"}
{"question_id": "CPP/62", "category": "Special", "subtype": "Misused Macro Definition", "level": "hard", "example": "Examples:\n>>> minRoundsToSameChar(\"aab\")\n1\n>>> minRoundsToSameChar(\"abc\")\n2\n>>> minRoundsToSameChar(\"aaa\")\n0", "docstring": "Given a string consisting of lowercase English letters, in each round you can change\none of the characters to another character. The question is: what is the minimum\nnumber of rounds needed to make the string composed of the same character?", "canonical_solution": "#include <cassert>\n#include <cstring>\n#include <iostream>\n/**\n * Given a string consisting of lowercase English letters, in each round you can change\n * one of the characters to another character. The question is: what is the minimum\n * number of rounds needed to make the string composed of the same character?\n * \n * Examples:\n * >>> minRoundsToSameChar(\"aab\")\n * 1\n * >>> minRoundsToSameChar(\"abc\")\n * 2\n * >>> minRoundsToSameChar(\"aaa\")\n * 0\n */\nint minRoundsToSameChar(const char* s)\n\n{\n    int charCount[26] = {0}; // Assuming only lowercase letters\n    for (int i = 0; i < 26; i++) {\n        charCount[i] = 0;\n    }\n    while (*s) {\n        charCount[*s - 'a']++;\n        s++;\n    }\n    int maxCount = 0;\n    for (int i = 0; i < 26; i++) {\n        if (charCount[i] != 0 ) {\n            maxCount ++;\n        }\n    }\n\n    return maxCount - 1;\n}\n\n", "buggy_code": "#include <cassert>\n#include <cstring>\n#include <iostream>\n\n#define MAX_CHAR 25\n\nint minRoundsToSameChar(const char* s)\n{\n    int charCount[MAX_CHAR] = {0}; // Assuming only lowercase letters\n    for (int i = 0; i < MAX_CHAR; i++) {\n        charCount[i] = 0;\n    }\n    while (*s) {\n        charCount[*s - 'a']++;\n        s++;\n    }\n    int maxCount = 0;\n    for (int i = 0; i < MAX_CHAR; i++) {\n        if (charCount[i] != 0 ) {\n            maxCount ++;\n        }\n    }\n\n    return maxCount - 1;\n}", "bug_with_line_numbers": "   1 | #include <cassert>\n   2 | #include <cstring>\n   3 | #include <iostream>\n   4 | #define MAX_CHAR 25\n   5 | int minRoundsToSameChar(const char* s)\n   6 | {\n   7 |     int charCount[MAX_CHAR] = {0}; \n   8 |     for (int i = 0; i < MAX_CHAR; i++) {\n   9 |         charCount[i] = 0;\n  10 |     }\n  11 |     while (*s) {\n  12 |         charCount[*s - 'a']++;\n  13 |         s++;\n  14 |     }\n  15 |     int maxCount = 0;\n  16 |     for (int i = 0; i < MAX_CHAR; i++) {\n  17 |         if (charCount[i] != 0 ) {\n  18 |             maxCount ++;\n  19 |         }\n  20 |     }\n  21 |     return maxCount - 1;\n  22 | }", "fragment_lines": [4], "fragment_content": ["#define MAX_CHAR 25"], "test": "int main() {\n    assert(minRoundsToSameChar(\"aab\") == 1);\n    assert(minRoundsToSameChar(\"abc\") == 2);\n    assert(minRoundsToSameChar(\"aaa\") == 0);\n    assert(minRoundsToSameChar(\"abab\") == 1);\n    assert(minRoundsToSameChar(\"zzzzz\") == 0);\n\n    return 0;\n}", "instruction": "Observe the following faulty CPP code\n```cpp\n#include <cassert>\n#include <cstring>\n#include <iostream>\n\n#define MAX_CHAR 25\n\nint minRoundsToSameChar(const char* s)\n{\n    int charCount[MAX_CHAR] = {0}; // Assuming only lowercase letters\n    for (int i = 0; i < MAX_CHAR; i++) {\n        charCount[i] = 0;\n    }\n    while (*s) {\n        charCount[*s - 'a']++;\n        s++;\n    }\n    int maxCount = 0;\n    for (int i = 0; i < MAX_CHAR; i++) {\n        if (charCount[i] != 0 ) {\n            maxCount ++;\n        }\n    }\n\n    return maxCount - 1;\n}\n```\nFix bugs in the given code snippet. The fixed code must be placed between ```cpp```. Do not generate any test, main,example usage or check code!\n"}
{"question_id": "CPP/63", "category": "Special", "subtype": "Misused Macro Definition", "level": "hard", "example": "Example:\n   newModuloFactorial(3, 7) returns 6\n", "docstring": "Given a prime number p, you need to handle several queries where you're given\nan integer n and you must compute n! ⊕ p. Here, n! is the factorial of n.\n", "canonical_solution": "#include <cassert>\n#include <cstdio>\n/**\n * This problem introduces a custom modulo operation, denoted by \"⊕\".\n * When calculating x ⊕ y, if x is not a multiple of y, the result is x % y.\n * If x is a multiple of y, divide x by y repeatedly until x is no longer a\n * multiple of y, denoting this final value as x'. Then the result is x' % y.\n * For example:\n * - 4⊕5=4,\n * - 20⊕5=4,\n * - 100⊕5=4.\n * Given a prime number p, you need to handle several queries where you're given\n * an integer n and you must compute n! ⊕ p. Here, n! is the factorial of n.\n * Example:\n *    newModuloFactorial(3, 7) returns 6\n */\nunsigned long long newModuloFactorial(unsigned long long n, unsigned long long p)\n\n{\n    unsigned long long pj[p];\n    pj[0] = 1;\n    pj[1] = 1;\n    for (unsigned long long i = 2; i < p; i++) pj[i] = i * pj[i - 1] % p;\n\n    unsigned long long ans = 1;\n    while (n) {\n        ans = ans * pj[n % p] % p;\n        ans = (n / p) & 1 ? p - ans : ans;\n        n /= p;\n    }\n    return ans;\n}", "buggy_code": "#include <cassert>\n#include <cstdio>\n\n#define p 5\n\nunsigned long long newModuloFactorial(unsigned long long n)\n{\n    unsigned long long pj[p];\n    pj[0] = 1;\n    pj[1] = 1;\n    for (unsigned long long i = 2; i < p; i++) pj[i] = i * pj[i - 1] % p;\n\n    unsigned long long ans = 1;\n    while (n) {\n        ans = ans * pj[n % p] % p;\n        ans = (n / p) & 1 ? p - ans : ans;\n        n /= p;\n    }\n    return ans;\n}", "bug_with_line_numbers": "   1 | #include <cassert>\n   2 | #include <cstdio>\n   3 | #define p 5\n   4 | unsigned long long newModuloFactorial(unsigned long long n)\n   5 | {\n   6 |     unsigned long long pj[p];\n   7 |     pj[0] = 1;\n   8 |     pj[1] = 1;\n   9 |     for (unsigned long long i = 2; i < p; i++) pj[i] = i * pj[i - 1] % p;\n  10 |     unsigned long long ans = 1;\n  11 |     while (n) {\n  12 |         ans = ans * pj[n % p] % p;\n  13 |         ans = (n / p) & 1 ? p - ans : ans;\n  14 |         n /= p;\n  15 |     }\n  16 |     return ans;\n  17 | }", "fragment_lines": [3, 4], "fragment_content": ["#define p 5", "unsigned long long newModuloFactorial(unsigned long long n)"], "test": "int main() {\n    // Test cases\n    assert(newModuloFactorial(3, 7) == 6);\n    assert(newModuloFactorial(10, 3) == 1);\n    assert(newModuloFactorial(11, 7) == 4);\n    assert(newModuloFactorial(45, 7) == 1);\n    assert(newModuloFactorial(14, 7) == 2);\n    assert(newModuloFactorial(1919, 10007) == 3152);\n    assert(newModuloFactorial(810, 10007) == 3679);\n    assert(newModuloFactorial(3, 7) == 6);\n    assert(newModuloFactorial(10, 3) == 1);\n    assert(newModuloFactorial(1, 2) == 1);\n    assert(newModuloFactorial(5, 11) == 10);\n    assert(newModuloFactorial(6, 13) == 5);\n    assert(newModuloFactorial(8, 17) == 13);\n    assert(newModuloFactorial(15, 19) == 16);\n    assert(newModuloFactorial(21, 23) == 1);\n    assert(newModuloFactorial(30, 29) == 28);\n    assert(newModuloFactorial(100, 101) == 100);\n    return 0;\n}", "instruction": "Observe the following faulty CPP code\n```cpp\n#include <cassert>\n#include <cstdio>\n\n#define p 5\n\nunsigned long long newModuloFactorial(unsigned long long n)\n{\n    unsigned long long pj[p];\n    pj[0] = 1;\n    pj[1] = 1;\n    for (unsigned long long i = 2; i < p; i++) pj[i] = i * pj[i - 1] % p;\n\n    unsigned long long ans = 1;\n    while (n) {\n        ans = ans * pj[n % p] % p;\n        ans = (n / p) & 1 ? p - ans : ans;\n        n /= p;\n    }\n    return ans;\n}\n```\nFix bugs in the given code snippet. The fixed code must be placed between ```cpp```. Do not generate any test, main,example usage or check code!\n"}
{"question_id": "CPP/64", "category": "Special", "subtype": "misused templte", "level": "hard", "example": "Examples:\ncalculate_distance(0, 0, 3, 4) returns 5", "docstring": "Calculate the distance between two points A (xa, ya) and B (xb, yb).\n\nParameters:\n- xa (double): x-coordinate of point A.\n- ya (double): y-coordinate of point A.\n- xb (double): x-coordinate of point B.\n- yb (double): y-coordinate of point B.\n\nReturns:\ndouble: The distance between points A and B.", "canonical_solution": "#include <cassert>\n#include <cmath>\n#include <cstring>\n/**\n * Calculate the distance between two points A (xa, ya) and B (xb, yb).\n * \n * Parameters:\n * - xa (double): x-coordinate of point A.\n * - ya (double): y-coordinate of point A.\n * - xb (double): x-coordinate of point B.\n * - yb (double): y-coordinate of point B.\n * \n * Returns:\n * double: The distance between points A and B.\n * \n * Examples:\n * calculate_distance(0, 0, 3, 4) returns 5\n */\ndouble calculate_distance(double xa, double ya, double xb, double yb)\n\n{\n    return sqrt((xa - xb) * (xa - xb) + (ya - yb) * (ya - yb));\n}", "buggy_code": "#include <cassert>\n#include <cmath>\n#include <cstring>\n\ntemplate <typename T>\nT calculate_distance(T xa, T ya, T xb, T yb)\n{\n    return sqrt((xa - xb) * (xa - xb) + (ya - yb) * (ya - yb));\n}", "bug_with_line_numbers": "   1 | #include <cassert>\n   2 | #include <cmath>\n   3 | #include <cstring>\n   4 | template <typename T>\n   5 | T calculate_distance(T xa, T ya, T xb, T yb)\n   6 | {\n   7 |     return sqrt((xa - xb) * (xa - xb) + (ya - yb) * (ya - yb));\n   8 | }", "fragment_lines": [4, 5], "fragment_content": ["template <typename T>", "T calculate_distance(T xa, T ya, T xb, T yb)"], "test": "int main() \n{\n    assert(fabs(calculate_distance(0, 0, 3, 4) - 5) < 1e-6);\n    assert(fabs(calculate_distance(0, 0, 0, 0) - 0) < 1e-6);\n    assert(fabs(calculate_distance(-1, -1, 2, 2) - 4.242640687) < 1e-6);\n    assert(fabs(calculate_distance(1.5, 3.9, 4.2, -1.1) - 5.68243) < 1e-6);\n    //std::cout << \"All test cases passed!\\n\"; // printf can be replaced with std::cout\n    return 0;\n}", "instruction": "Observe the following faulty CPP code\n```cpp\n#include <cassert>\n#include <cmath>\n#include <cstring>\n\ntemplate <typename T>\nT calculate_distance(T xa, T ya, T xb, T yb)\n{\n    return sqrt((xa - xb) * (xa - xb) + (ya - yb) * (ya - yb));\n}\n```\nFix bugs in the given code snippet. The fixed code must be placed between ```cpp```. Do not generate any test, main,example usage or check code!\n"}
{"question_id": "CPP/65", "category": "Special", "subtype": "misused templte", "level": "hard", "example": "\nExample:\n   >>> Is_Square({9})\n   true\n", "docstring": "Determines if it is possible to assemble the wooden squares from n buckets\ninto a single larger square, where each bucket contains squares with a side length of 1.\n\nInput: vector of numbers\n\n@param squares Vector containing the count of squares in each bucket.\n@return True if it is possible to form a larger square, False otherwise.\n", "canonical_solution": "#include <cassert>\n#include <cmath>\n#include <vector>\n/**\n * Determines if it is possible to assemble the wooden squares from n buckets\n * into a single larger square, where each bucket contains squares with a side length of 1.\n * \n * Input: vector of numbers\n * Example:\n *    >>> Is_Square({9})\n *    true\n * \n * @param squares Vector containing the count of squares in each bucket.\n * @return True if it is possible to form a larger square, False otherwise.\n */\nbool Is_Square(std::vector<int> squares)\n\n{\n    long long sum = 0;\n    for (int square : squares) {\n        sum += square; // Sum the squares\n    }\n    int root = static_cast<int>(std::sqrt(sum));\n    return root * root == sum; // Check if the sum is a perfect square\n}", "buggy_code": "#include <cassert>\n#include <cmath>\n#include <vector>\n\ntemplate<typename T>\nbool Is_Square(std::vector<T> squares)\n{\n    long long sum = 0;\n    for (T square : squares) {\n        sum += square; // Sum the squares\n    }\n    int root = static_cast<int>(std::sqrt(sum));\n    return root * root == sum; // Check if the sum is a perfect square\n}", "bug_with_line_numbers": "   1 | #include <cassert>\n   2 | #include <cmath>\n   3 | #include <vector>\n   4 | template<typename T>\n   5 | bool Is_Square(std::vector<T> squares)\n   6 | {\n   7 |     long long sum = 0;\n   8 |     for (T square : squares) {\n   9 |         sum += square; \n  10 |     }\n  11 |     int root = static_cast<int>(std::sqrt(sum));\n  12 |     return root * root == sum; \n  13 | }", "fragment_lines": [4, 5, 8], "fragment_content": ["template<typename T>", "bool Is_Square(std::vector<T> squares)", "for (T square : squares) {"], "test": "int main() {\n    assert(Is_Square({9}) == true);\n    assert(Is_Square({14, 2}) == true);\n    assert(Is_Square({7, 7}) == false);\n    assert(Is_Square({1, 2, 3, 4, 5, 6, 7}) == false);\n    assert(Is_Square({1, 3, 5, 7, 9, 11}) == true);\n    assert(Is_Square({2, 2, 2, 2}) == false);\n\n    // Additional test cases\n    assert(Is_Square({4, 5, 6}) == false);\n    assert(Is_Square({16, 9, 4, 1}) == false);\n    assert(Is_Square({1, 1, 1, 1, 1}) == false);\n    assert(Is_Square({25, 25}) == false);\n    assert(Is_Square({10, 10, 5}) == true);\n\n    // All tests passed\n    return 0;\n}", "instruction": "Observe the following faulty CPP code\n```cpp\n#include <cassert>\n#include <cmath>\n#include <vector>\n\ntemplate<typename T>\nbool Is_Square(std::vector<T> squares)\n{\n    long long sum = 0;\n    for (T square : squares) {\n        sum += square; // Sum the squares\n    }\n    int root = static_cast<int>(std::sqrt(sum));\n    return root * root == sum; // Check if the sum is a perfect square\n}\n```\nFix bugs in the given code snippet. The fixed code must be placed between ```cpp```. Do not generate any test, main,example usage or check code!\n"}
{"question_id": "CPP/66", "category": "Special", "subtype": "misused templte", "level": "hard", "example": "Example:\nint asciiCode = display_ascii_info('A');\nstd::cout << asciiCode; // Output: 65", "docstring": "Displays the ASCII information for a given character.\n\n@param character The input character for which ASCII information is to be displayed.\n@return The corresponding ASCII code.", "canonical_solution": "#include <cassert>\n#include <cstdio>\n/**\n * Displays the ASCII information for a given character.\n * \n * @param character The input character for which ASCII information is to be displayed.\n * @return The corresponding ASCII code.\n * \n * Example:\n * ```cpp\n * int asciiCode = display_ascii_info('A');\n * std::cout << asciiCode; // Output: 65\n * ```\n */\nint display_ascii_info(char character)\n\n{\n    return character;\n}", "buggy_code": "#include <cassert>\n#include <cstdio>\n\ntemplate <typename T>\nT display_ascii_info(char character)\n{\n    return character;\n}", "bug_with_line_numbers": "   1 | #include <cassert>\n   2 | #include <cstdio>\n   3 | template <typename T>\n   4 | T display_ascii_info(char character)\n   5 | {\n   6 |     return character;\n   7 | }", "fragment_lines": [3, 4], "fragment_content": ["template <typename T>", "T display_ascii_info(char character)"], "test": "int main() {\n    assert(display_ascii_info('A') == 65);\n    assert(display_ascii_info('B') == 66); // Additional test case\n    assert(display_ascii_info('0') == 48); // Additional test case\n    assert(display_ascii_info(' ') == 32); // Additional test case\n    \n    // Uncomment the line below to print a success message if compiled outside a test framework\n    // std::printf(\"All tests passed.\\n\");\n\n    return 0;\n}", "instruction": "Observe the following faulty CPP code\n```cpp\n#include <cassert>\n#include <cstdio>\n\ntemplate <typename T>\nT display_ascii_info(char character)\n{\n    return character;\n}\n```\nFix bugs in the given code snippet. The fixed code must be placed between ```cpp```. Do not generate any test, main,example usage or check code!\n"}
{"question_id": "CPP/67", "category": "Special", "subtype": "Pointer error", "level": "middle", "example": "/**\n * Given n positive integers representing the count of each number from 1 to n,\n * find the maximum sum of the mode (most frequent element) for all prefixes of\n * a sequence constructed from these numbers. The mode is the largest number among\n * the most frequent elements in a sequence.\n * \n * Example:\n * >>> maxModeSum(3, {1, 2, 3})\n * 17\n * A sequence that reaches its maximum value is (3,2,3,1,2,2).\n */", "docstring": "/**\n * Given n positive integers representing the count of each number from 1 to n,\n * find the maximum sum of the mode (most frequent element) for all prefixes of\n * a sequence constructed from these numbers. The mode is the largest number among\n * the most frequent elements in a sequence.\n * \n * Example:\n * >>> maxModeSum(3, {1, 2, 3})\n * 17\n * A sequence that reaches its maximum value is (3,2,3,1,2,2).\n */", "canonical_solution": "#include <cassert>\n#include <cstdio>\n\nlong long maxModeSum(int n, const int* counts)\n{\n    long long ans = 0;\n    int mx = 0;\n    long long* f = new long long[1000000];  // 动态分配内存\n\n    for (int i = 0; i <= n; ++i) f[i] = 0;\n\n    for (int i = n; i > 0; --i) {\n        while (mx < counts[i - 1]) {\n            mx++;\n            f[mx] = f[mx - 1] + i;\n        }\n        ans += f[counts[i - 1]];\n    }\n    delete[] f;\n    return ans;\n}", "buggy_code": "#include <cassert>\n#include <cstdio>\n\nlong long maxModeSum(int n, const int* counts)\n{\n    long long ans = 0;\n    int mx = 0;\n    long long* f = new long long[1000000];  // 动态分配内存\n\n    for (int i = 0; i <= n; ++i) f[i] = 0;\n\n    for (int i = n; i > 0; --i) {\n        while (mx < counts[i - 1]) {\n            mx++;\n            f[mx] = f[mx - 1] + i;\n        }\n        ans += f[counts[i - 1]];\n    }\n    return ans;\n}", "bug_with_line_numbers": "   1 | #include <cassert>\n   2 | #include <cstdio>\n   3 | long long maxModeSum(int n, const int* counts)\n   4 | {\n   5 |     long long ans = 0;\n   6 |     int mx = 0;\n   7 |     long long* f = new long long[1000000];  // 动态分配内存\n   8 |     for (int i = 0; i <= n; ++i) f[i] = 0;\n   9 |     for (int i = n; i > 0; --i) {\n  10 |         while (mx < counts[i - 1]) {\n  11 |             mx++;\n  12 |             f[mx] = f[mx - 1] + i;\n  13 |         }\n  14 |         ans += f[counts[i - 1]];\n  15 |     }\n  16 |     return ans;\n  17 | }", "fragment_lines": [-1], "fragment_content": ["missing critical code snippet"], "test": "int main() {\n    int a1[] = {1, 3, 2};\n    int a2[] = {4, 1, 2, 3};\n    int a3[] = {1, 1};\n    int a4[] = {1, 2, 3, 4, 5};\n    int a5[] = {100000};\n    int a6[] = {5, 3, 2, 4, 1};\n    int a7[] = {100000, 100000, 100000};\n    int a8[] = {2, 2, 5};\n    int a9[] = {4, 4, 4, 4};\n    int a10[] = {1, 2, 3, 4, 5, 6};\n    int a11[] = {3, 1, 2};\n\n    assert(maxModeSum(3, a1) == 17);\n    assert(maxModeSum(4, a2) == 37);\n    assert(maxModeSum(2, a3) == 4);\n    assert(maxModeSum(5, a4) == 75);\n    assert(maxModeSum(1, a5) == 100000);\n    assert(maxModeSum(5, a6) == 62);\n    assert(maxModeSum(3, a7) == 900000);\n    assert(maxModeSum(3, a8) == 27);\n    assert(maxModeSum(4, a9) == 64);\n    assert(maxModeSum(6, a10) == 126);\n    assert(maxModeSum(3, a11) == 16);\n\n    return 0;\n}", "instruction": "Observe the following faulty add code\n```None\n#include <cassert>\n#include <cstdio>\n\nlong long maxModeSum(int n, const int* counts)\n{\n    long long ans = 0;\n    int mx = 0;\n    long long* f = new long long[1000000];  // 动态分配内存\n\n    for (int i = 0; i <= n; ++i) f[i] = 0;\n\n    for (int i = n; i > 0; --i) {\n        while (mx < counts[i - 1]) {\n            mx++;\n            f[mx] = f[mx - 1] + i;\n        }\n        ans += f[counts[i - 1]];\n    }\n    return ans;\n}\n```\nFix bugs in the given code snippet. The fixed code must be placed between ```None```. Do not generate any test, main,example usage or check code!\n"}
{"question_id": "CPP/68", "category": "Special", "subtype": "Pointer error", "level": "middle", "example": "    >>> countPermutations(2, 1, [1, 2])\n    2", "docstring": "/*\nGiven a permutation q of n elements and an integer k, find the number of permutations p of n elements such that f(p) = q, where f(p) is the lexicographically smallest permutation that can be obtained by dividing p into exactly k non-empty contiguous segments and sorting each segment (i.e., choose k-1 breakpoints 1 <= x_1 < x_2 < ... < x_{k-1} < n, and divide it into [1, x_1], (x_1, x_2], ..., (x_{k-1}, n]). The result should be modulo 998244353.\n\n\n\n*/", "canonical_solution": "#include <bits/stdc++.h>\n\nint countPermutations(int n, int k, int qq[])\n{\n    const int N = 505, P = 998244353;\n    int *q = new int[n + 10];\n    int m, dp[N][N], jc[N], f[N], ans;\n    memset(q, 0, sizeof(int) * (n + 1));\n    memset(dp, 0, sizeof(dp));\n    memset(jc, 0, sizeof(jc));\n    memset(f, 0, sizeof(f));\n    ans = 0;\n\n    for (int i = 1; i <= n; i++)\n        q[i] = qq[i - 1];\n    dp[0][0] = f[0] = 1;\n    for (int i = jc[0] = 1; i <= n; i++)\n        jc[i] = 1LL * jc[i - 1] * i % P;\n    for (int i = 1; i <= n; i++)\n    {\n        f[i] = jc[i];\n        for (int j = 1; j < i; j++)\n            f[i] = (f[i] + P - 1LL * f[j] * jc[i - j] % P) % P;\n    }\n    for (int i = 1; i <= n; i++)\n    {\n        for (int j = 0; j < i; j++)\n            for (int k = 1; k <= n; k++)\n                dp[i][k] = (dp[i][k] + dp[j][k - 1] * 1LL * f[i - j] % P) % P;\n    }\n    m = 0;\n    for (int i = 1; i <= n; i++)\n        if (q[i] > q[i + 1])\n        {\n            m = i;\n            break;\n        }\n    if (m == n)\n    {\n        for (int i = k; i <= n; i++)\n            ans = (ans + dp[n][i]) % P;\n    }\n    else\n    {\n        for (int i = m + 1; i <= n; i++)\n        {\n            if (i != m + 1 && (q[i - 1] > q[i] || q[i] < q[m]))\n                break;\n            int c = k + i - n - 1;\n            if (c >= 0)\n                ans = (ans + dp[m][c] * 1LL * jc[i - m - 1] % P) % P;\n        }\n    }\n    delete[] q;\n    return ans;\n}", "buggy_code": "#include <bits/stdc++.h>\n\nint countPermutations(int n, int k, int qq[])\n{\n    const int N = 505, P = 998244353;\n    int *q = new int[n + 10];\n    int m, dp[N][N], jc[N], f[N], ans;\n    memset(q, 0, sizeof(int) * (n + 1));\n    memset(dp, 0, sizeof(dp));\n    memset(jc, 0, sizeof(jc));\n    memset(f, 0, sizeof(f));\n    ans = 0;\n\n    for (int i = 1; i <= n; i++)\n        q[i] = qq[i - 1];\n    dp[0][0] = f[0] = 1;\n    for (int i = jc[0] = 1; i <= n; i++)\n        jc[i] = 1LL * jc[i - 1] * i % P;\n    for (int i = 1; i <= n; i++)\n    {\n        f[i] = jc[i];\n        for (int j = 1; j < i; j++)\n            f[i] = (f[i] + P - 1LL * f[j] * jc[i - j] % P) % P;\n    }\n    for (int i = 1; i <= n; i++)\n    {\n        for (int j = 0; j < i; j++)\n            for (int k = 1; k <= n; k++)\n                dp[i][k] = (dp[i][k] + dp[j][k - 1] * 1LL * f[i - j] % P) % P;\n    }\n    m = 0;\n    for (int i = 1; i <= n; i++)\n        if (q[i] > q[i + 1])\n        {\n            m = i;\n            break;\n        }\n    if (m == n)\n    {\n        for (int i = k; i <= n; i++)\n            ans = (ans + dp[n][i]) % P;\n    }\n    else\n    {\n        for (int i = m + 1; i <= n; i++)\n        {\n            if (i != m + 1 && (q[i - 1] > q[i] || q[i] < q[m]))\n                break;\n            int c = k + i - n - 1;\n            if (c >= 0)\n                ans = (ans + dp[m][c] * 1LL * jc[i - m - 1] % P) % P;\n        }\n    }\n    return ans;\n}", "bug_with_line_numbers": "   1 | #include <bits/stdc++.h>\n   2 | int countPermutations(int n, int k, int qq[])\n   3 | {\n   4 |     const int N = 505, P = 998244353;\n   5 |     int *q = new int[n + 10];\n   6 |     int m, dp[N][N], jc[N], f[N], ans;\n   7 |     memset(q, 0, sizeof(int) * (n + 1));\n   8 |     memset(dp, 0, sizeof(dp));\n   9 |     memset(jc, 0, sizeof(jc));\n  10 |     memset(f, 0, sizeof(f));\n  11 |     ans = 0;\n  12 |     for (int i = 1; i <= n; i++)\n  13 |         q[i] = qq[i - 1];\n  14 |     dp[0][0] = f[0] = 1;\n  15 |     for (int i = jc[0] = 1; i <= n; i++)\n  16 |         jc[i] = 1LL * jc[i - 1] * i % P;\n  17 |     for (int i = 1; i <= n; i++)\n  18 |     {\n  19 |         f[i] = jc[i];\n  20 |         for (int j = 1; j < i; j++)\n  21 |             f[i] = (f[i] + P - 1LL * f[j] * jc[i - j] % P) % P;\n  22 |     }\n  23 |     for (int i = 1; i <= n; i++)\n  24 |     {\n  25 |         for (int j = 0; j < i; j++)\n  26 |             for (int k = 1; k <= n; k++)\n  27 |                 dp[i][k] = (dp[i][k] + dp[j][k - 1] * 1LL * f[i - j] % P) % P;\n  28 |     }\n  29 |     m = 0;\n  30 |     for (int i = 1; i <= n; i++)\n  31 |         if (q[i] > q[i + 1])\n  32 |         {\n  33 |             m = i;\n  34 |             break;\n  35 |         }\n  36 |     if (m == n)\n  37 |     {\n  38 |         for (int i = k; i <= n; i++)\n  39 |             ans = (ans + dp[n][i]) % P;\n  40 |     }\n  41 |     else\n  42 |     {\n  43 |         for (int i = m + 1; i <= n; i++)\n  44 |         {\n  45 |             if (i != m + 1 && (q[i - 1] > q[i] || q[i] < q[m]))\n  46 |                 break;\n  47 |             int c = k + i - n - 1;\n  48 |             if (c >= 0)\n  49 |                 ans = (ans + dp[m][c] * 1LL * jc[i - m - 1] % P) % P;\n  50 |         }\n  51 |     }\n  52 |     return ans;\n  53 | }", "fragment_lines": [-1], "fragment_content": ["missing critical code snippet"], "test": "int main() {\n    int q1[] = {1, 2};\n    assert(countPermutations(2, 1, q1) == 2);\n\n    int q2[] = {3, 1, 2};\n    assert(countPermutations(3, 3, q2) == 1);\n\n    int q3[] = {1, 2, 3, 6, 5, 4};\n    assert(countPermutations(6, 3, q3) == 13);\n\n    int q4[] = {1, 2, 3, 4, 5, 6};\n    assert(countPermutations(6, 1, q4) == 720);\n\n    int q5[] = {1, 2, 5, 3, 4, 5};\n    assert(countPermutations(6, 3, q5) == 0);\n\n    int q6[] = {1, 2, 3, 4, 5, 6, 7, 8, 9};\n    assert(countPermutations(9, 9, q6) == 1);\n\n    int q7[] = {1, 2, 3, 4, 5, 6, 7, 9, 8};\n    assert(countPermutations(9, 2, q7) == 29093);\n    return 0;\n    }", "instruction": "Observe the following faulty add code\n```None\n#include <bits/stdc++.h>\n\nint countPermutations(int n, int k, int qq[])\n{\n    const int N = 505, P = 998244353;\n    int *q = new int[n + 10];\n    int m, dp[N][N], jc[N], f[N], ans;\n    memset(q, 0, sizeof(int) * (n + 1));\n    memset(dp, 0, sizeof(dp));\n    memset(jc, 0, sizeof(jc));\n    memset(f, 0, sizeof(f));\n    ans = 0;\n\n    for (int i = 1; i <= n; i++)\n        q[i] = qq[i - 1];\n    dp[0][0] = f[0] = 1;\n    for (int i = jc[0] = 1; i <= n; i++)\n        jc[i] = 1LL * jc[i - 1] * i % P;\n    for (int i = 1; i <= n; i++)\n    {\n        f[i] = jc[i];\n        for (int j = 1; j < i; j++)\n            f[i] = (f[i] + P - 1LL * f[j] * jc[i - j] % P) % P;\n    }\n    for (int i = 1; i <= n; i++)\n    {\n        for (int j = 0; j < i; j++)\n            for (int k = 1; k <= n; k++)\n                dp[i][k] = (dp[i][k] + dp[j][k - 1] * 1LL * f[i - j] % P) % P;\n    }\n    m = 0;\n    for (int i = 1; i <= n; i++)\n        if (q[i] > q[i + 1])\n        {\n            m = i;\n            break;\n        }\n    if (m == n)\n    {\n        for (int i = k; i <= n; i++)\n            ans = (ans + dp[n][i]) % P;\n    }\n    else\n    {\n        for (int i = m + 1; i <= n; i++)\n        {\n            if (i != m + 1 && (q[i - 1] > q[i] || q[i] < q[m]))\n                break;\n            int c = k + i - n - 1;\n            if (c >= 0)\n                ans = (ans + dp[m][c] * 1LL * jc[i - m - 1] % P) % P;\n        }\n    }\n    return ans;\n}\n```\nFix bugs in the given code snippet. The fixed code must be placed between ```None```. Do not generate any test, main,example usage or check code!\n"}
{"question_id": "CPP/69", "category": "Special", "subtype": "Pointer error", "level": "middle", "example": " * @param n The number of squares.\n * @param m The number of colors.\n * @return The count of different coloring methods satisfying the specified conditions.\n *         The result is modulo 1000003.", "docstring": "/**\n * Counts the number of different coloring methods for n squares with m colors,\n * considering the requirement that adjacent squares and the first/last squares\n * must have different colors.\n * \n *\n * Examples:\n * count_coloring_methods(1,1) returns 1\n * count_coloring_methods(2,2) returns 2\n */", "canonical_solution": "#include <cassert>\n#include <iostream>\n\nint count_coloring_methods(int n, int m)\n\n{\n    \n    if (n == 1) return m;\n    if (n == 2) return static_cast<long long>(m) * (m - 1) % 1000003;\n    int *f = new int[1111]; // Array to store results\n    // Initialize the first three elements\n\n    f[1] = m;\n    f[2] = static_cast<long long>(m) * (m - 1) % 1000003;\n    // Formula derived from the given gold.c code\n    f[3] = static_cast<long long>(f[2]) * (m - 2) % 1000003;\n    for(int i = 4; i <= n; ++i) {\n        f[i] = (static_cast<long long>(f[i - 1]) * (m - 2) % 1000003 +\n                static_cast<long long>(f[i - 2]) * (m - 1) % 1000003) % 1000003;\n    }\n    int res = f[n];\n    delete[] f\n    return res;\n}", "buggy_code": "#include <cassert>\n#include <iostream>\n\nint count_coloring_methods(int n, int m)\n\n{\n    int *f = new int[1111]; // Array to store results\n    if (n == 1) return m;\n    if (n == 2) return static_cast<long long>(m) * (m - 1) % 1000003;\n    // Initialize the first three elements\n\n    f[1] = m;\n    f[2] = static_cast<long long>(m) * (m - 1) % 1000003;\n    // Formula derived from the given gold.c code\n    f[3] = static_cast<long long>(f[2]) * (m - 2) % 1000003;\n    for(int i = 4; i <= n; ++i) {\n        f[i] = (static_cast<long long>(f[i - 1]) * (m - 2) % 1000003 +\n                static_cast<long long>(f[i - 2]) * (m - 1) % 1000003) % 1000003;\n    }\n    int res = f[n];\n    return res;\n}", "bug_with_line_numbers": "   1 | #include <cassert>\n   2 | #include <iostream>\n   3 | int count_coloring_methods(int n, int m)\n   4 | {\n   5 |     int *f = new int[1111]; // Array to store results\n   6 |     if (n == 1) return m;\n   7 |     if (n == 2) return static_cast<long long>(m) * (m - 1) % 1000003;\n   8 |     // Initialize the first three elements\n   9 |     f[1] = m;\n  10 |     f[2] = static_cast<long long>(m) * (m - 1) % 1000003;\n  11 |     // Formula derived from the given gold.c code\n  12 |     f[3] = static_cast<long long>(f[2]) * (m - 2) % 1000003;\n  13 |     for(int i = 4; i <= n; ++i) {\n  14 |         f[i] = (static_cast<long long>(f[i - 1]) * (m - 2) % 1000003 +\n  15 |                 static_cast<long long>(f[i - 2]) * (m - 1) % 1000003) % 1000003;\n  16 |     }\n  17 |     int res = f[n];\n  18 |     return res;\n  19 | }", "fragment_lines": [-1], "fragment_content": ["missing critical code snippet"], "test": "int main() {\n    assert(count_coloring_methods(1, 1) == 1);\n    assert(count_coloring_methods(2, 2) == 2);\n    assert(count_coloring_methods(3, 3) == 6);\n    assert(count_coloring_methods(4, 2) == 2);\n    assert(count_coloring_methods(1000, 10) == 566585); // We don't have the expected result for this case\n\n    assert(count_coloring_methods(2, 3) == 6);\n    assert(count_coloring_methods(1000, 1000) == 67911);\n    assert(count_coloring_methods(999, 66) == 501817);\n    assert(count_coloring_methods(5, 3) == 30); // Example of an expected output\n    return 0;\n}", "instruction": "Observe the following faulty add code\n```None\n#include <cassert>\n#include <iostream>\n\nint count_coloring_methods(int n, int m)\n\n{\n    int *f = new int[1111]; // Array to store results\n    if (n == 1) return m;\n    if (n == 2) return static_cast<long long>(m) * (m - 1) % 1000003;\n    // Initialize the first three elements\n\n    f[1] = m;\n    f[2] = static_cast<long long>(m) * (m - 1) % 1000003;\n    // Formula derived from the given gold.c code\n    f[3] = static_cast<long long>(f[2]) * (m - 2) % 1000003;\n    for(int i = 4; i <= n; ++i) {\n        f[i] = (static_cast<long long>(f[i - 1]) * (m - 2) % 1000003 +\n                static_cast<long long>(f[i - 2]) * (m - 1) % 1000003) % 1000003;\n    }\n    int res = f[n];\n    return res;\n}\n```\nFix bugs in the given code snippet. The fixed code must be placed between ```None```. Do not generate any test, main,example usage or check code!\n"}