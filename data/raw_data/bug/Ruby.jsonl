{"question_id": "Ruby/1", "category": "Reference", "subtype": "illegal_keyword", "level": "easy", "example": "Example:\n>>> min_operations_to_transform(\"apple\", \"aple\")\n1\n>>> min_operations_to_transform(\"kitten\", \"sitting\")\n3", "docstring": "Calculates the minimum number of character operations needed to transform one string into another.\nThe function takes two string arguments, str_a and str_b. The operations allowed are:\n1. Delete a character;\n2. Insert a character;\n3. Replace a character with another.\nIt returns an integer representing the minimum number of operations required to transform str_a into str_b.\nBoth strings should have a length less than 200.\n\n", "canonical_solution": "def min_operations_to_transform(str_a, str_b)\n    m, n = str_a.length, str_b.length\n    dp = Array.new(m + 1) { Array.new(n + 1) }\n  \n    (0..m).each { |i| dp[i][0] = i }\n    (0..n).each { |j| dp[0][j] = j }\n  \n    (1..m).each do |i|\n      (1..n).each do |j|\n        if str_a[i - 1] == str_b[j - 1]\n          dp[i][j] = dp[i - 1][j - 1]\n        else\n          dp[i][j] = [dp[i - 1][j], dp[i][j - 1], dp[i - 1][j - 1]].min + 1\n        end\n      end\n    end\n  \n    dp[m][n]\n  end", "buggy_code": "def min_operations_to_transform(str_a, str_b)\n\nm, n = str_a.length, str_b.length\ndp = Array.new(m + 1) { Array.new(n + 1) }\n\n(0..m).each { |i| dp[i][0] = i }\n(0..n).each { |j| dp[0][j] = j }\n\n(1..m).each do |i|\n  (1..n).each do |j|\n    if print(str_a[i - 1] == str_b[j - 1])\n      dp[i][j] = dp[i - 1][j - 1]\n    else\n      dp[i][j] = [dp[i - 1][j], dp[i][j - 1], dp[i - 1][j - 1]].min + 1\n    end\n  end\nend\n\ndp[m][n]\nend\n", "bug_with_line_numbers": "   1 | def min_operations_to_transform(str_a, str_b)\n   2 | m, n = str_a.length, str_b.length\n   3 | dp = Array.new(m + 1) { Array.new(n + 1) }\n   4 | (0..m).each { |i| dp[i][0] = i }\n   5 | (0..n).each { |j| dp[0][j] = j }\n   6 | (1..m).each do |i|\n   7 |   (1..n).each do |j|\n   8 |     if print(str_a[i - 1] == str_b[j - 1])\n   9 |       dp[i][j] = dp[i - 1][j - 1]\n  10 |     else\n  11 |       dp[i][j] = [dp[i - 1][j], dp[i][j - 1], dp[i - 1][j - 1]].min + 1\n  12 |     end\n  13 |   end\n  14 | end\n  15 | dp[m][n]\n  16 | end", "fragment_lines": [8], "fragment_content": ["if print(str_a[i - 1] == str_b[j - 1])"], "test": "raise 'Test failed' unless min_operations_to_transform(\"apple\", \"aple\") == 1\nraise 'Test failed' unless min_operations_to_transform(\"kitten\", \"sitting\") == 3\nraise 'Test failed' unless min_operations_to_transform(\"sfdxbqw\", \"gfdgw\") == 4\nraise 'Test failed' unless min_operations_to_transform(\"horse\", \"ros\") == 3\nraise 'Test failed' unless min_operations_to_transform(\"\", \"abc\") == 3\n\n\n\nputs 'All tests passed!'", "instruction": "Observe the following faulty Ruby code\n```ruby\ndef min_operations_to_transform(str_a, str_b)\n\nm, n = str_a.length, str_b.length\ndp = Array.new(m + 1) { Array.new(n + 1) }\n\n(0..m).each { |i| dp[i][0] = i }\n(0..n).each { |j| dp[0][j] = j }\n\n(1..m).each do |i|\n  (1..n).each do |j|\n    if print(str_a[i - 1] == str_b[j - 1])\n      dp[i][j] = dp[i - 1][j - 1]\n    else\n      dp[i][j] = [dp[i - 1][j], dp[i][j - 1], dp[i - 1][j - 1]].min + 1\n    end\n  end\nend\n\ndp[m][n]\nend\n```\nFix bugs in the given code snippet. The fixed code must be placed between ```ruby```. Do not generate any test, main,example usage or check code!\n"}
{"question_id": "Ruby/2", "category": "Reference", "subtype": "illegal_keyword", "level": "hard", "example": "# Example:\n# >>> min_tiles_required(4)\n# 4\n# >>> min_tiles_required(5)\n# 8", "docstring": "Calculates the minimum number of square tiles required to completely cover a square room of size n x n.\nThe tiles used must be smaller than n x n and can be of varying sizes.\nThe function takes a single argument, n, which is a positive integer representing the size of the room,\nand returns the minimum number of tiles required.\n", "canonical_solution": "def min_tiles_required(n)\n    # Base case: If the room size is 1, only one tile is needed\n    return 1 if n == 1\n  \n    # If the room size is even, divide it into four equal parts\n    if n.even?\n      return 4 \n    else\n    \n      return (n+3)\n    end\n  end", "buggy_code": "def min_tiles_required(n)\n\n\nreturn 1 if n == 1\n\n\nif n.even?\n  return 4 \nelsif undefined_keyword\n  return 0\nelse\n  return (n+3)\nend\n", "bug_with_line_numbers": "   1 | def min_tiles_required(n)\n   2 | return 1 if n == 1\n   3 | if n.even?\n   4 |   return 4 \n   5 | elsif undefined_keyword\n   6 |   return 0\n   7 | else\n   8 |   return (n+3)\n   9 | end", "fragment_lines": [5, 6], "fragment_content": ["elsif undefined_keyword", "return 0"], "test": "raise 'Test failed' unless min_tiles_required(4) == 4\nraise 'Test failed' unless min_tiles_required(5) == 8\nraise 'Test failed' unless min_tiles_required(2) == 4\nraise 'Test failed' unless min_tiles_required(10) == 4\nraise 'Test failed' unless min_tiles_required(7) == 10\n  \nputs 'All tests passed!'   ", "instruction": "Observe the following faulty Ruby code\n```ruby\ndef min_tiles_required(n)\n\n\nreturn 1 if n == 1\n\n\nif n.even?\n  return 4 \nelsif undefined_keyword\n  return 0\nelse\n  return (n+3)\nend\n```\nFix bugs in the given code snippet. The fixed code must be placed between ```ruby```. Do not generate any test, main,example usage or check code!\n"}
{"question_id": "Ruby/3", "category": "Reference", "subtype": "illegal_keyword", "level": "medium", "example": "# Example:\n# >>> count_matching_pairs([[90, 90, 90], [85, 95, 90], [80, 100, 91]])\n# 2", "docstring": "Counts the number of pairs of students who are considered \"equally matched opponents\".\n Two students are \"equally matched\" if the difference in scores for each subject (Chinese, Mathematics, English) \n is no more than 5 points, and the total score difference is no more than 10 points.\n The function takes an array of arrays, where each sub-array represents a student's scores in the three subjects,\n and returns the total count of \"equally matched\" student pairs.\n", "canonical_solution": "def count_matching_pairs(students_scores)\n  # Initialize a counter for matching pairs\n  matching_pairs_count = 0\n  \n  # Iterate over the array of students_scores with indices\n  students_scores.each_with_index do |student1, index1|\n    # Compare the current student with every other student ahead in the list\n    students_scores[(index1+1)..-1].each do |student2|\n      # Calculate the absolute differences in scores for each subject\n      differences = student1.zip(student2).map { |score1, score2| (score1 - score2).abs }\n      \n      # Calculate the total scores for each student to check the total score difference\n      total_score_diff = (student1.sum - student2.sum).abs\n      \n      # Check if the pair is \"equally matched\"\n      if differences.all? { |diff| diff <= 5 } && total_score_diff <= 10\n        # If they are equally matched, increment the counter\n        matching_pairs_count += 1\n      end\n    end\n  end\n  \n  # Return the total count of equally matched pairs\n\n  matching_pairs_count\nend", "buggy_code": "def count_matching_pairs(students_scores)\n\n\nmatching_pairs_count = 0\n\n\nstudents_scores.each_with_index do |student1, index1|\n  \n  students_scores[(index1+1)..-1].each do |student2|\n    \n    differences = student1.zip(student2).map { |score1, score2| (score1 - score2).abs }\n    \n    \n    foreach student1 do\n      \n      total_score_diff = (student1.sum - student2.sum).abs\n      \n      \n      if differences.all? { |diff| diff <= 5 } && total_score_diff <= 10\n        \n        matching_pairs_count += 1\n      end\n    end\n  end\nend\n\n\n\nmatching_pairs_count\nend\n", "bug_with_line_numbers": "   1 | def count_matching_pairs(students_scores)\n   2 | matching_pairs_count = 0\n   3 | students_scores.each_with_index do |student1, index1|\n   4 |   students_scores[(index1+1)..-1].each do |student2|\n   5 |     differences = student1.zip(student2).map { |score1, score2| (score1 - score2).abs }\n   6 |     foreach student1 do\n   7 |       total_score_diff = (student1.sum - student2.sum).abs\n   8 |       if differences.all? { |diff| diff <= 5 } && total_score_diff <= 10\n   9 |         matching_pairs_count += 1\n  10 |       end\n  11 |     end\n  12 |   end\n  13 | end\n  14 | matching_pairs_count\n  15 | end", "fragment_lines": [6, 13], "fragment_content": ["foreach student1 do", "end"], "test": "raise 'Test failed' unless count_matching_pairs([[90, 90, 90], [85, 95, 90], [80, 100, 91]]) == 2\nraise 'Test failed' unless count_matching_pairs([[100, 100, 100], [100, 100, 105], [90, 90, 90]]) == 1\nraise 'Test failed' unless count_matching_pairs([[90, 90, 90], [85, 80, 85], [80, 85, 80], [76, 81, 85]]) == 2\nraise 'Test failed' unless count_matching_pairs([[100, 100, 100]]) == 0\nraise 'Test failed' unless count_matching_pairs([]) == 0", "instruction": "Observe the following faulty Ruby code\n```ruby\ndef count_matching_pairs(students_scores)\n\n\nmatching_pairs_count = 0\n\n\nstudents_scores.each_with_index do |student1, index1|\n  \n  students_scores[(index1+1)..-1].each do |student2|\n    \n    differences = student1.zip(student2).map { |score1, score2| (score1 - score2).abs }\n    \n    \n    foreach student1 do\n      \n      total_score_diff = (student1.sum - student2.sum).abs\n      \n      \n      if differences.all? { |diff| diff <= 5 } && total_score_diff <= 10\n        \n        matching_pairs_count += 1\n      end\n    end\n  end\nend\n\n\n\nmatching_pairs_count\nend\n```\nFix bugs in the given code snippet. The fixed code must be placed between ```ruby```. Do not generate any test, main,example usage or check code!\n"}
{"question_id": "Ruby/4", "category": "Logic", "subtype": "algorithm_error", "level": "easy", "example": "# Example:\n# >>> swap_case(\"HelloWorld\")\n# \"hELLOwORLD\"\n# >>> swap_case(\"Ruby\")\n# \"rUBY\"", "docstring": "Swaps the case of each letter in a given string.\nThe function takes a single argument, input_string, which is a string containing only English alphabets without any spaces or other types of characters.\nIt returns a new string where every lowercase letter is converted to uppercase and every uppercase letter is converted to lowercase.", "canonical_solution": "def swap_case(input_string)\n    input_string.chars.map do |char|\n      if char =~ /[a-z]/\n        char.upcase\n      elsif char =~ /[A-Z]/\n        char.downcase\n      else\n        char\n      end\n    end.join\n  end", "buggy_code": "def swap_case(input_string)\n\ninput_string.chars.map do |char|\n  if char =~ /[a-z]/\n    char.upcase\n  elsif char =~ /[A-Z]/\n    char.downcase\n  else\n    char\n  end\nend.join + \"BUG\"\n", "bug_with_line_numbers": "   1 | def swap_case(input_string)\n   2 | input_string.chars.map do |char|\n   3 |   if char =~ /[a-z]/\n   4 |     char.upcase\n   5 |   elsif char =~ /[A-Z]/\n   6 |     char.downcase\n   7 |   else\n   8 |     char\n   9 |   end\n  10 | end.join + \"BUG\"", "fragment_lines": [10], "fragment_content": ["end.join + \"BUG\""], "test": "raise 'Test failed' unless swap_case(\"HelloWorld\") == \"hELLOwORLD\"\nraise 'Test failed' unless swap_case(\"Ruby\") == \"rUBY\"\nraise 'Test failed' unless swap_case(\"AeDb\") == \"aEdB\"\nraise 'Test failed' unless swap_case(\"JAVA\") == \"java\"\nraise 'Test failed' unless swap_case(\"python\") == \"PYTHON\"\n  \n\nputs 'All tests passed!'", "instruction": "Observe the following faulty Ruby code\n```ruby\ndef swap_case(input_string)\n\ninput_string.chars.map do |char|\n  if char =~ /[a-z]/\n    char.upcase\n  elsif char =~ /[A-Z]/\n    char.downcase\n  else\n    char\n  end\nend.join + \"BUG\"\n```\nFix bugs in the given code snippet. The fixed code must be placed between ```ruby```. Do not generate any test, main,example usage or check code!\n"}
{"question_id": "Ruby/5", "category": "Multiple", "subtype": "double_bug", "level": "hard", "example": "Examples:\n>>> ming_sum(35, 80)\n15\n>>> ming_sum(15, 1152)\n67", "docstring": "Calculates the sum of two integers as perceived by Xiao Ming, a child who\nsimplifies numbers larger than 99 to their last two digits before addition,\nand also keeps only the last two digits of the result if it exceeds 99.\n\nThe function takes two arguments, a and b, which are non-negative integers, and\nreturns the final sum according to Xiao Ming's calculation method.\n\n", "canonical_solution": "def ming_sum(a, b)\n    a %= 100\n    b %= 100\n    (a + b) % 100\n  end", "buggy_code": "def ming_sum(a, b)\n\ndef calculate_mod(a, b)\n  a %= 100\n  b %= 100\n  (a - b) % 100\nend\n", "bug_with_line_numbers": "   1 | def ming_sum(a, b)\n   2 | def calculate_mod(a, b)\n   3 |   a %= 100\n   4 |   b %= 100\n   5 |   (a - b) % 100\n   6 | end", "fragment_lines": [2, 5], "fragment_content": ["def calculate_mod(a, b)", "(a - b) % 100"], "test": "raise 'Test failed' unless ming_sum(35, 80) == 15\nraise 'Test failed' unless ming_sum(15, 1152) == 67\nraise 'Test failed' unless ming_sum(1234, 5678) == 12\nraise 'Test failed' unless ming_sum(0, 99) == 99\nraise 'Test failed' unless ming_sum(50, 50) == 0\n\n\n\n\nputs 'All tests passed!'", "instruction": "Observe the following faulty Ruby code\n```ruby\ndef ming_sum(a, b)\n\ndef calculate_mod(a, b)\n  a %= 100\n  b %= 100\n  (a - b) % 100\nend\n```\nFix bugs in the given code snippet. The fixed code must be placed between ```ruby```. Do not generate any test, main,example usage or check code!\n"}
{"question_id": "Ruby/6", "category": "Logic", "subtype": "algorithm_error", "level": "medium", "example": "# Example:\n# >>> min_operations_to_transform(\"apple\", \"aple\")\n# 1\n# >>> min_operations_to_transform(\"kitten\", \"sitting\")\n# 3", "docstring": "Calculates the minimum number of character operations needed to transform one string into another.\nThe function takes two string arguments, str_a and str_b. The operations allowed are:\n1. Delete a character;\n2. Insert a character;\n3. Replace a character with another.\nIt returns an integer representing the minimum number of operations required to transform str_a into str_b.\nBoth strings should have a length less than 200.\n", "canonical_solution": "def min_operations_to_transform(str_a, str_b)\n    m, n = str_a.length, str_b.length\n    dp = Array.new(m + 1) { Array.new(n + 1) }\n  \n    (0..m).each { |i| dp[i][0] = i }\n    (0..n).each { |j| dp[0][j] = j }\n  \n    (1..m).each do |i|\n      (1..n).each do |j|\n        if str_a[i - 1] == str_b[j - 1]\n          dp[i][j] = dp[i - 1][j - 1]\n        else\n          dp[i][j] = [dp[i - 1][j], dp[i][j - 1], dp[i - 1][j - 1]].min + 1\n        end\n      end\n    end\n  \n    dp[m][n]\n  end", "buggy_code": "def min_operations_to_transform(str_a, str_b)\n\nm, n = str_a.length, str_b.length\ndp = Array.new(m + 1) { Array.new(n + 1) }\n\n(0..m).each { |i| dp[i][0] = i }\n(0..n).each { |j| dp[0][j] = j }\n\n(1..m).each do |i|\n  (1..n).each do |j|\n    if str_a[i] == str_b[j]\n      dp[i][j] = dp[i - 1][j - 1]\n    else\n      dp[i][j] = [dp[i - 1][j], dp[i][j - 1], dp[i - 1][j - 1]].min + 1\n    end\n  end\nend\n\ndp[m][n]\nend\n", "bug_with_line_numbers": "   1 | def min_operations_to_transform(str_a, str_b)\n   2 | m, n = str_a.length, str_b.length\n   3 | dp = Array.new(m + 1) { Array.new(n + 1) }\n   4 | (0..m).each { |i| dp[i][0] = i }\n   5 | (0..n).each { |j| dp[0][j] = j }\n   6 | (1..m).each do |i|\n   7 |   (1..n).each do |j|\n   8 |     if str_a[i] == str_b[j]\n   9 |       dp[i][j] = dp[i - 1][j - 1]\n  10 |     else\n  11 |       dp[i][j] = [dp[i - 1][j], dp[i][j - 1], dp[i - 1][j - 1]].min + 1\n  12 |     end\n  13 |   end\n  14 | end\n  15 | dp[m][n]\n  16 | end", "fragment_lines": [8], "fragment_content": ["if str_a[i] == str_b[j]"], "test": "raise 'Test failed' unless min_operations_to_transform(\"apple\", \"aple\") == 1\nraise 'Test failed' unless min_operations_to_transform(\"kitten\", \"sitting\") == 3\nraise 'Test failed' unless min_operations_to_transform(\"sfdxbqw\", \"gfdgw\") == 4\nraise 'Test failed' unless min_operations_to_transform(\"horse\", \"ros\") == 3\nraise 'Test failed' unless min_operations_to_transform(\"\", \"abc\") == 3\n\n\n\nputs 'All tests passed!'", "instruction": "Observe the following faulty Ruby code\n```ruby\ndef min_operations_to_transform(str_a, str_b)\n\nm, n = str_a.length, str_b.length\ndp = Array.new(m + 1) { Array.new(n + 1) }\n\n(0..m).each { |i| dp[i][0] = i }\n(0..n).each { |j| dp[0][j] = j }\n\n(1..m).each do |i|\n  (1..n).each do |j|\n    if str_a[i] == str_b[j]\n      dp[i][j] = dp[i - 1][j - 1]\n    else\n      dp[i][j] = [dp[i - 1][j], dp[i][j - 1], dp[i - 1][j - 1]].min + 1\n    end\n  end\nend\n\ndp[m][n]\nend\n```\nFix bugs in the given code snippet. The fixed code must be placed between ```ruby```. Do not generate any test, main,example usage or check code!\n"}
{"question_id": "Ruby/7", "category": "Multiple", "subtype": "double_bug", "level": "hard", "example": "# Examples:\n# >>> palindrome_sum_steps(12)\n# 1\n# >>> palindrome_sum_steps(87)\n# 4\n# >>> palindrome_sum_steps(89)\n# 0", "docstring": "This method calculates the minimum number of steps required to transform a given number into a palindrome by repeatedly reversing its digits and adding the result to the original number. The process is stopped when a palindrome is obtained. If the palindrome is not obtained within 8 steps, the method returns 0.\nThe function takes a single argument, m, which is a positive integer between 12 and 100, and returns the number of steps taken to reach a palindrome. The input number m itself is not a palindrome.\n", "canonical_solution": "def palindrome_sum_steps(m)\n  steps = 0\n  until m.to_s == m.to_s.reverse || steps == 8\n    m += m.to_s.reverse.to_i\n    steps += 1\n    return steps if m.to_s == m.to_s.reverse\n  end\n  steps < 8 ? steps : 0\nend", "buggy_code": "def palindrome_sum_steps(m)\n\ndef palindromic_steps(m)\n  steps = 0\n  until m.to_s == m.to_s.reverse || steps == 8\n    m += m.to_s.reverse.to_i\n    steps += 1\n    return steps if m.to_s == m.to_s.reverse\n    m -= 1\n  end\n  steps < 8 ? steps : 0\nend\n", "bug_with_line_numbers": "   1 | def palindrome_sum_steps(m)\n   2 | def palindromic_steps(m)\n   3 |   steps = 0\n   4 |   until m.to_s == m.to_s.reverse || steps == 8\n   5 |     m += m.to_s.reverse.to_i\n   6 |     steps += 1\n   7 |     return steps if m.to_s == m.to_s.reverse\n   8 |     m -= 1\n   9 |   end\n  10 |   steps < 8 ? steps : 0\n  11 | end", "fragment_lines": [2, 8], "fragment_content": ["def palindromic_steps(m)", "m -= 1"], "test": "raise 'Test failed' unless palindrome_sum_steps(12) == 1\nraise 'Test failed' unless palindrome_sum_steps(87) == 4\nraise 'Test failed' unless palindrome_sum_steps(89) == 0\nraise 'Test failed' unless palindrome_sum_steps(56) == 1\nraise 'Test failed' unless palindrome_sum_steps(95) == 3\n\nputs 'All tests passed!'", "instruction": "Observe the following faulty Ruby code\n```ruby\ndef palindrome_sum_steps(m)\n\ndef palindromic_steps(m)\n  steps = 0\n  until m.to_s == m.to_s.reverse || steps == 8\n    m += m.to_s.reverse.to_i\n    steps += 1\n    return steps if m.to_s == m.to_s.reverse\n    m -= 1\n  end\n  steps < 8 ? steps : 0\nend\n```\nFix bugs in the given code snippet. The fixed code must be placed between ```ruby```. Do not generate any test, main,example usage or check code!\n"}
{"question_id": "Ruby/8", "category": "Logic", "subtype": "algorithm_error", "level": "hard", "example": "# Examples:\n# >>> count_chars_in_title(\"234\")\n# 3\n# >>> count_chars_in_title(\"Ca 45\")\n# 4\n# >>> count_chars_in_title(\"Hello World\\n\")\n# 10", "docstring": "Counts the number of characters in a given title, excluding spaces and newline characters.\n The function takes a single argument, title, which is a string representing the title of an essay.\n It returns the count of characters in the title, excluding any spaces and newline characters.\n", "canonical_solution": "def count_chars_in_title(title)\n    title.count(\"^ \\n\")\n  end", "buggy_code": "def count_chars_in_title(title)\n\ntitle.count(\"^ \\n\", \"a\")\n", "bug_with_line_numbers": "   1 | def count_chars_in_title(title)\n   2 | title.count(\"^ \\n\", \"a\")", "fragment_lines": [-1, 2], "fragment_content": ["missing critical code snippet", "title.count(\"^ \\n\", \"a\")"], "test": "raise 'Test failed' unless count_chars_in_title(\"234\") == 3\nraise 'Test failed' unless count_chars_in_title(\"Ca 45\") == 4\nraise 'Test failed' unless count_chars_in_title(\"Hello World\\n\") == 10\nraise 'Test failed' unless count_chars_in_title(\"Ruby Programming 101 \") == 18\nraise 'Test failed' unless count_chars_in_title(\"\\nNew Line\\n\") == 7", "instruction": "Observe the following faulty Ruby code\n```ruby\ndef count_chars_in_title(title)\n\ntitle.count(\"^ \\n\", \"a\")\n```\nFix bugs in the given code snippet. The fixed code must be placed between ```ruby```. Do not generate any test, main,example usage or check code!\n"}
{"question_id": "Ruby/9", "category": "Syntax", "subtype": "unclosed_string", "level": "easy", "example": "# Example:\n# >>> count_seven_related_numbers(20)\n# 3\n# >>> count_seven_related_numbers(15)\n# 2", "docstring": "Counts the number of numbers less than or equal to n that are either multiples of 7 or contain the digit '7'.\nThe function takes a single argument, n, which is a positive integer, and returns the count of numbers\nthat are related to 7 as per the criteria.\n", "canonical_solution": "def count_seven_related_numbers(n)\n    count = 0\n    (1..n).each do |num|\n      count += 1 if num % 7 == 0 || num.to_s.include?('7')\n    end\n    count\n  end", "buggy_code": "def count_seven_related_numbers(n)\n\n    count = 0\n    (1..n).each do |num|\n      count += 1 if num % 7 == 0 || num.to_s.include?('7)\n    end\n    count\n  end\n", "bug_with_line_numbers": "   1 | def count_seven_related_numbers(n)\n   2 |     count = 0\n   3 |     (1..n).each do |num|\n   4 |       count += 1 if num % 7 == 0 || num.to_s.include?('7)\n   5 |     end\n   6 |     count\n   7 |   end", "fragment_lines": [4], "fragment_content": ["count += 1 if num % 7 == 0"], "test": "raise 'Test failed' unless count_seven_related_numbers(20) == 3\nraise 'Test failed' unless count_seven_related_numbers(15) == 2\nraise 'Test failed' unless count_seven_related_numbers(50) == 11\nraise 'Test failed' unless count_seven_related_numbers(28) == 6\nraise 'Test failed' unless count_seven_related_numbers(100) == 30\n  \n\nputs 'All tests passed!'", "instruction": "Observe the following faulty Ruby code\n```ruby\ndef count_seven_related_numbers(n)\n\n    count = 0\n    (1..n).each do |num|\n      count += 1 if num % 7 == 0 || num.to_s.include?('7)\n    end\n    count\n  end\n```\nFix bugs in the given code snippet. The fixed code must be placed between ```ruby```. Do not generate any test, main,example usage or check code!\n"}
{"question_id": "Ruby/10", "category": "Syntax", "subtype": "unclosed_string", "level": "medium", "example": "Example:\n>>> count_common_students(5, 5, [1, 2, 3, 4, 5], [1, 3, 4, 5, 6])\n4\n>>> count_common_students(3, 2, [1, 2, 3], [2, 4])\n1", "docstring": "Counts the number of students who have enrolled in both courses A and B.\n This function takes four arguments: n and m are the number of students enrolled in courses A and B, respectively.\n a_n is an array of student IDs enrolled in course A, and b_m is an array of student IDs enrolled in course B.\n The function returns the count of students who have enrolled in both courses.\n", "canonical_solution": "def count_common_students(n, m, a_n, b_m)\n    # Using the '&' operator to find the intersection of the two arrays\n    common_students = a_n & b_m\n    \n    # Returning the count of common students\n    common_students.count\n  end", "buggy_code": "def count_common_students(n, m, a_n, b_m)\n\n    \n    common_students = a_n & b_m\n    \n    \n    common_students.count\n    puts \"The count of common students is \n", "bug_with_line_numbers": "   1 | def count_common_students(n, m, a_n, b_m)\n   2 |     common_students = a_n & b_m\n   3 |     common_students.count\n   4 |     puts \"The count of common students is ", "fragment_lines": [4], "fragment_content": ["puts \"The count of common students is"], "test": "raise 'Test failed' unless count_common_students(5, 5, [1, 2, 3, 4, 5], [1, 3, 4, 5, 6]) == 4\nraise 'Test failed' unless count_common_students(3, 2, [1, 2, 3], [2, 4]) == 1\nraise 'Test failed' unless count_common_students(4, 4, [7, 8, 9, 10], [10, 11, 12, 13]) == 1\nraise 'Test failed' unless count_common_students(2, 3, [14, 15], [15, 16, 17]) == 1\nraise 'Test failed' unless count_common_students(6, 5, [18, 19, 20, 21, 22, 23], [20, 21, 24, 25, 26]) == 2", "instruction": "Observe the following faulty Ruby code\n```ruby\ndef count_common_students(n, m, a_n, b_m)\n\n    \n    common_students = a_n & b_m\n    \n    \n    common_students.count\n    puts \"The count of common students is\n```\nFix bugs in the given code snippet. The fixed code must be placed between ```ruby```. Do not generate any test, main,example usage or check code!\n"}
{"question_id": "Ruby/11", "category": "Syntax", "subtype": "unclosed_string", "level": "easy", "example": "Examples:\n>>> minimum_swaps_to_group_companies(\"TABTABBTTTT\")\n3\n>>> minimum_swaps_to_group_companies(\"BBTAAT\")\n1", "docstring": "Calculates the minimum number of seat swaps required to group representatives of the same company together.\nGiven a string representing a sequence of seats occupied by representatives of three companies, A, B, and T,\nthe function returns the minimum number of swaps needed so that all representatives of each company are seated together.\nThe input string contains only the characters 'A', 'B', and 'T', and each character represents a seat taken by a representative from the respective companies.\n", "canonical_solution": "def minimum_swaps_to_group_companies(s)\n    def func(s, a, b, c)\n        count_a = count_b = count_c = 0\n        abc = ab = ba = bc = 0\n      \n        s.chars.each_with_index do |char, i|\n        \n          count_a += 1 if char == a\n          count_b += 1 if char == b\n          count_c += 1 if char == c\n        end \n        (0..count_a-1).each do |i|\n           \n            abc += 1 if s.chars[i] != a\n            ab += 1 if s.chars[i] == b\n        end \n        (count_a..count_a+count_b-1).each do |i|\n            ba += 1 if s.chars[i] == a\n            bc += 1 if s.chars[i] == c\n        end\n        res = abc + bc + ba - [ba, ab].min\n        res\n    end\n    permutations = ['BAT', 'ATB', 'TBA', 'BTA', 'ABT', 'TAB']\n    min_swaps = Float::INFINITY\n  \n    permutations.each do |perm|\n      swaps = func(s, perm[0], perm[1], perm[2])\n      min_swaps = [min_swaps, swaps].min\n    end\n    min_swaps\n  end", "buggy_code": "def minimum_swaps_to_group_companies(s)\n\n    def func(s, a, b, c)\n        count_a = count_b = count_c = 0\n        abc = ab = ba = bc = 0\n      \n        s.chars.each_with_index do |char, i|\n        \n          count_a += 1 if char == a\n          count_b += 1 if char == b\n          count_c += 1 if char == c\n        end \n        (0..count_a-1).each do |i|\n           \n            abc += 1 if s.chars[i] != a\n            ab += 1 if s.chars[i] == b\n        end \n        (count_a..count_a+count_b-1).each do |i|\n            ba += 1 if s.chars[i] == a\n            bc += 1 if s.chars[i] == c\n        end\n        res = abc + bc + ba - [ba, ab].min\n        res\n    end\n    permutations = ['BAT\", 'ATB', 'TBA', 'BTA', 'ABT', 'TAB']\n    min_swaps = Float::INFINITY\n  \n    permutations.each do |perm|\n      swaps = func(s, perm[0], perm[1], perm[2])\n      min_swaps = [min_swaps, swaps].min\n    end\n    min_swaps\n  end\n", "bug_with_line_numbers": "   1 | def minimum_swaps_to_group_companies(s)\n   2 |     def func(s, a, b, c)\n   3 |         count_a = count_b = count_c = 0\n   4 |         abc = ab = ba = bc = 0\n   5 |         s.chars.each_with_index do |char, i|\n   6 |           count_a += 1 if char == a\n   7 |           count_b += 1 if char == b\n   8 |           count_c += 1 if char == c\n   9 |         end \n  10 |         (0..count_a-1).each do |i|\n  11 |             abc += 1 if s.chars[i] != a\n  12 |             ab += 1 if s.chars[i] == b\n  13 |         end \n  14 |         (count_a..count_a+count_b-1).each do |i|\n  15 |             ba += 1 if s.chars[i] == a\n  16 |             bc += 1 if s.chars[i] == c\n  17 |         end\n  18 |         res = abc + bc + ba - [ba, ab].min\n  19 |         res\n  20 |     end\n  21 |     permutations = ['BAT\", 'ATB', 'TBA', 'BTA', 'ABT', 'TAB']\n  22 |     min_swaps = Float::INFINITY\n  23 |     permutations.each do |perm|\n  24 |       swaps = func(s, perm[0], perm[1], perm[2])\n  25 |       min_swaps = [min_swaps, swaps].min\n  26 |     end\n  27 |     min_swaps\n  28 |   end", "fragment_lines": [21], "fragment_content": ["permutations = ['BAT\", 'ATB', 'TBA', 'BTA', 'ABT', 'TAB']"], "test": "raise 'Test failed' unless minimum_swaps_to_group_companies(\"TABTABBTTTT\") == 3\nraise 'Test failed' unless minimum_swaps_to_group_companies(\"BBTAAT\") == 1\nraise 'Test failed' unless minimum_swaps_to_group_companies(\"AABBBTTT\") == 0\nraise 'Test failed' unless minimum_swaps_to_group_companies(\"ATBT\") == 1\nraise 'Test failed' unless minimum_swaps_to_group_companies(\"TTABAB\") == 1\n  \n\n\n\nputs 'All tests passed!'", "instruction": "Observe the following faulty Ruby code\n```ruby\ndef minimum_swaps_to_group_companies(s)\n\n    def func(s, a, b, c)\n        count_a = count_b = count_c = 0\n        abc = ab = ba = bc = 0\n      \n        s.chars.each_with_index do |char, i|\n        \n          count_a += 1 if char == a\n          count_b += 1 if char == b\n          count_c += 1 if char == c\n        end \n        (0..count_a-1).each do |i|\n           \n            abc += 1 if s.chars[i] != a\n            ab += 1 if s.chars[i] == b\n        end \n        (count_a..count_a+count_b-1).each do |i|\n            ba += 1 if s.chars[i] == a\n            bc += 1 if s.chars[i] == c\n        end\n        res = abc + bc + ba - [ba, ab].min\n        res\n    end\n    permutations = ['BAT\", 'ATB', 'TBA', 'BTA', 'ABT', 'TAB']\n    min_swaps = Float::INFINITY\n  \n    permutations.each do |perm|\n      swaps = func(s, perm[0], perm[1], perm[2])\n      min_swaps = [min_swaps, swaps].min\n    end\n    min_swaps\n  end\n```\nFix bugs in the given code snippet. The fixed code must be placed between ```ruby```. Do not generate any test, main,example usage or check code!\n"}
{"question_id": "Ruby/12", "category": "Syntax", "subtype": "unclosed_string", "level": "easy", "example": "# Example:\n# >>> decrypt_caesar_cipher('NS BFW, JAJSYX TK NRUTWYFSHJ FWJ YMJ WJXZQY TK YWNANFQ HFZXJX')\n# 'IN WAR, EVENTS OF IMPORTANCE ARE THE RESULT OF TRIVIAL CAUSES'\n# >>> decrypt_caesar_cipher('N BTZQI WFYMJW GJ KNWXY NS F QNYYQJ NGJWNFS ANQQFLJ YMFS XJHTSI NS WTRJ')\n# 'I WOULD RATHER BE FIRST IN A LITTLE IBERIAN VILLAGE THAN SECOND IN ROME'", "docstring": "Decrypts a message encrypted with Caesar's cipher.\nThe cipher shifts each letter in the message 5 positions to the right in the alphabet.\nNon-letter characters are left unchanged. All letters are in uppercase.\n", "canonical_solution": "def decrypt_caesar_cipher(message)\n    message.chars.map do |char|\n      if char.match?(/[A-Z]/)\n        ((char.ord - 'A'.ord - 5) % 26 + 'A'.ord).chr\n      else\n        char\n      end\n    end.join\n  end", "buggy_code": "def decrypt_caesar_cipher(message)\n\n    message.chars.map do |char|\n      if char.match?(/[A-Z]/)\n        ((char.ord - 'A'.ord - 5) % 26 + 'A'.ord).chr\n      else\n        \"char\n      end\n    end.join\n  end\n", "bug_with_line_numbers": "   1 | def decrypt_caesar_cipher(message)\n   2 |     message.chars.map do |char|\n   3 |       if char.match?(/[A-Z]/)\n   4 |         ((char.ord - 'A'.ord - 5) % 26 + 'A'.ord).chr\n   5 |       else\n   6 |         \"char\n   7 |       end\n   8 |     end.join\n   9 |   end", "fragment_lines": [6], "fragment_content": ["\"char"], "test": "raise 'Test failed' unless decrypt_caesar_cipher('NS BFW, JAJSYX TK NRUTWYFSHJ FWJ YMJ WJXZQY TK YWNANFQ HFZXJX') == 'IN WAR, EVENTS OF IMPORTANCE ARE THE RESULT OF TRIVIAL CAUSES'\nraise 'Test failed' unless decrypt_caesar_cipher('N BTZQI WFYMJW GJ KNWXY NS F QNYYQJ NGJWNFS ANQQFLJ YMFS XJHTSI NS WTRJ') == 'I WOULD RATHER BE FIRST IN A LITTLE IBERIAN VILLAGE THAN SECOND IN ROME'\nraise 'Test failed' unless decrypt_caesar_cipher('IFSLJW PSTBX KZQQ BJQQ YMFY HFJXFW NX RTWJ IFSLJWTZX YMFS MJ') == 'DANGER KNOWS FULL WELL THAT CAESAR IS MORE DANGEROUS THAN HE'\nraise 'Test failed' unless decrypt_caesar_cipher('ABCDEF') == 'VWXYZA'\nraise 'Test failed' unless decrypt_caesar_cipher('XYZ') == 'STU'\n\n  \n\n\nputs 'All tests passed!'", "instruction": "Observe the following faulty Ruby code\n```ruby\ndef decrypt_caesar_cipher(message)\n\n    message.chars.map do |char|\n      if char.match?(/[A-Z]/)\n        ((char.ord - 'A'.ord - 5) % 26 + 'A'.ord).chr\n      else\n        \"char\n      end\n    end.join\n  end\n```\nFix bugs in the given code snippet. The fixed code must be placed between ```ruby```. Do not generate any test, main,example usage or check code!\n"}
{"question_id": "Ruby/13", "category": "Syntax", "subtype": "unclosed_string", "level": "easy", "example": "# Example:\n# >>> count_ones_in_range(15)\n# 8\n# >>> count_ones_in_range(20)\n# 12", "docstring": "Counts the number of times the digit '1' appears in all numbers from 1 to n.\nThe function takes a single argument, n, which is a positive integer, and\nreturns the total count of the digit '1' appearing in all numbers from 1 to n.\n", "canonical_solution": "def count_ones_in_range(n)\n  count = 0\n  (1..n).each do |num|\n    count += num.to_s.count('1')\n  end\n  count\nend\n", "buggy_code": "def count_ones_in_range(n)\n\n  count = 0\n  (1..n).each do |num|\n    count += num.to_s.count('1)\n  end\n  count\nend\n", "bug_with_line_numbers": "   1 | def count_ones_in_range(n)\n   2 |   count = 0\n   3 |   (1..n).each do |num|\n   4 |     count += num.to_s.count('1)\n   5 |   end\n   6 |   count\n   7 | end", "fragment_lines": [4], "fragment_content": ["count += num.to_s.count('1)"], "test": "raise 'Test failed' unless count_ones_in_range(15) == 8\nraise 'Test failed' unless count_ones_in_range(20) == 12\nraise 'Test failed' unless count_ones_in_range(100) == 21\nraise 'Test failed' unless count_ones_in_range(5) == 1\nraise 'Test failed' unless count_ones_in_range(55) == 16\nraise 'Test failed' unless count_ones_in_range(0) == 0\n\nputs 'All tests passed!'", "instruction": "Observe the following faulty Ruby code\n```ruby\ndef count_ones_in_range(n)\n\n  count = 0\n  (1..n).each do |num|\n    count += num.to_s.count('1)\n  end\n  count\nend\n```\nFix bugs in the given code snippet. The fixed code must be placed between ```ruby```. Do not generate any test, main,example usage or check code!\n"}
{"question_id": "Ruby/14", "category": "Syntax", "subtype": "unclosed_string", "level": "easy", "example": "Examples:\n>>> convert_score_to_grade(56)\n'E'\n>>> convert_score_to_grade(100)\n'A'\n>>> convert_score_to_grade(123)\n'Score is error!'", "docstring": "Converts a numerical score into a corresponding letter grade based on predefined ranges.\nThe function takes a single argument, score, which is an integer representing the score.\nIt returns a string representing the letter grade, or an error message for invalid scores.\n\nGrade Conversion:\n90-100: 'A'\n80-89: 'B'\n70-79: 'C'\n60-69: 'D'\n0-59: 'E'\nAny other score: 'Score is error!'\n\n", "canonical_solution": "def convert_score_to_grade(score)\n    return 'Score is error!' if score < 0 || score > 100\n  \n    case score\n    when 90..100\n      'A'\n    when 80...90\n      'B'\n    when 70...80\n      'C'\n    when 60...70\n      'D'\n    when 0...60\n      'E'\n    else\n      'Score is error!'\n    end\n  end", "buggy_code": "def convert_score_to_grade(score)\n\nreturn 'Score is error! if score < 0 || score > 100\n\ncase score\nwhen 90..100\n  'A'\nwhen 80...90\n  'B'\nwhen 70...80\n  'C'\nwhen 60...70\n  'D'\nwhen 0...60\n  'E'\nelse\n  'Score is error!'\nend\nend\n", "bug_with_line_numbers": "   1 | def convert_score_to_grade(score)\n   2 | return 'Score is error! if score < 0 || score > 100\n   3 | case score\n   4 | when 90..100\n   5 |   'A'\n   6 | when 80...90\n   7 |   'B'\n   8 | when 70...80\n   9 |   'C'\n  10 | when 60...70\n  11 |   'D'\n  12 | when 0...60\n  13 |   'E'\n  14 | else\n  15 |   'Score is error!'\n  16 | end\n  17 | end", "fragment_lines": [2], "fragment_content": ["return 'Score is error! if score < 0"], "test": "raise 'Test failed' unless convert_score_to_grade(56) == 'E'\nraise 'Test failed' unless convert_score_to_grade(67) == 'D'\nraise 'Test failed' unless convert_score_to_grade(100) == 'A'\nraise 'Test failed' unless convert_score_to_grade(123) == 'Score is error!'\nraise 'Test failed' unless convert_score_to_grade(-5) == 'Score is error!'\nraise 'Test failed' unless convert_score_to_grade(85) == 'B'\n  \n\nputs 'All tests passed!'", "instruction": "Observe the following faulty Ruby code\n```ruby\ndef convert_score_to_grade(score)\n\nreturn 'Score is error! if score < 0 || score > 100\n\ncase score\nwhen 90..100\n  'A'\nwhen 80...90\n  'B'\nwhen 70...80\n  'C'\nwhen 60...70\n  'D'\nwhen 0...60\n  'E'\nelse\n  'Score is error!'\nend\nend\n```\nFix bugs in the given code snippet. The fixed code must be placed between ```ruby```. Do not generate any test, main,example usage or check code!\n"}
{"question_id": "Ruby/15", "category": "Logic", "subtype": "condition_error", "level": "medium", "example": "# Example:\n>>> find_possible_last_digits(200, 40)\n[\"00\", \"40\", \"80\"]\n>>> find_possible_last_digits(1992, 95)\n[\"15\"]", "docstring": "Finds all possible last two digits of a number that, when added to the number 'a',\nmakes it divisible by 'b'. The function takes two arguments, 'a' and 'b', where 'a' is\na positive integer less than 10000, and 'b' is a positive integer between 10 and 100.\nThe function returns an array of strings representing the possible two-digit suffixes.\n", "canonical_solution": "def find_possible_last_digits(a, b)\n    possible_digits = []\n    (0..99).each do |i|\n      suffix = '%02d' % i # Ensures a two-digit format\n      combined_number = (a.to_s + suffix).to_i\n      possible_digits << suffix if combined_number % b == 0\n    end\n    possible_digits\n  end", "buggy_code": "def find_possible_last_digits(a, b)\n\npossible_digits = []\n(0..99).each do |i|\n  suffix = '%02d' % i \n  combined_number = (a.to_s + suffix).to_i\n  possible_digits << suffix if combined_number % b != 0\nend\npossible_digits\nend\n", "bug_with_line_numbers": "   1 | def find_possible_last_digits(a, b)\n   2 | possible_digits = []\n   3 | (0..99).each do |i|\n   4 |   suffix = '%02d' % i \n   5 |   combined_number = (a.to_s + suffix).to_i\n   6 |   possible_digits << suffix if combined_number % b != 0\n   7 | end\n   8 | possible_digits\n   9 | end", "fragment_lines": [6], "fragment_content": ["possible_digits << suffix if combined_number % b != 0"], "test": "raise 'Test failed' unless find_possible_last_digits(200, 40) == [\"00\", \"40\", \"80\"]\nraise 'Test failed' unless find_possible_last_digits(1992, 95) == [\"15\"]\nraise 'Test failed' unless find_possible_last_digits(1500, 25) == [\"00\", \"25\", \"50\", \"75\"]\nraise 'Test failed' unless find_possible_last_digits(300, 30) == [\"00\", \"30\", \"60\", \"90\"]\n  \nputs 'All tests passed!'", "instruction": "Observe the following faulty Ruby code\n```ruby\ndef find_possible_last_digits(a, b)\n\npossible_digits = []\n(0..99).each do |i|\n  suffix = '%02d' % i \n  combined_number = (a.to_s + suffix).to_i\n  possible_digits << suffix if combined_number % b != 0\nend\npossible_digits\nend\n```\nFix bugs in the given code snippet. The fixed code must be placed between ```ruby```. Do not generate any test, main,example usage or check code!\n"}
{"question_id": "Ruby/16", "category": "Logic", "subtype": "condition_error", "level": "easy", "example": "# Example:\n# >>> count_ones_in_range(15)\n# 8\n# >>> count_ones_in_range(20)\n# 12", "docstring": "Counts the number of times the digit '1' appears in all numbers from 1 to n.\nThe function takes a single argument, n, which is a positive integer, and\nreturns the total count of the digit '1' appearing in all numbers from 1 to n.\n", "canonical_solution": "def count_ones_in_range(n)\n  count = 0\n  (1..n).each do |num|\n    count += num.to_s.count('1')\n  end\n  count\nend\n", "buggy_code": "def count_ones_in_range(n)\n\ndef count_ones(n)\n  count = 0\n  (1..n).each do |num|\n    count += num.to_s.count('1')\n  end\n  count\nend\n", "bug_with_line_numbers": "   1 | def count_ones_in_range(n)\n   2 | def count_ones(n)\n   3 |   count = 0\n   4 |   (1..n).each do |num|\n   5 |     count += num.to_s.count('1')\n   6 |   end\n   7 |   count\n   8 | end", "fragment_lines": [2], "fragment_content": ["def count_ones(n)"], "test": "raise 'Test failed' unless count_ones_in_range(15) == 8\nraise 'Test failed' unless count_ones_in_range(20) == 12\nraise 'Test failed' unless count_ones_in_range(100) == 21\nraise 'Test failed' unless count_ones_in_range(5) == 1\nraise 'Test failed' unless count_ones_in_range(55) == 16\nraise 'Test failed' unless count_ones_in_range(0) == 0\n\nputs 'All tests passed!'", "instruction": "Observe the following faulty Ruby code\n```ruby\ndef count_ones_in_range(n)\n\ndef count_ones(n)\n  count = 0\n  (1..n).each do |num|\n    count += num.to_s.count('1')\n  end\n  count\nend\n```\nFix bugs in the given code snippet. The fixed code must be placed between ```ruby```. Do not generate any test, main,example usage or check code!\n"}
{"question_id": "Ruby/17", "category": "Logic", "subtype": "condition_error", "level": "easy", "example": "Example:\n>>> final_min_weight_fish(1, [1, 2, 3])\n3\n>>> final_min_weight_fish(2, [4, 3, 2, 1])\n4", "docstring": "Calculates the final minimum weight of fish in a simulated feeding game.\nIn this game, there are 'n' fish, each with an initial weight given in the 'weights' array.\nThe game proceeds for 'm' rounds. In each round, the lightest fish eats the second lightest,\nand its weight becomes the sum of both. The function returns the weight of the lightest fish\nafter 'm' rounds.\n\nArguments:\nn (Integer) -- The number of fish.\nm (Integer) -- The number of rounds the game will be played.\nweights (Array of Integers) -- An array representing the weights of each fish.\n\n", "canonical_solution": "def final_min_weight_fish(m, weights)\n  # Sort the weights array to ensure the lightest fish are at the beginning.\n  sorted_weights = weights.sort\n\n  m.times do\n    # The lightest fish eats the second lightest.\n    sorted_weights[0] += sorted_weights[1]\n    # Remove the second lightest fish since it has been eaten.\n    sorted_weights.delete_at(1)\n    # Re-sort the weights to find the new lightest and second lightest for the next round.\n    sorted_weights.sort!\n  end\n\n  # After 'm' rounds, return the weight of the lightest fish.\n  sorted_weights[0]\nend", "buggy_code": "def final_min_weight_fish(m, weights)\n  \n  sorted_weights = weights.sort\n\n  m.times do\n    \n    sorted_weights[0] += sorted_weights[1]\n    \n    sorted_weights.delete_at(0)\n    \n    sorted_weights.sort!\n  end\n\n  \n  sorted_weights[0]\nend\n", "bug_with_line_numbers": "   1 | def final_min_weight_fish(m, weights)\n   2 |   sorted_weights = weights.sort\n   3 |   m.times do\n   4 |     sorted_weights[0] += sorted_weights[1]\n   5 |     sorted_weights.delete_at(0)\n   6 |     sorted_weights.sort!\n   7 |   end\n   8 |   sorted_weights[0]\n   9 | end", "fragment_lines": [5], "fragment_content": ["sorted_weights.delete_at(0)"], "test": "raise 'Test failed' unless final_min_weight_fish(1, [1, 2, 3]) == 3\nraise 'Test failed' unless final_min_weight_fish(2, [4, 3, 2, 1]) == 4\nraise 'Test failed' unless final_min_weight_fish(2, [5, 4, 3, 2, 1]) == 4\nraise 'Test failed' unless final_min_weight_fish(2, [3, 2, 1]) == 6\nraise 'Test failed' unless final_min_weight_fish(3, [1, 2, 3, 4]) == 10\n  \nputs 'All tests passed!'", "instruction": "Observe the following faulty Ruby code\n```ruby\ndef final_min_weight_fish(m, weights)\n  \n  sorted_weights = weights.sort\n\n  m.times do\n    \n    sorted_weights[0] += sorted_weights[1]\n    \n    sorted_weights.delete_at(0)\n    \n    sorted_weights.sort!\n  end\n\n  \n  sorted_weights[0]\nend\n```\nFix bugs in the given code snippet. The fixed code must be placed between ```ruby```. Do not generate any test, main,example usage or check code!\n"}
{"question_id": "Ruby/18", "category": "Logic", "subtype": "condition_error", "level": "easy", "example": "# Example:\n# >>> transpose_matrix([[34, 76, -54, 7], [-4, 5, 23, 9]])\n# [[34, -4], [76, 5], [-54, 23], [7, 9]]", "docstring": "Transposes a given n x m matrix.\nThe function takes a single argument, matrix, which is an array of arrays representing the n x m matrix.\nThe matrix has n rows and m columns, where 1 ≤ n ≤ 20 and 1 ≤ m ≤ 20. Each element in the matrix is an integer.\nThe function returns a new matrix which is the transpose of the input matrix.\n", "canonical_solution": "def transpose_matrix(matrix)\n    return [] if matrix.empty? || matrix[0].empty?\n  \n    transposed = Array.new(matrix[0].size) { Array.new(matrix.size) }\n    matrix.each_with_index do |row, i|\n      row.each_with_index do |value, j|\n        transposed[j][i] = value\n      end\n    end\n    transposed\n  end", "buggy_code": "def transpose_matrix(matrix)\n\ndef transpose(matrix)\n    return [] if matrix.empty? || matrix[0].empty?\n\n    transposed = Array.new(matrix[0].size) { Array.new(matrix.size) }\n    matrix.each_with_index do |row, i|\n        row.each_with_index do |value, j|\n            transposed[j][i] = value\n        end\n    end\n    transposed\nend\n\n", "bug_with_line_numbers": "   1 | def transpose_matrix(matrix)\n   2 | def transpose(matrix)\n   3 |     return [] if matrix.empty? || matrix[0].empty?\n   4 |     transposed = Array.new(matrix[0].size) { Array.new(matrix.size) }\n   5 |     matrix.each_with_index do |row, i|\n   6 |         row.each_with_index do |value, j|\n   7 |             transposed[j][i] = value\n   8 |         end\n   9 |     end\n  10 |     transposed\n  11 | end", "fragment_lines": [2], "fragment_content": ["def transpose(matrix)"], "test": "raise 'Test failed' unless transpose_matrix([[34, 76, -54, 7], [-4, 5, 23, 9]]) == [[34, -4], [76, 5], [-54, 23], [7, 9]]\nraise 'Test failed' unless transpose_matrix([[1, 2, 3], [4, 5, 6]]) == [[1, 4], [2, 5], [3, 6]]\nraise 'Test failed' unless transpose_matrix([[10]]) == [[10]]\nraise 'Test failed' unless transpose_matrix([]) == []\nraise 'Test failed' unless transpose_matrix([[1, 2], [3, 4], [5, 6]]) == [[1, 3, 5], [2, 4, 6]]\n\n\nputs 'All tests passed!'", "instruction": "Observe the following faulty Ruby code\n```ruby\ndef transpose_matrix(matrix)\n\ndef transpose(matrix)\n    return [] if matrix.empty? || matrix[0].empty?\n\n    transposed = Array.new(matrix[0].size) { Array.new(matrix.size) }\n    matrix.each_with_index do |row, i|\n        row.each_with_index do |value, j|\n            transposed[j][i] = value\n        end\n    end\n    transposed\nend\n```\nFix bugs in the given code snippet. The fixed code must be placed between ```ruby```. Do not generate any test, main,example usage or check code!\n"}
{"question_id": "Ruby/19", "category": "Multiple", "subtype": "double_bug", "level": "easy", "example": "Examples:\n>>> count_chars_types(\"yLOI2022\")\n[4, 1, 3]\n>>> count_chars_types(\"IAKIOIOI\")\n[0, 0, 8]\n>>> count_chars_types(\"1n2s0e1s\")\n[4, 4, 0]", "docstring": "Counts the number of digits, lowercase letters, and uppercase letters in a given string.\n The function takes a single argument, s, which is a string of length 8,\n and returns an array with three integers representing the count of digits,\n lowercase letters, and uppercase letters in the string, respectively.\n", "canonical_solution": "def count_chars_types(s)\n    digits_count = s.count(\"0-9\")\n    lowercase_count = s.count(\"a-z\")\n    uppercase_count = s.count(\"A-Z\")\n    [digits_count, lowercase_count, uppercase_count]\n  end", "buggy_code": "def count_chars_types(s)\n\ndigits_count = s.count(\"0-9\")\nlowercase_count = s.count(\"a-z\")\nuppercase_count = u.count(\"A-Z\")\n[digits_count, lowercase_count, uppercase_count]\n", "bug_with_line_numbers": "   1 | def count_chars_types(s)\n   2 | digits_count = s.count(\"0-9\")\n   3 | lowercase_count = s.count(\"a-z\")\n   4 | uppercase_count = u.count(\"A-Z\")\n   5 | [digits_count, lowercase_count, uppercase_count]", "fragment_lines": [4, -1], "fragment_content": ["uppercase_count = u.count(\"A-Z\")", "missing critical code snippet"], "test": "raise 'Test failed' unless count_chars_types(\"yLOI2022\") == [4, 1, 3]\nraise 'Test failed' unless count_chars_types(\"IAKIOIOI\") == [0, 0, 8]\nraise 'Test failed' unless count_chars_types(\"1n2s0e1s\") == [4, 4, 0]\nraise 'Test failed' unless count_chars_types(\"12345678\") == [8, 0, 0]\nraise 'Test failed' unless count_chars_types(\"abcdefgh\") == [0, 8, 0]", "instruction": "Observe the following faulty Ruby code\n```ruby\ndef count_chars_types(s)\n\ndigits_count = s.count(\"0-9\")\nlowercase_count = s.count(\"a-z\")\nuppercase_count = u.count(\"A-Z\")\n[digits_count, lowercase_count, uppercase_count]\n```\nFix bugs in the given code snippet. The fixed code must be placed between ```ruby```. Do not generate any test, main,example usage or check code!\n"}
{"question_id": "Ruby/20", "category": "Reference", "subtype": "undefined_objects", "level": "medium", "example": ">>> has_close_elements([1.0, 2.0, 3.0], 0.5)\nFalse\n>>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\nTrue", "docstring": "Check if in given list of numbers, any two numbers are closer to each other than\ngiven threshold.\n", "canonical_solution": "def has_close_elements(numbers, threshold)\nnumbers.each_with_index do |elem, idx|\n      numbers.each_with_index do |elem2, idx2|\n        next if idx == idx2\n  \n        distance = (elem - elem2).abs\n        return true if distance < threshold\n      end\n    end\n  \n    false\n  end", "buggy_code": "def has_close_elements(numbers, threshold)\n\nnumbers.each_with_index do |elem, idx|\n      numbers.each_with_index do |elem2, idx2|\n        next if idx == idx2\n  \n        distance = (elem - elem2).abs\n        return true if distance < threshold\n      end\n    end\n  \n    false\n  end\n  \n    array = numbers.map { |n| n * 2 }\n", "bug_with_line_numbers": "   1 | def has_close_elements(numbers, threshold)\n   2 | numbers.each_with_index do |elem, idx|\n   3 |       numbers.each_with_index do |elem2, idx2|\n   4 |         next if idx == idx2\n   5 |         distance = (elem - elem2).abs\n   6 |         return true if distance < threshold\n   7 |       end\n   8 |     end\n   9 |     false\n  10 |   end\n  11 |     array = numbers.map { |n| n * 2 }", "fragment_lines": [11], "fragment_content": ["array = numbers.map {"], "test": "  # Test cases\n  def check(has_close_elements)\n    raise 'Test failed' unless has_close_elements.call([1.0, 2.0, 3.9, 4.0, 5.0, 2.2], 0.3)\n    raise 'Test failed' if has_close_elements.call([1.0, 2.0, 3.9, 4.0, 5.0, 2.2], 0.05)\n    raise 'Test failed' unless has_close_elements.call([1.0, 2.0, 5.9, 4.0, 5.0], 0.95)\n    raise 'Test failed' if has_close_elements.call([1.0, 2.0, 5.9, 4.0, 5.0], 0.8)\n    raise 'Test failed' unless has_close_elements.call([1.0, 2.0, 3.0, 4.0, 5.0, 2.0], 0.1)\n    raise 'Test failed' unless has_close_elements.call([1.1, 2.2, 3.1, 4.1, 5.1], 1.0)\n    raise 'Test failed' if has_close_elements.call([1.1, 2.2, 3.1, 4.1, 5.1], 0.5)\n  \n    puts 'All tests passed!'\n  end\n  \n  check(method(:has_close_elements))", "instruction": "Observe the following faulty Ruby code\n```ruby\ndef has_close_elements(numbers, threshold)\n\nnumbers.each_with_index do |elem, idx|\n      numbers.each_with_index do |elem2, idx2|\n        next if idx == idx2\n  \n        distance = (elem - elem2).abs\n        return true if distance < threshold\n      end\n    end\n  \n    false\n  end\n  \n    array = numbers.map { |n| n * 2 }\n```\nFix bugs in the given code snippet. The fixed code must be placed between ```ruby```. Do not generate any test, main,example usage or check code!\n"}
{"question_id": "Ruby/21", "category": "Reference", "subtype": "undefined_objects", "level": "medium", "example": "Examples:\n>>> min_time_to_reverse_order(4)\n2\n>>> min_time_to_reverse_order(5)\n4\n>>> min_time_to_reverse_order(6)\n6", "docstring": "Calculates the minimum time required to reverse the order of M people standing in a circle.\nIn each minute, only a pair of adjacent people can swap places. The function returns the\nminimum number of minutes required to reverse the order of the people, such that each person's\nleft neighbor becomes their right neighbor and vice versa.\n\nArgs:\n- m: A positive integer representing the number of people in the circle.\n\nReturns:\n- An integer representing the minimum number of minutes required to achieve the reversed order.\n\n", "canonical_solution": "def min_time_to_reverse_order(m)\n    if m.even?\n      (m / 2) * (m / 2 - 1)\n    else\n      (m - 1) * (m - 1) / 4\n    end\n  end", "buggy_code": "def min_time_to_reverse_order(m)\n\n    if m.even?\n      (m / 2) * (m / 2 - 1)\n    else\n      (m1 - 1) * (m1 - 1) / 4\n    end\n  end\n", "bug_with_line_numbers": "   1 | def min_time_to_reverse_order(m)\n   2 |     if m.even?\n   3 |       (m / 2) * (m / 2 - 1)\n   4 |     else\n   5 |       (m1 - 1) * (m1 - 1) / 4\n   6 |     end\n   7 |   end", "fragment_lines": [5], "fragment_content": ["(m1 - 1) * (m1 - 1) / 4"], "test": "raise 'Test failed' unless min_time_to_reverse_order(4) == 2\nraise 'Test failed' unless min_time_to_reverse_order(5) == 4\nraise 'Test failed' unless min_time_to_reverse_order(6) == 6\nraise 'Test failed' unless min_time_to_reverse_order(7) == 9\nraise 'Test failed' unless min_time_to_reverse_order(10) == 20\n\n\n\nputs 'All tests passed!'", "instruction": "Observe the following faulty Ruby code\n```ruby\ndef min_time_to_reverse_order(m)\n\n    if m.even?\n      (m / 2) * (m / 2 - 1)\n    else\n      (m1 - 1) * (m1 - 1) / 4\n    end\n  end\n```\nFix bugs in the given code snippet. The fixed code must be placed between ```ruby```. Do not generate any test, main,example usage or check code!\n"}
{"question_id": "Ruby/22", "category": "Multiple", "subtype": "double_bug", "level": "medium", "example": "# Example:\n# >>> binary_power_representation(137)\n# \"2(2(2)+2+2(0))+2(2+2(0))+2(0)\"\n# >>> binary_power_representation(1315)\n# \"2(2(2+2(0))+2)+2(2(2+2(0)))+2(2(2)+2(0))+2+2(0)\"", "docstring": "Converts a positive integer into a unique binary power representation.\nThe function takes a single argument, n, which is a positive integer, and\nreturns a string representing n as a sum of powers of 2, with the powers\nthemselves also represented as sums of powers of 2 when applicable.\n\nThe representation is formatted as '2(b)' where 'b' is the power. If 'b' itself\nis a power of 2, it's represented in a similar nested format. Spaces are not\nused in the representation.\n", "canonical_solution": "def binary_power_representation(n)\n    return '2(0)' if n == 1  # Base case for 1\n  \n    terms = []\n    power = 0\n    while n > 0\n      if n % 2 == 1\n        # If the power is greater than 1, we need to represent it in binary power format\n        if power > 1\n          terms << \"2(#{binary_power_representation(power)})\"\n        else\n          terms << (power == 1 ? '2' : '2(0)')\n        end\n      end\n      n /= 2\n      power += 1\n    end\n    puts terms.reverse.join('+')\n    terms.reverse.join('+')\n    \n  end", "buggy_code": "def binary_power_representation(n)\n\ndef binary_power_representation(n)\n  return '2(0)' if n == 1  \n\n  terms = []\n  power = 0\n  while n > 0\n    if n % 2 == 1\n      if power > 1\n        terms << \"2(\n      else\n        terms << (power == 1 ? '2' : '2(0)')\n      end\n    end\n    n /= 2\n    power += 1\n  end\n  puts terms.reverse.join('+')\n  terms.reverse.join('+')\nend", "bug_with_line_numbers": "   1 | def binary_power_representation(n)\n   2 | def binary_power_representation(n)\n   3 |   return '2(0)' if n == 1  \n   4 |   terms = []\n   5 |   power = 0\n   6 |   while n > 0\n   7 |     if n % 2 == 1\n   8 |       if power > 1\n   9 |         terms << \"2(\n  10 |       else\n  11 |         terms << (power == 1 ? '2' : '2(0)')\n  12 |       end\n  13 |     end\n  14 |     n /= 2\n  15 |     power += 1\n  16 |   end\n  17 |   puts terms.reverse.join('+')\n  18 |   terms.reverse.join('+')\n  19 | end", "fragment_lines": [2, 9], "fragment_content": ["def binary_power_representation(n)", "terms << \"2("], "test": "raise 'Test failed' unless binary_power_representation(137) == \"2(2(2)+2+2(0))+2(2+2(0))+2(0)\"\nraise 'Test failed' unless binary_power_representation(1315) == \"2(2(2+2(0))+2)+2(2(2+2(0)))+2(2(2)+2(0))+2+2(0)\"\nraise 'Test failed' unless binary_power_representation(1) == \"2(0)\"\nraise 'Test failed' unless binary_power_representation(3) == \"2+2(0)\"\nraise 'Test failed' unless binary_power_representation(10) == \"2(2+2(0))+2\"\n\n\nputs 'All tests passed!'", "instruction": "Observe the following faulty Ruby code\n```ruby\ndef binary_power_representation(n)\n\ndef binary_power_representation(n)\n  return '2(0)' if n == 1  \n\n  terms = []\n  power = 0\n  while n > 0\n    if n % 2 == 1\n      if power > 1\n        terms << \"2(\n      else\n        terms << (power == 1 ? '2' : '2(0)')\n      end\n    end\n    n /= 2\n    power += 1\n  end\n  puts terms.reverse.join('+')\n  terms.reverse.join('+')\nend\n```\nFix bugs in the given code snippet. The fixed code must be placed between ```ruby```. Do not generate any test, main,example usage or check code!\n"}
{"question_id": "Ruby/23", "category": "Multiple", "subtype": "double_bug", "level": "easy", "example": "# Example:\n# >>> total_drinks_with_promo(100)\n# 149\n# >>> total_drinks_with_promo(3)\n# 4", "docstring": "Calculates the total number of drinks a customer can enjoy under a promotional offer.\nUnder this offer, for every 3 bottle caps, the customer can get 1 additional drink.\nThe promotion continues as long as the customer has enough caps for exchange.\n\nThe function takes a single integer argument, n, which represents the initial number\nof drinks purchased. It returns an integer representing the total number of drinks\nthe customer can enjoy, including those received through the promotion.\n", "canonical_solution": "def total_drinks_with_promo(n)\n    total_drinks = n\n    caps = n\n  \n    while caps >= 3\n      exchanged_drinks = caps / 3\n      total_drinks += exchanged_drinks\n      caps = caps % 3 + exchanged_drinks\n    end\n  \n    total_drinks\n  end", "buggy_code": "def total_drinks_with_promo(n)\n\ntotal_drinks = n\ncaps = n\n\nwhile caps >= 3\n  exchanged_drinks = caps / 3\n  total_drinks += exchanged_drinks\n  caps = caps % 3 + exchanged_drinks\nend\n\nundefined_variable = total_drinks\n", "bug_with_line_numbers": "   1 | def total_drinks_with_promo(n)\n   2 | total_drinks = n\n   3 | caps = n\n   4 | while caps >= 3\n   5 |   exchanged_drinks = caps / 3\n   6 |   total_drinks += exchanged_drinks\n   7 |   caps = caps % 3 + exchanged_drinks\n   8 | end\n   9 | undefined_variable = total_drinks", "fragment_lines": [9, -1], "fragment_content": ["undefined_variable = total_drinks", "missing critical code snippet"], "test": "raise 'Test failed' unless total_drinks_with_promo(100) == 149\nraise 'Test failed' unless total_drinks_with_promo(3) == 4\nraise 'Test failed' unless total_drinks_with_promo(9) == 13\nraise 'Test failed' unless total_drinks_with_promo(10) == 14\nraise 'Test failed' unless total_drinks_with_promo(1) == 1\n  \nputs 'All tests passed!'", "instruction": "Observe the following faulty Ruby code\n```ruby\ndef total_drinks_with_promo(n)\n\ntotal_drinks = n\ncaps = n\n\nwhile caps >= 3\n  exchanged_drinks = caps / 3\n  total_drinks += exchanged_drinks\n  caps = caps % 3 + exchanged_drinks\nend\n\nundefined_variable = total_drinks\n```\nFix bugs in the given code snippet. The fixed code must be placed between ```ruby```. Do not generate any test, main,example usage or check code!\n"}
{"question_id": "Ruby/24", "category": "Syntax", "subtype": "illegal_comment", "level": "hard", "example": "Examples:\n>>> sort_dates([\"15/12/1999\", \"10/21/2003\", \"02/12/2004\"])\n[\"15/12/1999\", \"10/21/2003\", \"02/12/2004\"]\n>>> sort_dates([\"12/31/2005\", \"11/30/2005\", \"10/22/2003\"])\n[\"10/22/2003\", \"11/30/2005\", \"12/31/2005\"]", "docstring": "Sorts a list of dates in the format 'MM/DD/YYYY'.\nThe function takes an array of string dates and returns an array of dates sorted in ascending order.\nThe sorting is done based on the chronological order of the dates.\n\n", "canonical_solution": "def sort_dates(dates)\n    dates.sort_by { |date| date.split('/').rotate(-1).join }\n  end", "buggy_code": "def sort_dates(dates)\n\n    \n  end\n", "bug_with_line_numbers": "   1 | def sort_dates(dates)\n   2 |   end", "fragment_lines": [-1], "fragment_content": ["missing critical code snippet"], "test": "raise 'Test failed' unless sort_dates([\"10/21/2003\", \"15/12/1999\",  \"02/12/2004\"]) == [\"15/12/1999\", \"10/21/2003\", \"02/12/2004\"]\nraise 'Test failed' unless sort_dates([\"12/31/2005\", \"11/30/2005\", \"10/22/2003\"]) == [\"10/22/2003\", \"11/30/2005\", \"12/31/2005\"]\nraise 'Test failed' unless sort_dates([\"01/01/2000\", \"12/31/1999\"]) == [\"12/31/1999\", \"01/01/2000\"]\n  \n\nputs 'All tests passed!'", "instruction": "Observe the following faulty Ruby code\n```ruby\ndef sort_dates(dates)\n\n    \n  end\n```\nFix bugs in the given code snippet. The fixed code must be placed between ```ruby```. Do not generate any test, main,example usage or check code!\n"}
{"question_id": "Ruby/25", "category": "Multiple", "subtype": "double_bug", "level": "easy", "example": "Examples:\n>>> convert_score_to_grade(56)\n'E'\n>>> convert_score_to_grade(100)\n'A'\n>>> convert_score_to_grade(123)\n'Score is error!'", "docstring": "Converts a numerical score into a corresponding letter grade based on predefined ranges.\nThe function takes a single argument, score, which is an integer representing the score.\nIt returns a string representing the letter grade, or an error message for invalid scores.\n\nGrade Conversion:\n90-100: 'A'\n80-89: 'B'\n70-79: 'C'\n60-69: 'D'\n0-59: 'E'\nAny other score: 'Score is error!'\n\n", "canonical_solution": "def convert_score_to_grade(score)\n    return 'Score is error!' if score < 0 || score > 100\n  \n    case score\n    when 90..100\n      'A'\n    when 80...90\n      'B'\n    when 70...80\n      'C'\n    when 60...70\n      'D'\n    when 0...60\n      'E'\n    else\n      'Score is error!'\n    end\n  end", "buggy_code": "def convert_score_to_grade(score)\n\ndef grade(score)\n  return 'Score is error!' if score < 0 || score > 100\n\n  case score\n  when 90..100\n    'A'\n  when 80...90\n    'B'\n  when 70...80\n    'C'\n  when 60...70\n    'D'\n  when \"0\"...60\n    'E'\n  else\n    'Score is error!'\n  end\nend\n", "bug_with_line_numbers": "   1 | def convert_score_to_grade(score)\n   2 | def grade(score)\n   3 |   return 'Score is error!' if score < 0 || score > 100\n   4 |   case score\n   5 |   when 90..100\n   6 |     'A'\n   7 |   when 80...90\n   8 |     'B'\n   9 |   when 70...80\n  10 |     'C'\n  11 |   when 60...70\n  12 |     'D'\n  13 |   when \"0\"...60\n  14 |     'E'\n  15 |   else\n  16 |     'Score is error!'\n  17 |   end\n  18 | end", "fragment_lines": [2, 13], "fragment_content": ["def grade(score)", "when \"0\"...60"], "test": "raise 'Test failed' unless convert_score_to_grade(56) == 'E'\nraise 'Test failed' unless convert_score_to_grade(67) == 'D'\nraise 'Test failed' unless convert_score_to_grade(100) == 'A'\nraise 'Test failed' unless convert_score_to_grade(123) == 'Score is error!'\nraise 'Test failed' unless convert_score_to_grade(-5) == 'Score is error!'\nraise 'Test failed' unless convert_score_to_grade(85) == 'B'\n  \n\nputs 'All tests passed!'", "instruction": "Observe the following faulty Ruby code\n```ruby\ndef convert_score_to_grade(score)\n\ndef grade(score)\n  return 'Score is error!' if score < 0 || score > 100\n\n  case score\n  when 90..100\n    'A'\n  when 80...90\n    'B'\n  when 70...80\n    'C'\n  when 60...70\n    'D'\n  when \"0\"...60\n    'E'\n  else\n    'Score is error!'\n  end\nend\n```\nFix bugs in the given code snippet. The fixed code must be placed between ```ruby```. Do not generate any test, main,example usage or check code!\n"}
{"question_id": "Ruby/26", "category": "Logic", "subtype": "type_error", "level": "easy", "example": "# Example:\n>>> find_possible_last_digits(200, 40)\n[\"00\", \"40\", \"80\"]\n>>> find_possible_last_digits(1992, 95)\n[\"15\"]\n", "docstring": "Finds all possible last two digits of a number that, when added to the number 'a',\nmakes it divisible by 'b'. The function takes two arguments, 'a' and 'b', where 'a' is\na positive integer less than 10000, and 'b' is a positive integer between 10 and 100.\nThe function returns an array of strings representing the possible two-digit suffixes.\n", "canonical_solution": "def find_possible_last_digits(a, b)\n    possible_digits = []\n    (0..99).each do |i|\n      suffix = '%02d' % i # Ensures a two-digit format\n      combined_number = (a.to_s + suffix).to_i\n      possible_digits << suffix if combined_number % b == 0\n    end\n    possible_digits\n  end", "buggy_code": "def find_possible_last_digits(a, b)\n\npossible_digits = []\n(0..99).each do |i|\n  suffix = '%02d' % i \n  combined_number = (a.to_s + suffix).to_i\n  possible_digits << (suffix + 1) if combined_number % b == 0\nend\npossible_digits\n", "bug_with_line_numbers": "   1 | def find_possible_last_digits(a, b)\n   2 | possible_digits = []\n   3 | (0..99).each do |i|\n   4 |   suffix = '%02d' % i \n   5 |   combined_number = (a.to_s + suffix).to_i\n   6 |   possible_digits << (suffix + 1) if combined_number % b == 0\n   7 | end\n   8 | possible_digits", "fragment_lines": [6], "fragment_content": ["possible_digits << (suffix + 1) if combined_number % b == 0"], "test": "raise 'Test failed' unless find_possible_last_digits(200, 40) == [\"00\", \"40\", \"80\"]\nraise 'Test failed' unless find_possible_last_digits(1992, 95) == [\"15\"]\nraise 'Test failed' unless find_possible_last_digits(1500, 25) == [\"00\", \"25\", \"50\", \"75\"]\nraise 'Test failed' unless find_possible_last_digits(300, 30) == [\"00\", \"30\", \"60\", \"90\"]\n  \nputs 'All tests passed!'", "instruction": "Observe the following faulty Ruby code\n```ruby\ndef find_possible_last_digits(a, b)\n\npossible_digits = []\n(0..99).each do |i|\n  suffix = '%02d' % i \n  combined_number = (a.to_s + suffix).to_i\n  possible_digits << (suffix + 1) if combined_number % b == 0\nend\npossible_digits\n```\nFix bugs in the given code snippet. The fixed code must be placed between ```ruby```. Do not generate any test, main,example usage or check code!\n"}
{"question_id": "Ruby/27", "category": "Logic", "subtype": "type_error", "level": "medium", "example": "Examples:\n>>> sort_dates([\"15/12/1999\", \"10/21/2003\", \"02/12/2004\"])\n[\"15/12/1999\", \"10/21/2003\", \"02/12/2004\"]\n>>> sort_dates([\"12/31/2005\", \"11/30/2005\", \"10/22/2003\"])\n[\"10/22/2003\", \"11/30/2005\", \"12/31/2005\"]", "docstring": "Sorts a list of dates in the format 'MM/DD/YYYY'.\nThe function takes an array of string dates and returns an array of dates sorted in ascending order.\nThe sorting is done based on the chronological order of the dates.\n\n", "canonical_solution": "def sort_dates(dates)\n    dates.sort_by { |date| date.split('/').rotate(-1).join }\n  end", "buggy_code": "def sort_dates(dates)\n\ndates.sort_by { |date| date.split('/').rotate(-1).join.to_i }\nend\n", "bug_with_line_numbers": "   1 | def sort_dates(dates)\n   2 | dates.sort_by { |date| date.split('/').rotate(-1).join.to_i }\n   3 | end ", "fragment_lines": [2], "fragment_content": ["dates.sort_by {"], "test": "raise 'Test failed' unless sort_dates([\"10/21/2003\", \"15/12/1999\",  \"02/12/2004\"]) == [\"15/12/1999\", \"10/21/2003\", \"02/12/2004\"]\nraise 'Test failed' unless sort_dates([\"12/31/2005\", \"11/30/2005\", \"10/22/2003\"]) == [\"10/22/2003\", \"11/30/2005\", \"12/31/2005\"]\nraise 'Test failed' unless sort_dates([\"01/01/2000\", \"12/31/1999\"]) == [\"12/31/1999\", \"01/01/2000\"]\n  \n\nputs 'All tests passed!'", "instruction": "Observe the following faulty Ruby code\n```ruby\ndef sort_dates(dates)\n\ndates.sort_by { |date| date.split('/').rotate(-1).join.to_i }\nend\n```\nFix bugs in the given code snippet. The fixed code must be placed between ```ruby```. Do not generate any test, main,example usage or check code!\n"}
{"question_id": "Ruby/28", "category": "Logic", "subtype": "type_error", "level": "easy", "example": "# Example:\n# >>> victory_gap_in_teams(\"abaabcaa\")\n# 4\n# >>> victory_gap_in_teams(\"abcd\")\n# 0", "docstring": "Calculates the difference in the number of victories between the most and least successful teams.\nThis function takes a string, team_sequence, representing the sequence of winning teams, where each team\nis identified by a lowercase letter. It returns an integer representing the difference in the number\nof victories between the team that won the most and the team that won the least (excluding teams with zero victories).\n", "canonical_solution": "def victory_gap_in_teams(team_sequence)\n    counts = Hash.new(0)\n    team_sequence.each_char { |team| counts[team] += 1 }\n  \n    max_victories = counts.values.max\n    min_victories = counts.values.reject { |v| v == 0 }.min\n  \n    max_victories - min_victories\n  end", "buggy_code": "def victory_gap_in_teams(team_sequence)\n\ncounts = Hash.new(0)\nteam_sequence.each_char { |team| counts[team] += '1' }\n\nmax_victories = counts.values.max\nmin_victories = counts.values.reject { |v| v == 0 }.min\n\nmax_victories - min_victories\nend\n", "bug_with_line_numbers": "   1 | def victory_gap_in_teams(team_sequence)\n   2 | counts = Hash.new(0)\n   3 | team_sequence.each_char { |team| counts[team] += '1' }\n   4 | max_victories = counts.values.max\n   5 | min_victories = counts.values.reject { |v| v == 0 }.min\n   6 | max_victories - min_victories\n   7 | end", "fragment_lines": [3], "fragment_content": ["team_sequence.each_char {"], "test": "raise 'Test failed' unless victory_gap_in_teams(\"abaabcaa\") == 4\nraise 'Test failed' unless victory_gap_in_teams(\"abcd\") == 0\nraise 'Test failed' unless victory_gap_in_teams(\"a\") == 0\nraise 'Test failed' unless victory_gap_in_teams(\"aaabbbccc\") == 0\nraise 'Test failed' unless victory_gap_in_teams(\"abcdaaa\") == 3\n\nputs 'All tests passed!'", "instruction": "Observe the following faulty Ruby code\n```ruby\ndef victory_gap_in_teams(team_sequence)\n\ncounts = Hash.new(0)\nteam_sequence.each_char { |team| counts[team] += '1' }\n\nmax_victories = counts.values.max\nmin_victories = counts.values.reject { |v| v == 0 }.min\n\nmax_victories - min_victories\nend\n```\nFix bugs in the given code snippet. The fixed code must be placed between ```ruby```. Do not generate any test, main,example usage or check code!\n"}
{"question_id": "Ruby/29", "category": "Logic", "subtype": "type_error", "level": "easy", "example": "Example:\n>>> find_intersection(1.0, 0.0, -1.0, 2.0)\n[1.00, 1.00]\n>>> find_intersection(2.0, 3.0, 2.0, -1.0)\nnil  Parallel lines with no intersection", "docstring": "Finds the intersection point of two linear functions.\nThis function takes four arguments: slope1, intercept1, slope2, intercept2.\nslope1 and slope2 are the slopes of the two lines, while intercept1 and intercept2 are their y-intercepts.\nThe function calculates and returns the coordinates of the intersection point of these two lines, if it exists.\nThe coordinates are returned as a two-element array [x, y], rounded to two decimal places.\n\n", "canonical_solution": "def find_intersection(slope1, intercept1, slope2, intercept2)\n    # Handle parallel lines which never intersect\n    return nil if slope1 == slope2\n  \n    # Calculate intersection point\n    x = (intercept2 - intercept1).to_f / (slope1 - slope2)\n    y = slope1 * x + intercept1\n  \n    # Round the coordinates to two decimal places\n    [x.round(2), y.round(2)]\n  end", "buggy_code": "def find_intersection(slope1, intercept1, slope2, intercept2)\n  return nil if slope1 == slope2\n\n  x = (intercept2 - intercept1) / (slope1 - slope2)\n  y = slope1 * x + intercept1\n\n  [x.round(2), y.round(2)]\nend\n", "bug_with_line_numbers": "   1 | def find_intersection(slope1, intercept1, slope2, intercept2)\n   2 |   return nil if slope1 == slope2\n   3 |   x = (intercept2 - intercept1) / (slope1 - slope2)\n   4 |   y = slope1 * x + intercept1\n   5 |   [x.round(2), y.round(2)]\n   6 | end", "fragment_lines": [3], "fragment_content": ["x = (intercept2 - intercept1) / (slope1 - slope2)"], "test": "raise 'Test failed' unless find_intersection(1.0, 0.0, -1.0, 2.0) == [1.00, 1.00]\nraise 'Test failed' unless find_intersection(2.0, 3.0, 2.0, -1.0).nil?\nraise 'Test failed' unless find_intersection(0.5, 1.0, -0.5, -1.0) == [-2.00, 0.00]\nraise 'Test failed' unless find_intersection(3.0, 2.0, -1.0, 4.0) == [0.50, 3.50]\nraise 'Test failed' unless find_intersection(2.0, 0.0, 0.0, 2.0) == [1.0, 2.0]\n  \n\nputs 'All tests passed!'", "instruction": "Observe the following faulty Ruby code\n```ruby\ndef find_intersection(slope1, intercept1, slope2, intercept2)\n  return nil if slope1 == slope2\n\n  x = (intercept2 - intercept1) / (slope1 - slope2)\n  y = slope1 * x + intercept1\n\n  [x.round(2), y.round(2)]\nend\n```\nFix bugs in the given code snippet. The fixed code must be placed between ```ruby```. Do not generate any test, main,example usage or check code!\n"}
{"question_id": "Ruby/30", "category": "Logic", "subtype": "algorithm_error", "level": "medium", "example": "# Example:\n# >>> max_regex_string_length(\"((xx|xxx)x|(x|xx))xx\")\n# 6\n# >>> max_regex_string_length(\"x(xx|x)x\")\n# 4", "docstring": "Determines the maximum length of a string that can be accepted by a simplified regular expression.\nThe function takes a single argument, regex, which is a string representing a regular expression\ncomposed only of 'x', '(', ')', and '|'. The function returns the length of the longest string\nthat can be accepted by this regular expression.\n", "canonical_solution": "def max_regex_string_length(regex)\n    @regex = regex\n    @index = 0\n    dfs\n  end\n  \n  def dfs\n    temp = 0\n    max = 0\n    while @index < @regex.length\n      case @regex[@index]\n      when '('\n        @index += 1\n        temp += dfs\n      when ')'\n        @index += 1\n        break\n      when '|'\n        @index += 1\n        max = temp if temp > max\n        temp = 0\n      else # assuming 'x'\n        @index += 1\n        temp += 1\n      end\n    end\n    max = temp if temp > max\n    max\n  end", "buggy_code": "def max_regex_string_length(regex)\n\n@regex = regex\n@index = 0\ndfs\nend\n\ndef dfs\n  temp = 0\n  max = 0\n  while @index < @regex.length\n    case @regex[@index]\n    when '('\n      @index += 1\n      temp += dfs\n    when ')'\n      @index += 1\n      break\n    when '|'\n      @index += 1\n      max = temp if temp > max\n      temp = 0\n    else \n      @index += 1\n      temp += 1\n  end\n\n  max = temp if temp > max\n  max\nend\n", "bug_with_line_numbers": "   1 | def max_regex_string_length(regex)\n   2 | @regex = regex\n   3 | @index = 0\n   4 | dfs\n   5 | end\n   6 | def dfs\n   7 |   temp = 0\n   8 |   max = 0\n   9 |   while @index < @regex.length\n  10 |     case @regex[@index]\n  11 |     when '('\n  12 |       @index += 1\n  13 |       temp += dfs\n  14 |     when ')'\n  15 |       @index += 1\n  16 |       break\n  17 |     when '|'\n  18 |       @index += 1\n  19 |       max = temp if temp > max\n  20 |       temp = 0\n  21 |     else \n  22 |       @index += 1\n  23 |       temp += 1\n  24 |   end\n  25 |   max = temp if temp > max\n  26 |   max\n  27 | end", "fragment_lines": [-1], "fragment_content": ["missing critical code snippet"], "test": "raise 'Test failed' unless max_regex_string_length(\"((xx|xxx)x|(x|xx))xx\") == 6\nraise 'Test failed' unless max_regex_string_length(\"x(xx|x)x\") == 4\nraise 'Test failed' unless max_regex_string_length(\"xx|x\") == 2\nraise 'Test failed' unless max_regex_string_length(\"(xx|x)(x|xx)\") == 4\nraise 'Test failed' unless max_regex_string_length(\"x\") == 1\n  \n\nputs 'All tests passed!'", "instruction": "Observe the following faulty Ruby code\n```ruby\ndef max_regex_string_length(regex)\n\n@regex = regex\n@index = 0\ndfs\nend\n\ndef dfs\n  temp = 0\n  max = 0\n  while @index < @regex.length\n    case @regex[@index]\n    when '('\n      @index += 1\n      temp += dfs\n    when ')'\n      @index += 1\n      break\n    when '|'\n      @index += 1\n      max = temp if temp > max\n      temp = 0\n    else \n      @index += 1\n      temp += 1\n  end\n\n  max = temp if temp > max\n  max\nend\n```\nFix bugs in the given code snippet. The fixed code must be placed between ```ruby```. Do not generate any test, main,example usage or check code!\n"}
{"question_id": "Ruby/31", "category": "Logic", "subtype": "algorithm_error", "level": "medium", "example": "# Example:\n# >>> longest_consecutive_sequence([1, 5, 6, 2, 3, 4, 5, 6, 8, 9])\n# 6   Because the longest consecutive sequence is 1, 2, 3, 4, 5, 6\n# >>> longest_consecutive_sequence([10, 4, 20, 1, 3, 2])\n# 4   Because the longest consecutive sequence is 1, 2, 3, 4", "docstring": "Finds the length of the longest consecutive sequence in an array of integers.\n The function takes an array of integers as an argument and returns the length\n of the longest consecutive sequence of numbers present in the array.\n", "canonical_solution": "def longest_consecutive_sequence(arr)\n    # Return 0 if the array is empty\n    return 0 if arr.empty?\n  \n    # Sort the array\n    sorted_arr = arr.sort.uniq  # Also remove duplicates to handle repeated numbers\n  \n    max_length = 1\n    current_length = 1\n  \n    (1...sorted_arr.length).each do |i|\n      # Check if the current number is consecutive to the previous\n      if sorted_arr[i] == sorted_arr[i - 1] + 1\n        current_length += 1\n        max_length = [max_length, current_length].max\n      else\n        current_length = 1\n      end\n    end\n  \n    max_length\n  end", "buggy_code": "\ndef longest_consecutive_sequence(arr)\n  return 0 if arr.empty?\n\n  sorted_arr = arr.sort \n\n  max_length = 1\n  current_length = 1\n\n  (1...sorted_arr.length).each do |i|\n    if sorted_arr[i] == sorted_arr[i - 1] + 1\n      current_length += 1\n      max_length = [max_length, current_length].max\n    else\n      current_length = 1\n    end\n  end\n\n  max_length\nend\n", "bug_with_line_numbers": "   1 | \n   2 | def longest_consecutive_sequence(arr)\n   3 |   return 0 if arr.empty?\n   4 |   sorted_arr = arr.sort \n   5 |   max_length = 1\n   6 |   current_length = 1\n   7 |   (1...sorted_arr.length).each do |i|\n   8 |     if sorted_arr[i] == sorted_arr[i - 1] + 1\n   9 |       current_length += 1\n  10 |       max_length = [max_length, current_length].max\n  11 |     else\n  12 |       current_length = 1\n  13 |     end\n  14 |   end\n  15 |   max_length\n  16 | end", "fragment_lines": [4], "fragment_content": ["sorted_arr = arr.sort"], "test": "raise 'Test failed' unless longest_consecutive_sequence([1, 5, 6, 2, 3, 4, 5, 6, 8, 9]) ==6\nraise 'Test failed' unless longest_consecutive_sequence([10, 4, 20, 1, 3, 2]) == 4\nraise 'Test failed' unless longest_consecutive_sequence([100, 4, 200, 1, 3, 2]) == 4\nraise 'Test failed' unless longest_consecutive_sequence([1, 2, 0, 1]) == 3\nraise 'Test failed' unless longest_consecutive_sequence([]) == 0\nraise 'Test failed' unless longest_consecutive_sequence([1]) == 1", "instruction": "Observe the following faulty Ruby code\n```ruby\ndef longest_consecutive_sequence(arr)\n  return 0 if arr.empty?\n\n  sorted_arr = arr.sort \n\n  max_length = 1\n  current_length = 1\n\n  (1...sorted_arr.length).each do |i|\n    if sorted_arr[i] == sorted_arr[i - 1] + 1\n      current_length += 1\n      max_length = [max_length, current_length].max\n    else\n      current_length = 1\n    end\n  end\n\n  max_length\nend\n```\nFix bugs in the given code snippet. The fixed code must be placed between ```ruby```. Do not generate any test, main,example usage or check code!\n"}
{"question_id": "Ruby/32", "category": "Logic", "subtype": "algorithm_error", "level": "hard", "example": "# Examples:\n# >>> insert_max_after_largest_letters(\"abcdefgfedcba\")\n# \"abcdefg(max)fedcba\"\n# >>> insert_max_after_largest_letters(\"aAbBcC\")\n# \"aAbBc(max)C(max)\"", "docstring": "Finds the largest letter(s) in the input string (considering 'A' and 'a' as the same letter) and inserts \"(max)\" after each of its occurrences.\nThe function takes one argument, input_string, which is a string of letters and possibly digits.\nReturns a new string with \"(max)\" inserted after each occurrence of the largest letter(s).\n", "canonical_solution": "def insert_max_after_largest_letters(input_string)\n    # Normalize the string to lowercase for comparison\n    normalized_string = input_string.downcase\n  \n    # Find the largest letter\n    largest_letter = normalized_string.chars.max\n  \n    # Insert '(max)' after each occurrence of the largest letter\n    result = ''\n    input_string.each_char do |char|\n      result += char\n      result += '(max)' if char.downcase == largest_letter\n    end\n  \n    result\n  end", "buggy_code": "def insert_max_after_largest_letters(input_string)\n\n    \n    normalized_string = input_string.downcase\n  \n    \n    largest_letter = normalized_string.chars.max\n  \n    \n    result = ''\n    input_string.each_char do |char|\n      result += char\n      result += '(max)' if char == largest_letter\n    end\n  \n    result\n  end\n", "bug_with_line_numbers": "   1 | def insert_max_after_largest_letters(input_string)\n   2 |     normalized_string = input_string.downcase\n   3 |     largest_letter = normalized_string.chars.max\n   4 |     result = ''\n   5 |     input_string.each_char do |char|\n   6 |       result += char\n   7 |       result += '(max)' if char == largest_letter\n   8 |     end\n   9 |     result\n  10 |   end", "fragment_lines": [7], "fragment_content": ["result += '(max)' if char == largest_letter"], "test": "raise 'Test failed' unless insert_max_after_largest_letters(\"abcdefgfedcba\") == \"abcdefg(max)fedcba\"\nraise 'Test failed' unless insert_max_after_largest_letters(\"xxxxx\") == \"x(max)x(max)x(max)x(max)x(max)\"\nraise 'Test failed' unless insert_max_after_largest_letters(\"Hello World!\") == \"Hello W(max)orld!\"\nraise 'Test failed' unless insert_max_after_largest_letters(\"Ruby123\") == \"Ruby(max)123\"\nraise 'Test failed' unless insert_max_after_largest_letters(\"\") == \"\"\nraise 'Test failed' unless insert_max_after_largest_letters(\"aAbBcC\") == \"aAbBc(max)C(max)\"\n  \n\nputs 'All tests passed!'", "instruction": "Observe the following faulty Ruby code\n```ruby\ndef insert_max_after_largest_letters(input_string)\n\n    \n    normalized_string = input_string.downcase\n  \n    \n    largest_letter = normalized_string.chars.max\n  \n    \n    result = ''\n    input_string.each_char do |char|\n      result += char\n      result += '(max)' if char == largest_letter\n    end\n  \n    result\n  end\n```\nFix bugs in the given code snippet. The fixed code must be placed between ```ruby```. Do not generate any test, main,example usage or check code!\n"}
{"question_id": "Ruby/33", "category": "Logic", "subtype": "operation_error", "level": "easy", "example": "# Example:\n# >>> swap_case(\"HelloWorld\")\n# \"hELLOwORLD\"\n# >>> swap_case(\"Ruby\")\n# \"rUBY\"", "docstring": "Swaps the case of each letter in a given string.\nThe function takes a single argument, input_string, which is a string containing only English alphabets without any spaces or other types of characters.\nIt returns a new string where every lowercase letter is converted to uppercase and every uppercase letter is converted to lowercase.\n", "canonical_solution": "def swap_case(input_string)\n    input_string.chars.map do |char|\n      if char =~ /[a-z]/\n        char.upcase\n      elsif char =~ /[A-Z]/\n        char.downcase\n      else\n        char\n      end\n    end.join\n  end", "buggy_code": "def swap_case(input_string)\n\ninput_string.chars.map do |char|\n  if char =~ /[a-z]/\n    char.upcase\n  elsif char.downcase\n    char.downcase\n  else\n    char\n  end\nend.join\n", "bug_with_line_numbers": "   1 | def swap_case(input_string)\n   2 | input_string.chars.map do |char|\n   3 |   if char =~ /[a-z]/\n   4 |     char.upcase\n   5 |   elsif char.downcase\n   6 |     char.downcase\n   7 |   else\n   8 |     char\n   9 |   end\n  10 | end.join", "fragment_lines": [5], "fragment_content": ["elsif char.downcase"], "test": "raise 'Test failed' unless swap_case(\"HelloWorld\") == \"hELLOwORLD\"\nraise 'Test failed' unless swap_case(\"Ruby\") == \"rUBY\"\nraise 'Test failed' unless swap_case(\"AeDb\") == \"aEdB\"\nraise 'Test failed' unless swap_case(\"JAVA\") == \"java\"\nraise 'Test failed' unless swap_case(\"python\") == \"PYTHON\"\n  \n\nputs 'All tests passed!'", "instruction": "Observe the following faulty Ruby code\n```ruby\ndef swap_case(input_string)\n\ninput_string.chars.map do |char|\n  if char =~ /[a-z]/\n    char.upcase\n  elsif char.downcase\n    char.downcase\n  else\n    char\n  end\nend.join\n```\nFix bugs in the given code snippet. The fixed code must be placed between ```ruby```. Do not generate any test, main,example usage or check code!\n"}
{"question_id": "Ruby/34", "category": "Multiple", "subtype": "triple_bug", "level": "hard", "example": "Examples:\n>>> count_chars_types(\"yLOI2022\")\n[4, 1, 3]\n>>> count_chars_types(\"IAKIOIOI\")\n[0, 0, 8]\n>>> count_chars_types(\"1n2s0e1s\")\n[4, 4, 0]", "docstring": "Counts the number of digits, lowercase letters, and uppercase letters in a given string.\n The function takes a single argument, s, which is a string of length 8,\n and returns an array with three integers representing the count of digits,\n lowercase letters, and uppercase letters in the string, respectively.\n", "canonical_solution": "def count_chars_types(s)\n    digits_count = s.count(\"0-9\")\n    lowercase_count = s.count(\"a-z\")\n    uppercase_count = s.count(\"A-Z\")\n    [digits_count, lowercase_count, uppercase_count]\n  end", "buggy_code": "def count_chars_types(s)\n\ndigits_count = s.count(\"0-9\")\nlowercase_count = s.count(\"a-z\")\nuppercase_count = s.count(\"A-Z\")\nspecial_count = s.count(\"!-\\/:-@[-`{-~\")\n[digits_count, lowercase_count, uppercase_count, special_count]\n", "bug_with_line_numbers": "   1 | def count_chars_types(s)\n   2 | digits_count = s.count(\"0-9\")\n   3 | lowercase_count = s.count(\"a-z\")\n   4 | uppercase_count = s.count(\"A-Z\")\n   5 | special_count = s.count(\"!-\\/:-@[-`{-~\")\n   6 | [digits_count, lowercase_count, uppercase_count, special_count]", "fragment_lines": [5, 6, -1], "fragment_content": ["special_count = s.count(\"!-\\/:-@[-`{-~\")", "[digits_count, lowercase_count, uppercase_count, special_count]", "missing critical code snippet"], "test": "raise 'Test failed' unless count_chars_types(\"yLOI2022\") == [4, 1, 3]\nraise 'Test failed' unless count_chars_types(\"IAKIOIOI\") == [0, 0, 8]\nraise 'Test failed' unless count_chars_types(\"1n2s0e1s\") == [4, 4, 0]\nraise 'Test failed' unless count_chars_types(\"12345678\") == [8, 0, 0]\nraise 'Test failed' unless count_chars_types(\"abcdefgh\") == [0, 8, 0]", "instruction": "Observe the following faulty Ruby code\n```ruby\ndef count_chars_types(s)\n\ndigits_count = s.count(\"0-9\")\nlowercase_count = s.count(\"a-z\")\nuppercase_count = s.count(\"A-Z\")\nspecial_count = s.count(\"!-\\/:-@[-`{-~\")\n[digits_count, lowercase_count, uppercase_count, special_count]\n```\nFix bugs in the given code snippet. The fixed code must be placed between ```ruby```. Do not generate any test, main,example usage or check code!\n"}
{"question_id": "Ruby/35", "category": "Logic", "subtype": "operation_error", "level": "medium", "example": "# Examples:\n# >>> compare_area(5, 4, 6)\n# \"Alice\"\n# >>> compare_area(7, 5, 10)\n# \"Bob\"", "docstring": "Compares the area of a square with side length 'a' to the area of a rectangle with sides 'b' and 'c'.\n The function takes three arguments, a, b, and c, which are positive integers representing the side length of the square and the sides of the rectangle, respectively.\n It returns a string indicating whose shape has the greater area: \"Alice\" if the square's area is larger, and \"Bob\" if the rectangle's area is larger.\n", "canonical_solution": "def compare_area(a, b, c)\n    square_area = a * a\n    rectangle_area = b * c\n    if square_area > rectangle_area\n      \"Alice\"\n    else\n      \"Bob\"\n    end\n  end", "buggy_code": "def compare_area(a, b, c)\n\ndef compare_areas(a, b, c)\n  square_area = a * a\n  rectangle_area = b * c\n  if square_area > rectangle_area\n    \"Alice\"\n  else\n    \"Bob\"\n  end\nend\n", "bug_with_line_numbers": "   1 | def compare_area(a, b, c)\n   2 | def compare_areas(a, b, c)\n   3 |   square_area = a * a\n   4 |   rectangle_area = b * c\n   5 |   if square_area > rectangle_area\n   6 |     \"Alice\"\n   7 |   else\n   8 |     \"Bob\"\n   9 |   end\n  10 | end", "fragment_lines": [2], "fragment_content": ["def compare_areas(a, b, c)"], "test": "raise 'Test failed' unless compare_area(5, 4, 6) == \"Alice\"\nraise 'Test failed' unless compare_area(7, 5, 10) == \"Bob\"\nraise 'Test failed' unless compare_area(6, 3, 12) == \"Bob\"\nraise 'Test failed' unless compare_area(10, 10, 1) == \"Alice\"\nraise 'Test failed' unless compare_area(8, 8, 8) == \"Bob\" # Case where areas are equal, but based on the problem statement, Bob wins in a tie.", "instruction": "Observe the following faulty Ruby code\n```ruby\ndef compare_area(a, b, c)\n\ndef compare_areas(a, b, c)\n  square_area = a * a\n  rectangle_area = b * c\n  if square_area > rectangle_area\n    \"Alice\"\n  else\n    \"Bob\"\n  end\nend\n```\nFix bugs in the given code snippet. The fixed code must be placed between ```ruby```. Do not generate any test, main,example usage or check code!\n"}
{"question_id": "Ruby/36", "category": "Logic", "subtype": "operation_error", "level": "easy", "example": "# Example:\n# >>> digit_sum_to_single(\"35379\")\n# 9\n# >>> digit_sum_to_single(\"24815\")\n# 3", "docstring": "Computes the repeated sum of digits of a given number string until it reduces to a single digit.\nThe function takes a single argument, `input_string`, which is a string representing a non-negative number.\nIt repeatedly sums the digits of the number until the sum is a single digit, then returns this single digit.\n", "canonical_solution": "def digit_sum_to_single(input_string)\n    sum = input_string.chars.map(&:to_i).sum\n    while sum > 9\n      sum = sum.to_s.chars.map(&:to_i).sum\n    end\n    sum\n  end", "buggy_code": "def digit_sum_to_single(input_string)\n\ndef compute_single_digit_sum(input_string)\n  sum = input_string.chars.map(&:to_i).sum\n  while sum > 9\n    sum = sum.to_s.chars.map(&:to_i).sum\n  end\n  sum\nend\n", "bug_with_line_numbers": "   1 | def digit_sum_to_single(input_string)\n   2 | def compute_single_digit_sum(input_string)\n   3 |   sum = input_string.chars.map(&:to_i).sum\n   4 |   while sum > 9\n   5 |     sum = sum.to_s.chars.map(&:to_i).sum\n   6 |   end\n   7 |   sum\n   8 | end", "fragment_lines": [2], "fragment_content": ["def compute_single_digit_sum(input_string)"], "test": "raise 'Test failed' unless digit_sum_to_single(\"35379\") == 9\nraise 'Test failed' unless digit_sum_to_single(\"24815\") == 2\nraise 'Test failed' unless digit_sum_to_single(\"9999\") == 9\nraise 'Test failed' unless digit_sum_to_single(\"12345\") == 6\nraise 'Test failed' unless digit_sum_to_single(\"0\") == 0\n  \n\nputs 'All tests passed!'", "instruction": "Observe the following faulty Ruby code\n```ruby\ndef digit_sum_to_single(input_string)\n\ndef compute_single_digit_sum(input_string)\n  sum = input_string.chars.map(&:to_i).sum\n  while sum > 9\n    sum = sum.to_s.chars.map(&:to_i).sum\n  end\n  sum\nend\n```\nFix bugs in the given code snippet. The fixed code must be placed between ```ruby```. Do not generate any test, main,example usage or check code!\n"}
{"question_id": "Ruby/37", "category": "Multiple", "subtype": "double_bug", "level": "hard", "example": "# Example:\n# >>> min_tiles_required(4)\n# 4\n# >>> min_tiles_required(5)\n# 8", "docstring": "Calculates the minimum number of square tiles required to completely cover a square room of size n x n.\nThe tiles used must be smaller than n x n and can be of varying sizes.\nThe function takes a single argument, n, which is a positive integer representing the size of the room,\nand returns the minimum number of tiles required.\n", "canonical_solution": "def min_tiles_required(n)\n    # Base case: If the room size is 1, only one tile is needed\n    return 1 if n == 1\n  \n    # If the room size is even, divide it into four equal parts\n    if n.even?\n      return 4 \n    else\n    \n      return (n+3)\n    end\n  end", "buggy_code": "def min_tiles_required(n)\n\ndef tiles_needed(n)\n  \n  return 1 if n == 1\n\n  \n  if n.even?\n    return 4 / 0 \n  else\n    return (n + 3)\n  end\nend\n", "bug_with_line_numbers": "   1 | def min_tiles_required(n)\n   2 | def tiles_needed(n)\n   3 |   return 1 if n == 1\n   4 |   if n.even?\n   5 |     return 4 / 0 \n   6 |   else\n   7 |     return (n + 3)\n   8 |   end\n   9 | end", "fragment_lines": [2, 5], "fragment_content": ["def tiles_needed(n)", "return 4 / 0"], "test": "raise 'Test failed' unless min_tiles_required(4) == 4\nraise 'Test failed' unless min_tiles_required(5) == 8\nraise 'Test failed' unless min_tiles_required(2) == 4\nraise 'Test failed' unless min_tiles_required(10) == 4\nraise 'Test failed' unless min_tiles_required(7) == 10\n  \nputs 'All tests passed!'   ", "instruction": "Observe the following faulty Ruby code\n```ruby\ndef min_tiles_required(n)\n\ndef tiles_needed(n)\n  \n  return 1 if n == 1\n\n  \n  if n.even?\n    return 4 / 0 \n  else\n    return (n + 3)\n  end\nend\n```\nFix bugs in the given code snippet. The fixed code must be placed between ```ruby```. Do not generate any test, main,example usage or check code!\n"}
{"question_id": "Ruby/38", "category": "Syntax", "subtype": "misused ==and=", "level": "easy", "example": "# Example:\n# >>> find_possible_last_digits(200, 40)\n# [\"00\", \"40\", \"80\"]\n# >>> find_possible_last_digits(1992, 95)\n# [\"15\"]", "docstring": "Finds all possible last two digits of a number that, when added to the number 'a',\nmakes it divisible by 'b'. The function takes two arguments, 'a' and 'b', where 'a' is\na positive integer less than 10000, and 'b' is a positive integer between 10 and 100.\nThe function returns an array of strings representing the possible two-digit suffixes.\n", "canonical_solution": "def find_possible_last_digits(a, b)\n    possible_digits = []\n    (0..99).each do |i|\n      suffix = '%02d' % i # Ensures a two-digit format\n      combined_number = (a.to_s + suffix).to_i\n      possible_digits << suffix if combined_number % b == 0\n    end\n    possible_digits\n  end", "buggy_code": "def find_possible_last_digits(a, b)\n\npossible_digits = []\n(0..99).each do |i|\n  suffix = '%02d' % i\n  combined_number = (a.to_s + suffix).to_i\n  possible_digits << suffix if combined_number % b = 0\nend\npossible_digits\nend\n", "bug_with_line_numbers": "   1 | def find_possible_last_digits(a, b)\n   2 | possible_digits = []\n   3 | (0..99).each do |i|\n   4 |   suffix = '%02d' % i\n   5 |   combined_number = (a.to_s + suffix).to_i\n   6 |   possible_digits << suffix if combined_number % b = 0\n   7 | end\n   8 | possible_digits\n   9 | end", "fragment_lines": [6], "fragment_content": ["possible_digits << suffix if combined_number % b = 0"], "test": "raise 'Test failed' unless find_possible_last_digits(200, 40) == [\"00\", \"40\", \"80\"]\nraise 'Test failed' unless find_possible_last_digits(1992, 95) == [\"15\"]\nraise 'Test failed' unless find_possible_last_digits(1500, 25) == [\"00\", \"25\", \"50\", \"75\"]\nraise 'Test failed' unless find_possible_last_digits(300, 30) == [\"00\", \"30\", \"60\", \"90\"]\n  \nputs 'All tests passed!'", "instruction": "Observe the following faulty Ruby code\n```ruby\ndef find_possible_last_digits(a, b)\n\npossible_digits = []\n(0..99).each do |i|\n  suffix = '%02d' % i\n  combined_number = (a.to_s + suffix).to_i\n  possible_digits << suffix if combined_number % b = 0\nend\npossible_digits\nend\n```\nFix bugs in the given code snippet. The fixed code must be placed between ```ruby```. Do not generate any test, main,example usage or check code!\n"}
{"question_id": "Ruby/39", "category": "Syntax", "subtype": "misused ==and=", "level": "easy", "example": "# Example:\n>>> find_longest_palindrome(\"ABBA\")\n4\n>>> find_longest_palindrome(\"12ABBA\")\n4\n>>> find_longest_palindrome(\"A\")\n1\n>>> find_longest_palindrome(\"ABAKK\")\n3\n>>> find_longest_palindrome(\"51233214\")\n6\n>>> find_longest_palindrome(\"abaaab\")\n5", "docstring": "Finds the longest palindrome within a given string.\nThe function takes a single argument, str, which is a string that may include letters, numbers, and symbols.\nIt returns the length of the longest palindrome that can be found within the string.\nPalindromes are sequences that read the same backward as forward.\nNote: The function is case-sensitive and considers each character.\n", "canonical_solution": "def find_longest_palindrome(str)\n    return 0 if str.nil? || str.empty?\n  \n    longest = 0\n  \n    (0...str.length).each do |i|\n      # check for odd length palindromes\n      odd_palindrome = expand_around_center(str, i, i)\n      longest = [longest, odd_palindrome].max\n  \n      # check for even length palindromes\n      even_palindrome = expand_around_center(str, i, i + 1)\n      longest = [longest, even_palindrome].max\n    end\n  \n    longest\n  end\n  \n  def expand_around_center(str, left, right)\n    while left >= 0 && right < str.length && str[left] == str[right]\n      left -= 1\n      right += 1\n    end\n  \n    right - left - 1\n  end", "buggy_code": "def find_longest_palindrome(str)\n\n    return 0 if str.nil? || str.empty?\n  \n    longest = 0\n  \n    (0...str.length).each do |i|\n      \n      odd_palindrome = expand_around_center(str, i, i)\n      longest = [longest, odd_palindrome].max\n  \n      \n      even_palindrome = expand_around_center(str, i, i + 1)\n      longest = [longest, even_palindrome].max\n    end\n  \n    longest\n  end\n  \n  def expand_around_center(str, left, right)\n    while left >= 0 && right < str.length && str[left] = str[right]\n      left -= 1\n      right += 1\n    end\n  \n    right - left - 1\n  end\n", "bug_with_line_numbers": "   1 | def find_longest_palindrome(str)\n   2 |     return 0 if str.nil? || str.empty?\n   3 |     longest = 0\n   4 |     (0...str.length).each do |i|\n   5 |       odd_palindrome = expand_around_center(str, i, i)\n   6 |       longest = [longest, odd_palindrome].max\n   7 |       even_palindrome = expand_around_center(str, i, i + 1)\n   8 |       longest = [longest, even_palindrome].max\n   9 |     end\n  10 |     longest\n  11 |   end\n  12 |   def expand_around_center(str, left, right)\n  13 |     while left >= 0 && right < str.length && str[left] = str[right]\n  14 |       left -= 1\n  15 |       right += 1\n  16 |     end\n  17 |     right - left - 1\n  18 |   end", "fragment_lines": [13], "fragment_content": ["while left >= 0 && right < str.length && str[left] = str[right]"], "test": "raise 'Test failed' unless find_longest_palindrome(\"ABBA\") == 4\nraise 'Test failed' unless find_longest_palindrome(\"12ABBA\") == 4\nraise 'Test failed' unless find_longest_palindrome(\"A\") == 1\nraise 'Test failed' unless find_longest_palindrome(\"ABAKK\") == 3\nraise 'Test failed' unless find_longest_palindrome(\"51233214\") == 6\nraise 'Test failed' unless find_longest_palindrome(\"abaaab\") == 5\n\n\nputs 'All tests passed!'", "instruction": "Observe the following faulty Ruby code\n```ruby\ndef find_longest_palindrome(str)\n\n    return 0 if str.nil? || str.empty?\n  \n    longest = 0\n  \n    (0...str.length).each do |i|\n      \n      odd_palindrome = expand_around_center(str, i, i)\n      longest = [longest, odd_palindrome].max\n  \n      \n      even_palindrome = expand_around_center(str, i, i + 1)\n      longest = [longest, even_palindrome].max\n    end\n  \n    longest\n  end\n  \n  def expand_around_center(str, left, right)\n    while left >= 0 && right < str.length && str[left] = str[right]\n      left -= 1\n      right += 1\n    end\n  \n    right - left - 1\n  end\n```\nFix bugs in the given code snippet. The fixed code must be placed between ```ruby```. Do not generate any test, main,example usage or check code!\n"}
{"question_id": "Ruby/40", "category": "Syntax", "subtype": "misused ==and=", "level": "easy", "example": "# Examples:\n# >>> palindrome_sum_steps(12)\n# 1\n# >>> palindrome_sum_steps(87)\n# 4\n# >>> palindrome_sum_steps(89)\n# 0", "docstring": "This method calculates the minimum number of steps required to transform a given number into a palindrome by repeatedly reversing its digits and adding the result to the original number. The process is stopped when a palindrome is obtained. If the palindrome is not obtained within 8 steps, the method returns 0.\nThe function takes a single argument, m, which is a positive integer between 12 and 100, and returns the number of steps taken to reach a palindrome. The input number m itself is not a palindrome.\n", "canonical_solution": "def palindrome_sum_steps(m)\n  steps = 0\n  until m.to_s == m.to_s.reverse || steps == 8\n    m += m.to_s.reverse.to_i\n    steps += 1\n    return steps if m.to_s == m.to_s.reverse\n  end\n  steps < 8 ? steps : 0\nend", "buggy_code": "def palindrome_sum_steps(m)\n\nsteps = 0\nuntil m.to_s = m.to_s.reverse || steps == 8\n  m += m.to_s.reverse.to_i\n  steps += 1\n  return steps if m.to_s == m.to_s.reverse\nend\nsteps < 8 ? steps : 0\nend\n", "bug_with_line_numbers": "   1 | def palindrome_sum_steps(m)\n   2 | steps = 0\n   3 | until m.to_s = m.to_s.reverse || steps == 8\n   4 |   m += m.to_s.reverse.to_i\n   5 |   steps += 1\n   6 |   return steps if m.to_s == m.to_s.reverse\n   7 | end\n   8 | steps < 8 ? steps : 0\n   9 | end", "fragment_lines": [3], "fragment_content": ["until m.to_s = m.to_s.reverse"], "test": "raise 'Test failed' unless palindrome_sum_steps(12) == 1\nraise 'Test failed' unless palindrome_sum_steps(87) == 4\nraise 'Test failed' unless palindrome_sum_steps(89) == 0\nraise 'Test failed' unless palindrome_sum_steps(56) == 1\nraise 'Test failed' unless palindrome_sum_steps(95) == 3\n\nputs 'All tests passed!'", "instruction": "Observe the following faulty Ruby code\n```ruby\ndef palindrome_sum_steps(m)\n\nsteps = 0\nuntil m.to_s = m.to_s.reverse || steps == 8\n  m += m.to_s.reverse.to_i\n  steps += 1\n  return steps if m.to_s == m.to_s.reverse\nend\nsteps < 8 ? steps : 0\nend\n```\nFix bugs in the given code snippet. The fixed code must be placed between ```ruby```. Do not generate any test, main,example usage or check code!\n"}
{"question_id": "Ruby/41", "category": "Syntax", "subtype": "misused ==and=", "level": "medium", "example": "# Example:\n# >>> min_tiles_required(4)\n# 4\n# >>> min_tiles_required(5)\n# 8", "docstring": "Calculates the minimum number of square tiles required to completely cover a square room of size n x n.\nThe tiles used must be smaller than n x n and can be of varying sizes.\nThe function takes a single argument, n, which is a positive integer representing the size of the room,\nand returns the minimum number of tiles required.\n", "canonical_solution": "def min_tiles_required(n)\n    # Base case: If the room size is 1, only one tile is needed\n    return 1 if n == 1\n  \n    # If the room size is even, divide it into four equal parts\n    if n.even?\n      return 4 \n    else\n    \n      return (n+3)\n    end\n  end", "buggy_code": "def min_tiles_required(n)\n\n\nreturn 1 if n = 1\n\n\nif n.even?\n  return 4 \nelse\n\n  return (n+3)\nend\nend\n", "bug_with_line_numbers": "   1 | def min_tiles_required(n)\n   2 | return 1 if n = 1\n   3 | if n.even?\n   4 |   return 4 \n   5 | else\n   6 |   return (n+3)\n   7 | end\n   8 | end", "fragment_lines": [2], "fragment_content": ["return 1 if n = 1"], "test": "raise 'Test failed' unless min_tiles_required(4) == 4\nraise 'Test failed' unless min_tiles_required(5) == 8\nraise 'Test failed' unless min_tiles_required(2) == 4\nraise 'Test failed' unless min_tiles_required(10) == 4\nraise 'Test failed' unless min_tiles_required(7) == 10\n  \nputs 'All tests passed!'   ", "instruction": "Observe the following faulty Ruby code\n```ruby\ndef min_tiles_required(n)\n\n\nreturn 1 if n = 1\n\n\nif n.even?\n  return 4 \nelse\n\n  return (n+3)\nend\nend\n```\nFix bugs in the given code snippet. The fixed code must be placed between ```ruby```. Do not generate any test, main,example usage or check code!\n"}
{"question_id": "Ruby/42", "category": "Multiple", "subtype": "double_bug", "level": "medium", "example": "# Example:\n# >>> min_tiles_required(4)\n# 4\n# >>> min_tiles_required(5)\n# 8", "docstring": "Calculates the minimum number of square tiles required to completely cover a square room of size n x n.\nThe tiles used must be smaller than n x n and can be of varying sizes.\nThe function takes a single argument, n, which is a positive integer representing the size of the room,\nand returns the minimum number of tiles required.\n", "canonical_solution": "def min_tiles_required(n)\n    # Base case: If the room size is 1, only one tile is needed\n    return 1 if n == 1\n  \n    # If the room size is even, divide it into four equal parts\n    if n.even?\n      return 4 \n    else\n    \n      return (n+3)\n    end\n  end", "buggy_code": "def min_tiles_required(n)\n\n\nreturn 1 if n == 1\n  \n\nif n.even?\n  return 4 \nelse\n    \n  return (n+3\nend\n", "bug_with_line_numbers": "   1 | def min_tiles_required(n)\n   2 | return 1 if n == 1\n   3 | if n.even?\n   4 |   return 4 \n   5 | else\n   6 |   return (n+3\n   7 | end", "fragment_lines": [6, -1], "fragment_content": ["return (n+3", "missing critical code snippet"], "test": "raise 'Test failed' unless min_tiles_required(4) == 4\nraise 'Test failed' unless min_tiles_required(5) == 8\nraise 'Test failed' unless min_tiles_required(2) == 4\nraise 'Test failed' unless min_tiles_required(10) == 4\nraise 'Test failed' unless min_tiles_required(7) == 10\n  \nputs 'All tests passed!'   ", "instruction": "Observe the following faulty Ruby code\n```ruby\ndef min_tiles_required(n)\n\n\nreturn 1 if n == 1\n  \n\nif n.even?\n  return 4 \nelse\n    \n  return (n+3\nend\n```\nFix bugs in the given code snippet. The fixed code must be placed between ```ruby```. Do not generate any test, main,example usage or check code!\n"}
{"question_id": "Ruby/43", "category": "Syntax", "subtype": "unclosed_parentheses", "level": "easy", "example": "# Example:\n# >>> count_chars_in_title(\"234\")\n# 3\n# >>> count_chars_in_title(\"Ca 45\")\n# 4\n# >>> count_chars_in_title(\"Hello World\\n\")\n# 10", "docstring": "Counts the number of characters in a given title, excluding spaces and newline characters.\n The function takes a single argument, title, which is a string representing the title of an essay.\n It returns the count of characters in the title, excluding any spaces and newline characters.\n", "canonical_solution": "def count_chars_in_title(title)\n    title.count(\"^ \\n\")\n  end", "buggy_code": "def count_chars_in_title(title)\n\n    title.count(\"^ \\n\"\n  end\n", "bug_with_line_numbers": "   1 | def count_chars_in_title(title)\n   2 |     title.count(\"^ \\n\"\n   3 |   end", "fragment_lines": [2], "fragment_content": ["title.count(\"^ \\n\""], "test": "raise 'Test failed' unless count_chars_in_title(\"234\") == 3\nraise 'Test failed' unless count_chars_in_title(\"Ca 45\") == 4\nraise 'Test failed' unless count_chars_in_title(\"Hello World\\n\") == 10\nraise 'Test failed' unless count_chars_in_title(\"Ruby Programming 101 \") == 18\nraise 'Test failed' unless count_chars_in_title(\"\\nNew Line\\n\") == 7", "instruction": "Observe the following faulty Ruby code\n```ruby\ndef count_chars_in_title(title)\n\n    title.count(\"^ \\n\"\n  end\n```\nFix bugs in the given code snippet. The fixed code must be placed between ```ruby```. Do not generate any test, main,example usage or check code!\n"}
{"question_id": "Ruby/44", "category": "Syntax", "subtype": "unclosed_parentheses", "level": "easy", "example": "# Example:\n# >>> count_seven_related_numbers(20)\n# 3\n# >>> count_seven_related_numbers(15)\n# 2", "docstring": "Counts the number of numbers less than or equal to n that are either multiples of 7 or contain the digit '7'.\nThe function takes a single argument, n, which is a positive integer, and returns the count of numbers\nthat are related to 7 as per the criteria.\n", "canonical_solution": "def count_seven_related_numbers(n)\n    count = 0\n    (1..n).each do |num|\n      count += 1 if num % 7 == 0 || num.to_s.include?('7')\n    end\n    count\n  end", "buggy_code": "def count_seven_related_numbers(n)\n\n    count = 0\n    (1..n).each do |num|\n      count += 1 if num % 7 == 0 || num.to_s.include?('7'))\n    end\n    count\n  end\n", "bug_with_line_numbers": "   1 | def count_seven_related_numbers(n)\n   2 |     count = 0\n   3 |     (1..n).each do |num|\n   4 |       count += 1 if num % 7 == 0 || num.to_s.include?('7'))\n   5 |     end\n   6 |     count\n   7 |   end", "fragment_lines": [4], "fragment_content": ["count += 1 if num % 7 == 0"], "test": "raise 'Test failed' unless count_seven_related_numbers(20) == 3\nraise 'Test failed' unless count_seven_related_numbers(15) == 2\nraise 'Test failed' unless count_seven_related_numbers(50) == 11\nraise 'Test failed' unless count_seven_related_numbers(28) == 6\nraise 'Test failed' unless count_seven_related_numbers(100) == 30\n  \n\nputs 'All tests passed!'", "instruction": "Observe the following faulty Ruby code\n```ruby\ndef count_seven_related_numbers(n)\n\n    count = 0\n    (1..n).each do |num|\n      count += 1 if num % 7 == 0 || num.to_s.include?('7'))\n    end\n    count\n  end\n```\nFix bugs in the given code snippet. The fixed code must be placed between ```ruby```. Do not generate any test, main,example usage or check code!\n"}
{"question_id": "Ruby/45", "category": "Syntax", "subtype": "unclosed_parentheses", "level": "easy", "example": "# Example:\n>>> find_possible_last_digits(200, 40)\n[\"00\", \"40\", \"80\"]\n>>> find_possible_last_digits(1992, 95)\n[\"15\"]", "docstring": "Finds all possible last two digits of a number that, when added to the number 'a',\nmakes it divisible by 'b'. The function takes two arguments, 'a' and 'b', where 'a' is\na positive integer less than 10000, and 'b' is a positive integer between 10 and 100.\nThe function returns an array of strings representing the possible two-digit suffixes.\n", "canonical_solution": "def find_possible_last_digits(a, b)\n    possible_digits = []\n    (0..99).each do |i|\n      suffix = '%02d' % i # Ensures a two-digit format\n      combined_number = (a.to_s + suffix).to_i\n      possible_digits << suffix if combined_number % b == 0\n    end\n    possible_digits\n  end", "buggy_code": "def find_possible_last_digits(a, b)\n\npossible_digits = []\n(0..99.each do |i|\n  suffix = '%02d' % i \n  combined_number = (a.to_s + suffix).to_i\n  possible_digits << suffix if combined_number % b == 0\nend\npossible_digits\nend\n", "bug_with_line_numbers": "   1 | def find_possible_last_digits(a, b)\n   2 | possible_digits = []\n   3 | (0..99.each do |i|\n   4 |   suffix = '%02d' % i \n   5 |   combined_number = (a.to_s + suffix).to_i\n   6 |   possible_digits << suffix if combined_number % b == 0\n   7 | end\n   8 | possible_digits\n   9 | end", "fragment_lines": [3], "fragment_content": ["(0..99.each do"], "test": "raise 'Test failed' unless find_possible_last_digits(200, 40) == [\"00\", \"40\", \"80\"]\nraise 'Test failed' unless find_possible_last_digits(1992, 95) == [\"15\"]\nraise 'Test failed' unless find_possible_last_digits(1500, 25) == [\"00\", \"25\", \"50\", \"75\"]\nraise 'Test failed' unless find_possible_last_digits(300, 30) == [\"00\", \"30\", \"60\", \"90\"]\n  \nputs 'All tests passed!'", "instruction": "Observe the following faulty Ruby code\n```ruby\ndef find_possible_last_digits(a, b)\n\npossible_digits = []\n(0..99.each do |i|\n  suffix = '%02d' % i \n  combined_number = (a.to_s + suffix).to_i\n  possible_digits << suffix if combined_number % b == 0\nend\npossible_digits\nend\n```\nFix bugs in the given code snippet. The fixed code must be placed between ```ruby```. Do not generate any test, main,example usage or check code!\n"}
{"question_id": "Ruby/46", "category": "Multiple", "subtype": "double_bug", "level": "easy", "example": "# Example:\n# >>> max_sum_divisible_by_k([1, 2, 3, 4], 3)\n# 9\n# >>> max_sum_divisible_by_k([4, 5, 10, 20], 5)\n# 35", "docstring": "Finds the maximum sum of any three numbers from a given array that is divisible by a specified number k.\nThis function takes an array of numbers and an integer k as arguments. It returns the maximum sum\nof any three numbers from the array such that this sum is divisible by k. It's guaranteed that there\nare at least three numbers in the array and that a solution exists.\n", "canonical_solution": "def max_sum_divisible_by_k(numbers, k)\n    numbers.sort!.reverse!\n    max_sum = 0\n  \n    (0..numbers.length - 3).each do |i|\n      (i+1..numbers.length - 2).each do |j|\n        (j+1..numbers.length - 1).each do |l|\n          sum = numbers[i] + numbers[j] + numbers[l]\n          if sum % k == 0 && sum > max_sum\n            max_sum = sum\n          end\n        end\n      end\n    end\n    # puts max_sum\n    max_sum\n  end", "buggy_code": "def max_sum_divisible_by_k(numbers, k)\n\nnumbers.sort!.reverse!\nmax_sum = 0\n\n(0..numbers.length - 3).each do |i|\n  (i+1..numbers.length - 2).each do |j|\n    (j+1..numbers.length - 1).each do |l|\n      sum = numbers[i] + numbers[j] + numbers[l]\n      if (sum % k == 0 && sum > max_sum\n        max_sum = sum\n      end\n    end\n  end\nend\n\nmax_sum\n", "bug_with_line_numbers": "   1 | def max_sum_divisible_by_k(numbers, k)\n   2 | numbers.sort!.reverse!\n   3 | max_sum = 0\n   4 | (0..numbers.length - 3).each do |i|\n   5 |   (i+1..numbers.length - 2).each do |j|\n   6 |     (j+1..numbers.length - 1).each do |l|\n   7 |       sum = numbers[i] + numbers[j] + numbers[l]\n   8 |       if (sum % k == 0 && sum > max_sum\n   9 |         max_sum = sum\n  10 |       end\n  11 |     end\n  12 |   end\n  13 | end\n  14 | max_sum", "fragment_lines": [8, -1], "fragment_content": ["if (sum % k == 0 && sum > max_sum", "missing critical code snippet"], "test": "raise 'Test failed' unless max_sum_divisible_by_k([1, 2, 3, 4], 3) == 9\nraise 'Test failed' unless max_sum_divisible_by_k([4, 5, 10, 20], 5) == 35\nraise 'Test failed' unless max_sum_divisible_by_k([6, 12, 17, 23, 29], 7) == 35\nraise 'Test failed' unless max_sum_divisible_by_k([7, 14, 21, 28], 7) == 63\nraise 'Test failed' unless max_sum_divisible_by_k([10, 15, 25, 30, 40], 10) == 80\n\n\nputs 'All tests passed!'", "instruction": "Observe the following faulty Ruby code\n```ruby\ndef max_sum_divisible_by_k(numbers, k)\n\nnumbers.sort!.reverse!\nmax_sum = 0\n\n(0..numbers.length - 3).each do |i|\n  (i+1..numbers.length - 2).each do |j|\n    (j+1..numbers.length - 1).each do |l|\n      sum = numbers[i] + numbers[j] + numbers[l]\n      if (sum % k == 0 && sum > max_sum\n        max_sum = sum\n      end\n    end\n  end\nend\n\nmax_sum\n```\nFix bugs in the given code snippet. The fixed code must be placed between ```ruby```. Do not generate any test, main,example usage or check code!\n"}
{"question_id": "Ruby/47", "category": "Multiple", "subtype": "double_bug", "level": "medium", "example": "Examples:\n>>> convert_score_to_grade(56)\n'E'\n>>> convert_score_to_grade(100)\n'A'\n>>> convert_score_to_grade(123)\n'Score is error!'", "docstring": "Converts a numerical score into a corresponding letter grade based on predefined ranges.\nThe function takes a single argument, score, which is an integer representing the score.\nIt returns a string representing the letter grade, or an error message for invalid scores.\n\nGrade Conversion:\n90-100: 'A'\n80-89: 'B'\n70-79: 'C'\n60-69: 'D'\n0-59: 'E'\nAny other score: 'Score is error!'\n\n", "canonical_solution": "def convert_score_to_grade(score)\n    return 'Score is error!' if score < 0 || score > 100\n  \n    case score\n    when 90..100\n      'A'\n    when 80...90\n      'B'\n    when 70...80\n      'C'\n    when 60...70\n      'D'\n    when 0...60\n      'E'\n    else\n      'Score is error!'\n    end\n  end", "buggy_code": "def convert_score_to_grade(score)\n\ndef grade(score)\n  return 'Score is error!' if scores < 0 || scores > 100\n  \n  case score\n  when 90..100\n    'A'\n  when 80...90\n    'B'\n  when 70...80\n    'C'\n  when 60...70\n    'D'\n  when 0...60\n    'E'\n  else\n    'Score is error!'\n  end\nend\n", "bug_with_line_numbers": "   1 | def convert_score_to_grade(score)\n   2 | def grade(score)\n   3 |   return 'Score is error!' if scores < 0 || scores > 100\n   4 |   case score\n   5 |   when 90..100\n   6 |     'A'\n   7 |   when 80...90\n   8 |     'B'\n   9 |   when 70...80\n  10 |     'C'\n  11 |   when 60...70\n  12 |     'D'\n  13 |   when 0...60\n  14 |     'E'\n  15 |   else\n  16 |     'Score is error!'\n  17 |   end\n  18 | end", "fragment_lines": [2, 3], "fragment_content": ["def grade(score)", "return 'Score is error!' if scores < 0"], "test": "raise 'Test failed' unless convert_score_to_grade(56) == 'E'\nraise 'Test failed' unless convert_score_to_grade(67) == 'D'\nraise 'Test failed' unless convert_score_to_grade(100) == 'A'\nraise 'Test failed' unless convert_score_to_grade(123) == 'Score is error!'\nraise 'Test failed' unless convert_score_to_grade(-5) == 'Score is error!'\nraise 'Test failed' unless convert_score_to_grade(85) == 'B'\n  \n\nputs 'All tests passed!'", "instruction": "Observe the following faulty Ruby code\n```ruby\ndef convert_score_to_grade(score)\n\ndef grade(score)\n  return 'Score is error!' if scores < 0 || scores > 100\n  \n  case score\n  when 90..100\n    'A'\n  when 80...90\n    'B'\n  when 70...80\n    'C'\n  when 60...70\n    'D'\n  when 0...60\n    'E'\n  else\n    'Score is error!'\n  end\nend\n```\nFix bugs in the given code snippet. The fixed code must be placed between ```ruby```. Do not generate any test, main,example usage or check code!\n"}
{"question_id": "Ruby/48", "category": "Multiple", "subtype": "double_bug", "level": "medium", "example": "# Examples:\n# >>> insert_max_after_largest_letters(\"abcdefgfedcba\")\n# \"abcdefg(max)fedcba\"\n# >>> insert_max_after_largest_letters(\"aAbBcC\")\n# \"aAbBc(max)C(max)\"", "docstring": "Finds the largest letter(s) in the input string (considering 'A' and 'a' as the same letter) and inserts \"(max)\" after each of its occurrences.\nThe function takes one argument, input_string, which is a string of letters and possibly digits.\nReturns a new string with \"(max)\" inserted after each occurrence of the largest letter(s).\n", "canonical_solution": "def insert_max_after_largest_letters(input_string)\n    # Normalize the string to lowercase for comparison\n    normalized_string = input_string.downcase\n  \n    # Find the largest letter\n    largest_letter = normalized_string.chars.max\n  \n    # Insert '(max)' after each occurrence of the largest letter\n    result = ''\n    input_string.each_char do |char|\n      result += char\n      result += '(max)' if char.downcase == largest_letter\n    end\n  \n    result\n  end", "buggy_code": "def insert_max_after_largest_letters(input_string)\n\ndef append_max_to_largest_letter(input_string)\n  \n  normalized_string = inpurt_string.downcase\n  \n  \n  largest_letter = normalized_string.chars.max\n  \n  \n  result = ''\n  input_string.each_char do |char|\n    result += char\n    result += '(max)' if char.downcase == largest_letter\n  end\n\n  result\nend\n", "bug_with_line_numbers": "   1 | def insert_max_after_largest_letters(input_string)\n   2 | def append_max_to_largest_letter(input_string)\n   3 |   normalized_string = inpurt_string.downcase\n   4 |   largest_letter = normalized_string.chars.max\n   5 |   result = ''\n   6 |   input_string.each_char do |char|\n   7 |     result += char\n   8 |     result += '(max)' if char.downcase == largest_letter\n   9 |   end\n  10 |   result\n  11 | end", "fragment_lines": [2, 3], "fragment_content": ["def append_max_to_largest_letter(input_string)", "normalized_string = inpurt_string.downcase"], "test": "raise 'Test failed' unless insert_max_after_largest_letters(\"abcdefgfedcba\") == \"abcdefg(max)fedcba\"\nraise 'Test failed' unless insert_max_after_largest_letters(\"xxxxx\") == \"x(max)x(max)x(max)x(max)x(max)\"\nraise 'Test failed' unless insert_max_after_largest_letters(\"Hello World!\") == \"Hello W(max)orld!\"\nraise 'Test failed' unless insert_max_after_largest_letters(\"Ruby123\") == \"Ruby(max)123\"\nraise 'Test failed' unless insert_max_after_largest_letters(\"\") == \"\"\nraise 'Test failed' unless insert_max_after_largest_letters(\"aAbBcC\") == \"aAbBc(max)C(max)\"\n  \n\nputs 'All tests passed!'", "instruction": "Observe the following faulty Ruby code\n```ruby\ndef insert_max_after_largest_letters(input_string)\n\ndef append_max_to_largest_letter(input_string)\n  \n  normalized_string = inpurt_string.downcase\n  \n  \n  largest_letter = normalized_string.chars.max\n  \n  \n  result = ''\n  input_string.each_char do |char|\n    result += char\n    result += '(max)' if char.downcase == largest_letter\n  end\n\n  result\nend\n```\nFix bugs in the given code snippet. The fixed code must be placed between ```ruby```. Do not generate any test, main,example usage or check code!\n"}
{"question_id": "Ruby/49", "category": "Multiple", "subtype": "double_bug", "level": "easy", "example": "# Example:\n# >>> find_longest_word(\"I am a student\")\n# \"student\"\n# >>> find_longest_word(\"The quick brown fox\")\n# \"quick\"", "docstring": "Finds the longest word in a given sentence.\nThe function takes a single argument, sentence, which is a string containing multiple words separated by spaces.\nEach word is composed only of lowercase letters. The function returns the longest word found in the sentence.\nIf there are multiple words of the same longest length, it returns the first one encountered.\n", "canonical_solution": "def find_longest_word(sentence)\n  words = sentence.split(' ')\n  longest_word = words.max_by(&:length)\n  longest_word\nend", "buggy_code": "def find_longest_word(sentence)\n\ndef find_longest_word(sentence)\n  words = sentence.split(' ')\n  longest_word = wordlist.max_by(&:length)\n  longest_word\nend\n", "bug_with_line_numbers": "   1 | def find_longest_word(sentence)\n   2 | def find_longest_word(sentence)\n   3 |   words = sentence.split(' ')\n   4 |   longest_word = wordlist.max_by(&:length)\n   5 |   longest_word\n   6 | end", "fragment_lines": [2, 4], "fragment_content": ["def find_longest_word(sentence)", "longest_word = wordlist.max_by(&:length)"], "test": "raise 'Test failed' unless find_longest_word(\"I am a student\") == \"student\"\nraise 'Test failed' unless find_longest_word(\"The quick brown fox jumps over the lazy dog\") == \"quick\"\nraise 'Test failed' unless find_longest_word(\"Hello world\") == \"Hello\"\nraise 'Test failed' unless find_longest_word(\"A B C D EFG HI\") == \"EFG\"\nraise 'Test failed' unless find_longest_word(\"Ruby Python Java\") == \"Python\"", "instruction": "Observe the following faulty Ruby code\n```ruby\ndef find_longest_word(sentence)\n\ndef find_longest_word(sentence)\n  words = sentence.split(' ')\n  longest_word = wordlist.max_by(&:length)\n  longest_word\nend\n```\nFix bugs in the given code snippet. The fixed code must be placed between ```ruby```. Do not generate any test, main,example usage or check code!\n"}
{"question_id": "Ruby/50", "category": "Logic", "subtype": "variable_error", "level": "easy", "example": "# Example:\n# >>> victory_gap_in_teams(\"abaabcaa\")\n# 4\n# >>> victory_gap_in_teams(\"abcd\")\n# 0", "docstring": "Calculates the difference in the number of victories between the most and least successful teams.\nThis function takes a string, team_sequence, representing the sequence of winning teams, where each team\nis identified by a lowercase letter. It returns an integer representing the difference in the number\nof victories between the team that won the most and the team that won the least (excluding teams with zero victories).\n", "canonical_solution": "def victory_gap_in_teams(team_sequence)\n    counts = Hash.new(0)\n    team_sequence.each_char { |team| counts[team] += 1 }\n  \n    max_victories = counts.values.max\n    min_victories = counts.values.reject { |v| v == 0 }.min\n  \n    max_victories - min_victories\n  end", "buggy_code": "def victory_gap_in_teams(team_sequence)\n\ncounts = Hash.new(0)\nteam_sequence.each_char { |team| counts[team_name] += 1 }\n\nmax_victories = counts.values.max\nmin_victories = counts.values.reject { |v| v == 0 }.min\n\nmax_victories - min_victories\nend\n", "bug_with_line_numbers": "   1 | def victory_gap_in_teams(team_sequence)\n   2 | counts = Hash.new(0)\n   3 | team_sequence.each_char { |team| counts[team_name] += 1 }\n   4 | max_victories = counts.values.max\n   5 | min_victories = counts.values.reject { |v| v == 0 }.min\n   6 | max_victories - min_victories\n   7 | end", "fragment_lines": [3], "fragment_content": ["team_sequence.each_char {"], "test": "raise 'Test failed' unless victory_gap_in_teams(\"abaabcaa\") == 4\nraise 'Test failed' unless victory_gap_in_teams(\"abcd\") == 0\nraise 'Test failed' unless victory_gap_in_teams(\"a\") == 0\nraise 'Test failed' unless victory_gap_in_teams(\"aaabbbccc\") == 0\nraise 'Test failed' unless victory_gap_in_teams(\"abcdaaa\") == 3\n\nputs 'All tests passed!'", "instruction": "Observe the following faulty Ruby code\n```ruby\ndef victory_gap_in_teams(team_sequence)\n\ncounts = Hash.new(0)\nteam_sequence.each_char { |team| counts[team_name] += 1 }\n\nmax_victories = counts.values.max\nmin_victories = counts.values.reject { |v| v == 0 }.min\n\nmax_victories - min_victories\nend\n```\nFix bugs in the given code snippet. The fixed code must be placed between ```ruby```. Do not generate any test, main,example usage or check code!\n"}
{"question_id": "Ruby/51", "category": "Logic", "subtype": "variable_error", "level": "easy", "example": "# Example:\n# >>> find_missing_and_duplicate_ids([[5, 6, 8, 11, 9], [10, 12, 9]])\n# [7, 9]\n# >>> find_missing_and_duplicate_ids([[1, 2, 4], [3, 5, 5]])\n# [6, 5]", "docstring": "Finds the missing (broken) and duplicate ID in a sequence of ticket IDs.\n The function takes a nested array (array of arrays) where each sub-array\n contains ticket IDs for a particular batch. It returns an array with two elements:\n the first is the missing ID, and the second is the duplicate ID.\n", "canonical_solution": "def find_missing_and_duplicate_ids(ids)\n    all_ids = ids.flatten.sort\n    missing_id = nil\n    duplicate_id = nil\n    expected_sum = (all_ids.first..all_ids.last).sum\n    actual_sum = all_ids.sum\n  \n    all_ids.each_with_index do |id, index|\n      if index > 0 && id == all_ids[index - 1]\n        duplicate_id = id\n      end\n    end\n  \n    missing_id = expected_sum - actual_sum + duplicate_id\n    [missing_id, duplicate_id]\n  end", "buggy_code": "def find_missing_and_duplicate_ids(ids)\n\ndef find_ids_with_errors(ids)\n    all_id = ids.flatten.sort\n    missing_id = nil\n    duplicate_id = nil\n    expected_sum = (all_id.first..all_id.last).sum\n    actual_sum = all_id.sum\n  \n    all_id.each_with_index do |id, index|\n      if index > 0 && id == all_id[index - 1]\n        duplicate_id = id\n      end\n    end\n  \n    missing_id = expected_sum - actual_sum + duplicate_id\n    [missing_id, duplicate_id]\nend\n", "bug_with_line_numbers": "   1 | def find_missing_and_duplicate_ids(ids)\n   2 | def find_ids_with_errors(ids)\n   3 |     all_id = ids.flatten.sort\n   4 |     missing_id = nil\n   5 |     duplicate_id = nil\n   6 |     expected_sum = (all_id.first..all_id.last).sum\n   7 |     actual_sum = all_id.sum\n   8 |     all_id.each_with_index do |id, index|\n   9 |       if index > 0 && id == all_id[index - 1]\n  10 |         duplicate_id = id\n  11 |       end\n  12 |     end\n  13 |     missing_id = expected_sum - actual_sum + duplicate_id\n  14 |     [missing_id, duplicate_id]\n  15 | end", "fragment_lines": [2], "fragment_content": ["def find_ids_with_errors(ids)"], "test": "raise 'Test failed' unless find_missing_and_duplicate_ids([[5, 6, 8, 11, 9], [10, 12, 9]]) == [7, 9]\nraise 'Test failed' unless find_missing_and_duplicate_ids([[1, 2, 4], [3, 5, 5, 7]]) == [6, 5]\nraise 'Test failed' unless find_missing_and_duplicate_ids([[20, 21, 23], [22, 24, 24, 26]]) == [25, 24]\nraise 'Test failed' unless find_missing_and_duplicate_ids([[100, 102, 106], [101, 103, 103, 105]]) == [104, 103]", "instruction": "Observe the following faulty Ruby code\n```ruby\ndef find_missing_and_duplicate_ids(ids)\n\ndef find_ids_with_errors(ids)\n    all_id = ids.flatten.sort\n    missing_id = nil\n    duplicate_id = nil\n    expected_sum = (all_id.first..all_id.last).sum\n    actual_sum = all_id.sum\n  \n    all_id.each_with_index do |id, index|\n      if index > 0 && id == all_id[index - 1]\n        duplicate_id = id\n      end\n    end\n  \n    missing_id = expected_sum - actual_sum + duplicate_id\n    [missing_id, duplicate_id]\nend\n```\nFix bugs in the given code snippet. The fixed code must be placed between ```ruby```. Do not generate any test, main,example usage or check code!\n"}
{"question_id": "Ruby/52", "category": "Logic", "subtype": "variable_error", "level": "easy", "example": "# Example:\n# >>> count_prime_pairs(10)\n# 2 (since 10 can be expressed as 3+7 and 5+5)\n# >>> count_prime_pairs(14)\n# 2 (since 14 can be expressed as 3+11 and 7+7)", "docstring": "This function calculates the number of different prime pairs whose sum equals a given even number.\nThe function accepts a single argument, even_number, which is an even number greater than 6 and less than 32767.\nIt returns the count of distinct prime pairs whose sum equals the given even number.\nA prime pair is considered distinct if the primes in the pair are different, regardless of their order.\n", "canonical_solution": "def count_prime_pairs(even_number)\n    # Helper function to check if a number is prime\n    def is_prime?(num)\n      return false if num <= 1\n      (2...num).none? { |i| num % i == 0 }\n    end\n  \n    # Generating a list of primes up to even_number\n    primes = (2...even_number).select { |num| is_prime?(num) }\n  \n    # Counting distinct prime pairs\n    count = 0\n    primes.each_with_index do |prime, index|\n      count += 1 if primes[index..-1].any? { |other_prime| prime + other_prime == even_number }\n    end\n  \n    count\n  end\n", "buggy_code": "def count_prime_pairs(even_number)\n\n\ndef is_prime?(num)\n  return false if num <= 1\n  (2...num).none? { |i| num % i == 0 }\nend\n\n\nprimes = (2...even_number).select { |num| is_prime?(num) }\n\n\ncount = 0\npries.each_with_index do |prime, index|\n  count += 1 if primes[index..-1].any? { |other_prime| prime + other_prime == even_number }\nend\n\ncount\nend\n", "bug_with_line_numbers": "   1 | def count_prime_pairs(even_number)\n   2 | def is_prime?(num)\n   3 |   return false if num <= 1\n   4 |   (2...num).none? { |i| num % i == 0 }\n   5 | end\n   6 | primes = (2...even_number).select { |num| is_prime?(num) }\n   7 | count = 0\n   8 | pries.each_with_index do |prime, index|\n   9 |   count += 1 if primes[index..-1].any? { |other_prime| prime + other_prime == even_number }\n  10 | end\n  11 | count\n  12 | end", "fragment_lines": [8], "fragment_content": ["pries.each_with_index do"], "test": "raise 'Test failed' unless count_prime_pairs(10) == 2\nraise 'Test failed' unless count_prime_pairs(14) == 2\nraise 'Test failed' unless count_prime_pairs(20) == 2\nraise 'Test failed' unless count_prime_pairs(26) == 3\nraise 'Test failed' unless count_prime_pairs(100) == 6\nraise 'Test failed' unless count_prime_pairs(1234) == 25\n\n\nputs 'All tests passed!'", "instruction": "Observe the following faulty Ruby code\n```ruby\ndef count_prime_pairs(even_number)\n\n\ndef is_prime?(num)\n  return false if num <= 1\n  (2...num).none? { |i| num % i == 0 }\nend\n\n\nprimes = (2...even_number).select { |num| is_prime?(num) }\n\n\ncount = 0\npries.each_with_index do |prime, index|\n  count += 1 if primes[index..-1].any? { |other_prime| prime + other_prime == even_number }\nend\n\ncount\nend\n```\nFix bugs in the given code snippet. The fixed code must be placed between ```ruby```. Do not generate any test, main,example usage or check code!\n"}
{"question_id": "Ruby/53", "category": "Reference", "subtype": "faulty_indexing", "level": "hard", "example": "# Examples:\n# >>> max_product_partition(6, 3)\n# [2, 2, 2]\n# >>> max_product_partition(8, 3)\n# [2, 3, 3]", "docstring": "Finds M positive integers whose sum is N, such that their product is maximized.\n The function returns an array of these integers in lexicographically smallest order.\n\n Args:\n   n: A positive integer representing the sum of the integers to find.\n   m: A positive integer representing the number of integers to find.\n\n Returns:\n   An array of integers that are the lexicographically smallest set of integers\n   whose sum is N and whose product is maximized.\n", "canonical_solution": "def max_product_partition(n, m)\n    # The base number each part should be at least.\n    base = n / m\n    \n    # The remainder when N is not perfectly divisible by M, \n    # indicating how many numbers should be base + 1\n    remainder = n % m\n    \n    # Initialize the result array with base values\n    result = [base] * (m - remainder)\n    \n    # Add the necessary numbers to make the sum equal to N\n    result += [base + 1] * remainder\n    \n    result\n  end", "buggy_code": "def max_product_partition(n, m)\n\ndef distribute_numbers(n, m)\n  base = n / m\n  remainder = n % m\n  result = [base] * (m - remainder)\n  result += [base + 1] * (remainder + 1)  \n  result\nend\n", "bug_with_line_numbers": "   1 | def max_product_partition(n, m)\n   2 | def distribute_numbers(n, m)\n   3 |   base = n / m\n   4 |   remainder = n % m\n   5 |   result = [base] * (m - remainder)\n   6 |   result += [base + 1] * (remainder + 1)  \n   7 |   result\n   8 | end", "fragment_lines": [6], "fragment_content": ["result += [base + 1] * (remainder + 1)"], "test": "raise 'Test failed' unless max_product_partition(6, 3) == [2, 2, 2]\nraise 'Test failed' unless max_product_partition(8, 3) == [2, 3, 3]\nraise 'Test failed' unless max_product_partition(10, 2) == [5, 5]\nraise 'Test failed' unless max_product_partition(7, 3) == [2, 2, 3]\nraise 'Test failed' unless max_product_partition(20, 5) == [4, 4, 4, 4, 4]", "instruction": "Observe the following faulty Ruby code\n```ruby\ndef max_product_partition(n, m)\n\ndef distribute_numbers(n, m)\n  base = n / m\n  remainder = n % m\n  result = [base] * (m - remainder)\n  result += [base + 1] * (remainder + 1)  \n  result\nend\n```\nFix bugs in the given code snippet. The fixed code must be placed between ```ruby```. Do not generate any test, main,example usage or check code!\n"}
{"question_id": "Ruby/54", "category": "Reference", "subtype": "faulty_indexing", "level": "easy", "example": "# Example:\n# >>> find_longest_palindrome(\"ABBA\")\n# 4\n# >>> find_longest_palindrome(\"12ABBA\")\n# 4\n# >>> find_longest_palindrome(\"A\")\n# 1\n# >>> find_longest_palindrome(\"ABAKK\")\n# 3\n# >>> find_longest_palindrome(\"51233214\")\n# 6\n# >>> find_longest_palindrome(\"abaaab\")\n# 5", "docstring": "Finds the longest palindrome within a given string.\nThe function takes a single argument, str, which is a string that may include letters, numbers, and symbols.\nIt returns the length of the longest palindrome that can be found within the string.\nPalindromes are sequences that read the same backward as forward.\nNote: The function is case-sensitive and considers each character.\n", "canonical_solution": "def find_longest_palindrome(str)\n    return 0 if str.nil? || str.empty?\n  \n    longest = 0\n  \n    (0...str.length).each do |i|\n      # check for odd length palindromes\n      odd_palindrome = expand_around_center(str, i, i)\n      longest = [longest, odd_palindrome].max\n  \n      # check for even length palindromes\n      even_palindrome = expand_around_center(str, i, i + 1)\n      longest = [longest, even_palindrome].max\n    end\n  \n    longest\n  end\n  \n  def expand_around_center(str, left, right)\n    while left >= 0 && right < str.length && str[left] == str[right]\n      left -= 1\n      right += 1\n    end\n  \n    right - left - 1\n  end", "buggy_code": "def find_longest_palindrome(str)\nreturn 0 if str.nil? || str.empty?\n\nlongest = 0\n\n(0...str.length).each do |i|\n  \n  odd_palindrome = expand_around_center(str, i, i)\n  longest = [longest, odd_palindrome].max\n\n  \n  even_palindrome = expand_around_center(str, i + 1, i + 2) \n  longest = [longest, even_palindrome].max\nend\n\nlongest\nend\n\ndef expand_around_center(str, left, right)\n  while left >= 0 && right < str.length && str[left] == str[right]\n    left -= 1\n    right += 1\n  end\n\n  right - left - 1\nend\n", "bug_with_line_numbers": "   1 | def find_longest_palindrome(str)\n   2 | return 0 if str.nil? || str.empty?\n   3 | longest = 0\n   4 | (0...str.length).each do |i|\n   5 |   odd_palindrome = expand_around_center(str, i, i)\n   6 |   longest = [longest, odd_palindrome].max\n   7 |   even_palindrome = expand_around_center(str, i + 1, i + 2) \n   8 |   longest = [longest, even_palindrome].max\n   9 | end\n  10 | longest\n  11 | end\n  12 | def expand_around_center(str, left, right)\n  13 |   while left >= 0 && right < str.length && str[left] == str[right]\n  14 |     left -= 1\n  15 |     right += 1\n  16 |   end\n  17 |   right - left - 1\n  18 | end", "fragment_lines": [7], "fragment_content": ["even_palindrome = expand_around_center(str, i + 1, i + 2)"], "test": "raise 'Test failed' unless find_longest_palindrome(\"ABBA\") == 4\nraise 'Test failed' unless find_longest_palindrome(\"12ABBA\") == 4\nraise 'Test failed' unless find_longest_palindrome(\"A\") == 1\nraise 'Test failed' unless find_longest_palindrome(\"ABAKK\") == 3\nraise 'Test failed' unless find_longest_palindrome(\"51233214\") == 6\nraise 'Test failed' unless find_longest_palindrome(\"abaaab\") == 5\n\n\nputs 'All tests passed!'", "instruction": "Observe the following faulty Ruby code\n```ruby\ndef find_longest_palindrome(str)\nreturn 0 if str.nil? || str.empty?\n\nlongest = 0\n\n(0...str.length).each do |i|\n  \n  odd_palindrome = expand_around_center(str, i, i)\n  longest = [longest, odd_palindrome].max\n\n  \n  even_palindrome = expand_around_center(str, i + 1, i + 2) \n  longest = [longest, even_palindrome].max\nend\n\nlongest\nend\n\ndef expand_around_center(str, left, right)\n  while left >= 0 && right < str.length && str[left] == str[right]\n    left -= 1\n    right += 1\n  end\n\n  right - left - 1\nend\n```\nFix bugs in the given code snippet. The fixed code must be placed between ```ruby```. Do not generate any test, main,example usage or check code!\n"}
{"question_id": "Ruby/55", "category": "Reference", "subtype": "faulty_indexing", "level": "easy", "example": "# Example:\n# >>> find_max_with_index([3, 2, 1])\n# [3, 0]\n# >>> find_max_with_index([10, 20, 30, 40])\n# [40, 3]", "docstring": "Finds the maximum value in an array and returns its value along with its index.\nThe function takes a single argument, arr, which is an array of integers. The array size should be between 1 and 100.\nIt returns an array containing the maximum value and its index in the format [max_value, index].\n", "canonical_solution": "def find_max_with_index(arr)\n    max_value = arr[0]\n    index = 0\n    arr.each_with_index do |value, idx|\n      if value > max_value\n        max_value = value\n        index = idx\n      end\n    end\n    [max_value, index]\n  end", "buggy_code": "def find_max_with_index(arr)\n\nmax_value = arr[1]\nindex = 0\narr.each_with_index do |value, idx|\n  if value > max_value\n    max_value = value\n    index = idx\n  end\nend\n[max_value, index]\nend\n", "bug_with_line_numbers": "   1 | def find_max_with_index(arr)\n   2 | max_value = arr[1]\n   3 | index = 0\n   4 | arr.each_with_index do |value, idx|\n   5 |   if value > max_value\n   6 |     max_value = value\n   7 |     index = idx\n   8 |   end\n   9 | end\n  10 | [max_value, index]\n  11 | end", "fragment_lines": [2], "fragment_content": ["max_value = arr[1]"], "test": "raise 'Test failed' unless find_max_with_index([3, 2, 1]) == [3, 0]\nraise 'Test failed' unless find_max_with_index([10, 20, 30, 40]) == [40, 3]\nraise 'Test failed' unless find_max_with_index([5]) == [5, 0]\nraise 'Test failed' unless find_max_with_index([-3, -2, -1, -4]) == [-1, 2]\nraise 'Test failed' unless find_max_with_index([100, 200, 100, 50]) == [200, 1]\n  \nputs 'All tests passed!'", "instruction": "Observe the following faulty Ruby code\n```ruby\ndef find_max_with_index(arr)\n\nmax_value = arr[1]\nindex = 0\narr.each_with_index do |value, idx|\n  if value > max_value\n    max_value = value\n    index = idx\n  end\nend\n[max_value, index]\nend\n```\nFix bugs in the given code snippet. The fixed code must be placed between ```ruby```. Do not generate any test, main,example usage or check code!\n"}
{"question_id": "Ruby/56", "category": "Reference", "subtype": "undefined_methods", "level": "easy", "example": "# Example:\n>>> unique_permutations_count(\"aacc\")\n6\n>>> unique_permutations_count(\"abc\")\n6", "docstring": "Calculates the number of unique permutations of a given string.\nThe function takes a single argument, str, which is a string consisting of\nlowercase letters. It returns the total number of unique permutations that\ncan be formed with the characters in str.\n", "canonical_solution": "def unique_permutations_count(str)\n    return 1 if str.empty?\n  \n    # Count frequency of each character\n    freq = Hash.new(0)\n    str.each_char { |char| freq[char] += 1 }\n  \n    # Calculate the factorial of the length of the string\n    total_permutations = (1..str.length).inject(:*)\n  \n    # Divide by the factorial of the frequency of each character\n    freq.each_value do |value|\n      total_permutations /= (1..value).inject(:*)\n    end\n  \n    total_permutations\n  end", "buggy_code": "def unique_permutations_count(str)\n\ndef count_unique_permutations(str)\n  return 1 if str.empty?\n  \n  \n  freq = Hash.new(0)\n  str.each_char { |char| freq[char] += 1 }\n  \n  \n  total_permutations = (1..str.length).inject(:*)\n  \n  \n  freq.each_value do |value|\n    total_permutations /= (1..value).inject(:*)\n  end\n  \n  total_permutations\nend\n", "bug_with_line_numbers": "   1 | def unique_permutations_count(str)\n   2 | def count_unique_permutations(str)\n   3 |   return 1 if str.empty?\n   4 |   freq = Hash.new(0)\n   5 |   str.each_char { |char| freq[char] += 1 }\n   6 |   total_permutations = (1..str.length).inject(:*)\n   7 |   freq.each_value do |value|\n   8 |     total_permutations /= (1..value).inject(:*)\n   9 |   end\n  10 |   total_permutations\n  11 | end", "fragment_lines": [2], "fragment_content": ["def count_unique_permutations(str)"], "test": "raise 'Test failed' unless unique_permutations_count(\"aacc\") == 6\nraise 'Test failed' unless unique_permutations_count(\"abc\") == 6\nraise 'Test failed' unless unique_permutations_count(\"abcd\") == 24\nraise 'Test failed' unless unique_permutations_count(\"aaa\") == 1\nraise 'Test failed' unless unique_permutations_count(\"ab\") == 2\nraise 'Test failed' unless unique_permutations_count(\"aacdarwqea\") == 151200\n\n  \n\nputs 'All tests passed!'", "instruction": "Observe the following faulty Ruby code\n```ruby\ndef unique_permutations_count(str)\n\ndef count_unique_permutations(str)\n  return 1 if str.empty?\n  \n  \n  freq = Hash.new(0)\n  str.each_char { |char| freq[char] += 1 }\n  \n  \n  total_permutations = (1..str.length).inject(:*)\n  \n  \n  freq.each_value do |value|\n    total_permutations /= (1..value).inject(:*)\n  end\n  \n  total_permutations\nend\n```\nFix bugs in the given code snippet. The fixed code must be placed between ```ruby```. Do not generate any test, main,example usage or check code!\n"}
{"question_id": "Ruby/57", "category": "Multiple", "subtype": "triple_bug", "level": "hard", "example": "# Example:\n# >>> sort_patients([[\"021075\", 40], [\"004003\", 15], [\"010158\", 67], [\"021033\", 75], [\"102012\", 30]])\n# [[\"021033\", 75], [\"010158\", 67], [\"021075\", 40], [\"004003\", 15], [\"102012\", 30]]", "docstring": "Sorts a list of patient information based on their age and registration order.\nThe function takes an array of arrays, where each sub-array contains a patient's ID (a string) and age (an integer).\nThe sorting criteria are as follows:\n1. Patients aged 60 and above are given priority over younger patients.\n2. Elderly patients (aged 60+) are sorted in descending order of age. If ages are equal, they are sorted by their registration order.\n3. Younger patients (below 60) are sorted based on their registration order.\n", "canonical_solution": "def sort_patients(patient_info)\n    elderly, non_elderly = patient_info.partition { |_, age| age >= 60 }\n    sorted_elderly = elderly.sort_by { |_, age| -age }\n    sorted_elderly + non_elderly\n  end", "buggy_code": "def sort_patients(patient_info)\n\nelderly, non_elderly = patient_info.partition { |_, age| age >= 60 }\nsorted_elderly = elderly.sort_by { |_, age| -age }\nresult = sorted_elderly + non_elderly\ndisplay_result(result)\n", "bug_with_line_numbers": "   1 | def sort_patients(patient_info)\n   2 | elderly, non_elderly = patient_info.partition { |_, age| age >= 60 }\n   3 | sorted_elderly = elderly.sort_by { |_, age| -age }\n   4 | result = sorted_elderly + non_elderly\n   5 | display_result(result)", "fragment_lines": [4, 5, -1], "fragment_content": ["result = sorted_elderly + non_elderly", "display_result(result)", "missing critical code snippet"], "test": "raise 'Test failed' unless sort_patients([[\"021075\", 40], [\"004003\", 15], [\"010158\", 67], [\"021033\", 75], [\"102012\", 30]]) == [[\"021033\", 75], [\"010158\", 67], [\"021075\", 40], [\"004003\", 15], [\"102012\", 30]]\nraise 'Test failed' unless sort_patients([[\"001122\", 60], [\"003344\", 60], [\"005566\", 30]]) == [[\"001122\", 60], [\"003344\", 60], [\"005566\", 30]]\nraise 'Test failed' unless sort_patients([[\"987654\", 45], [\"123456\", 65], [\"543210\", 55]]) == [[\"123456\", 65], [\"987654\", 45], [\"543210\", 55]]\n\n\n\nputs 'All tests passed!'", "instruction": "Observe the following faulty Ruby code\n```ruby\ndef sort_patients(patient_info)\n\nelderly, non_elderly = patient_info.partition { |_, age| age >= 60 }\nsorted_elderly = elderly.sort_by { |_, age| -age }\nresult = sorted_elderly + non_elderly\ndisplay_result(result)\n```\nFix bugs in the given code snippet. The fixed code must be placed between ```ruby```. Do not generate any test, main,example usage or check code!\n"}
{"question_id": "Ruby/58", "category": "Reference", "subtype": "undefined_methods", "level": "easy", "example": "# Example:\n# >>> victory_gap_in_teams(\"abaabcaa\")\n# 4\n# >>> victory_gap_in_teams(\"abcd\")\n# 0", "docstring": "Calculates the difference in the number of victories between the most and least successful teams.\nThis function takes a string, team_sequence, representing the sequence of winning teams, where each team\nis identified by a lowercase letter. It returns an integer representing the difference in the number\nof victories between the team that won the most and the team that won the least (excluding teams with zero victories).\n", "canonical_solution": "def victory_gap_in_teams(team_sequence)\n    counts = Hash.new(0)\n    team_sequence.each_char { |team| counts[team] += 1 }\n  \n    max_victories = counts.values.max\n    min_victories = counts.values.reject { |v| v == 0 }.min\n  \n    max_victories - min_victories\n  end", "buggy_code": "def victory_gap_in_teams(team_sequence)\n\ncounts = Hash.new(0)\nteam_sequence.each_char { |team| counts[team] += 1 }\n\nmax_victories = counts.values.maximum\nmin_victories = counts.values.reject { |v| v == 0 }.minimum\n\nmax_victories - min_victories\n", "bug_with_line_numbers": "   1 | def victory_gap_in_teams(team_sequence)\n   2 | counts = Hash.new(0)\n   3 | team_sequence.each_char { |team| counts[team] += 1 }\n   4 | max_victories = counts.values.maximum\n   5 | min_victories = counts.values.reject { |v| v == 0 }.minimum\n   6 | max_victories - min_victories", "fragment_lines": [4, 5], "fragment_content": ["max_victories = counts.values.maximum", "min_victories = counts.values.reject {"], "test": "raise 'Test failed' unless victory_gap_in_teams(\"abaabcaa\") == 4\nraise 'Test failed' unless victory_gap_in_teams(\"abcd\") == 0\nraise 'Test failed' unless victory_gap_in_teams(\"a\") == 0\nraise 'Test failed' unless victory_gap_in_teams(\"aaabbbccc\") == 0\nraise 'Test failed' unless victory_gap_in_teams(\"abcdaaa\") == 3\n\nputs 'All tests passed!'", "instruction": "Observe the following faulty Ruby code\n```ruby\ndef victory_gap_in_teams(team_sequence)\n\ncounts = Hash.new(0)\nteam_sequence.each_char { |team| counts[team] += 1 }\n\nmax_victories = counts.values.maximum\nmin_victories = counts.values.reject { |v| v == 0 }.minimum\n\nmax_victories - min_victories\n```\nFix bugs in the given code snippet. The fixed code must be placed between ```ruby```. Do not generate any test, main,example usage or check code!\n"}
{"question_id": "Ruby/59", "category": "Reference", "subtype": "undefined_methods", "level": "easy", "example": "# Examples:\n# >>> total_drinks_with_promo(100)\n# 149\n# >>> total_drinks_with_promo(3)\n# 4", "docstring": "Calculates the total number of drinks a customer can enjoy under a promotional offer.\nUnder this offer, for every 3 bottle caps, the customer can get 1 additional drink.\nThe promotion continues as long as the customer has enough caps for exchange.\n\nThe function takes a single integer argument, n, which represents the initial number\nof drinks purchased. It returns an integer representing the total number of drinks\nthe customer can enjoy, including those received through the promotion.\n", "canonical_solution": "def total_drinks_with_promo(n)\n    total_drinks = n\n    caps = n\n  \n    while caps >= 3\n      exchanged_drinks = caps / 3\n      total_drinks += exchanged_drinks\n      caps = caps % 3 + exchanged_drinks\n    end\n  \n    total_drinks\n  end", "buggy_code": "def total_drinks_with_promo(n)\n\ndef total_drinks_with_caps(n)\n  total_drinks = n\n  caps = n\n\n  while caps >= 3\n    exchanged_drinks = caps / 3\n    total_drinks += exchanged_drinks\n    caps = caps % 3 + exchanged_drinks\n  end\n\n  total_drinks\nend\n", "bug_with_line_numbers": "   1 | def total_drinks_with_promo(n)\n   2 | def total_drinks_with_caps(n)\n   3 |   total_drinks = n\n   4 |   caps = n\n   5 |   while caps >= 3\n   6 |     exchanged_drinks = caps / 3\n   7 |     total_drinks += exchanged_drinks\n   8 |     caps = caps % 3 + exchanged_drinks\n   9 |   end\n  10 |   total_drinks\n  11 | end", "fragment_lines": [2], "fragment_content": ["def total_drinks_with_caps(n)"], "test": "raise 'Test failed' unless total_drinks_with_promo(100) == 149\nraise 'Test failed' unless total_drinks_with_promo(3) == 4\nraise 'Test failed' unless total_drinks_with_promo(9) == 13\nraise 'Test failed' unless total_drinks_with_promo(10) == 14\nraise 'Test failed' unless total_drinks_with_promo(1) == 1\n  \nputs 'All tests passed!'", "instruction": "Observe the following faulty Ruby code\n```ruby\ndef total_drinks_with_promo(n)\n\ndef total_drinks_with_caps(n)\n  total_drinks = n\n  caps = n\n\n  while caps >= 3\n    exchanged_drinks = caps / 3\n    total_drinks += exchanged_drinks\n    caps = caps % 3 + exchanged_drinks\n  end\n\n  total_drinks\nend\n```\nFix bugs in the given code snippet. The fixed code must be placed between ```ruby```. Do not generate any test, main,example usage or check code!\n"}
{"question_id": "Ruby/60", "category": "Reference", "subtype": "undefined_methods", "level": "medium", "example": "# Example:\n>>> minimum_time_to_top([3, 5, 1, 8, 4])\n1", "docstring": "Calculates the minimum time required for a character to reach the top of a building with varying floor heights.\nThe character can move up one or two floors at a time, but cannot use the two-floor jump consecutively.\nMoving up one floor takes one unit of time, while jumping up two floors is instantaneous.\n\nArgs:\n- floor_heights (Array): An array of integers representing the height of each floor.\n\nReturns:\n- Integer: The minimum time required to reach the top of the building.\n", "canonical_solution": "def minimum_time_to_top(heights)\n    # Initialize arrays for storing minimum time for climb and jump to each floor.\n    n = heights.length\n    \n    climb_time = [0, heights.first]\n    jump_time  = [0, 0]\n  \n    (2..n).each do |i|\n      climb_time[i] = [climb_time[i - 1], jump_time[i - 1]].min + heights[i-1]\n      jump_time[i]  = [climb_time[i - 1], climb_time[i - 2]].min\n    end\n    [climb_time[n], jump_time[n]].min\n  end", "buggy_code": "def minimum_time_to_top(heights)\n\n\nn = heights.length\n\nclimb_time = [0, heights.first]\njump_time  = [0, 0]\n\n(2..n).each do |i|\n  climb_time[i] = [climb_time[i - 1], jump_time[i - 1]].min + heights[i-1]\n  jump_time[i]  = [climb_time[i - 1], climb_time[i - 2]].min\nend\n[climb_time[n], jump_time[n]].min\n", "bug_with_line_numbers": "   1 | def minimum_time_to_top(heights)\n   2 | n = heights.length\n   3 | climb_time = [0, heights.first]\n   4 | jump_time  = [0, 0]\n   5 | (2..n).each do |i|\n   6 |   climb_time[i] = [climb_time[i - 1], jump_time[i - 1]].min + heights[i-1]\n   7 |   jump_time[i]  = [climb_time[i - 1], climb_time[i - 2]].min\n   8 | end\n   9 | [climb_time[n], jump_time[n]].min", "fragment_lines": [-1], "fragment_content": ["missing critical code snippet"], "test": "raise 'Test failed' unless minimum_time_to_top([3, 5, 1, 8, 4]) == 1\nraise 'Test failed' unless minimum_time_to_top([2, 2, 2, 2, 2]) == 2\nraise 'Test failed' unless minimum_time_to_top([1, 1, 1, 1, 1]) == 1\nraise 'Test failed' unless minimum_time_to_top([10]) == 0\n\n\n\nputs 'All tests passed!'", "instruction": "Observe the following faulty Ruby code\n```ruby\ndef minimum_time_to_top(heights)\n\n\nn = heights.length\n\nclimb_time = [0, heights.first]\njump_time  = [0, 0]\n\n(2..n).each do |i|\n  climb_time[i] = [climb_time[i - 1], jump_time[i - 1]].min + heights[i-1]\n  jump_time[i]  = [climb_time[i - 1], climb_time[i - 2]].min\nend\n[climb_time[n], jump_time[n]].min\n```\nFix bugs in the given code snippet. The fixed code must be placed between ```ruby```. Do not generate any test, main,example usage or check code!\n"}
{"question_id": "Ruby/61", "category": "Special", "subtype": "Misused begin/end", "level": "hard", "example": "Example:\n>>> minimum_time_to_top([3, 5, 1, 8, 4])\n1", "docstring": "Calculates the minimum time required for a character to reach the top of a building with varying floor heights.\nThe character can move up one or two floors at a time, but cannot use the two-floor jump consecutively.\nMoving up one floor takes one unit of time, while jumping up two floors is instantaneous.\n\nArgs:\n- floor_heights (Array): An array of integers representing the height of each floor.\n\nReturns:\n- Integer: The minimum time required to reach the top of the building.", "canonical_solution": "# Calculates the minimum time required for a character to reach the top of a building with varying floor heights.\n# The character can move up one or two floors at a time, but cannot use the two-floor jump consecutively. \n# Moving up one floor takes one unit of time, while jumping up two floors is instantaneous.\n#\n# Args:\n# - floor_heights (Array): An array of integers representing the height of each floor.\n#\n# Returns:\n# - Integer: The minimum time required to reach the top of the building.\n#\n# Example:\n# >>> minimum_time_to_top([3, 5, 1, 8, 4])\n# 1\n\ndef minimum_time_to_top(heights)\n\n    # Initialize arrays for storing minimum time for climb and jump to each floor.\n    n = heights.length\n    \n    climb_time = [0, heights.first]\n    jump_time  = [0, 0]\n  \n    (2..n).each do |i|\n      climb_time[i] = [climb_time[i - 1], jump_time[i - 1]].min + heights[i-1]\n      jump_time[i]  = [climb_time[i - 1], climb_time[i - 2]].min\n    end\n    [climb_time[n], jump_time[n]].min\n  end", "buggy_code": "def minimum_time_to_top(heights)\n    n = heights.length\n    \n    climb_time = [0, heights.first]\n    jump_time  = [0, 0]\n  \n    (2..n).each do |i|\n      climb_time[i] = [climb_time[i - 1], jump_time[i - 1]].min + heights[i-1]\n      jump_time[i]  = [climb_time[i - 1], climb_time[i - 2]].min", "bug_with_line_numbers": "   1 | def minimum_time_to_top(heights)\n   2 |     n = heights.length\n   3 |     climb_time = [0, heights.first]\n   4 |     jump_time  = [0, 0]\n   5 |     (2..n).each do |i|\n   6 |       climb_time[i] = [climb_time[i - 1], jump_time[i - 1]].min + heights[i-1]\n   7 |       jump_time[i]  = [climb_time[i - 1], climb_time[i - 2]].min", "fragment_lines": [-1], "fragment_content": ["missing critical code snippet"], "test": "raise 'Test failed' unless minimum_time_to_top([3, 5, 1, 8, 4]) == 1\nraise 'Test failed' unless minimum_time_to_top([2, 2, 2, 2, 2]) == 2\nraise 'Test failed' unless minimum_time_to_top([1, 1, 1, 1, 1]) == 1\nraise 'Test failed' unless minimum_time_to_top([10]) == 0\n\n\n\nputs 'All tests passed!'", "instruction": "Observe the following faulty Ruby code\n```ruby\ndef minimum_time_to_top(heights)\n    n = heights.length\n    \n    climb_time = [0, heights.first]\n    jump_time  = [0, 0]\n  \n    (2..n).each do |i|\n      climb_time[i] = [climb_time[i - 1], jump_time[i - 1]].min + heights[i-1]\n      jump_time[i]  = [climb_time[i - 1], climb_time[i - 2]].min\n```\nFix bugs in the given code snippet. The fixed code must be placed between ```ruby```. Do not generate any test, main,example usage or check code!\n"}
{"question_id": "Ruby/62", "category": "Special", "subtype": "Misused begin/end", "level": "medium", "example": "\nExample:\n>>> sort_patients([[\"021075\", 40], [\"004003\", 15], [\"010158\", 67], [\"021033\", 75], [\"102012\", 30]])\n[[\"021033\", 75], [\"010158\", 67], [\"021075\", 40], [\"004003\", 15], [\"102012\", 30]]", "docstring": "Sorts a list of patient information based on their age and registration order.\nThe function takes an array of arrays, where each sub-array contains a patient's ID (a string) and age (an integer).\nThe sorting criteria are as follows:\n1. Patients aged 60 and above are given priority over younger patients.\n2. Elderly patients (aged 60+) are sorted in descending order of age. If ages are equal, they are sorted by their registration order.\n3. Younger patients (below 60) are sorted based on their registration order.", "canonical_solution": "# Sorts a list of patient information based on their age and registration order.\n# The function takes an array of arrays, where each sub-array contains a patient's ID (a string) and age (an integer).\n# The sorting criteria are as follows:\n# 1. Patients aged 60 and above are given priority over younger patients.\n# 2. Elderly patients (aged 60+) are sorted in descending order of age. If ages are equal, they are sorted by their registration order.\n# 3. Younger patients (below 60) are sorted based on their registration order.\n#\n# Example:\n# >>> sort_patients([[\"021075\", 40], [\"004003\", 15], [\"010158\", 67], [\"021033\", 75], [\"102012\", 30]])\n# [[\"021033\", 75], [\"010158\", 67], [\"021075\", 40], [\"004003\", 15], [\"102012\", 30]]\n\n\n\ndef sort_patients(patient_info)\n\n    elderly, non_elderly = patient_info.partition { |_, age| age >= 60 }\n    sorted_elderly = elderly.sort_by { |_, age| -age }\n    sorted_elderly + non_elderly\n  end", "buggy_code": "def sort_patients(patient_info)\n    elderly, non_elderly = patient_info.partition { |_, age| age >= 60 }\n    sorted_elderly = elderly.sort_by { |_, age| -age }\n    sorted_elderly + non_elderly", "bug_with_line_numbers": "   1 | def sort_patients(patient_info)\n   2 |     elderly, non_elderly = patient_info.partition { |_, age| age >= 60 }\n   3 |     sorted_elderly = elderly.sort_by { |_, age| -age }\n   4 |     sorted_elderly + non_elderly", "fragment_lines": [-1], "fragment_content": ["missing critical code snippet"], "test": "raise 'Test failed' unless sort_patients([[\"021075\", 40], [\"004003\", 15], [\"010158\", 67], [\"021033\", 75], [\"102012\", 30]]) == [[\"021033\", 75], [\"010158\", 67], [\"021075\", 40], [\"004003\", 15], [\"102012\", 30]]\nraise 'Test failed' unless sort_patients([[\"001122\", 60], [\"003344\", 60], [\"005566\", 30]]) == [[\"001122\", 60], [\"003344\", 60], [\"005566\", 30]]\nraise 'Test failed' unless sort_patients([[\"987654\", 45], [\"123456\", 65], [\"543210\", 55]]) == [[\"123456\", 65], [\"987654\", 45], [\"543210\", 55]]\n\n\n\nputs 'All tests passed!'", "instruction": "Observe the following faulty Ruby code\n```ruby\ndef sort_patients(patient_info)\n    elderly, non_elderly = patient_info.partition { |_, age| age >= 60 }\n    sorted_elderly = elderly.sort_by { |_, age| -age }\n    sorted_elderly + non_elderly\n```\nFix bugs in the given code snippet. The fixed code must be placed between ```ruby```. Do not generate any test, main,example usage or check code!\n"}
{"question_id": "Ruby/63", "category": "Special", "subtype": "Misused begin/end", "level": "easy", "example": "\n Examples:\n >>> count_chars_types(\"yLOI2022\")\n [4, 1, 3]\n >>> count_chars_types(\"IAKIOIOI\")\n [0, 0, 8]\n >>> count_chars_types(\"1n2s0e1s\")\n [4, 4, 0]", "docstring": "Counts the number of digits, lowercase letters, and uppercase letters in a given string.\n The function takes a single argument, s, which is a string of length 8,\n and returns an array with three integers representing the count of digits,\n lowercase letters, and uppercase letters in the string, respectively.", "canonical_solution": "# Counts the number of digits, lowercase letters, and uppercase letters in a given string.\n# The function takes a single argument, s, which is a string of length 8,\n# and returns an array with three integers representing the count of digits,\n# lowercase letters, and uppercase letters in the string, respectively.\n#\n# Examples:\n# >>> count_chars_types(\"yLOI2022\")\n# [4, 1, 3]\n# >>> count_chars_types(\"IAKIOIOI\")\n# [0, 0, 8]\n# >>> count_chars_types(\"1n2s0e1s\")\n# [4, 4, 0]\ndef count_chars_types(s)\n\n    digits_count = s.count(\"0-9\")\n    lowercase_count = s.count(\"a-z\")\n    uppercase_count = s.count(\"A-Z\")\n    [digits_count, lowercase_count, uppercase_count]\n  end", "buggy_code": "def count_chars_types(s)\n    digits_count = s.count(\"0-9\")\n    lowercase_count = s.count(\"a-z\")\n    uppercase_count = s.count(\"A-Z\")\n    [digits_count, lowercase_count, uppercase_count]", "bug_with_line_numbers": "   1 | def count_chars_types(s)\n   2 |     digits_count = s.count(\"0-9\")\n   3 |     lowercase_count = s.count(\"a-z\")\n   4 |     uppercase_count = s.count(\"A-Z\")\n   5 |     [digits_count, lowercase_count, uppercase_count]", "fragment_lines": [-1], "fragment_content": ["missing critical code snippet"], "test": "raise 'Test failed' unless count_chars_types(\"yLOI2022\") == [4, 1, 3]\nraise 'Test failed' unless count_chars_types(\"IAKIOIOI\") == [0, 0, 8]\nraise 'Test failed' unless count_chars_types(\"1n2s0e1s\") == [4, 4, 0]\nraise 'Test failed' unless count_chars_types(\"12345678\") == [8, 0, 0]\nraise 'Test failed' unless count_chars_types(\"abcdefgh\") == [0, 8, 0]", "instruction": "Observe the following faulty Ruby code\n```ruby\ndef count_chars_types(s)\n    digits_count = s.count(\"0-9\")\n    lowercase_count = s.count(\"a-z\")\n    uppercase_count = s.count(\"A-Z\")\n    [digits_count, lowercase_count, uppercase_count]\n```\nFix bugs in the given code snippet. The fixed code must be placed between ```ruby```. Do not generate any test, main,example usage or check code!\n"}
