{"question_id": "Clisp/1", "category": "Syntax", "subtype": "illegal_comment", "level": "easy", "example": " multiple-value-bind (quarters dimes nickels pennies) (make-change 98\n quarters 3\n dimes 2\n nickels 0\n pennies 3", "docstring": ";; Define a function that accepts an integer cents and returns four values, displaying the numbers as 25-, 10-, 5-, 1-, using the minimum number of coins. (Translation: 25- is 25 cents, and so on)", "canonical_solution": "(defun make-change (cents)\n\n\n(let ((quarters (floor cents 25))\n(remaining-after-quarters (mod cents 25)))\n(let ((dimes (floor remaining-after-quarters 10))\n(remaining-after-dimes (mod remaining-after-quarters 10)))\n(let ((nickels (floor remaining-after-dimes 5))\n(pennies (mod remaining-after-dimes 5)))\n(values quarters dimes nickels pennies)))))", "buggy_code": "(defun make-change (cents)\n\n\n//Greedy Algorithm\n(let ((quarters (floor cents 25))\n(remaining-after-quarters (mod cents 25)))\n(let ((dimes (floor remaining-after-quarters 10))\n(remaining-after-dimes (mod remaining-after-quarters 10)))\n(let ((nickels (floor remaining-after-dimes 5))\n(pennies (mod remaining-after-dimes 5)))\n(values quarters dimes nickels pennies)))))", "test": "(defun check ()\n;; 测试 'make-change' 函数。\n(multiple-value-bind (quarters dimes nickels pennies) (make-change 98)\n(assert (equal quarters 3))\n(assert (equal dimes 2))\n(assert (equal nickels 0))\n(assert (equal pennies 3)))\n(multiple-value-bind (quarters dimes nickels pennies) (make-change 41)\n(assert (equal quarters 1))\n(assert (equal dimes 1))\n(assert (equal nickels 1))\n(assert (equal pennies 1)))\n(multiple-value-bind (quarters dimes nickels pennies) (make-change 3)\n(assert (equal quarters 0))\n(assert (equal dimes 0))\n(assert (equal nickels 0))\n(assert (equal pennies 3))))\n\n(check)", "instruction": "Observe the following faulty Clisp```lisp\n(defun make-change (cents)\n\n\n//Greedy Algorithm\n(let ((quarters (floor cents 25))\n(remaining-after-quarters (mod cents 25)))\n(let ((dimes (floor remaining-after-quarters 10))\n(remaining-after-dimes (mod remaining-after-quarters 10)))\n(let ((nickels (floor remaining-after-dimes 5))\n(pennies (mod remaining-after-dimes 5)))\n(values quarters dimes nickels pennies)))))\n```\n Fix bugs in the given code snippet. The fixed code must be placed between ```lisp```. Do not generate any test, main,example usage or check code!"}
{"question_id": "Clisp/2", "category": "Syntax", "subtype": "illegal_comment", "level": "easy", "example": " (total-cigarettes-smoked 4 3)  Returns 5\n (total-cigarettes-smoked 10 4)  Returns 13", "docstring": ";; Calculates the total number of cigarettes Peter can smoke.\n;; 'initial-cigarettes' is the starting number of cigarettes.\n;; 'butt-to-cigarette-ratio' is the number of cigarette butts required to get a new cigarette.\n;; The function returns the total number of cigarettes Peter can smoke.", "canonical_solution": "(defun total-cigarettes-smoked (initial-cigarettes butt-to-cigarette-ratio)\n\n\n(let ((total-smoked initial-cigarettes)\n(butts initial-cigarettes))\n(loop while (>= butts butt-to-cigarette-ratio)\ndo (let ((new-cigarettes (floor butts butt-to-cigarette-ratio)))\n(incf total-smoked new-cigarettes)\n(decf butts (* new-cigarettes butt-to-cigarette-ratio))\n(incf butts new-cigarettes)))\ntotal-smoked))", "buggy_code": "(defun total-cigarettes-smoked (initial-cigarettes butt-to-cigarette-ratio)\n\n\"Calculates the total number of cigarettes Peter can smoke.\n(let ((total-smoked initial-cigarettes)\n(butts initial-cigarettes))\n(loop while (>= butts butt-to-cigarette-ratio)\ndo (let ((new-cigarettes (floor butts butt-to-cigarette-ratio)))\n(incf total-smoked new-cigarettes)\n(decf butts (* new-cigarettes butt-to-cigarette-ratio))\n(incf butts new-cigarettes)))\ntotal-smoked))", "test": "(defun check ()\n(assert (equal (total-cigarettes-smoked 4 3) 5))\n(assert (equal (total-cigarettes-smoked 10 4) 13))\n(assert (equal (total-cigarettes-smoked 20 5) 24))\n(assert (equal (total-cigarettes-smoked 15 3) 22))\n(assert (equal (total-cigarettes-smoked 7 2) 13))\n(assert (equal (total-cigarettes-smoked 5 5) 6))\n(assert (equal (total-cigarettes-smoked 0 3) 0)))\n\n(check)", "instruction": "Observe the following faulty Clisp```lisp\n(defun total-cigarettes-smoked (initial-cigarettes butt-to-cigarette-ratio)\n\n\"Calculates the total number of cigarettes Peter can smoke.\n(let ((total-smoked initial-cigarettes)\n(butts initial-cigarettes))\n(loop while (>= butts butt-to-cigarette-ratio)\ndo (let ((new-cigarettes (floor butts butt-to-cigarette-ratio)))\n(incf total-smoked new-cigarettes)\n(decf butts (* new-cigarettes butt-to-cigarette-ratio))\n(incf butts new-cigarettes)))\ntotal-smoked))\n```\n Fix bugs in the given code snippet. The fixed code must be placed between ```lisp```. Do not generate any test, main,example usage or check code!"}
{"question_id": "Clisp/3", "category": "Syntax", "subtype": "illegal_separation", "level": "easy", "example": " (calculate-year-end-amount '(290 230 280 200 300 170 340 50 90 80 200 60))  Returns -7", "docstring": ";; Calculates whether Jinjin can follow her savings plan without running out of money in any month.\n;; 'monthly-budgets' is a list of 12 integers representing Jinjin's monthly budget.\n;; If successful, returns the total amount of money Jinjin will have by year-end, including 20% interest on savings.\n;; Otherwise, returns -X, where X is the first month Jinjin runs out of money.\n;; Add monthly allowance\n;; Subtract monthly budget\n;; Check if Jinjin runs out of money\n;; Calculate total with interest", "canonical_solution": "(defun calculate-year-end-amount (monthly-budgets)\n;; Calculates whether Jinjin can follow her savings plan without running out of money in any month.\n;; 'monthly-budgets' is a list of 12 integers representing Jinjin's monthly budget.\n;; If successful, returns the total amount of money Jinjin will have by year-end, including 20% interest on savings.\n;; Otherwise, returns -X, where X is the first month Jinjin runs out of money.\n;; Example:\n;; (calculate-year-end-amount '(290 230 280 200 300 170 340 50 90 80 200 60)) ;; Returns -7\n\n(let ((current-amount 0)\n(total-saved 0))\n(loop for month from 1 to 12\nfor budget in monthly-budgets\ndo (progn\n(incf current-amount 300) ;; Add monthly allowance\n(decf current-amount budget) ;; Subtract monthly budget\n(when (< current-amount 0)\n(return-from calculate-year-end-amount (- month))) ;; Check if Jinjin runs out of money\n(let ((savings (floor current-amount 100)))\n(decf current-amount (* 100 savings))\n(incf total-saved (* 100 savings))))\nfinally (return (+ current-amount (* total-saved 1.2)))))) ;; Calculate total with interest", "buggy_code": "(defun calculate-year-end-amount (monthly-budgets)\n;; Calculates whether Jinjin can follow her savings plan without running out of money in any month.\n;; 'monthly-budgets' is a list of 12 integers representing Jinjin's monthly budget.\n;; If successful, returns the total amount of money Jinjin will have by year-end, including 20% interest on savings.\n;; Otherwise, returns -X, where X is the first month Jinjin runs out of money.\n\n(let ((current-amount 0)\n(total-saved 0))\n(loop for month from 1 to 12\nfor budget in monthly-budgets\ndo (\n(incf current-amount 300) ;; Add monthly allowance\n(decf current-amount budget) ;; Subtract monthly budget\n(when (< current-amount 0)\n(return-from calculate-year-end-amount (- month))) ;; Check if Jinjin runs out of money\n(let ((savings (floor current-amount 100)))\n(decf current-amount (* 100 savings))\n(incf total-saved (* 100 savings))))\nfinally (return (+ current-amount (* total-saved 1.2)))))) ;; Calculate total with interest", "test": "(defun check ()\n(assert (equal (calculate-year-end-amount '(290 230 280 200 300 170 340 50 90 80 200 60)) -7))\n(assert (equal (calculate-year-end-amount '(100 100 100 100 100 100 100 100 100 100 100 100)) 2880.0)) ;; Assuming all savings\n(assert (equal (calculate-year-end-amount '(300 300 300 300 300 300 300 300 300 300 300 300)) 0.0)) ;; No savings\n(assert (equal (calculate-year-end-amount '(150 150 150 150 150 150 150 150 150 150 150 150)) 2160.0)) ;; Half savings\n(assert (equal (calculate-year-end-amount '(250 250 250 250 250 250 250 250 250 250 250 250)) 720.0))) ;; Runs out first month\n(check)", "instruction": "Observe the following faulty Clisp```lisp\n(defun calculate-year-end-amount (monthly-budgets)\n;; Calculates whether Jinjin can follow her savings plan without running out of money in any month.\n;; 'monthly-budgets' is a list of 12 integers representing Jinjin's monthly budget.\n;; If successful, returns the total amount of money Jinjin will have by year-end, including 20% interest on savings.\n;; Otherwise, returns -X, where X is the first month Jinjin runs out of money.\n\n(let ((current-amount 0)\n(total-saved 0))\n(loop for month from 1 to 12\nfor budget in monthly-budgets\ndo (\n(incf current-amount 300) ;; Add monthly allowance\n(decf current-amount budget) ;; Subtract monthly budget\n(when (< current-amount 0)\n(return-from calculate-year-end-amount (- month))) ;; Check if Jinjin runs out of money\n(let ((savings (floor current-amount 100)))\n(decf current-amount (* 100 savings))\n(incf total-saved (* 100 savings))))\nfinally (return (+ current-amount (* total-saved 1.2)))))) ;; Calculate total with interest\n```\n Fix bugs in the given code snippet. The fixed code must be placed between ```lisp```. Do not generate any test, main,example usage or check code!"}
{"question_id": "Clisp/4", "category": "Syntax", "subtype": "illegal_separation", "level": "easy", "example": " >>> count-digit-two 2 22\n 6\n >>> count-digit-two 10 25\n 9", "docstring": ";; This function counts the occurrences of the digit '2' in all integers within a given range [L, R].\n;; Both L and R are inclusive.\n;; It iterates through each number in the range and counts how many times '2' appears in each number.", "canonical_solution": "(defun count-digit-two (L R)\n\n\n(let ((count 0))\n(loop for i from L to R do\n(loop for char across (write-to-string i) do\n(when (char= char #\\2) (incf count))))\ncount))", "buggy_code": "(defun count-digit-two (L R)\n\n(let ((count 0))\n(loop for i from l to r do\n(loop for char across (write-to-string i) do\n(when (char= char \\2) (incf count))))\ncount))", "test": "(defun check ()\n(assert (equal (count-digit-two 2 22) 6))\n(assert (equal (count-digit-two 10 25) 8))\n(assert (equal (count-digit-two 1 100) 20))\n(assert (equal (count-digit-two 29 55) 4))\n(assert (equal (count-digit-two 200 250) 66)))\n\n(check)", "instruction": "Observe the following faulty Clisp```lisp\n(defun count-digit-two (L R)\n\n(let ((count 0))\n(loop for i from l to r do\n(loop for char across (write-to-string i) do\n(when (char= char \\2) (incf count))))\ncount))\n```\n Fix bugs in the given code snippet. The fixed code must be placed between ```lisp```. Do not generate any test, main,example usage or check code!"}
{"question_id": "Clisp/5", "category": "Syntax", "subtype": "missing_colons", "level": "easy", "example": " (count-remaining-trees 10 '((2 5) (7 9)))  Returns 4\n (count-remaining-trees 15 '((1 3) (5 10)))  Returns 7", "docstring": ";; Counts the number of trees remaining on a road of length 'road-length' after removing trees in specified 'regions'.\n;; Each region is a list of two integers representing the start and end points on the road.\n;; The function returns the number of trees remaining after the removal.", "canonical_solution": "(defun count-remaining-trees (road-length regions)\n\n\n(let ((tree-map (make-array (1+ road-length) :initial-element t)))\n(dolist (region regions)\n(loop for i from (first region) to (second region)\ndo (setf (aref tree-map i) nil)))\n(count t tree-map)))", "buggy_code": "(defun count-remaining-trees (road-length regions)\n\n\n(let ((tree-map (make-array (1+ road-length) initial-element t)))\n(dolist (region regions)\n(loop for i from (first region) to (second region)\ndo (setf (aref tree-map i) nil)))\n(count t tree-map)))", "test": "(defun check ()\n(assert (equal (count-remaining-trees 10 '((2 5) (7 9))) 4))\n(assert (equal (count-remaining-trees 15 '((1 3) (5 10))) 7))\n(assert (equal (count-remaining-trees 20 '((0 5) (10 15))) 9))\n(assert (equal (count-remaining-trees 30 '((3 6) (8 10) (15 20))) 18))\n(assert (equal (count-remaining-trees 50 '((0 10) (20 30) (40 50))) 18)))\n\n(check)", "instruction": "Observe the following faulty Clisp```lisp\n(defun count-remaining-trees (road-length regions)\n\n\n(let ((tree-map (make-array (1+ road-length) initial-element t)))\n(dolist (region regions)\n(loop for i from (first region) to (second region)\ndo (setf (aref tree-map i) nil)))\n(count t tree-map)))\n```\n Fix bugs in the given code snippet. The fixed code must be placed between ```lisp```. Do not generate any test, main,example usage or check code!"}
{"question_id": "Clisp/6", "category": "Syntax", "subtype": "missing_colons", "level": "easy", "example": " >>> create-largest-number '(56 9 45)\n \"95645\"\n >>> create-largest-number '(5 50 56)\n \"56550\"", "docstring": ";; This function takes a list of positive integers and rearranges them to form the largest possible number. \n;; It does this by concatenating the integers in an order such that their digit-wise combination yields the maximum value.", "canonical_solution": "(defun create-largest-number (numbers)\n\n\n(let ((str-numbers (mapcar #'number-to-string numbers)))\n(setf str-numbers (sort str-numbers #'larger-when-concatenated))\n(reduce (lambda (acc x) (concatenate 'string acc x)) str-numbers :initial-value \"\")))\n\n(defun number-to-string (number)\n(write-to-string number))\n\n(defun larger-when-concatenated (a b)\n(string> (concatenate 'string a b) (concatenate 'string b a)))", "buggy_code": "(defun create-largest-number (numbers)\n\n\n(let ((str-numbers (mapcar #'number-to-string numbers)))\n(setf str-numbers (sort str-numbers #'larger-when-concatenated))\n(reduce (lambda (acc x) (concatenate 'string acc x)) str-numbers initial-value \"\")))\n\n(defun number-to-string (number)\n(write-to-string number))\n\n(defun larger-when-concatenated (a b)\n(string> (concatenate 'string a b) (concatenate 'string b a)))", "test": "(defun check ()\n(assert (string= (create-largest-number '(56 9 45)) \"95645\"))\n(assert (string= (create-largest-number '(5 50 56)) \"56550\"))\n(assert (string= (create-largest-number '(3 34 302 50)) \"50343302\"))\n(assert (string= (create-largest-number '(10 2 23)) \"23210\"))\n(assert (string= (create-largest-number '(4 42 40 400)) \"44240400\")))\n\n(check)", "instruction": "Observe the following faulty Clisp```lisp\n(defun create-largest-number (numbers)\n\n\n(let ((str-numbers (mapcar #'number-to-string numbers)))\n(setf str-numbers (sort str-numbers #'larger-when-concatenated))\n(reduce (lambda (acc x) (concatenate 'string acc x)) str-numbers initial-value \"\")))\n\n(defun number-to-string (number)\n(write-to-string number))\n\n(defun larger-when-concatenated (a b)\n(string> (concatenate 'string a b) (concatenate 'string b a)))\n```\n Fix bugs in the given code snippet. The fixed code must be placed between ```lisp```. Do not generate any test, main,example usage or check code!"}
{"question_id": "Clisp/7", "category": "Syntax", "subtype": "misused ==and=", "level": "easy", "example": " >>> bin-search 3 '#(1 2 3 4 5)\n t", "docstring": ";; Binary search for 'obj' in sorted vector 'vec'.\n;; Returns 't' if 'obj' is found, 'nil' otherwise.", "canonical_solution": "(defun bin-search (obj vec)\n\n\n(let ((low 0)\n(high (1- (length vec))))\n(loop while (<= low high)\nfor mid = (floor (+ low high) 2)\nfor mid-val = (aref vec mid)\ndo (cond ((= obj mid-val) (return-from bin-search t))\n((< obj mid-val) (setf high (1- mid)))\n((> obj mid-val) (setf low (1+ mid)))))\nnil))", "buggy_code": "(defun bin-search (obj vec)\n\n\n(let ((low 0)\n(high (1- (length vec))))\n(loop while (<= low high)\nfor mid = (floor (+ low high) 2)\nfor mid-val = (aref vec mid)\ndo (cond ((== obj mid-val) (return-from bin-search t))\n((< obj mid-val) (setf high (1- mid)))\n((> obj mid-val) (setf low (1+ mid)))))\nnil))", "test": "(defun check ()\n;; Test the 'bin-search' function with various cases.\n(assert (equal (bin-search 3 '#(1 2 3 4 5)) t))\n(assert (equal (bin-search 6 '#(1 2 3 4 5)) nil))\n(assert (equal (bin-search 1 '#(1)) t))\n(assert (equal (bin-search 2 '#(1)) nil))\n(assert (equal (bin-search 0 '#()) nil))\n(assert (equal (bin-search 5 '#(2 4 6 8 10)) nil))\n(assert (equal (bin-search 4 '#(2 4 6 8 10)) t)))\n\n(check)", "instruction": "Observe the following faulty Clisp```lisp\n(defun bin-search (obj vec)\n\n\n(let ((low 0)\n(high (1- (length vec))))\n(loop while (<= low high)\nfor mid = (floor (+ low high) 2)\nfor mid-val = (aref vec mid)\ndo (cond ((== obj mid-val) (return-from bin-search t))\n((< obj mid-val) (setf high (1- mid)))\n((> obj mid-val) (setf low (1+ mid)))))\nnil))\n```\n Fix bugs in the given code snippet. The fixed code must be placed between ```lisp```. Do not generate any test, main,example usage or check code!"}
{"question_id": "Clisp/8", "category": "Syntax", "subtype": "misused ==and=", "level": "easy", "example": " >>> count-prime-sums '(1 2 3 4) 2\n 2 ; (1+2) and (3+4) are prime\n >>> count-prime-sums '(1 2 3 4 5 6) 3\n 1 ; Only (1+2+5) is prime", "docstring": ";; This function counts the number of ways to select 'k' integers from a list of 'n' integers such that their sum is a prime number.\n;; It considers all possible combinations of 'k' integers from the list and checks if their sum is prime.", "canonical_solution": "(defun count-prime-sums (numbers k)\n\n\n(count t (mapcar (lambda (comb) (is-prime (reduce '+ comb)))\n(sum-combinations numbers k))))\n(defun is-prime (n)\n(cond ((<= n 1) nil)\n((= n 2) t)\n(t (loop for i from 2 to (isqrt n) never (zerop (mod n i))))))\n\n(defun sum-combinations (lst k)\n(if (= k 0)\n'(())\n(loop for i from 0 below (length lst)\nnconc (mapcar (lambda (x) (cons (nth i lst) x))\n(sum-combinations (subseq lst (1+ i)) (1- k))))))", "buggy_code": "(defun count-prime-sums (numbers k)\n\n\n\n(count t (mapcar (lambda (comb) (is-prime (reduce '+ comb)))\n(sum-combinations numbers k))))\n(defun is-prime (n)\n(cond ((<= n 1) nil)\n((= n 2) t)\n(t (loop for i from 2 to (isqrt n) never (zerop (mod n i))))))\n\n(defun sum-combinations (lst k)\n(if (== k 0)\n'(())\n(loop for i from 0 below (length lst)\nnconc (mapcar (lambda (x) (cons (nth i lst) x))\n(sum-combinations (subseq lst (1+ i)) (1- k))))))", "test": "(defun check ()\n(assert (equal (count-prime-sums '(3 7 12 19) 3) 1))\n(assert (equal (count-prime-sums '(1 2 3 4) 2) 4))\n(assert (equal (count-prime-sums '(1 2 3 4 5 6) 3) 6))\n(assert (equal (count-prime-sums '(10 20 30 40) 2) 0))\n(assert (equal (count-prime-sums '(11 13 17 19 23 29) 3) 12))) \n\n(check)", "instruction": "Observe the following faulty Clisp```lisp\n(defun count-prime-sums (numbers k)\n\n\n\n(count t (mapcar (lambda (comb) (is-prime (reduce '+ comb)))\n(sum-combinations numbers k))))\n(defun is-prime (n)\n(cond ((<= n 1) nil)\n((= n 2) t)\n(t (loop for i from 2 to (isqrt n) never (zerop (mod n i))))))\n\n(defun sum-combinations (lst k)\n(if (== k 0)\n'(())\n(loop for i from 0 below (length lst)\nnconc (mapcar (lambda (x) (cons (nth i lst) x))\n(sum-combinations (subseq lst (1+ i)) (1- k))))))\n```\n Fix bugs in the given code snippet. The fixed code must be placed between ```lisp```. Do not generate any test, main,example usage or check code!"}
{"question_id": "Clisp/9", "category": "Syntax", "subtype": "unclosed_parentheses", "level": "easy", "example": ">>> has_close_elements([1.0, 2.0, 3.0], 0.5)\nnil\n>>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\nt", "docstring": ";;Check if in given list of numbers, are any two numbers closer to each other than\n;;given threshold.", "canonical_solution": "(defun has-close-elements (numbers threshold)\n\n\n(loop for i from 0 below (length numbers)\ndo (loop for j from 0 below (length numbers)\ndo (when (and (/= i j)\n(< (abs (- (nth i numbers) (nth j numbers))) threshold))\n(return-from has-close-elements t))))\nnil)", "buggy_code": "(defun has-close-elements (numbers threshold)\n\n\n\n(loop for i from 0 below (length numbers)\ndo (loop for j from 0 below (length numbers)\ndo (when (and (/= i j)\n(< (abs (- (nth i numbers) (nth j numbers))) threshold))\n(return-from has-close-elements t)))\nnil)", "test": "(defun check ()\n(assert (equal (has-close-elements '(1.0 2.0 3.9 4.0 5.0 2.2) 0.3) t))\n(assert (equal (has-close-elements '(1.0 2.0 3.9 4.0 5.0 2.2) 0.05) nil))\n(assert (equal (has-close-elements '(1.0 2.0 5.9 4.0 5.0) 0.95) t))\n(assert (equal (has-close-elements '(1.0 2.0 5.9 4.0 5.0) 0.8) nil))\n(assert (equal (has-close-elements '(1.0 2.0 3.0 4.0 5.0 2.0) 0.1) t))\n(assert (equal (has-close-elements '(1.1 2.2 3.1 4.1 5.1) 1.0) t))\n(assert (equal (has-close-elements '(1.1 2.2 3.1 4.1 5.1) 0.5) nil)))\n\n(check)", "instruction": "Observe the following faulty Clisp```lisp\n(defun has-close-elements (numbers threshold)\n\n\n\n(loop for i from 0 below (length numbers)\ndo (loop for j from 0 below (length numbers)\ndo (when (and (/= i j)\n(< (abs (- (nth i numbers) (nth j numbers))) threshold))\n(return-from has-close-elements t)))\nnil)\n```\n Fix bugs in the given code snippet. The fixed code must be placed between ```lisp```. Do not generate any test, main,example usage or check code!"}
{"question_id": "Clisp/10", "category": "Syntax", "subtype": "unclosed_parentheses", "level": "easy", "example": " multiple-value-bind (quarters dimes nickels pennies) (make-change 98\n quarters 3\n dimes 2\n nickels 0\n pennies 3", "docstring": ";; Define a function that accepts an integer cents and returns four values, displaying the numbers as 25-, 10-, 5-, 1-, using the minimum number of coins. (Translation: 25- is 25 cents, and so on)", "canonical_solution": "(defun make-change (cents)\n\n\n(let ((quarters (floor cents 25))\n(remaining-after-quarters (mod cents 25)))\n(let ((dimes (floor remaining-after-quarters 10))\n(remaining-after-dimes (mod remaining-after-quarters 10)))\n(let ((nickels (floor remaining-after-dimes 5))\n(pennies (mod remaining-after-dimes 5)))\n(values quarters dimes nickels pennies)))))", "buggy_code": "(defun make-change (cents)\n\n\n\n(let ((quarters (round cents 25))\n(remaining-after-quarters (mod cents 25)))\n(let ((dimes (round remaining-after-quarters 10))\n(remaining-after-dimes (mod remaining-after-quarters 10)))\n(let ((nickels (round remaining-after-dimes 5))\n(pennies (mod remaining-after-dimes 5)))\n(values quarters dimes nickels pennies))))", "test": "(defun check ()\n;; 测试 'make-change' 函数。\n(multiple-value-bind (quarters dimes nickels pennies) (make-change 98)\n(assert (equal quarters 3))\n(assert (equal dimes 2))\n(assert (equal nickels 0))\n(assert (equal pennies 3)))\n(multiple-value-bind (quarters dimes nickels pennies) (make-change 41)\n(assert (equal quarters 1))\n(assert (equal dimes 1))\n(assert (equal nickels 1))\n(assert (equal pennies 1)))\n(multiple-value-bind (quarters dimes nickels pennies) (make-change 3)\n(assert (equal quarters 0))\n(assert (equal dimes 0))\n(assert (equal nickels 0))\n(assert (equal pennies 3))))\n\n(check)", "instruction": "Observe the following faulty Clisp```lisp\n(defun make-change (cents)\n\n\n\n(let ((quarters (round cents 25))\n(remaining-after-quarters (mod cents 25)))\n(let ((dimes (round remaining-after-quarters 10))\n(remaining-after-dimes (mod remaining-after-quarters 10)))\n(let ((nickels (round remaining-after-dimes 5))\n(pennies (mod remaining-after-dimes 5)))\n(values quarters dimes nickels pennies))))\n```\n Fix bugs in the given code snippet. The fixed code must be placed between ```lisp```. Do not generate any test, main,example usage or check code!"}
{"question_id": "Clisp/11", "category": "Syntax", "subtype": "unclosed_parentheses", "level": "easy", "example": " (find-substring-index \"apple pie\" \"pie\")  Returns 6\n (find-substring-index \"hello world\" \"bye\")  Returns -1", "docstring": ";; Finds the first occurrence of the substring 'needle' within the string 'haystack'.\n;; Returns the index of the first character of the first occurrence of 'needle'.\n;; If 'needle' is not a part of 'haystack', returns -1.", "canonical_solution": "(defun find-substring-index (haystack needle)\n\n\n(let ((hay-len (length haystack))\n(need-len (length needle)))\n(if (zerop need-len)\n0\n(if (> need-len hay-len)\n-1\n(loop for i below (1+ (- hay-len need-len))\nwhen (string= (subseq haystack i (min (+ i need-len) hay-len)) needle)\nreturn i\nfinally (return -1))))))", "buggy_code": "(defun find-substring-index (haystack needle)\n\n\n(let ((hay-len (length haystack))\n(need-len (length needle)))\n(if (zerop need-len)\n0\n(if (> need-len hay-len)\n-1\n(loop for i below (1+ (- hay-len need-len))\nwhen (string= (subseq haystack i (min (+ i need-len) hay-len)) needle)\nreturn i\nfinally (return -1)))))", "test": "(defun check ()\n(assert (equal (find-substring-index \"apple pie\" \"pie\") 6))\n(assert (equal (find-substring-index \"hello world\" \"bye\") -1))\n(assert (equal (find-substring-index \"common lisp\" \"lisp\") 7))\n(assert (equal (find-substring-index \"quick brown fox\" \"brown\") 6))\n(assert (equal (find-substring-index \"abcdef\" \"de\") 3))\n(assert (equal (find-substring-index \"abcdef\" \"xyz\") -1)))\n\n(check)", "instruction": "Observe the following faulty Clisp```lisp\n(defun find-substring-index (haystack needle)\n\n\n(let ((hay-len (length haystack))\n(need-len (length needle)))\n(if (zerop need-len)\n0\n(if (> need-len hay-len)\n-1\n(loop for i below (1+ (- hay-len need-len))\nwhen (string= (subseq haystack i (min (+ i need-len) hay-len)) needle)\nreturn i\nfinally (return -1)))))\n```\n Fix bugs in the given code snippet. The fixed code must be placed between ```lisp```. Do not generate any test, main,example usage or check code!"}
{"question_id": "Clisp/12", "category": "Syntax", "subtype": "unclosed_parentheses", "level": "easy", "example": " (calculate-year-end-amount '(290 230 280 200 300 170 340 50 90 80 200 60))  Returns -7", "docstring": ";; Calculates whether Jinjin can follow her savings plan without running out of money in any month.\n;; 'monthly-budgets' is a list of 12 integers representing Jinjin's monthly budget.\n;; If successful, returns the total amount of money Jinjin will have by year-end, including 20% interest on savings.\n;; Otherwise, returns -X, where X is the first month Jinjin runs out of money.", "canonical_solution": "(defun calculate-year-end-amount (monthly-budgets)\n;; Calculates whether Jinjin can follow her savings plan without running out of money in any month.\n;; 'monthly-budgets' is a list of 12 integers representing Jinjin's monthly budget.\n;; If successful, returns the total amount of money Jinjin will have by year-end, including 20% interest on savings.\n;; Otherwise, returns -X, where X is the first month Jinjin runs out of money.\n;; Example:\n;; (calculate-year-end-amount '(290 230 280 200 300 170 340 50 90 80 200 60)) ;; Returns -7\n\n(let ((current-amount 0)\n(total-saved 0))\n(loop for month from 1 to 12\nfor budget in monthly-budgets\ndo (progn\n(incf current-amount 300) ;; Add monthly allowance\n(decf current-amount budget) ;; Subtract monthly budget\n(when (< current-amount 0)\n(return-from calculate-year-end-amount (- month))) ;; Check if Jinjin runs out of money\n(let ((savings (floor current-amount 100)))\n(decf current-amount (* 100 savings))\n(incf total-saved (* 100 savings))))\nfinally (return (+ current-amount (* total-saved 1.2)))))) ;; Calculate total with interest", "buggy_code": "(defun calculate-year-end-amount (monthly-budgets)\n\n\n(let ((current-amount 0)\n(total-saved 0))\n(loop for month from 1 to 12\nfor budget in monthly-budgets\ndo (progn\n(incf current-amount 300)\n(decf current-amount budget)\n(when (< current-amount 0)\n(return-from calculate-year-end-amount (- month)))\n(let ((savings (floor current-amount 100)))\n(decf current-amount (* 100 savings))\n(incf total-saved (* 100 savings))))\nfinally (return (+ current-amount (* total-saved 1.2)))))", "test": "(defun check ()\n(assert (equal (calculate-year-end-amount '(290 230 280 200 300 170 340 50 90 80 200 60)) -7))\n(assert (equal (calculate-year-end-amount '(100 100 100 100 100 100 100 100 100 100 100 100)) 2880.0)) ;; Assuming all savings\n(assert (equal (calculate-year-end-amount '(300 300 300 300 300 300 300 300 300 300 300 300)) 0.0)) ;; No savings\n(assert (equal (calculate-year-end-amount '(150 150 150 150 150 150 150 150 150 150 150 150)) 2160.0)) ;; Half savings\n(assert (equal (calculate-year-end-amount '(250 250 250 250 250 250 250 250 250 250 250 250)) 720.0))) ;; Runs out first month\n(check)", "instruction": "Observe the following faulty Clisp```lisp\n(defun calculate-year-end-amount (monthly-budgets)\n\n\n(let ((current-amount 0)\n(total-saved 0))\n(loop for month from 1 to 12\nfor budget in monthly-budgets\ndo (progn\n(incf current-amount 300)\n(decf current-amount budget)\n(when (< current-amount 0)\n(return-from calculate-year-end-amount (- month)))\n(let ((savings (floor current-amount 100)))\n(decf current-amount (* 100 savings))\n(incf total-saved (* 100 savings))))\nfinally (return (+ current-amount (* total-saved 1.2)))))\n```\n Fix bugs in the given code snippet. The fixed code must be placed between ```lisp```. Do not generate any test, main,example usage or check code!"}
{"question_id": "Clisp/13", "category": "Syntax", "subtype": "unclosed_parentheses", "level": "easy", "example": " >>> construct-preorder \"DBEAC\" \"DEBCA\"\n \"ABCDE\"\n >>> construct-preorder \"HGFEIDBA\" \"HGFIEDBA\"\n \"ABDEFGHI\"", "docstring": ";; This function reconstructs the preorder traversal of a binary tree from its inorder and postorder traversals.\n;; The nodes of the binary tree are represented by distinct uppercase letters.\n;; It is assumed that the tree has no more than 8 nodes.", "canonical_solution": "(defun construct-preorder (inorder postorder)\n\n\n(when (and inorder postorder (not (zerop (length postorder))))\n(let* ((root (char postorder (1- (length postorder))))\n(root-pos (position root inorder)))\n(concatenate 'string\n(string root)\n(construct-preorder (subseq inorder 0 root-pos)\n(subseq postorder 0 root-pos))\n(construct-preorder (subseq inorder (1+ root-pos))\n(subseq postorder root-pos (1- (length postorder))))))))", "buggy_code": "(defun construct-preorder (inorder postorder)\n\n\n(when (and inorder postorder (not (zerop (length postorder))))\n(let* ((root (char postorder (1- (length postorder))))\n(root-pos (position root inorder)))\n(concatenate 'string\n(string root)\n(construct-preorder (subseq inorder 0 root-pos)\n(subseq postorder 0 root-pos))\n(construct-preorder (subseq inorder (1+ root-pos))\n(subseq postorder root-pos (1- (length postorder)))))))", "test": "(defun check ()\n(assert (string= (construct-preorder \"DBEAC\" \"DEBCA\") \"ABDEC\"))\n(assert (string= (construct-preorder \"HGFEIDBA\" \"HGFIEDBA\") \"ABDEFGHI\"))\n(assert (string= (construct-preorder \"BADC\" \"BDCA\") \"ABCD\"))\n(assert (string= (construct-preorder \"FBAEDC\" \"FBEADC\") \"CDABFE\"))\n(assert (string= (construct-preorder \"A\" \"A\") \"A\")))\n\n(check)", "instruction": "Observe the following faulty Clisp```lisp\n(defun construct-preorder (inorder postorder)\n\n\n(when (and inorder postorder (not (zerop (length postorder))))\n(let* ((root (char postorder (1- (length postorder))))\n(root-pos (position root inorder)))\n(concatenate 'string\n(string root)\n(construct-preorder (subseq inorder 0 root-pos)\n(subseq postorder 0 root-pos))\n(construct-preorder (subseq inorder (1+ root-pos))\n(subseq postorder root-pos (1- (length postorder)))))))\n```\n Fix bugs in the given code snippet. The fixed code must be placed between ```lisp```. Do not generate any test, main,example usage or check code!"}
{"question_id": "Clisp/14", "category": "Syntax", "subtype": "unclosed_parentheses", "level": "easy", "example": " >>> count-output-sequences 3\n 5\n >>> count-output-sequences 4\n 14", "docstring": ";; This function calculates the total number of different output sequences that can be obtained by using a stack \n;; with operations push and pop on a sequence of numbers from 1 to n.\n;; The operations are: \n;; 1. Push the next number from the input sequence onto the stack.\n;; 2. Pop the top number from the stack and add it to the output sequence.\n;; It counts all the possible sequences of these operations that result in all numbers being moved from the input sequence to the output sequence.", "canonical_solution": "(defun count-output-sequences (n)\n\n\n(let ((dp (make-array (1+ n) :initial-element 0)))\n(setf (aref dp 0) 1)\n(loop for i from 1 to n do\n(loop for j from 0 to (1- i) do\n(incf (aref dp i) (* (aref dp j) (aref dp (1- (- i j)))))))\n(aref dp n)))", "buggy_code": "(defun count-output-sequences (n)\n\n\n(let ((dp (make-array (1+ n) :initial-element 0)))\n(setf (aref dp 0) 1)\n(loop for i from 1 to n do\n(loop for j from 0 to (1- i) do\n(incf (aref dp i) (* (aref dp j) (aref dp (1- (- i j))))))\n(aref dp n)))", "test": "(defun check ()\n(assert (equal (count-output-sequences 3) 5))\n(assert (equal (count-output-sequences 4) 14))\n(assert (equal (count-output-sequences 5) 42))\n(assert (equal (count-output-sequences 6) 132))\n(assert (equal (count-output-sequences 7) 429)))\n\n(check)", "instruction": "Observe the following faulty Clisp```lisp\n(defun count-output-sequences (n)\n\n\n(let ((dp (make-array (1+ n) :initial-element 0)))\n(setf (aref dp 0) 1)\n(loop for i from 1 to n do\n(loop for j from 0 to (1- i) do\n(incf (aref dp i) (* (aref dp j) (aref dp (1- (- i j))))))\n(aref dp n)))\n```\n Fix bugs in the given code snippet. The fixed code must be placed between ```lisp```. Do not generate any test, main,example usage or check code!"}
{"question_id": "Clisp/15", "category": "Syntax", "subtype": "unclosed_parentheses", "level": "easy", "example": " >>> list-to-dots '(a b c)\n (a . (b . (c . nil)))", "docstring": ";; takes a list and prints it in dot natation", "canonical_solution": "(defun list-to-dots (lst)\n\n\n(if (null lst)\n'nil\n(cons (car lst) (list-to-dots (cdr lst)))))", "buggy_code": "(defun list-to-dots (lst)\n\n\n(if (null lst)\n'nil\n(cons (car lst) (list-to-dots (cdr lst))))", "test": "(defun check ()\n;; 测试 'list-to-dots' 函数。\n(assert (equal (list-to-dots '(a b c)) '(a . (b . (c . nil)))))\n(assert (equal (list-to-dots '(1 2 3)) '(1 . (2 . (3 . nil)))))\n(assert (equal (list-to-dots '(x y)) '(x . (y . nil))))\n(assert (equal (list-to-dots '()) 'nil)))\n\n(check)", "instruction": "Observe the following faulty Clisp```lisp\n(defun list-to-dots (lst)\n\n\n(if (null lst)\n'nil\n(cons (car lst) (list-to-dots (cdr lst))))\n```\n Fix bugs in the given code snippet. The fixed code must be placed between ```lisp```. Do not generate any test, main,example usage or check code!"}
{"question_id": "Clisp/16", "category": "Syntax", "subtype": "unclosed_string", "level": "easy", "example": " >>> represent-as-powers-of-two(10)\n \"2+2(2()+2)\"\n >>> represent-as-powers-of-two(26)\n \"2+2(2()+2)+2(2(2))\"", "docstring": ";; This function takes a positive integer 'n' and returns its representation as a sum of powers of two. \n;; The powers are expressed in a specific format where a^b is represented as a(b), and terms are summed without spaces.\n;; Specifically, 2^0 is represented as 2()\n;; This function joins a list of strings with a given separator.", "canonical_solution": "(defun represent-as-powers-of-two (n)\n;; This function takes a positive integer 'n' and returns its representation as a sum of powers of two. \n;; The powers are expressed in a specific format where a^b is represented as a(b), and terms are summed without spaces.\n;; Specifically, 2^0 is represented as 2()\n;; Example:\n;; >>> represent-as-powers-of-two(10)\n;; \"2+2(2()+2)\"\n;; >>> represent-as-powers-of-two(26)\n;; \"2+2(2()+2)+2(2(2))\"\n\n(let ((result '()) (power 0))\n(loop while (> n 0)\ndo (progn\n(when (> (logand n 1) 0)\n(push (if (= power 1) \"2\" (format nil \"2(~a)\" (represent-as-powers-of-two power))) result))\n(setq power (+ power 1))\n(setq n (ash n -1))))\n(string-join (reverse result) \"+\")))\n(defun string-join (list separator)\n;; This function joins a list of strings with a given separator.\n(with-output-to-string (stream)\n(when list\n(write-string (first list) stream)\n(dolist (item (rest list))\n(write-string separator stream)\n(write-string item stream)))))", "buggy_code": "(defun represent-as-powers-of-two (n)\n;; This function takes a positive integer 'n' and returns its representation as a sum of powers of two. \n;; The powers are expressed in a specific format where a^b is represented as a(b), and terms are summed without spaces.\n;; Specifically, 2^0 is represented as 2()\n\n(let ((result '()) (power 0))\n(loop while (> n 0)\ndo (progn\n(when (> (logand n 1) 0)\n(push (if (= power 1) \"2\" (format nil \"2(~a) (represent-as-powers-of-two power))) result))\n(setq power (+ power 1))\n(setq n (ash n -1))))\n(string-join (reverse result) \"+\")))\n(defun string-join (list separator)\n;; This function joins a list of strings with a given separator.\n(with-output-to-string (stream)\n(when list\n(write-string (first list) stream)\n(dolist (item (rest list))\n(write-string separator stream)\n(write-string item stream)))))", "test": "(defun check ()\n(assert (equal (represent-as-powers-of-two 10) \"2+2(2()+2)\"))\n(assert (equal (represent-as-powers-of-two 26) \"2+2(2()+2)+2(2(2))\"))\n(assert (equal (represent-as-powers-of-two 1) \"2()\"))\n(assert (equal (represent-as-powers-of-two 31) \"2()+2+2(2)+2(2()+2)+2(2(2))\"))\n(assert (equal (represent-as-powers-of-two 100) \"2(2)+2(2()+2(2))+2(2+2(2))\")))\n\n(check)", "instruction": "Observe the following faulty Clisp```lisp\n(defun represent-as-powers-of-two (n)\n;; This function takes a positive integer 'n' and returns its representation as a sum of powers of two. \n;; The powers are expressed in a specific format where a^b is represented as a(b), and terms are summed without spaces.\n;; Specifically, 2^0 is represented as 2()\n\n(let ((result '()) (power 0))\n(loop while (> n 0)\ndo (progn\n(when (> (logand n 1) 0)\n(push (if (= power 1) \"2\" (format nil \"2(~a) (represent-as-powers-of-two power))) result))\n(setq power (+ power 1))\n(setq n (ash n -1))))\n(string-join (reverse result) \"+\")))\n(defun string-join (list separator)\n;; This function joins a list of strings with a given separator.\n(with-output-to-string (stream)\n(when list\n(write-string (first list) stream)\n(dolist (item (rest list))\n(write-string separator stream)\n(write-string item stream)))))\n```\n Fix bugs in the given code snippet. The fixed code must be placed between ```lisp```. Do not generate any test, main,example usage or check code!"}
{"question_id": "Clisp/17", "category": "Reference", "subtype": "faulty_indexing", "level": "easy", "example": " (divisible-five-digit-numbers 15)  Returns (22555 25555 28555 30000)\n (divisible-five-digit-numbers 7)  Returns a list of numbers or 'No' if no such numbers exist", "docstring": ";; Finds all five-digit numbers between 10000 and 30000 where three sub-numbers \n;; (formed by consecutive digits) are divisible by 'k'.\n;; Each sub-number consists of three consecutive digits from the original number.\n;; The function returns a list of such five-digit numbers.", "canonical_solution": "(defun divisible-five-digit-numbers (k)\n\n\n(let ((results '()))\n(loop for num from 10000 to 30000\nwhen (and (zerop (mod (parse-integer (subseq (write-to-string num) 0 3)) k))\n(zerop (mod (parse-integer (subseq (write-to-string num) 1 4)) k))\n(zerop (mod (parse-integer (subseq (write-to-string num) 2 5)) k)))\ndo (push num results))\n(if (null results)\n'No\n(nreverse results))))", "buggy_code": "(defun divisible-five-digit-numbers (k)\n\n\n(let ((results '()))\n(loop for num from 10000 to 30000\nwhen (and (zerop (mod (parse-integer (subseq (write-to-string num) 1 3)) k))\n(zerop (mod (parse-integer (subseq (write-to-string num) 2 4)) k))\n(zerop (mod (parse-integer (subseq (write-to-string num) 3 5)) k)))\ndo (push num results))\n(if (null results)\n'No\n(nreverse results))))", "test": "(defun check ()\n(assert (equal (divisible-five-digit-numbers 15) '(22555 25555 28555 30000)))\n(assert (equal (divisible-five-digit-numbers 31) '(15589 18682))) ;; No such numbers exist\n(assert (equal (divisible-five-digit-numbers 999) 'No))) ;; No such numbers exist for a large divisor\n\n(check)", "instruction": "Observe the following faulty Clisp```lisp\n(defun divisible-five-digit-numbers (k)\n\n\n(let ((results '()))\n(loop for num from 10000 to 30000\nwhen (and (zerop (mod (parse-integer (subseq (write-to-string num) 1 3)) k))\n(zerop (mod (parse-integer (subseq (write-to-string num) 2 4)) k))\n(zerop (mod (parse-integer (subseq (write-to-string num) 3 5)) k)))\ndo (push num results))\n(if (null results)\n'No\n(nreverse results))))\n```\n Fix bugs in the given code snippet. The fixed code must be placed between ```lisp```. Do not generate any test, main,example usage or check code!"}
{"question_id": "Clisp/18", "category": "Reference", "subtype": "faulty_indexing", "level": "easy", "example": " >>> construct-preorder \"DBEAC\" \"DEBCA\"\n \"ABCDE\"\n >>> construct-preorder \"HGFEIDBA\" \"HGFIEDBA\"\n \"ABDEFGHI\"", "docstring": ";; This function reconstructs the preorder traversal of a binary tree from its inorder and postorder traversals.\n;; The nodes of the binary tree are represented by distinct uppercase letters.\n;; It is assumed that the tree has no more than 8 nodes.", "canonical_solution": "(defun construct-preorder (inorder postorder)\n\n\n(when (and inorder postorder (not (zerop (length postorder))))\n(let* ((root (char postorder (1- (length postorder))))\n(root-pos (position root inorder)))\n(concatenate 'string\n(string root)\n(construct-preorder (subseq inorder 0 root-pos)\n(subseq postorder 0 root-pos))\n(construct-preorder (subseq inorder (1+ root-pos))\n(subseq postorder root-pos (1- (length postorder))))))))", "buggy_code": "(defun construct-preorder (inorder postorder)\n\n\n\n(when (and inorder postorder (not (zerop (length postorder))))\n(let* ((root (char postorder (1- (length postorder))))\n(root-pos (position root inorder)))\n(concatenate 'string\n(string root)\n(construct-preorder (subseq inorder 0 root-pos)\n(subseq postorder 0 root-pos))\n(construct-preorder (subseq inorder  root-pos)\n(subseq postorder root-pos (1- (length postorder))))))))", "test": "(defun check ()\n(assert (string= (construct-preorder \"DBEAC\" \"DEBCA\") \"ABDEC\"))\n(assert (string= (construct-preorder \"HGFEIDBA\" \"HGFIEDBA\") \"ABDEFGHI\"))\n(assert (string= (construct-preorder \"BADC\" \"BDCA\") \"ABCD\"))\n(assert (string= (construct-preorder \"FBAEDC\" \"FBEADC\") \"CDABFE\"))\n(assert (string= (construct-preorder \"A\" \"A\") \"A\")))\n\n(check)", "instruction": "Observe the following faulty Clisp```lisp\n(defun construct-preorder (inorder postorder)\n\n\n\n(when (and inorder postorder (not (zerop (length postorder))))\n(let* ((root (char postorder (1- (length postorder))))\n(root-pos (position root inorder)))\n(concatenate 'string\n(string root)\n(construct-preorder (subseq inorder 0 root-pos)\n(subseq postorder 0 root-pos))\n(construct-preorder (subseq inorder  root-pos)\n(subseq postorder root-pos (1- (length postorder))))))))\n```\n Fix bugs in the given code snippet. The fixed code must be placed between ```lisp```. Do not generate any test, main,example usage or check code!"}
{"question_id": "Clisp/19", "category": "Reference", "subtype": "function_error", "level": "easy", "example": " >>> parse-date \"16 Aug 1980\"\n 16 8 1980", "docstring": "", "canonical_solution": "(defun parse-date (date-str)\n\"Parse a date string in the format 'DD MMM YYYY' and return a list (day month year).\"\n\n\n(let ((toks (tokens date-str #'constituent 0)))\n(list (parse-integer (first toks):junk-allowed t)\n(parse-month (second toks))\n(parse-integer (third toks)))))\n\n(defun tokens (str test start)\n(let ((p1 (position-if test str :start start)))\n(if p1\n(let ((p2 (position-if #'(lambda (c)\n(not (funcall test c)))\nstr :start p1)))\n(cons (subseq str p1 p2)\n(if p2\n(tokens str test p2)\nnil)))\nnil)))\n(defun constituent (c)\n(and (graphic-char-p c)\n(not (char= c #\\ ))))\n\n(defconstant month-names\n'(\"jan\" \"feb\" \"mar\" \"apr\" \"may\" \"jun\"\n\"jul\" \"aug\" \"sep\" \"oct\" \"nov\" \"dec\"))\n\n(defun parse-month (str)\n\"Parse the month string and return the month number.\"\n(let ((p (position (string-downcase str) month-names :test #'string-equal)))\n(if p\n(1+ p)\n(error \"Invalid month string: ~A\" str))))", "buggy_code": "(defun parse-date (date-str)\n\"Parse a date string in the format 'DD MMM YYYY' and return a list (day month year).\"\n\n\n(let ((toks (tokens date-str #'constituent)))\n(list (parse-integer (first toks):junk-allowed t)\n(parse-month (second toks))\n(parse-integer (third toks)))))\n\n(defun tokens (str test start)\n(let ((p1 (position-if test str :start start)))\n(if p1\n(let ((p2 (position-if #'(lambda (c)\n(not (funcall test c)))\nstr :start p1)))\n(cons (subseq str p1 p2)\n(if p2\n(tokens str test p2)\nnil)))\nnil)))\n\n(defun constituent (c)\n(and (graphic-char-p c)\n(not (char= c #\\ ))))\n\n(defconstant month-names\n'(\"jan\" \"feb\" \"mar\" \"apr\" \"may\" \"jun\"\n\"jul\" \"aug\" \"sep\" \"oct\" \"nov\" \"dec\"))\n\n(defun parse-month (str)\n\"Parse the month string and return the month number.\"\n(let ((p (position (string-downcase str) month-names :test #'string-equal)))\n(if p\n(1+ p)\n(error \"Invalid month string: ~A\" str))))", "test": "(defun check ()\n;; Test the 'parse-date' function with various date strings.\n(assert (equal (parse-date \"16 Aug 1980\") '(16 8 1980)))\n(assert (equal (parse-date \"1 Jan 2023\") '(1 1 2023)))\n(assert (equal (parse-date \"25 Dec 1999\") '(25 12 1999)))\n(assert (equal (parse-date \"31 Oct 2025\") '(31 10 2025)))\n(assert (equal (parse-date \"20 Feb 2010\") '(20 2 2010))))\n\n(check)", "instruction": "Observe the following faulty Clisp```lisp\n(defun parse-date (date-str)\n\"Parse a date string in the format 'DD MMM YYYY' and return a list (day month year).\"\n\n\n(let ((toks (tokens date-str #'constituent)))\n(list (parse-integer (first toks):junk-allowed t)\n(parse-month (second toks))\n(parse-integer (third toks)))))\n\n(defun tokens (str test start)\n(let ((p1 (position-if test str :start start)))\n(if p1\n(let ((p2 (position-if #'(lambda (c)\n(not (funcall test c)))\nstr :start p1)))\n(cons (subseq str p1 p2)\n(if p2\n(tokens str test p2)\nnil)))\nnil)))\n\n(defun constituent (c)\n(and (graphic-char-p c)\n(not (char= c #\\ ))))\n\n(defconstant month-names\n'(\"jan\" \"feb\" \"mar\" \"apr\" \"may\" \"jun\"\n\"jul\" \"aug\" \"sep\" \"oct\" \"nov\" \"dec\"))\n\n(defun parse-month (str)\n\"Parse the month string and return the month number.\"\n(let ((p (position (string-downcase str) month-names :test #'string-equal)))\n(if p\n(1+ p)\n(error \"Invalid month string: ~A\" str))))\n```\n Fix bugs in the given code snippet. The fixed code must be placed between ```lisp```. Do not generate any test, main,example usage or check code!"}
{"question_id": "Clisp/20", "category": "Reference", "subtype": "illegal_keyword", "level": "easy", "example": " quicksort '(3 1 4 1 5 9 2 6 5 3 5)\n 1 1 2 3 3 4 5 5 5 6 9", "docstring": ";; Quickly sort the list", "canonical_solution": "(defun quicksort (list)\n\n\n(if (null list)\nnil\n(let ((pivot (first list))\n(rest (rest list)))\n(append (quicksort (remove-if-not #'(lambda (x) (< x pivot)) rest))\n(list pivot)\n(quicksort (remove-if #'(lambda (x) (< x pivot)) rest))))))", "buggy_code": "(defun quicksort (list)\n\n\n(if (null list)\nnull\n(let ((pivot (first list))\n(rest (rest list)))\n(append (quicksort (remove-if-not #'(lambda (x) (< x pivot)) rest))\n(list pivot)\n(quicksort (remove-if #'(lambda (x) (< x pivot)) rest))))))", "test": "(defun check ()\n;; 测试 'quicksort' 函数。\n(assert (equal (quicksort '(3 1 4 1 5 9 2 6 5 3 5)) '(1 1 2 3 3 4 5 5 5 6 9)))\n(assert (equal (quicksort '(5 4 3 2 1)) '(1 2 3 4 5)))\n(assert (equal (quicksort '()) '()))\n(assert (equal (quicksort '(1)) '(1))))\n\n(check)\n\n;;fragment:null\n;;level:easy", "instruction": "Observe the following faulty Clisp```lisp\n(defun quicksort (list)\n\n\n(if (null list)\nnull\n(let ((pivot (first list))\n(rest (rest list)))\n(append (quicksort (remove-if-not #'(lambda (x) (< x pivot)) rest))\n(list pivot)\n(quicksort (remove-if #'(lambda (x) (< x pivot)) rest))))))\n```\n Fix bugs in the given code snippet. The fixed code must be placed between ```lisp```. Do not generate any test, main,example usage or check code!"}
{"question_id": "Clisp/21", "category": "Reference", "subtype": "illegal_keyword", "level": "easy", "example": " >>> count-output-sequences 3\n 5\n >>> count-output-sequences 4\n 14", "docstring": ";; This function calculates the total number of different output sequences that can be obtained by using a stack \n;; with operations push and pop on a sequence of numbers from 1 to n.\n;; The operations are: \n;; 1. Push the next number from the input sequence onto the stack.\n;; 2. Pop the top number from the stack and add it to the output sequence.\n;; It counts all the possible sequences of these operations that result in all numbers being moved from the input sequence to the output sequence.", "canonical_solution": "(defun count-output-sequences (n)\n\n\n(let ((dp (make-array (1+ n) :initial-element 0)))\n(setf (aref dp 0) 1)\n(loop for i from 1 to n do\n(loop for j from 0 to (1- i) do\n(incf (aref dp i) (* (aref dp j) (aref dp (1- (- i j)))))))\n(aref dp n)))", "buggy_code": "(defun count-output-sequences (n)\n\n\n(let ((dp (make-array (1+ n) :initialelement 0)))\n(setf (aref dp 0) 1)\n(loop for i from 1 to n do\n(loop for j from 0 to (1- i) do\n(incf (aref dp i) (* (aref dp j) (aref dp (1- (- i j)))))))\n(aref dp n)))", "test": "(defun check ()\n(assert (equal (count-output-sequences 3) 5))\n(assert (equal (count-output-sequences 4) 14))\n(assert (equal (count-output-sequences 5) 42))\n(assert (equal (count-output-sequences 6) 132))\n(assert (equal (count-output-sequences 7) 429)))\n\n(check)", "instruction": "Observe the following faulty Clisp```lisp\n(defun count-output-sequences (n)\n\n\n(let ((dp (make-array (1+ n) :initialelement 0)))\n(setf (aref dp 0) 1)\n(loop for i from 1 to n do\n(loop for j from 0 to (1- i) do\n(incf (aref dp i) (* (aref dp j) (aref dp (1- (- i j)))))))\n(aref dp n)))\n```\n Fix bugs in the given code snippet. The fixed code must be placed between ```lisp```. Do not generate any test, main,example usage or check code!"}
{"question_id": "Clisp/22", "category": "Reference", "subtype": "undefined_methods", "level": "easy", "example": " >>> parse-date \"16 Aug 1980\"\n 16 8 1980", "docstring": "", "canonical_solution": "(defun parse-date (date-str)\n\"Parse a date string in the format 'DD MMM YYYY' and return a list (day month year).\"\n\n\n(let ((toks (tokens date-str #'constituent 0)))\n(list (parse-integer (first toks):junk-allowed t)\n(parse-month (second toks))\n(parse-integer (third toks)))))\n\n(defun tokens (str test start)\n(let ((p1 (position-if test str :start start)))\n(if p1\n(let ((p2 (position-if #'(lambda (c)\n(not (funcall test c)))\nstr :start p1)))\n(cons (subseq str p1 p2)\n(if p2\n(tokens str test p2)\nnil)))\nnil)))\n(defun constituent (c)\n(and (graphic-char-p c)\n(not (char= c #\\ ))))\n\n(defconstant month-names\n'(\"jan\" \"feb\" \"mar\" \"apr\" \"may\" \"jun\"\n\"jul\" \"aug\" \"sep\" \"oct\" \"nov\" \"dec\"))\n\n(defun parse-month (str)\n\"Parse the month string and return the month number.\"\n(let ((p (position (string-downcase str) month-names :test #'string-equal)))\n(if p\n(1+ p)\n(error \"Invalid month string: ~A\" str))))", "buggy_code": "(defun parse-date (date-str)\n\"Parse a date string in the format 'DD MMM YYYY' and return a list (day month year).\"\n\n(let ((toks (tokens date-str #'constituent 0)))\n(list (parse-integer (first toks):junk-allowed t)\n(parse-month (second toks))\n(parse-integer (third toks)))))\n\n(defun tokens (str test start)\n(let ((p1 (position-if test str :start start)))\n(if p1\n(let ((p2 (position-if #'(lambda (c)\n(not (funcall test c)))\nstr :start p1)))\n(cons (subseq str p1 p2)\n(if p2\n(tokens str test p2)\nnil)))\nnil)))\n\n(defconstant month-names\n'(\"jan\" \"feb\" \"mar\" \"apr\" \"may\" \"jun\"\n\"jul\" \"aug\" \"sep\" \"oct\" \"nov\" \"dec\"))\n\n(defun parse-month (str)\n\"Parse the month string and return the month number.\"\n(let ((p (position (string-downcase str) month-names :test #'string-equal)))\n(if p\n(1+ p)\n(error \"Invalid month string: ~A\" str))))", "test": "(defun check ()\n;; Test the 'parse-date' function with various date strings.\n(assert (equal (parse-date \"16 Aug 1980\") '(16 8 1980)))\n(assert (equal (parse-date \"1 Jan 2023\") '(1 1 2023)))\n(assert (equal (parse-date \"25 Dec 1999\") '(25 12 1999)))\n(assert (equal (parse-date \"31 Oct 2025\") '(31 10 2025)))\n(assert (equal (parse-date \"20 Feb 2010\") '(20 2 2010))))\n\n(check)", "instruction": "Observe the following faulty Clisp```lisp\n(defun parse-date (date-str)\n\"Parse a date string in the format 'DD MMM YYYY' and return a list (day month year).\"\n\n(let ((toks (tokens date-str #'constituent 0)))\n(list (parse-integer (first toks):junk-allowed t)\n(parse-month (second toks))\n(parse-integer (third toks)))))\n\n(defun tokens (str test start)\n(let ((p1 (position-if test str :start start)))\n(if p1\n(let ((p2 (position-if #'(lambda (c)\n(not (funcall test c)))\nstr :start p1)))\n(cons (subseq str p1 p2)\n(if p2\n(tokens str test p2)\nnil)))\nnil)))\n\n(defconstant month-names\n'(\"jan\" \"feb\" \"mar\" \"apr\" \"may\" \"jun\"\n\"jul\" \"aug\" \"sep\" \"oct\" \"nov\" \"dec\"))\n\n(defun parse-month (str)\n\"Parse the month string and return the month number.\"\n(let ((p (position (string-downcase str) month-names :test #'string-equal)))\n(if p\n(1+ p)\n(error \"Invalid month string: ~A\" str))))\n```\n Fix bugs in the given code snippet. The fixed code must be placed between ```lisp```. Do not generate any test, main,example usage or check code!"}
{"question_id": "Clisp/23", "category": "Reference", "subtype": "undefined_methods", "level": "easy", "example": " >>> represent-as-powers-of-two(10)\n \"2+2(2()+2)\"\n >>> represent-as-powers-of-two(26)\n \"2+2(2()+2)+2(2(2))\"", "docstring": ";; This function takes a positive integer 'n' and returns its representation as a sum of powers of two. \n;; The powers are expressed in a specific format where a^b is represented as a(b), and terms are summed without spaces.\n;; Specifically, 2^0 is represented as 2()", "canonical_solution": "(defun represent-as-powers-of-two (n)\n;; This function takes a positive integer 'n' and returns its representation as a sum of powers of two. \n;; The powers are expressed in a specific format where a^b is represented as a(b), and terms are summed without spaces.\n;; Specifically, 2^0 is represented as 2()\n;; Example:\n;; >>> represent-as-powers-of-two(10)\n;; \"2+2(2()+2)\"\n;; >>> represent-as-powers-of-two(26)\n;; \"2+2(2()+2)+2(2(2))\"\n\n(let ((result '()) (power 0))\n(loop while (> n 0)\ndo (progn\n(when (> (logand n 1) 0)\n(push (if (= power 1) \"2\" (format nil \"2(~a)\" (represent-as-powers-of-two power))) result))\n(setq power (+ power 1))\n(setq n (ash n -1))))\n(string-join (reverse result) \"+\")))\n(defun string-join (list separator)\n;; This function joins a list of strings with a given separator.\n(with-output-to-string (stream)\n(when list\n(write-string (first list) stream)\n(dolist (item (rest list))\n(write-string separator stream)\n(write-string item stream)))))", "buggy_code": "(defun represent-as-powers-of-two (n)\n\n\n(let ((result '()) (power 0))\n(loop while (> n 0)\ndo (progn\n(when (> (logand n 1) 0)\n(push (if (= power 1) \"2\" (format nil \"2(~a)\" (represent-as-powers-of-two power))) result))\n(setq power (+ power 1))\n(setq n (ash n -1))))\n(string-join (reverse result) \"+\")))", "test": "(defun check ()\n(assert (equal (represent-as-powers-of-two 10) \"2+2(2()+2)\"))\n(assert (equal (represent-as-powers-of-two 26) \"2+2(2()+2)+2(2(2))\"))\n(assert (equal (represent-as-powers-of-two 1) \"2()\"))\n(assert (equal (represent-as-powers-of-two 31) \"2()+2+2(2)+2(2()+2)+2(2(2))\"))\n(assert (equal (represent-as-powers-of-two 100) \"2(2)+2(2()+2(2))+2(2+2(2))\")))\n\n(check)", "instruction": "Observe the following faulty Clisp```lisp\n(defun represent-as-powers-of-two (n)\n\n\n(let ((result '()) (power 0))\n(loop while (> n 0)\ndo (progn\n(when (> (logand n 1) 0)\n(push (if (= power 1) \"2\" (format nil \"2(~a)\" (represent-as-powers-of-two power))) result))\n(setq power (+ power 1))\n(setq n (ash n -1))))\n(string-join (reverse result) \"+\")))\n```\n Fix bugs in the given code snippet. The fixed code must be placed between ```lisp```. Do not generate any test, main,example usage or check code!"}
{"question_id": "Clisp/24", "category": "Reference", "subtype": "undefined_objects", "level": "easy", "example": " >>> move-first-instance-to-front 'b '(a b c d)\n b a c d", "docstring": ";; Define a function that takes two input parameters, object and queue, and can destructively move the first instance of object (eql equivalently) to the beginning of the queue", "canonical_solution": "(defun move-first-instance-to-front (object queue)\n\n\n(cond ((null queue) nil) \n((eql (first queue) object) queue) \n(t \n(let ((prev nil)\n(current queue))\n(loop while (and current (not (eql (first current) object)))\ndo (setq prev current)\n(setq current (rest current)))\n(if current \n(progn\n(when prev (setf (rest prev) (rest current))) \n(cons object (if prev queue (rest current)))) \nqueue)))))", "buggy_code": "(defun move-first-instance-to-front (object queue)\n\n\n(cond ((null queue) nil) \n((eql (first queue) object) queue) \n(t \n(current queue))\n(loop while (and current (not (eql (first current) object)))\ndo (setq prev current)\n(setq current (rest current)))\n(if current \n(progn\n(when prev (setf (rest prev) (rest current))) \n(cons object (if prev queue (rest current)))) \nqueue)))", "test": "(defun check ()\n(assert (equal (move-first-instance-to-front 'b '(a b c d)) '(b a c d)))\n(assert (equal (move-first-instance-to-front 'a '(a b c d)) '(a b c d)))\n(assert (equal (move-first-instance-to-front 'e '(a b c d)) '(a b c d)))\n(assert (equal (move-first-instance-to-front 'd '(a b c d)) '(d a b c))))\n\n(check)", "instruction": "Observe the following faulty Clisp```lisp\n(defun move-first-instance-to-front (object queue)\n\n\n(cond ((null queue) nil) \n((eql (first queue) object) queue) \n(t \n(current queue))\n(loop while (and current (not (eql (first current) object)))\ndo (setq prev current)\n(setq current (rest current)))\n(if current \n(progn\n(when prev (setf (rest prev) (rest current))) \n(cons object (if prev queue (rest current)))) \nqueue)))\n```\n Fix bugs in the given code snippet. The fixed code must be placed between ```lisp```. Do not generate any test, main,example usage or check code!"}
{"question_id": "Clisp/25", "category": "Reference", "subtype": "undefined_objects", "level": "easy", "example": " >>> count-digit-two 2 22\n 6\n >>> count-digit-two 10 25\n 9", "docstring": ";; This function counts the occurrences of the digit '2' in all integers within a given range [L, R].\n;; Both L and R are inclusive.\n;; It iterates through each number in the range and counts how many times '2' appears in each number.", "canonical_solution": "(defun count-digit-two (L R)\n\n\n(let ((count 0))\n(loop for i from L to R do\n(loop for char across (write-to-string i) do\n(when (char= char #\\2) (incf count))))\ncount))", "buggy_code": "(defun count-digit-two (L R)\n\n\n(loop for i from L to R do\n(loop for char across (write-to-string i) do\n(when (char= char #\\2) (incf count))))\ncount)", "test": "(defun check ()\n(assert (equal (count-digit-two 2 22) 6))\n(assert (equal (count-digit-two 10 25) 8))\n(assert (equal (count-digit-two 1 100) 20))\n(assert (equal (count-digit-two 29 55) 4))\n(assert (equal (count-digit-two 200 250) 66)))\n\n(check)", "instruction": "Observe the following faulty Clisp```lisp\n(defun count-digit-two (L R)\n\n\n(loop for i from L to R do\n(loop for char across (write-to-string i) do\n(when (char= char #\\2) (incf count))))\ncount)\n```\n Fix bugs in the given code snippet. The fixed code must be placed between ```lisp```. Do not generate any test, main,example usage or check code!"}
{"question_id": "Clisp/26", "category": "Logic", "subtype": "algorithm_error", "level": "easy", "example": ">>> occurrences '(a b a d a c d c a)\n(a . 4) (c . 2) (d . 2) (b . 1)", "docstring": ";; takes a list and returns a list indicating the number of times each (eql) element appears, sorted from most common element to least common", "canonical_solution": "(defun occurrences (lst)\n\n\n(let ((result nil))\n(dolist (obj lst)\n(if (null (assoc obj result))\n(push (cons obj 1) result)\n(incf (cdr (assoc obj result)))\n))\n(sort result #'(lambda (a b) (if (> (cdr a) (cdr b)) t nil)))))", "buggy_code": "(defun occurrences (lst)\n\n\n(let ((result nil))\n(dolist (obj lst)\n(if (null (assoc obj result))\n(push (cons obj 1) result)\n(incf (cdr (assoc obj result)))\n))\n(sort result #'(lambda (a b) (if (> a b) t nil)))))", "test": "(defun check ()\n;; 测试 'occurrences' 函数。\n(assert (equal (occurrences '(a b a d a c d c a)) '((a . 4) (c . 2) (d . 2) (b . 1))))\n(assert (equal (occurrences '(1 2 2 3 3 3)) '((3 . 3) (2 . 2) (1 . 1))))\n(assert (equal (occurrences '(a b a)) '((a . 2) (b . 1)))))\n\n(check)", "instruction": "Observe the following faulty Clisp```lisp\n(defun occurrences (lst)\n\n\n(let ((result nil))\n(dolist (obj lst)\n(if (null (assoc obj result))\n(push (cons obj 1) result)\n(incf (cdr (assoc obj result)))\n))\n(sort result #'(lambda (a b) (if (> a b) t nil)))))\n```\n Fix bugs in the given code snippet. The fixed code must be placed between ```lisp```. Do not generate any test, main,example usage or check code!"}
{"question_id": "Clisp/27", "category": "Logic", "subtype": "algorithm_error", "level": "easy", "example": "quicksort '(3 1 4 1 5 9 2 6 5 3 5)v\n1 1 2 3 3 4 5 5 5 6 9", "docstring": ";; Quickly sort the list", "canonical_solution": "(defun quicksort (list)\n\n\n(if (null list)\nnil\n(let ((pivot (first list))\n(rest (rest list)))\n(append (quicksort (remove-if-not #'(lambda (x) (< x pivot)) rest))\n(list pivot)\n(quicksort (remove-if #'(lambda (x) (< x pivot)) rest))))))", "buggy_code": "(defun quicksort (list)\n\n\n\n(let ((pivot (first list))\n(rest (rest list)))\n(append (quicksort (remove-if-not #'(lambda (x) (< x pivot)) rest))\n(list pivot)\n(quicksort (remove-if #'(lambda (x) (< x pivot)) rest)))))", "test": "(defun check ()\n;; 测试 'quicksort' 函数。\n(assert (equal (quicksort '(3 1 4 1 5 9 2 6 5 3 5)) '(1 1 2 3 3 4 5 5 5 6 9)))\n(assert (equal (quicksort '(5 4 3 2 1)) '(1 2 3 4 5)))\n(assert (equal (quicksort '()) '()))\n(assert (equal (quicksort '(1)) '(1))))\n\n(check)", "instruction": "Observe the following faulty Clisp```lisp\n(defun quicksort (list)\n\n\n\n(let ((pivot (first list))\n(rest (rest list)))\n(append (quicksort (remove-if-not #'(lambda (x) (< x pivot)) rest))\n(list pivot)\n(quicksort (remove-if #'(lambda (x) (< x pivot)) rest)))))\n```\n Fix bugs in the given code snippet. The fixed code must be placed between ```lisp```. Do not generate any test, main,example usage or check code!"}
{"question_id": "Clisp/28", "category": "Logic", "subtype": "algorithm_error", "level": "easy", "example": "(divisible-five-digit-numbers 15)  Returns (22555 25555 28555 30000)\n(divisible-five-digit-numbers 7)  Returns a list of numbers or 'No' if no such numbers exist", "docstring": ";; Finds all five-digit numbers between 10000 and 30000 where three sub-numbers \n;; (formed by consecutive digits) are divisible by 'k'.\n;; Each sub-number consists of three consecutive digits from the original number.\n;; The function returns a list of such five-digit numbers.", "canonical_solution": "(defun divisible-five-digit-numbers (k)\n\n\n(let ((results '()))\n(loop for num from 10000 to 30000\nwhen (and (zerop (mod (parse-integer (subseq (write-to-string num) 0 3)) k))\n(zerop (mod (parse-integer (subseq (write-to-string num) 1 4)) k))\n(zerop (mod (parse-integer (subseq (write-to-string num) 2 5)) k)))\ndo (push num results))\n(if (null results)\n'No\n(nreverse results))))", "buggy_code": "(defun divisible-five-digit-numbers (k)\n\n\n(let ((results '()))\n(loop for num from 10000 to 30000\nwhen (and (zerop (mod (parse-integer (subseq (write-to-string num) 0 3)) k))\n(zerop (mod (parse-integer (subseq (write-to-string num) 1 4)) k))\n(zerop (mod (parse-integer (subseq (write-to-string num) 2 5)) k)))\ndo (push num results))\n(if (null results)\n'No\n(results))))", "test": "(defun check ()\n(assert (equal (divisible-five-digit-numbers 15) '(22555 25555 28555 30000)))\n(assert (equal (divisible-five-digit-numbers 31) '(15589 18682))) ;; No such numbers exist\n(assert (equal (divisible-five-digit-numbers 999) 'No))) ;; No such numbers exist for a large divisor\n\n(check)", "instruction": "Observe the following faulty Clisp```lisp\n(defun divisible-five-digit-numbers (k)\n\n\n(let ((results '()))\n(loop for num from 10000 to 30000\nwhen (and (zerop (mod (parse-integer (subseq (write-to-string num) 0 3)) k))\n(zerop (mod (parse-integer (subseq (write-to-string num) 1 4)) k))\n(zerop (mod (parse-integer (subseq (write-to-string num) 2 5)) k)))\ndo (push num results))\n(if (null results)\n'No\n(results))))\n```\n Fix bugs in the given code snippet. The fixed code must be placed between ```lisp```. Do not generate any test, main,example usage or check code!"}
{"question_id": "Clisp/29", "category": "Logic", "subtype": "algorithm_error", "level": "easy", "example": ">>> count-prime-sums '(1 2 3 4) 2\n2 ; (1+2) and (3+4) are prime\n>>> count-prime-sums '(1 2 3 4 5 6) 3\n1 ; Only (1+2+5) is prime", "docstring": ";; This function counts the number of ways to select 'k' integers from a list of 'n' integers such that their sum is a prime number.\n;; It considers all possible combinations of 'k' integers from the list and checks if their sum is prime.", "canonical_solution": "(defun count-prime-sums (numbers k)\n\n\n(count t (mapcar (lambda (comb) (is-prime (reduce '+ comb)))\n(sum-combinations numbers k))))\n(defun is-prime (n)\n(cond ((<= n 1) nil)\n((= n 2) t)\n(t (loop for i from 2 to (isqrt n) never (zerop (mod n i))))))\n\n(defun sum-combinations (lst k)\n(if (= k 0)\n'(())\n(loop for i from 0 below (length lst)\nnconc (mapcar (lambda (x) (cons (nth i lst) x))\n(sum-combinations (subseq lst (1+ i)) (1- k))))))", "buggy_code": "(defun count-prime-sums (numbers k)\n\n\n\n(length t (mapcar (lambda (comb) (is-prime (reduce '+ comb)))\n(sum-combinations numbers k))))\n(defun is-prime (n)\n(cond ((<= n 1) nil)\n((= n 2) t)\n(t (loop for i from 2 to (isqrt n) never (zerop (mod n i))))))\n\n(defun sum-combinations (lst k)\n(if (= k 0)\n'(())\n(loop for i from 0 below (length lst)\nnconc (mapcar (lambda (x) (cons (nth i lst) x))\n(sum-combinations (subseq lst (1+ i)) (1- k))))))", "test": "(defun check ()\n(assert (equal (count-prime-sums '(3 7 12 19) 3) 1))\n(assert (equal (count-prime-sums '(1 2 3 4) 2) 4))\n(assert (equal (count-prime-sums '(1 2 3 4 5 6) 3) 6))\n(assert (equal (count-prime-sums '(10 20 30 40) 2) 0))\n(assert (equal (count-prime-sums '(11 13 17 19 23 29) 3) 12))) \n\n(check)", "instruction": "Observe the following faulty Clisp```lisp\n(defun count-prime-sums (numbers k)\n\n\n\n(length t (mapcar (lambda (comb) (is-prime (reduce '+ comb)))\n(sum-combinations numbers k))))\n(defun is-prime (n)\n(cond ((<= n 1) nil)\n((= n 2) t)\n(t (loop for i from 2 to (isqrt n) never (zerop (mod n i))))))\n\n(defun sum-combinations (lst k)\n(if (= k 0)\n'(())\n(loop for i from 0 below (length lst)\nnconc (mapcar (lambda (x) (cons (nth i lst) x))\n(sum-combinations (subseq lst (1+ i)) (1- k))))))\n```\n Fix bugs in the given code snippet. The fixed code must be placed between ```lisp```. Do not generate any test, main,example usage or check code!"}
{"question_id": "Clisp/30", "category": "Logic", "subtype": "condition_error", "level": "easy", "example": ">>> has_close_elements([1.0, 2.0, 3.0], 0.5)\nnil\n>>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\nt", "docstring": ";;Check if in given list of numbers, are any two numbers closer to each other than\n;;given threshold.", "canonical_solution": "(defun has-close-elements (numbers threshold)\n\n\n(loop for i from 0 below (length numbers)\ndo (loop for j from 0 below (length numbers)\ndo (when (and (/= i j)\n(< (abs (- (nth i numbers) (nth j numbers))) threshold))\n(return-from has-close-elements t))))\nnil)", "buggy_code": "(defun has-close-elements (numbers threshold)\n\n\n\n(loop for i from 0 below (length numbers)\ndo (loop for j from 0 below (length numbers)\ndo (when (and (/= i j)\n(> (abs (- (nth i numbers) (nth j numbers))) threshold))\n(return-from has-close-elements t))))\nnil)", "test": "(defun check ()\n(assert (equal (has-close-elements '(1.0 2.0 3.9 4.0 5.0 2.2) 0.3) t))\n(assert (equal (has-close-elements '(1.0 2.0 3.9 4.0 5.0 2.2) 0.05) nil))\n(assert (equal (has-close-elements '(1.0 2.0 5.9 4.0 5.0) 0.95) t))\n(assert (equal (has-close-elements '(1.0 2.0 5.9 4.0 5.0) 0.8) nil))\n(assert (equal (has-close-elements '(1.0 2.0 3.0 4.0 5.0 2.0) 0.1) t))\n(assert (equal (has-close-elements '(1.1 2.2 3.1 4.1 5.1) 1.0) t))\n(assert (equal (has-close-elements '(1.1 2.2 3.1 4.1 5.1) 0.5) nil)))\n\n(check)", "instruction": "Observe the following faulty Clisp```lisp\n(defun has-close-elements (numbers threshold)\n\n\n\n(loop for i from 0 below (length numbers)\ndo (loop for j from 0 below (length numbers)\ndo (when (and (/= i j)\n(> (abs (- (nth i numbers) (nth j numbers))) threshold))\n(return-from has-close-elements t))))\nnil)\n```\n Fix bugs in the given code snippet. The fixed code must be placed between ```lisp```. Do not generate any test, main,example usage or check code!"}
{"question_id": "Clisp/31", "category": "Logic", "subtype": "condition_error", "level": "medium", "example": ">>> segments-intersect? 0 0 1 1 1 0 0 1\nx 0.5\ny 0.5", "docstring": ";; Define a function that accepts 8 real numbers representing the endpoints of two line segments in two-dimensional space. If the line segments do not intersect, return false, or return two values representing the x and y coordinates of the intersection point", "canonical_solution": "(defun segments-intersect? (x1 y1 x2 y2 x3 y3 x4 y4)\n\n\n(let ((denom (- (* (- x2 x1) (- y4 y3)) (* (- y2 y1) (- x4 x3)))))\n(unless (zerop denom)\n(let* ((ua (/ (- (* (- x4 x3) (- y1 y3)) (* (- y4 y3) (- x1 x3))) denom))\n(ub (/ (- (* (- x2 x1) (- y1 y3)) (* (- y2 y1) (- x1 x3))) denom))\n(x-on-segment (+ x1 (* ua (- x2 x1))))\n(y-on-segment (+ y1 (* ua (- y2 y1)))))\n(when (and (>= ua 0) (<= ua 1) (>= ub 0) (<= ub 1))\n(values x-on-segment y-on-segment))))))\n\n(defun float-near-equal (a b &optional (tolerance 1e-5))\n(<= (abs (- a b)) tolerance))", "buggy_code": "(defun segments-intersect? (x1 y1 x2 y2 x3 y3 x4 y4)\n\n\n(let ((denom (- (* (- x2 x1) (- y4 y3)) (* (- y2 y1) (- x4 x3)))))\n(let* ((ua (/ (- (* (- x4 x3) (- y1 y3)) (* (- y4 y3) (- x1 x3))) denom))\n(ub (/ (- (* (- x2 x1) (- y1 y3)) (* (- y2 y1) (- x1 x3))) denom))\n(x-on-segment (+ x1 (* ua (- x2 x1))))\n(y-on-segment (+ y1 (* ua (- y2 y1)))))\n(when (and (>= ua 0) (<= ua 1) (>= ub 0) (<= ub 1))\n(values x-on-segment y-on-segment)))))\n\n(defun float-near-equal (a b &optional (tolerance 1e-5))\n(<= (abs (- a b)) tolerance))", "test": "(defun check ()\n(multiple-value-bind (x y) (segments-intersect? 0 0 1 1 1 0 0 1)\n(assert (and (float-near-equal x 0.5) (float-near-equal y 0.5))))\n(assert (null (segments-intersect? 0 0 1 1 2 2 3 3))))\n\n(check)", "instruction": "Observe the following faulty Clisp```lisp\n(defun segments-intersect? (x1 y1 x2 y2 x3 y3 x4 y4)\n\n\n(let ((denom (- (* (- x2 x1) (- y4 y3)) (* (- y2 y1) (- x4 x3)))))\n(let* ((ua (/ (- (* (- x4 x3) (- y1 y3)) (* (- y4 y3) (- x1 x3))) denom))\n(ub (/ (- (* (- x2 x1) (- y1 y3)) (* (- y2 y1) (- x1 x3))) denom))\n(x-on-segment (+ x1 (* ua (- x2 x1))))\n(y-on-segment (+ y1 (* ua (- y2 y1)))))\n(when (and (>= ua 0) (<= ua 1) (>= ub 0) (<= ub 1))\n(values x-on-segment y-on-segment)))))\n\n(defun float-near-equal (a b &optional (tolerance 1e-5))\n(<= (abs (- a b)) tolerance))\n```\n Fix bugs in the given code snippet. The fixed code must be placed between ```lisp```. Do not generate any test, main,example usage or check code!"}
{"question_id": "Clisp/32", "category": "Logic", "subtype": "condition_error", "level": "easy", "example": "(larger-prime-factor 15)  Returns 5\n(larger-prime-factor 33)  Returns 11", "docstring": ";; Finds the larger prime factor of a positive integer 'n', which is known to be the product of two distinct prime numbers.\n;; The function returns the larger of the two prime factors.", "canonical_solution": "(defun larger-prime-factor (n)\n\n\n(let ((factor 2))\n(loop while (> n factor)\nif (zerop (mod n factor))\ndo (setq n (/ n factor))\nelse\ndo (incf factor))\nn))", "buggy_code": "(defun larger-prime-factor (n)\n\n\n\n(let ((factor 2))\n(loop while (>= n factor)\nif (zerop (mod n factor))\ndo (setq n (/ n factor))\nelse\ndo (incf factor))\nn))", "test": "(defun check ()\n(assert (equal (larger-prime-factor 21) 7))\n(assert (equal (larger-prime-factor 15) 5))\n(assert (equal (larger-prime-factor 33) 11))\n(assert (equal (larger-prime-factor 35) 7))\n(assert (equal (larger-prime-factor 77) 11))\n(assert (equal (larger-prime-factor 26) 13)))\n\n(check)", "instruction": "Observe the following faulty Clisp```lisp\n(defun larger-prime-factor (n)\n\n\n\n(let ((factor 2))\n(loop while (>= n factor)\nif (zerop (mod n factor))\ndo (setq n (/ n factor))\nelse\ndo (incf factor))\nn))\n```\n Fix bugs in the given code snippet. The fixed code must be placed between ```lisp```. Do not generate any test, main,example usage or check code!"}
{"question_id": "Clisp/33", "category": "Logic", "subtype": "operation_error", "level": "easy", "example": "multiple-value-bind (quarters dimes nickels pennies) (make-change 98\nquarters 3\ndimes 2\nnickels 0\npennies 3", "docstring": ";; Define a function that accepts an integer cents and returns four values, displaying the numbers as 25-, 10-, 5-, 1-, using the minimum number of coins. (Translation: 25- is 25 cents, and so on)", "canonical_solution": "(defun make-change (cents)\n\n\n(let ((quarters (floor cents 25))\n(remaining-after-quarters (mod cents 25)))\n(let ((dimes (floor remaining-after-quarters 10))\n(remaining-after-dimes (mod remaining-after-quarters 10)))\n(let ((nickels (floor remaining-after-dimes 5))\n(pennies (mod remaining-after-dimes 5)))\n(values quarters dimes nickels pennies)))))", "buggy_code": "(defun make-change (cents)\n\n\n(let ((quarters (round cents 25))\n(remaining-after-quarters (mod cents 25)))\n(let ((dimes (round remaining-after-quarters 10))\n(remaining-after-dimes (mod remaining-after-quarters 10)))\n(let ((nickels (round remaining-after-dimes 5))\n(pennies (mod remaining-after-dimes 5)))\n(values quarters dimes nickels pennies)))))", "test": "(defun check ()\n;; 测试 'make-change' 函数。\n(multiple-value-bind (quarters dimes nickels pennies) (make-change 98)\n(assert (equal quarters 3))\n(assert (equal dimes 2))\n(assert (equal nickels 0))\n(assert (equal pennies 3)))\n(multiple-value-bind (quarters dimes nickels pennies) (make-change 41)\n(assert (equal quarters 1))\n(assert (equal dimes 1))\n(assert (equal nickels 1))\n(assert (equal pennies 1)))\n(multiple-value-bind (quarters dimes nickels pennies) (make-change 3)\n(assert (equal quarters 0))\n(assert (equal dimes 0))\n(assert (equal nickels 0))\n(assert (equal pennies 3))))\n\n(check)", "instruction": "Observe the following faulty Clisp```lisp\n(defun make-change (cents)\n\n\n(let ((quarters (round cents 25))\n(remaining-after-quarters (mod cents 25)))\n(let ((dimes (round remaining-after-quarters 10))\n(remaining-after-dimes (mod remaining-after-quarters 10)))\n(let ((nickels (round remaining-after-dimes 5))\n(pennies (mod remaining-after-dimes 5)))\n(values quarters dimes nickels pennies)))))\n```\n Fix bugs in the given code snippet. The fixed code must be placed between ```lisp```. Do not generate any test, main,example usage or check code!"}
{"question_id": "Clisp/34", "category": "Logic", "subtype": "operation_error", "level": "easy", "example": ">>> move-first-instance-to-front 'b '(a b c d)\nb a c d", "docstring": ";; Define a function that takes two input parameters, object and queue, and can destructively move the first instance of object (eql equivalently) to the beginning of the queue", "canonical_solution": "(defun move-first-instance-to-front (object queue)\n\n\n(cond ((null queue) nil) \n((eql (first queue) object) queue) \n(t \n(let ((prev nil)\n(current queue))\n(loop while (and current (not (eql (first current) object)))\ndo (setq prev current)\n(setq current (rest current)))\n(if current \n(progn\n(when prev (setf (rest prev) (rest current))) \n(cons object (if prev queue (rest current)))) \nqueue)))))", "buggy_code": "(defun move-first-instance-to-front (object queue)\n\n\n\n(cond ((null queue) nil) \n((eql (first queue) object) queue) \n(t \n(let ((prev nil)\n(current queue))\n(loop while (and current (not (eql (first current) object)))\ndo (setq prev current)\n(setq current (rest current)))\n(if current \n(progn\n(when prev (setq (rest prev) (rest current))) \n(cons object (if prev queue (rest current)))) \nqueue)))))", "test": "(defun check ()\n(assert (equal (move-first-instance-to-front 'b '(a b c d)) '(b a c d)))\n(assert (equal (move-first-instance-to-front 'a '(a b c d)) '(a b c d)))\n(assert (equal (move-first-instance-to-front 'e '(a b c d)) '(a b c d)))\n(assert (equal (move-first-instance-to-front 'd '(a b c d)) '(d a b c))))\n\n(check)", "instruction": "Observe the following faulty Clisp```lisp\n(defun move-first-instance-to-front (object queue)\n\n\n\n(cond ((null queue) nil) \n((eql (first queue) object) queue) \n(t \n(let ((prev nil)\n(current queue))\n(loop while (and current (not (eql (first current) object)))\ndo (setq prev current)\n(setq current (rest current)))\n(if current \n(progn\n(when prev (setq (rest prev) (rest current))) \n(cons object (if prev queue (rest current)))) \nqueue)))))\n```\n Fix bugs in the given code snippet. The fixed code must be placed between ```lisp```. Do not generate any test, main,example usage or check code!"}
{"question_id": "Clisp/35", "category": "Logic", "subtype": "operation_error", "level": "easy", "example": "(count-remaining-trees 10 '((2 5) (7 9)))  Returns 4\n(count-remaining-trees 15 '((1 3) (5 10)))  Returns 7", "docstring": ";; Counts the number of trees remaining on a road of length 'road-length' after removing trees in specified 'regions'.\n;; Each region is a list of two integers representing the start and end points on the road.\n;; The function returns the number of trees remaining after the removal.", "canonical_solution": "(defun count-remaining-trees (road-length regions)\n\n\n(let ((tree-map (make-array (1+ road-length) :initial-element t)))\n(dolist (region regions)\n(loop for i from (first region) to (second region)\ndo (setf (aref tree-map i) nil)))\n(count t tree-map)))", "buggy_code": "(defun count-remaining-trees (road-length regions)\n\n\n\n(let ((tree-map (make-array (1+ road-length) :initial-element t)))\n(dolist (region regions)\n(loop for i from (first region) to (second region)\ndo (setq (aref tree-map i) nil)))\n(count t tree-map)))", "test": "(defun check ()\n(assert (equal (count-remaining-trees 10 '((2 5) (7 9))) 4))\n(assert (equal (count-remaining-trees 15 '((1 3) (5 10))) 7))\n(assert (equal (count-remaining-trees 20 '((0 5) (10 15))) 9))\n(assert (equal (count-remaining-trees 30 '((3 6) (8 10) (15 20))) 18))\n(assert (equal (count-remaining-trees 50 '((0 10) (20 30) (40 50))) 18)))\n\n(check)", "instruction": "Observe the following faulty Clisp```lisp\n(defun count-remaining-trees (road-length regions)\n\n\n\n(let ((tree-map (make-array (1+ road-length) :initial-element t)))\n(dolist (region regions)\n(loop for i from (first region) to (second region)\ndo (setq (aref tree-map i) nil)))\n(count t tree-map)))\n```\n Fix bugs in the given code snippet. The fixed code must be placed between ```lisp```. Do not generate any test, main,example usage or check code!"}
{"question_id": "Clisp/36", "category": "Logic", "subtype": "operation_error", "level": "medium", "example": "(total-cigarettes-smoked 4 3)  Returns 5\n(total-cigarettes-smoked 10 4)  Returns 13", "docstring": ";; Calculates the total number of cigarettes Peter can smoke.\n;; 'initial-cigarettes' is the starting number of cigarettes.\n;; 'butt-to-cigarette-ratio' is the number of cigarette butts required to get a new cigarette.\n;; The function returns the total number of cigarettes Peter can smoke.", "canonical_solution": "(defun total-cigarettes-smoked (initial-cigarettes butt-to-cigarette-ratio)\n\n\n(let ((total-smoked initial-cigarettes)\n(butts initial-cigarettes))\n(loop while (>= butts butt-to-cigarette-ratio)\ndo (let ((new-cigarettes (floor butts butt-to-cigarette-ratio)))\n(incf total-smoked new-cigarettes)\n(decf butts (* new-cigarettes butt-to-cigarette-ratio))\n(incf butts new-cigarettes)))\ntotal-smoked))", "buggy_code": "(defun total-cigarettes-smoked (initial-cigarettes butt-to-cigarette-ratio)\n\n\n(let ((total-smoked initial-cigarettes)\n(butts initial-cigarettes))\n(loop while (>= butts butt-to-cigarette-ratio)\ndo (let ((new-cigarettes (/ butts butt-to-cigarette-ratio)))\n(incf total-smoked new-cigarettes)\n(decf butts (* new-cigarettes butt-to-cigarette-ratio))\n(incf butts new-cigarettes)))\ntotal-smoked))", "test": "(defun check ()\n(assert (equal (total-cigarettes-smoked 4 3) 5))\n(assert (equal (total-cigarettes-smoked 10 4) 13))\n(assert (equal (total-cigarettes-smoked 20 5) 24))\n(assert (equal (total-cigarettes-smoked 15 3) 22))\n(assert (equal (total-cigarettes-smoked 7 2) 13))\n(assert (equal (total-cigarettes-smoked 5 5) 6))\n(assert (equal (total-cigarettes-smoked 0 3) 0)))\n\n(check)", "instruction": "Observe the following faulty Clisp```lisp\n(defun total-cigarettes-smoked (initial-cigarettes butt-to-cigarette-ratio)\n\n\n(let ((total-smoked initial-cigarettes)\n(butts initial-cigarettes))\n(loop while (>= butts butt-to-cigarette-ratio)\ndo (let ((new-cigarettes (/ butts butt-to-cigarette-ratio)))\n(incf total-smoked new-cigarettes)\n(decf butts (* new-cigarettes butt-to-cigarette-ratio))\n(incf butts new-cigarettes)))\ntotal-smoked))\n```\n Fix bugs in the given code snippet. The fixed code must be placed between ```lisp```. Do not generate any test, main,example usage or check code!"}
{"question_id": "Clisp/37", "category": "Logic", "subtype": "type_error", "level": "easy", "example": "(find-substring-index \"apple pie\" \"pie\")  Returns 6\n(find-substring-index \"hello world\" \"bye\")  Returns -1", "docstring": ";; Finds the first occurrence of the substring 'needle' within the string 'haystack'.\n;; Returns the index of the first character of the first occurrence of 'needle'.\n;; If 'needle' is not a part of 'haystack', returns -1.", "canonical_solution": "(defun find-substring-index (haystack needle)\n\n\n(let ((hay-len (length haystack))\n(need-len (length needle)))\n(if (zerop need-len)\n0\n(if (> need-len hay-len)\n-1\n(loop for i below (1+ (- hay-len need-len))\nwhen (string= (subseq haystack i (min (+ i need-len) hay-len)) needle)\nreturn i\nfinally (return -1))))))", "buggy_code": "(defun find-substring-index (haystack needle)\n\n\n(let ((hay-len (length haystack))\n(need-len (length needle)))\n(if (zerop need-len)\n0\n(if (> need-len hay-len)\n-1\n(loop for i below (1+ (- hay-len need-len))\nwhen (= (subseq haystack i (min (+ i need-len) hay-len)) needle)\nreturn i\nfinally (return -1))))))", "test": "(defun check ()\n(assert (equal (find-substring-index \"apple pie\" \"pie\") 6))\n(assert (equal (find-substring-index \"hello world\" \"bye\") -1))\n(assert (equal (find-substring-index \"common lisp\" \"lisp\") 7))\n(assert (equal (find-substring-index \"quick brown fox\" \"brown\") 6))\n(assert (equal (find-substring-index \"abcdef\" \"de\") 3))\n(assert (equal (find-substring-index \"abcdef\" \"xyz\") -1)))\n\n(check)", "instruction": "Observe the following faulty Clisp```lisp\n(defun find-substring-index (haystack needle)\n\n\n(let ((hay-len (length haystack))\n(need-len (length needle)))\n(if (zerop need-len)\n0\n(if (> need-len hay-len)\n-1\n(loop for i below (1+ (- hay-len need-len))\nwhen (= (subseq haystack i (min (+ i need-len) hay-len)) needle)\nreturn i\nfinally (return -1))))))\n```\n Fix bugs in the given code snippet. The fixed code must be placed between ```lisp```. Do not generate any test, main,example usage or check code!"}
{"question_id": "Clisp/38", "category": "Logic", "subtype": "type_error", "level": "easy", "example": ">>> count-digit-two 2 22\n6\n>>> count-digit-two 10 25\n9", "docstring": ";; This function counts the occurrences of the digit '2' in all integers within a given range [L, R].\n;; Both L and R are inclusive.\n;; It iterates through each number in the range and counts how many times '2' appears in each number.", "canonical_solution": "(defun count-digit-two (L R)\n\n\n(let ((count 0))\n(loop for i from L to R do\n(loop for char across (write-to-string i) do\n(when (char= char #\\2) (incf count))))\ncount))", "buggy_code": "(defun count-digit-two (L R)\n\n\n\n(let ((count 0))\n(loop for i from L to R do\n(loop for char across i do\n(when (char= char #\\2) (incf count))))\ncount))", "test": "(defun check ()\n(assert (equal (count-digit-two 2 22) 6))\n(assert (equal (count-digit-two 10 25) 8))\n(assert (equal (count-digit-two 1 100) 20))\n(assert (equal (count-digit-two 29 55) 4))\n(assert (equal (count-digit-two 200 250) 66)))\n\n(check)", "instruction": "Observe the following faulty Clisp```lisp\n(defun count-digit-two (L R)\n\n\n\n(let ((count 0))\n(loop for i from L to R do\n(loop for char across i do\n(when (char= char #\\2) (incf count))))\ncount))\n```\n Fix bugs in the given code snippet. The fixed code must be placed between ```lisp```. Do not generate any test, main,example usage or check code!"}
{"question_id": "Clisp/39", "category": "Logic", "subtype": "variable_error", "level": "medium", "example": ">>> bin-search 3 '#(1 2 3 4 5)\nt", "docstring": ";; Binary search for 'obj' in sorted vector 'vec'.\n;; Returns 't' if 'obj' is found, 'nil' otherwise.", "canonical_solution": "(defun bin-search (obj vec)\n\n\n(let ((low 0)\n(high (1- (length vec))))\n(loop while (<= low high)\nfor mid = (floor (+ low high) 2)\nfor mid-val = (aref vec mid)\ndo (cond ((= obj mid-val) (return-from bin-search t))\n((< obj mid-val) (setf high (1- mid)))\n((> obj mid-val) (setf low (1+ mid)))))\nnil))", "buggy_code": "(defun bin-search (obj vec)\n\n\n(let ((low 0)\n(high ((length vec))))\n(loop while (<= low high)\nfor mid = (floor (+ low high) 2)\nfor mid-val = (aref vec mid)\ndo (cond ((= obj mid-val) (return-from bin-search t))\n((< obj mid-val) (setf high (1- mid)))\n((> obj mid-val) (setf low (1+ mid)))))\nnil))", "test": "(defun check ()\n;; Test the 'bin-search' function with various cases.\n(assert (equal (bin-search 3 '#(1 2 3 4 5)) t))\n(assert (equal (bin-search 6 '#(1 2 3 4 5)) nil))\n(assert (equal (bin-search 1 '#(1)) t))\n(assert (equal (bin-search 2 '#(1)) nil))\n(assert (equal (bin-search 0 '#()) nil))\n(assert (equal (bin-search 5 '#(2 4 6 8 10)) nil))\n(assert (equal (bin-search 4 '#(2 4 6 8 10)) t)))\n\n(check)", "instruction": "Observe the following faulty Clisp```lisp\n(defun bin-search (obj vec)\n\n\n(let ((low 0)\n(high ((length vec))))\n(loop while (<= low high)\nfor mid = (floor (+ low high) 2)\nfor mid-val = (aref vec mid)\ndo (cond ((= obj mid-val) (return-from bin-search t))\n((< obj mid-val) (setf high (1- mid)))\n((> obj mid-val) (setf low (1+ mid)))))\nnil))\n```\n Fix bugs in the given code snippet. The fixed code must be placed between ```lisp```. Do not generate any test, main,example usage or check code!"}
{"question_id": "Clisp/40", "category": "Logic", "subtype": "variable_error", "level": "easy", "example": "(larger-prime-factor 15)  Returns 5\n(larger-prime-factor 33)  Returns 11", "docstring": ";; Finds the larger prime factor of a positive integer 'n', which is known to be the product of two distinct prime numbers.\n;; The function returns the larger of the two prime factors.", "canonical_solution": "(defun larger-prime-factor (n)\n\n\n(let ((factor 2))\n(loop while (> n factor)\nif (zerop (mod n factor))\ndo (setq n (/ n factor))\nelse\ndo (incf factor))\nn))", "buggy_code": "(defun larger-prime-factor (n)\n\n\n(let ((factor 1))\n(loop while (> n factor)\nif (zerop (mod n factor))\ndo (setq n (/ n factor))\nelse\ndo (incf factor))\nn))", "test": "(defun check ()\n(assert (equal (larger-prime-factor 21) 7))\n(assert (equal (larger-prime-factor 15) 5))\n(assert (equal (larger-prime-factor 33) 11))\n(assert (equal (larger-prime-factor 35) 7))\n(assert (equal (larger-prime-factor 77) 11))\n(assert (equal (larger-prime-factor 26) 13)))\n\n(check)", "instruction": "Observe the following faulty Clisp```lisp\n(defun larger-prime-factor (n)\n\n\n(let ((factor 1))\n(loop while (> n factor)\nif (zerop (mod n factor))\ndo (setq n (/ n factor))\nelse\ndo (incf factor))\nn))\n```\n Fix bugs in the given code snippet. The fixed code must be placed between ```lisp```. Do not generate any test, main,example usage or check code!"}
{"question_id": "Clisp/41", "category": "Multiple", "subtype": "double_bug", "level": "medium", "example": ">>> has_close_elements([1.0, 2.0, 3.0], 0.5)\nnil\n>>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\nt", "docstring": ";;Check if in given list of numbers, are any two numbers closer to each other than\n;;given threshold.", "canonical_solution": "(defun has-close-elements (numbers threshold)\n\n\n(loop for i from 0 below (length numbers)\ndo (loop for j from 0 below (length numbers)\ndo (when (and (/= i j)\n(< (abs (- (nth i numbers) (nth j numbers))) threshold))\n(return-from has-close-elements t))))\nnil)", "buggy_code": "(defun has-close-elements (numbers threshold)\n\n\n(loop for i from 0 below (length numbers)\ndo (loop for j from 0 below (length numbers)\ndo (when (and (!= i j)\n(< (abs (- (nth i numbers) (nth j numbers))) threshold))\n(return-from has-close-element t))))\nnil)", "test": "(defun check ()\n(assert (equal (has-close-elements '(1.0 2.0 3.9 4.0 5.0 2.2) 0.3) t))\n(assert (equal (has-close-elements '(1.0 2.0 3.9 4.0 5.0 2.2) 0.05) nil))\n(assert (equal (has-close-elements '(1.0 2.0 5.9 4.0 5.0) 0.95) t))\n(assert (equal (has-close-elements '(1.0 2.0 5.9 4.0 5.0) 0.8) nil))\n(assert (equal (has-close-elements '(1.0 2.0 3.0 4.0 5.0 2.0) 0.1) t))\n(assert (equal (has-close-elements '(1.1 2.2 3.1 4.1 5.1) 1.0) t))\n(assert (equal (has-close-elements '(1.1 2.2 3.1 4.1 5.1) 0.5) nil)))\n\n(check)", "instruction": "Observe the following faulty Clisp```lisp\n(defun has-close-elements (numbers threshold)\n\n\n(loop for i from 0 below (length numbers)\ndo (loop for j from 0 below (length numbers)\ndo (when (and (!= i j)\n(< (abs (- (nth i numbers) (nth j numbers))) threshold))\n(return-from has-close-element t))))\nnil)\n```\n Fix bugs in the given code snippet. The fixed code must be placed between ```lisp```. Do not generate any test, main,example usage or check code!"}
{"question_id": "Clisp/42", "category": "Multiple", "subtype": "double_bug", "level": "easy", "example": ">>> occurrences '(a b a d a c d c a)\n(a . 4) (c . 2) (d . 2) (b . 1)", "docstring": ";; takes a list and returns a list indicating the number of times each (eql) element appears, sorted from most common element to least common", "canonical_solution": "(defun occurrences (lst)\n\n\n(let ((result nil))\n(dolist (obj lst)\n(if (null (assoc obj result))\n(push (cons obj 1) result)\n(incf (cdr (assoc obj result)))\n))\n(sort result #'(lambda (a b) (if (> (cdr a) (cdr b)) t nil)))))", "buggy_code": "(defun occurrences (lst)\n\n\n(let ((result nil))\n(dolist (obj lst)\n(if (null (assoc obj result))\n(push (cons obj 0) result)\n(incf (cdr (assoc obj result)))\n))\n(sort result #(lambda (a b) (if (> (cdr a) (cdr b)) t nil)))))", "test": "(defun check ()\n;; 测试 'occurrences' 函数。\n(assert (equal (occurrences '(a b a d a c d c a)) '((a . 4) (c . 2) (d . 2) (b . 1))))\n(assert (equal (occurrences '(1 2 2 3 3 3)) '((3 . 3) (2 . 2) (1 . 1))))\n(assert (equal (occurrences '(a b a)) '((a . 2) (b . 1)))))\n\n(check)", "instruction": "Observe the following faulty Clisp```lisp\n(defun occurrences (lst)\n\n\n(let ((result nil))\n(dolist (obj lst)\n(if (null (assoc obj result))\n(push (cons obj 0) result)\n(incf (cdr (assoc obj result)))\n))\n(sort result #(lambda (a b) (if (> (cdr a) (cdr b)) t nil)))))\n```\n Fix bugs in the given code snippet. The fixed code must be placed between ```lisp```. Do not generate any test, main,example usage or check code!"}
{"question_id": "Clisp/43", "category": "Multiple", "subtype": "double_bug", "level": "medium", "example": ">>> move-first-instance-to-front 'b '(a b c d)\nb a c d", "docstring": ";; Define a function that takes two input parameters, object and queue, and can destructively move the first instance of object (eql equivalently) to the beginning of the queue", "canonical_solution": "(defun move-first-instance-to-front (object queue)\n\n\n(cond ((null queue) nil) \n((eql (first queue) object) queue) \n(t \n(let ((prev nil)\n(current queue))\n(loop while (and current (not (eql (first current) object)))\ndo (setq prev current)\n(setq current (rest current)))\n(if current \n(progn\n(when prev (setf (rest prev) (rest current))) \n(cons object (if prev queue (rest current)))) \nqueue)))))", "buggy_code": "(defun move-first-instance-to-front (object queue)\n\n\n(cond ((null queue) nil) \n((eql (first queue) object) queue) \n(t \n(let ((prev nil)\n(current queue))\n(loop while (and current (not (eql (first current) object)))\ndo (setq prev current)\n(setq current (rest current)))\n(progn\n(when prev (setf (rest prev) (rest current))) \n(cons object (if prev queue (rest current)))) \nqueue)))))", "test": "(defun check ()\n(assert (equal (move-first-instance-to-front 'b '(a b c d)) '(b a c d)))\n(assert (equal (move-first-instance-to-front 'a '(a b c d)) '(a b c d)))\n(assert (equal (move-first-instance-to-front 'e '(a b c d)) '(a b c d)))\n(assert (equal (move-first-instance-to-front 'd '(a b c d)) '(d a b c))))\n\n(check)", "instruction": "Observe the following faulty Clisp```lisp\n(defun move-first-instance-to-front (object queue)\n\n\n(cond ((null queue) nil) \n((eql (first queue) object) queue) \n(t \n(let ((prev nil)\n(current queue))\n(loop while (and current (not (eql (first current) object)))\ndo (setq prev current)\n(setq current (rest current)))\n(progn\n(when prev (setf (rest prev) (rest current))) \n(cons object (if prev queue (rest current)))) \nqueue)))))\n```\n Fix bugs in the given code snippet. The fixed code must be placed between ```lisp```. Do not generate any test, main,example usage or check code!"}
{"question_id": "Clisp/44", "category": "Multiple", "subtype": "double_bug", "level": "easy", "example": "(find-substring-index \"apple pie\" \"pie\")  Returns 6\n(find-substring-index \"hello world\" \"bye\")  Returns -1", "docstring": ";; Finds the first occurrence of the substring 'needle' within the string 'haystack'.\n;; Returns the index of the first character of the first occurrence of 'needle'.\n;; If 'needle' is not a part of 'haystack', returns -1.", "canonical_solution": "(defun find-substring-index (haystack needle)\n\n\n(let ((hay-len (length haystack))\n(need-len (length needle)))\n(if (zerop need-len)\n0\n(if (> need-len hay-len)\n-1\n(loop for i below (1+ (- hay-len need-len))\nwhen (string= (subseq haystack i (min (+ i need-len) hay-len)) needle)\nreturn i\nfinally (return -1))))))", "buggy_code": "(defun find-substring-index (haystack needle)\n\n\n(let ((hay-len (length haystack))\n(need-len (length needle)))\n(if (zerop need-len)\n0\n(if (> need-len hay-len)\n-1\n(loop for i below (1+ (- hay-len need-len))\nwhen (string= (subseq haystack i (min ( i need-len) hay-len)) needle)\nreturn i\nfinally (return -1)))))", "test": "(defun check ()\n(assert (equal (find-substring-index \"apple pie\" \"pie\") 6))\n(assert (equal (find-substring-index \"hello world\" \"bye\") -1))\n(assert (equal (find-substring-index \"common lisp\" \"lisp\") 7))\n(assert (equal (find-substring-index \"quick brown fox\" \"brown\") 6))\n(assert (equal (find-substring-index \"abcdef\" \"de\") 3))\n(assert (equal (find-substring-index \"abcdef\" \"xyz\") -1))\n(assert (equal (find-substring-index \"pie\" \"apple pie\") -1)))\n\n(check)", "instruction": "Observe the following faulty Clisp```lisp\n(defun find-substring-index (haystack needle)\n\n\n(let ((hay-len (length haystack))\n(need-len (length needle)))\n(if (zerop need-len)\n0\n(if (> need-len hay-len)\n-1\n(loop for i below (1+ (- hay-len need-len))\nwhen (string= (subseq haystack i (min ( i need-len) hay-len)) needle)\nreturn i\nfinally (return -1)))))\n```\n Fix bugs in the given code snippet. The fixed code must be placed between ```lisp```. Do not generate any test, main,example usage or check code!"}
{"question_id": "Clisp/45", "category": "Multiple", "subtype": "double_bug", "level": "easy", "example": "(total-cigarettes-smoked 4 3)  Returns 5\n(total-cigarettes-smoked 10 4)  Returns 13", "docstring": ";; Calculates the total number of cigarettes Peter can smoke.\n;; 'initial-cigarettes' is the starting number of cigarettes.\n;; 'butt-to-cigarette-ratio' is the number of cigarette butts required to get a new cigarette.\n;; The function returns the total number of cigarettes Peter can smoke.", "canonical_solution": "(defun total-cigarettes-smoked (initial-cigarettes butt-to-cigarette-ratio)\n\n\n(let ((total-smoked initial-cigarettes)\n(butts initial-cigarettes))\n(loop while (>= butts butt-to-cigarette-ratio)\ndo (let ((new-cigarettes (floor butts butt-to-cigarette-ratio)))\n(incf total-smoked new-cigarettes)\n(decf butts (* new-cigarettes butt-to-cigarette-ratio))\n(incf butts new-cigarettes)))\ntotal-smoked))", "buggy_code": "(defun total-cigarettes-smoked (initial-cigarettes butt-to-cigarette-ratio)\n\n\n(loop while (>= butts butt-to-cigarette-ratio)\ndo (let ((new-cigarettes (floor butts butt-to-cigarette-ratio)))\n(incf total-smoked new-cigarettes)\n(decf butts (* new-cigarettes butt-to-cigarette-ratio))\n(incf butts new-cigarettes)))\ntotal-smoked))", "test": "(defun check ()\n(assert (equal (total-cigarettes-smoked 4 3) 5))\n(assert (equal (total-cigarettes-smoked 10 4) 13))\n(assert (equal (total-cigarettes-smoked 20 5) 24))\n(assert (equal (total-cigarettes-smoked 15 3) 22))\n(assert (equal (total-cigarettes-smoked 7 2) 13))\n(assert (equal (total-cigarettes-smoked 5 5) 6))\n(assert (equal (total-cigarettes-smoked 0 3) 0)))\n\n(check)", "instruction": "Observe the following faulty Clisp```lisp\n(defun total-cigarettes-smoked (initial-cigarettes butt-to-cigarette-ratio)\n\n\n(loop while (>= butts butt-to-cigarette-ratio)\ndo (let ((new-cigarettes (floor butts butt-to-cigarette-ratio)))\n(incf total-smoked new-cigarettes)\n(decf butts (* new-cigarettes butt-to-cigarette-ratio))\n(incf butts new-cigarettes)))\ntotal-smoked))\n```\n Fix bugs in the given code snippet. The fixed code must be placed between ```lisp```. Do not generate any test, main,example usage or check code!"}
{"question_id": "Clisp/46", "category": "Multiple", "subtype": "double_bug", "level": "hard", "example": ">>> create-largest-number '(56 9 45)\n\"95645\"\n>>> create-largest-number '(5 50 56)\n\"56550\"", "docstring": ";; This function takes a list of positive integers and rearranges them to form the largest possible number. \n;; It does this by concatenating the integers in an order such that their digit-wise combination yields the maximum value.", "canonical_solution": "(defun create-largest-number (numbers)\n\n\n(let ((str-numbers (mapcar #'number-to-string numbers)))\n(setf str-numbers (sort str-numbers #'larger-when-concatenated))\n(reduce (lambda (acc x) (concatenate 'string acc x)) str-numbers :initial-value \"\")))\n\n(defun number-to-string (number)\n(write-to-string number))\n\n(defun larger-when-concatenated (a b)\n(string> (concatenate 'string a b) (concatenate 'string b a)))", "buggy_code": "(defun create-largest-number (numbers)\n\n\n(let ((str-numbers (mapcar #'number-to-string numbers)))\n(setf str-numbers (sort str-numbers #'larger-when-concatenated))\n(reduce (lambda (acc x) (concatenate 'string acc x)) str-numbers :initial-value 0)))\n\n(defun number-to-string (number)\n(write-to-string number))\n\n(defun larger-when-concatenated (a b)\n(string> (concatenate string a b) (concatenate string b a)))", "test": "(defun check ()\n(assert (string= (create-largest-number '(56 9 45)) \"95645\"))\n(assert (string= (create-largest-number '(5 50 56)) \"56550\"))\n(assert (string= (create-largest-number '(3 34 302 50)) \"50343302\"))\n(assert (string= (create-largest-number '(10 2 23)) \"23210\"))\n(assert (string= (create-largest-number '(4 42 40 400)) \"44240400\")))\n\n(check)", "instruction": "Observe the following faulty Clisp```lisp\n(defun create-largest-number (numbers)\n\n\n(let ((str-numbers (mapcar #'number-to-string numbers)))\n(setf str-numbers (sort str-numbers #'larger-when-concatenated))\n(reduce (lambda (acc x) (concatenate 'string acc x)) str-numbers :initial-value 0)))\n\n(defun number-to-string (number)\n(write-to-string number))\n\n(defun larger-when-concatenated (a b)\n(string> (concatenate string a b) (concatenate string b a)))\n```\n Fix bugs in the given code snippet. The fixed code must be placed between ```lisp```. Do not generate any test, main,example usage or check code!"}
{"question_id": "Clisp/47", "category": "Multiple", "subtype": "triple_bug", "level": "easy", "example": " >>> bin-search 3 '#(1 2 3 4 5)\n t", "docstring": ";; Binary search for 'obj' in sorted vector 'vec'.\n;; Returns 't' if 'obj' is found, 'nil' otherwise.", "canonical_solution": "(defun bin-search (obj vec)\n\n\n(let ((low 0)\n(high (1- (length vec))))\n(loop while (<= low high)\nfor mid = (floor (+ low high) 2)\nfor mid-val = (aref vec mid)\ndo (cond ((= obj mid-val) (return-from bin-search t))\n((< obj mid-val) (setf high (1- mid)))\n((> obj mid-val) (setf low (1+ mid)))))\nnil))", "buggy_code": "(defun bin-search (obj vec)\n\n\n(let ((low 1)\n(high (1- (length vec))))\n(loop while (<= low high)\nfor mid = (floor (+ low high) 2)\nfor mid-val = (aref vec mid)\ndo (cond ((= obj mid-val) (return bin-search t))\n((< obj mid-val) (setf high (1- mid)))\n((> obj mid-val) (setf low (1+ mid))))\nnil))", "test": "(defun check ()\n;; Test the 'bin-search' function with various cases.\n(assert (equal (bin-search 3 '#(1 2 3 4 5)) t))\n(assert (equal (bin-search 6 '#(1 2 3 4 5)) nil))\n(assert (equal (bin-search 1 '#(1)) t))\n(assert (equal (bin-search 2 '#(1)) nil))\n(assert (equal (bin-search 0 '#()) nil))\n(assert (equal (bin-search 5 '#(2 4 6 8 10)) nil))\n(assert (equal (bin-search 4 '#(2 4 6 8 10)) t)))\n\n(check)", "instruction": "Observe the following faulty Clisp```lisp\n(defun bin-search (obj vec)\n\n\n(let ((low 1)\n(high (1- (length vec))))\n(loop while (<= low high)\nfor mid = (floor (+ low high) 2)\nfor mid-val = (aref vec mid)\ndo (cond ((= obj mid-val) (return bin-search t))\n((< obj mid-val) (setf high (1- mid)))\n((> obj mid-val) (setf low (1+ mid))))\nnil))\n```\n Fix bugs in the given code snippet. The fixed code must be placed between ```lisp```. Do not generate any test, main,example usage or check code!"}
{"question_id": "Clisp/48", "category": "Multiple", "subtype": "triple_bug", "level": "hard", "example": " >>> segments-intersect? 0 0 1 1 1 0 0 1\n x 0.5\n y 0.5", "docstring": ";; Define a function that accepts 8 real numbers representing the endpoints of two line segments in two-dimensional space. If the line segments do not intersect, return false, or return two values representing the x and y coordinates of the intersection point", "canonical_solution": "(defun segments-intersect? (x1 y1 x2 y2 x3 y3 x4 y4)\n\n\n(let ((denom (- (* (- x2 x1) (- y4 y3)) (* (- y2 y1) (- x4 x3)))))\n(unless (zerop denom)\n(let* ((ua (/ (- (* (- x4 x3) (- y1 y3)) (* (- y4 y3) (- x1 x3))) denom))\n(ub (/ (- (* (- x2 x1) (- y1 y3)) (* (- y2 y1) (- x1 x3))) denom))\n(x-on-segment (+ x1 (* ua (- x2 x1))))\n(y-on-segment (+ y1 (* ua (- y2 y1)))))\n(when (and (>= ua 0) (<= ua 1) (>= ub 0) (<= ub 1))\n(values x-on-segment y-on-segment))))))\n\n(defun float-near-equal (a b &optional (tolerance 1e-5))\n(<= (abs (- a b)) tolerance))", "buggy_code": "(defun segments-intersect? (x1 y1 x2 y2 x3 y3 x4 y4)\n\n\n(let ((denom (- (* (- x2 x1) (- y4 y3)) (* (- y2 y1) (- x4 x3)))))\n(unless (zerop denom)\n(let* ((ua ((- (* (- x4 x3) (- y1 y3)) (* (- y4 y3) (- x1 x3))) denom))\n(ub (/ (- (* (- x2 x1) (- y1 y3)) (* (- y2 y1) (- x1 x3))) denom))\n(x-on-segment (+ x1 (* ua (- x1 x2))))\n(y-on-segment (+ y1 (* ua (- y1 y2)))))\n(when (and (>= ua 0) (<= ua 1) (>= ub 0) (<= ub 1))\n(values x-on-segment y-on-segment)))))\n\n(defun float-near-equal (a b &optional (tolerance 1e-5))\n(<= (abs (- a b)) tolerance))", "test": "(defun check ()\n(multiple-value-bind (x y) (segments-intersect? 0 0 1 1 1 0 0 1)\n(assert (and (float-near-equal x 0.5) (float-near-equal y 0.5))))\n(assert (null (segments-intersect? 0 0 1 1 2 2 3 3))))\n\n(check)", "instruction": "Observe the following faulty Clisp```lisp\n(defun segments-intersect? (x1 y1 x2 y2 x3 y3 x4 y4)\n\n\n(let ((denom (- (* (- x2 x1) (- y4 y3)) (* (- y2 y1) (- x4 x3)))))\n(unless (zerop denom)\n(let* ((ua ((- (* (- x4 x3) (- y1 y3)) (* (- y4 y3) (- x1 x3))) denom))\n(ub (/ (- (* (- x2 x1) (- y1 y3)) (* (- y2 y1) (- x1 x3))) denom))\n(x-on-segment (+ x1 (* ua (- x1 x2))))\n(y-on-segment (+ y1 (* ua (- y1 y2)))))\n(when (and (>= ua 0) (<= ua 1) (>= ub 0) (<= ub 1))\n(values x-on-segment y-on-segment)))))\n\n(defun float-near-equal (a b &optional (tolerance 1e-5))\n(<= (abs (- a b)) tolerance))\n```\n Fix bugs in the given code snippet. The fixed code must be placed between ```lisp```. Do not generate any test, main,example usage or check code!"}
{"question_id": "Clisp/49", "category": "Multiple", "subtype": "triple_bug", "level": "easy", "example": " (count-remaining-trees 10 '((2 5) (7 9)))  Returns 4\n (count-remaining-trees 15 '((1 3) (5 10)))  Returns 7", "docstring": ";; Counts the number of trees remaining on a road of length 'road-length' after removing trees in specified 'regions'.\n;; Each region is a list of two integers representing the start and end points on the road.\n;; The function returns the number of trees remaining after the removal.", "canonical_solution": "(defun count-remaining-trees (road-length regions)\n\n\n(let ((tree-map (make-array (1+ road-length) :initial-element t)))\n(dolist (region regions)\n(loop for i from (first region) to (second region)\ndo (setf (aref tree-map i) nil)))\n(count t tree-map)))", "buggy_code": "(defun count-remaining-trees (road-length regions)\n\n\n(let ((tree-map (make-array (road-length) :initial-element t)))\n(dolist (region regions)\n(loop for i from (second region) to (first region)\n(setf (aref tree-map i) nil)))\n(count t tree-map)))", "test": "(defun check ()\n(assert (equal (count-remaining-trees 10 '((2 5) (7 9))) 4))\n(assert (equal (count-remaining-trees 15 '((1 3) (5 10))) 7))\n(assert (equal (count-remaining-trees 20 '((0 5) (10 15))) 9))\n(assert (equal (count-remaining-trees 30 '((3 6) (8 10) (15 20))) 18))\n(assert (equal (count-remaining-trees 50 '((0 10) (20 30) (40 50))) 18)))\n\n(check)", "instruction": "Observe the following faulty Clisp```lisp\n(defun count-remaining-trees (road-length regions)\n\n\n(let ((tree-map (make-array (road-length) :initial-element t)))\n(dolist (region regions)\n(loop for i from (second region) to (first region)\n(setf (aref tree-map i) nil)))\n(count t tree-map)))\n```\n Fix bugs in the given code snippet. The fixed code must be placed between ```lisp```. Do not generate any test, main,example usage or check code!"}
{"question_id": "Clisp/50", "category": "Multiple", "subtype": "triple_bug", "level": "easy", "example": " (larger-prime-factor 15)  Returns 5\n (larger-prime-factor 33)  Returns 11", "docstring": ";; Finds the larger prime factor of a positive integer 'n', which is known to be the product of two distinct prime numbers.\n;; The function returns the larger of the two prime factors.", "canonical_solution": "(defun larger-prime-factor (n)\n\n\n(let ((factor 2))\n(loop while (> n factor)\nif (zerop (mod n factor))\ndo (setq n (/ n factor))\nelse\ndo (incf factor))\nn))", "buggy_code": "(defun larger-prime-factor (n)\n\n\n(let ((factor 1))\n(loop while (>= n factor)\nif (zero (mod n factor))\ndo (setq n (/ n factor))\nelse\ndo (incf factor))\nn))", "test": "(defun check ()\n(assert (equal (larger-prime-factor 21) 7))\n(assert (equal (larger-prime-factor 15) 5))\n(assert (equal (larger-prime-factor 33) 11))\n(assert (equal (larger-prime-factor 35) 7))\n(assert (equal (larger-prime-factor 77) 11))\n(assert (equal (larger-prime-factor 26) 13)))\n\n(check)", "instruction": "Observe the following faulty Clisp```lisp\n(defun larger-prime-factor (n)\n\n\n(let ((factor 1))\n(loop while (>= n factor)\nif (zero (mod n factor))\ndo (setq n (/ n factor))\nelse\ndo (incf factor))\nn))\n```\n Fix bugs in the given code snippet. The fixed code must be placed between ```lisp```. Do not generate any test, main,example usage or check code!"}
{"question_id": "Clisp/51", "category": "Multiple", "subtype": "triple_bug", "level": "hard", "example": " >>> count-output-sequences 3\n 5\n >>> count-output-sequences 4\n 14", "docstring": ";; This function calculates the total number of different output sequences that can be obtained by using a stack \n;; with operations push and pop on a sequence of numbers from 1 to n.\n;; The operations are: \n;; 1. Push the next number from the input sequence onto the stack.\n;; 2. Pop the top number from the stack and add it to the output sequence.\n;; It counts all the possible sequences of these operations that result in all numbers being moved from the input sequence to the output sequence.", "canonical_solution": "(defun count-output-sequences (n)\n\n\n(let ((dp (make-array (1+ n) :initial-element 0)))\n(setf (aref dp 0) 1)\n(loop for i from 1 to n do\n(loop for j from 0 to (1- i) do\n(incf (aref dp i) (* (aref dp j) (aref dp (1- (- i j)))))))\n(aref dp n)))", "buggy_code": "(defun count-output-sequences (n)\n\n\n(let ((dp (make-array (n) :initial-element 0)))\n(setf (aref dp 0) 0)\n(loop for i from 1 to n do\n(loop for j from 0 to (1- i) do\n(incf (aref dp i) (* (aref dp j) (aref dp (1- (- i j))))))\n(aref dp n)))", "test": "(defun check ()\n(assert (equal (count-output-sequences 3) 5))\n(assert (equal (count-output-sequences 4) 14))\n(assert (equal (count-output-sequences 5) 42))\n(assert (equal (count-output-sequences 6) 132))\n(assert (equal (count-output-sequences 7) 429)))\n\n(check)", "instruction": "Observe the following faulty Clisp```lisp\n(defun count-output-sequences (n)\n\n\n(let ((dp (make-array (n) :initial-element 0)))\n(setf (aref dp 0) 0)\n(loop for i from 1 to n do\n(loop for j from 0 to (1- i) do\n(incf (aref dp i) (* (aref dp j) (aref dp (1- (- i j))))))\n(aref dp n)))\n```\n Fix bugs in the given code snippet. The fixed code must be placed between ```lisp```. Do not generate any test, main,example usage or check code!"}
{"question_id": "Clisp/52", "category": "Multiple", "subtype": "quadruple_bug", "level": "easy", "example": ">>> parse-date \"16 Aug 1980\"\n16 8 1980", "docstring": "", "canonical_solution": "(defun parse-date (date-str)\n\"Parse a date string in the format 'DD MMM YYYY' and return a list (day month year).\"\n\n\n(let ((toks (tokens date-str #'constituent 0)))\n(list (parse-integer (first toks):junk-allowed t)\n(parse-month (second toks))\n(parse-integer (third toks)))))\n\n(defun tokens (str test start)\n(let ((p1 (position-if test str :start start)))\n(if p1\n(let ((p2 (position-if #'(lambda (c)\n(not (funcall test c)))\nstr :start p1)))\n(cons (subseq str p1 p2)\n(if p2\n(tokens str test p2)\nnil)))\nnil)))\n(defun constituent (c)\n(and (graphic-char-p c)\n(not (char= c #\\ ))))\n\n(defconstant month-names\n'(\"jan\" \"feb\" \"mar\" \"apr\" \"may\" \"jun\"\n\"jul\" \"aug\" \"sep\" \"oct\" \"nov\" \"dec\"))\n\n(defun parse-month (str)\n\"Parse the month string and return the month number.\"\n(let ((p (position (string-downcase str) month-names :test #'string-equal)))\n(if p\n(1+ p)\n(error \"Invalid month string: ~A\" str))))", "buggy_code": "(defun parse-date (date-str)\n\"Parse a date string in the format 'DD MMM YYYY' and return a list (day month year).\"\n\n\n(let ((toks (tokens date-str #'constituent)))\n(list (parse-integer (first toks):junk-allowed t)\n(parse-month (second toks))\n(parse-integer (third toks)))))\n\n(defun tokens (str test start)\n(let ((p1 (position-if test str :start start)))\n(if p1\n(let ((p2 (position-if #(lambda (c)\n(not (funcall test c)))\nstr :start p1)))\n(cons (subseq str p1 p2)\n(if p2\n(tokens str test p2)\nnil))))))\n(defun constituent (c)\n(and (graphic-char-p c)\n(not (char= c #\\ ))))\n\n(defconstant month-names\n'(\"jan\" \"feb\" \"mar\" \"apr\" \"may\" \"jun\"\n\"jul\" \"aug\" \"sep\" \"oct\" \"nov\" \"dec\"))\n\n(defun parse-month (str)\n\"Parse the month string and return the month number.\"\n(let ((p (position (string-downcase str) month-names :test #'string-equal)))\n(if p\np\n(error \"Invalid month string: ~A\" str))))", "test": "(defun check ()\n;; Test the 'parse-date' function with various date strings.\n(assert (equal (parse-date \"16 Aug 1980\") '(16 8 1980)))\n(assert (equal (parse-date \"1 Jan 2023\") '(1 1 2023)))\n(assert (equal (parse-date \"25 Dec 1999\") '(25 12 1999)))\n(assert (equal (parse-date \"31 Oct 2025\") '(31 10 2025)))\n(assert (equal (parse-date \"20 Feb 2010\") '(20 2 2010))))\n\n(check)", "instruction": "Observe the following faulty Clisp```lisp\n(defun parse-date (date-str)\n\"Parse a date string in the format 'DD MMM YYYY' and return a list (day month year).\"\n\n\n(let ((toks (tokens date-str #'constituent)))\n(list (parse-integer (first toks):junk-allowed t)\n(parse-month (second toks))\n(parse-integer (third toks)))))\n\n(defun tokens (str test start)\n(let ((p1 (position-if test str :start start)))\n(if p1\n(let ((p2 (position-if #(lambda (c)\n(not (funcall test c)))\nstr :start p1)))\n(cons (subseq str p1 p2)\n(if p2\n(tokens str test p2)\nnil))))))\n(defun constituent (c)\n(and (graphic-char-p c)\n(not (char= c #\\ ))))\n\n(defconstant month-names\n'(\"jan\" \"feb\" \"mar\" \"apr\" \"may\" \"jun\"\n\"jul\" \"aug\" \"sep\" \"oct\" \"nov\" \"dec\"))\n\n(defun parse-month (str)\n\"Parse the month string and return the month number.\"\n(let ((p (position (string-downcase str) month-names :test #'string-equal)))\n(if p\np\n(error \"Invalid month string: ~A\" str))))\n```\n Fix bugs in the given code snippet. The fixed code must be placed between ```lisp```. Do not generate any test, main,example usage or check code!"}
{"question_id": "Clisp/53", "category": "Multiple", "subtype": "quadruple_bug", "level": "hard", "example": "quicksort '(3 1 4 1 5 9 2 6 5 3 5)v\n1 1 2 3 3 4 5 5 5 6 9", "docstring": ";; Quickly sort the list", "canonical_solution": "(defun quicksort (list)\n\n\n(if (null list)\nnil\n(let ((pivot (first list))\n(rest (rest list)))\n(append (quicksort (remove-if-not #'(lambda (x) (< x pivot)) rest))\n(list pivot)\n(quicksort (remove-if #'(lambda (x) (< x pivot)) rest))))))", "buggy_code": "(defun quicksort (list)\n\n\n(if (not list)\nnil\n(let ((pivot (first list))\n(rest (rest list)))\n(append (quicksort (remove-if-not #'(lambda (x) (<= x pivot)) rest))\n(quicksort (remove-if #'(lambda (x) (< x pivot)) rest)))))", "test": "(defun check ()\n;; 测试 'quicksort' 函数。\n(assert (equal (quicksort '(3 1 4 1 5 9 2 6 5 3 5)) '(1 1 2 3 3 4 5 5 5 6 9)))\n(assert (equal (quicksort '(5 4 3 2 1)) '(1 2 3 4 5)))\n(assert (equal (quicksort '()) '()))\n(assert (equal (quicksort '(1)) '(1))))\n\n(check)", "instruction": "Observe the following faulty Clisp```lisp\n(defun quicksort (list)\n\n\n(if (not list)\nnil\n(let ((pivot (first list))\n(rest (rest list)))\n(append (quicksort (remove-if-not #'(lambda (x) (<= x pivot)) rest))\n(quicksort (remove-if #'(lambda (x) (< x pivot)) rest)))))\n```\n Fix bugs in the given code snippet. The fixed code must be placed between ```lisp```. Do not generate any test, main,example usage or check code!"}
{"question_id": "Clisp/54", "category": "Multiple", "subtype": "quadruple_bug", "level": "easy", "example": "(calculate-year-end-amount '(290 230 280 200 300 170 340 50 90 80 200 60))  Returns -7", "docstring": ";; Calculates whether Jinjin can follow her savings plan without running out of money in any month.\n;; 'monthly-budgets' is a list of 12 integers representing Jinjin's monthly budget.\n;; If successful, returns the total amount of money Jinjin will have by year-end, including 20% interest on savings.\n;; Otherwise, returns -X, where X is the first month Jinjin runs out of money.", "canonical_solution": "(defun calculate-year-end-amount (monthly-budgets)\n;; Calculates whether Jinjin can follow her savings plan without running out of money in any month.\n;; 'monthly-budgets' is a list of 12 integers representing Jinjin's monthly budget.\n;; If successful, returns the total amount of money Jinjin will have by year-end, including 20% interest on savings.\n;; Otherwise, returns -X, where X is the first month Jinjin runs out of money.\n;; Example:\n;; (calculate-year-end-amount '(290 230 280 200 300 170 340 50 90 80 200 60)) ;; Returns -7\n\n(let ((current-amount 0)\n(total-saved 0))\n(loop for month from 1 to 12\nfor budget in monthly-budgets\ndo (progn\n(incf current-amount 300) ;; Add monthly allowance\n(decf current-amount budget) ;; Subtract monthly budget\n(when (< current-amount 0)\n(return-from calculate-year-end-amount (- month))) ;; Check if Jinjin runs out of money\n(let ((savings (floor current-amount 100)))\n(decf current-amount (* 100 savings))\n(incf total-saved (* 100 savings))))\nfinally (return (+ current-amount (* total-saved 1.2)))))) ;; Calculate total with interest", "buggy_code": "(defun calculate-year-end-amount (monthly-budgets)\n\n\n(let (current-amount 0)\n(total-saved 0))\n(loop for month from 1 to 12\nfor budget in monthly-budgets\ndo (progn\n(incf current-amount 300)\n(decf current-amount budget)\n(when (< current-amount 0)\n(return calculate-year-end-amount (- month)))\n(let* ((savings (floor current-amount 100)))\n(decf current-amount (* 100 savings))\n(incf total-saved (* 100 savings))))\n(return (+ current-amount (* total-saved 0.2))))))", "test": "(defun check ()\n(assert (equal (calculate-year-end-amount '(290 230 280 200 300 170 340 50 90 80 200 60)) -7))\n(assert (equal (calculate-year-end-amount '(100 100 100 100 100 100 100 100 100 100 100 100)) 2880.0)) ;; Assuming all savings\n(assert (equal (calculate-year-end-amount '(300 300 300 300 300 300 300 300 300 300 300 300)) 0.0)) ;; No savings\n(assert (equal (calculate-year-end-amount '(150 150 150 150 150 150 150 150 150 150 150 150)) 2160.0)) ;; Half savings\n(assert (equal (calculate-year-end-amount '(250 250 250 250 250 250 250 250 250 250 250 250)) 720.0))) ;; Runs out first month\n(check)", "instruction": "Observe the following faulty Clisp```lisp\n(defun calculate-year-end-amount (monthly-budgets)\n\n\n(let (current-amount 0)\n(total-saved 0))\n(loop for month from 1 to 12\nfor budget in monthly-budgets\ndo (progn\n(incf current-amount 300)\n(decf current-amount budget)\n(when (< current-amount 0)\n(return calculate-year-end-amount (- month)))\n(let* ((savings (floor current-amount 100)))\n(decf current-amount (* 100 savings))\n(incf total-saved (* 100 savings))))\n(return (+ current-amount (* total-saved 0.2))))))\n```\n Fix bugs in the given code snippet. The fixed code must be placed between ```lisp```. Do not generate any test, main,example usage or check code!"}
{"question_id": "Clisp/55", "category": "Multiple", "subtype": "quadruple_bug", "level": "hard", "example": " >>> represent-as-powers-of-two(10)\n \"2+2(2()+2)\"\n >>> represent-as-powers-of-two(26)\n \"2+2(2()+2)+2(2(2))\"", "docstring": ";; This function takes a positive integer 'n' and returns its representation as a sum of powers of two. \n;; The powers are expressed in a specific format where a^b is represented as a(b), and terms are summed without spaces.\n;; Specifically, 2^0 is represented as 2()\n;; This function joins a list of strings with a given separator.", "canonical_solution": "(defun represent-as-powers-of-two (n)\n;; This function takes a positive integer 'n' and returns its representation as a sum of powers of two. \n;; The powers are expressed in a specific format where a^b is represented as a(b), and terms are summed without spaces.\n;; Specifically, 2^0 is represented as 2()\n;; Example:\n;; >>> represent-as-powers-of-two(10)\n;; \"2+2(2()+2)\"\n;; >>> represent-as-powers-of-two(26)\n;; \"2+2(2()+2)+2(2(2))\"\n\n(let ((result '()) (power 0))\n(loop while (> n 0)\ndo (progn\n(when (> (logand n 1) 0)\n(push (if (= power 1) \"2\" (format nil \"2(~a)\" (represent-as-powers-of-two power))) result))\n(setq power (+ power 1))\n(setq n (ash n -1))))\n(string-join (reverse result) \"+\")))\n(defun string-join (list separator)\n;; This function joins a list of strings with a given separator.\n(with-output-to-string (stream)\n(when list\n(write-string (first list) stream)\n(dolist (item (rest list))\n(write-string separator stream)\n(write-string item stream)))))", "buggy_code": "(defun represent-as-powers-of-two (n)\n;; This function takes a positive integer 'n' and returns its representation as a sum of powers of two. \n;; The powers are expressed in a specific format where a^b is represented as a(b), and terms are summed without spaces.\n;; Specifically, 2^0 is represented as 2()\n\n(let ((result '()) (power 0))\n(loop while (> n 0)\ndo (progn\n(when (> (and n 1) 0)\n(push (if (= power 1) \"2\" (format nil \"2(a)\" (represent-as-powers-of-two power))) result))\n(setq power (+ power 1))\n(setq n (ash n -1))))\n(string-join (reverse result) +)))\n(defun string-join (list separator)\n;; This function joins a list of strings with a given separator.\n(with-output-to-string (stream)\n(when list\n(write-string (first list) stream)\n(dolist (item (rest list))\n(write-string separator stream)\n(write-string item stream)))))", "test": "(defun check ()\n(assert (equal (represent-as-powers-of-two 10) \"2+2(2()+2)\"))\n(assert (equal (represent-as-powers-of-two 26) \"2+2(2()+2)+2(2(2))\"))\n(assert (equal (represent-as-powers-of-two 1) \"2()\"))\n(assert (equal (represent-as-powers-of-two 31) \"2()+2+2(2)+2(2()+2)+2(2(2))\"))\n(assert (equal (represent-as-powers-of-two 100) \"2(2)+2(2()+2(2))+2(2+2(2))\")))\n\n(check)", "instruction": "Observe the following faulty Clisp```lisp\n(defun represent-as-powers-of-two (n)\n;; This function takes a positive integer 'n' and returns its representation as a sum of powers of two. \n;; The powers are expressed in a specific format where a^b is represented as a(b), and terms are summed without spaces.\n;; Specifically, 2^0 is represented as 2()\n\n(let ((result '()) (power 0))\n(loop while (> n 0)\ndo (progn\n(when (> (and n 1) 0)\n(push (if (= power 1) \"2\" (format nil \"2(a)\" (represent-as-powers-of-two power))) result))\n(setq power (+ power 1))\n(setq n (ash n -1))))\n(string-join (reverse result) +)))\n(defun string-join (list separator)\n;; This function joins a list of strings with a given separator.\n(with-output-to-string (stream)\n(when list\n(write-string (first list) stream)\n(dolist (item (rest list))\n(write-string separator stream)\n(write-string item stream)))))\n```\n Fix bugs in the given code snippet. The fixed code must be placed between ```lisp```. Do not generate any test, main,example usage or check code!"}
{"question_id": "Clisp/56", "category": "Multiple", "subtype": "quadruple_bug", "level": "easy", "example": " >>> count-prime-sums '(1 2 3 4) 2\n 2 ; (1+2) and (3+4) are prime\n >>> count-prime-sums '(1 2 3 4 5 6) 3\n 1 ; Only (1+2+5) is prime", "docstring": ";; This function counts the number of ways to select 'k' integers from a list of 'n' integers such that their sum is a prime number.\n;; It considers all possible combinations of 'k' integers from the list and checks if their sum is prime.", "canonical_solution": "(defun count-prime-sums (numbers k)\n\n\n(count t (mapcar (lambda (comb) (is-prime (reduce '+ comb)))\n(sum-combinations numbers k))))\n(defun is-prime (n)\n(cond ((<= n 1) nil)\n((= n 2) t)\n(t (loop for i from 2 to (isqrt n) never (zerop (mod n i))))))\n\n(defun sum-combinations (lst k)\n(if (= k 0)\n'(())\n(loop for i from 0 below (length lst)\nnconc (mapcar (lambda (x) (cons (nth i lst) x))\n(sum-combinations (subseq lst (1+ i)) (1- k))))))", "buggy_code": "(defun count-prime-sums (numbers k)\n\n\n(count t (mapcar (lambda (comb) (is-prime (reduce '* comb)))\n(sum-combinations numbers k))))\n(defun is-prime (n)\n(cond ((> n 1) nil)\n((= n 2) t)\n(t (loop for i from 2 to (isqrt n) never (zerop (mod n i))))))\n\n(defun sum-combinations (lst k)\n(if (= k 0)\n'(())\n(loop for i from 1 below (length lst)\nnconc (mapcar (lambda (x) (cons (nth i lst) x))\n(sum-combinations (sublist lst (1+ i)) (1- k))))))", "test": "(defun check ()\n(assert (equal (count-prime-sums '(3 7 12 19) 3) 1))\n(assert (equal (count-prime-sums '(1 2 3 4) 2) 4))\n(assert (equal (count-prime-sums '(1 2 3 4 5 6) 3) 6))\n(assert (equal (count-prime-sums '(10 20 30 40) 2) 0))\n(assert (equal (count-prime-sums '(11 13 17 19 23 29) 3) 12))) \n\n(check)", "instruction": "Observe the following faulty Clisp```lisp\n(defun count-prime-sums (numbers k)\n\n\n(count t (mapcar (lambda (comb) (is-prime (reduce '* comb)))\n(sum-combinations numbers k))))\n(defun is-prime (n)\n(cond ((> n 1) nil)\n((= n 2) t)\n(t (loop for i from 2 to (isqrt n) never (zerop (mod n i))))))\n\n(defun sum-combinations (lst k)\n(if (= k 0)\n'(())\n(loop for i from 1 below (length lst)\nnconc (mapcar (lambda (x) (cons (nth i lst) x))\n(sum-combinations (sublist lst (1+ i)) (1- k))))))\n```\n Fix bugs in the given code snippet. The fixed code must be placed between ```lisp```. Do not generate any test, main,example usage or check code!"}
{"question_id": "Clisp/57", "category": "Syntax", "subtype": "missing_backtick", "level": "easy", "example": " >>> occurrences '(a b a d a c d c a)\n (a . 4) (c . 2) (d . 2) (b . 1)", "docstring": ";; takes a list and returns a list indicating the number of times each (eql) element appears, sorted from most common element to least common", "canonical_solution": "(defun occurrences (lst)\n\n\n(let ((result nil))\n(dolist (obj lst)\n(if (null (assoc obj result))\n(push (cons obj 1) result)\n(incf (cdr (assoc obj result)))\n))\n(sort result #'(lambda (a b) (if (> (cdr a) (cdr b)) t nil)))))", "buggy_code": "(defun occurrences (lst)\n\n\n(let ((result nil))\n(dolist (obj lst)\n(if (null (assoc obj result))\n(push (cons obj 1) result)\n(incf (cdr (assoc obj result)))\n))\n(sort result #(lambda (a b) (if (> (cdr a) (cdr b)) t nil)))))", "test": "(defun check ()\n;; 测试 'occurrences' 函数。\n(assert (equal (occurrences '(a b a d a c d c a)) '((a . 4) (c . 2) (d . 2) (b . 1))))\n(assert (equal (occurrences '(1 2 2 3 3 3)) '((3 . 3) (2 . 2) (1 . 1))))\n(assert (equal (occurrences '(a b a)) '((a . 2) (b . 1)))))\n\n(check)", "instruction": "Observe the following faulty Clisp```lisp\n(defun occurrences (lst)\n\n\n(let ((result nil))\n(dolist (obj lst)\n(if (null (assoc obj result))\n(push (cons obj 1) result)\n(incf (cdr (assoc obj result)))\n))\n(sort result #(lambda (a b) (if (> (cdr a) (cdr b)) t nil)))))\n```\n Fix bugs in the given code snippet. The fixed code must be placed between ```lisp```. Do not generate any test, main,example usage or check code!"}
{"question_id": "Clisp/58", "category": "Syntax", "subtype": "missing_backtick", "level": "easy", "example": " (divisible-five-digit-numbers 15)  Returns (22555 25555 28555 30000)\n (divisible-five-digit-numbers 7)  Returns a list of numbers or 'No' if no such numbers exist", "docstring": ";; Finds all five-digit numbers between 10000 and 30000 where three sub-numbers \n;; (formed by consecutive digits) are divisible by 'k'.\n;; Each sub-number consists of three consecutive digits from the original number.\n;; The function returns a list of such five-digit numbers.", "canonical_solution": "(defun divisible-five-digit-numbers (k)\n\n\n(let ((results '()))\n(loop for num from 10000 to 30000\nwhen (and (zerop (mod (parse-integer (subseq (write-to-string num) 0 3)) k))\n(zerop (mod (parse-integer (subseq (write-to-string num) 1 4)) k))\n(zerop (mod (parse-integer (subseq (write-to-string num) 2 5)) k)))\ndo (push num results))\n(if (null results)\n'No\n(nreverse results))))", "buggy_code": "(defun divisible-five-digit-numbers (k)\n\n\n(let ((results '()))\n(loop for num from 10000 to 30000\nwhen (and (zerop (mod (parse-integer (subseq (write-to-string num) 0 3)) k))\n(zerop (mod (parse-integer (subseq (write-to-string num) 1 4)) k))\n(zerop (mod (parse-integer (subseq (write-to-string num) 2 5)) k)))\ndo (push num results))\n(if (null results)\nNo\n(nreverse results))))", "test": "(defun check ()\n(assert (equal (divisible-five-digit-numbers 15) '(22555 25555 28555 30000)))\n(assert (equal (divisible-five-digit-numbers 31) '(15589 18682))) ;; No such numbers exist\n(assert (equal (divisible-five-digit-numbers 999) 'No))) ;; No such numbers exist for a large divisor\n\n(check)", "instruction": "Observe the following faulty Clisp```lisp\n(defun divisible-five-digit-numbers (k)\n\n\n(let ((results '()))\n(loop for num from 10000 to 30000\nwhen (and (zerop (mod (parse-integer (subseq (write-to-string num) 0 3)) k))\n(zerop (mod (parse-integer (subseq (write-to-string num) 1 4)) k))\n(zerop (mod (parse-integer (subseq (write-to-string num) 2 5)) k)))\ndo (push num results))\n(if (null results)\nNo\n(nreverse results))))\n```\n Fix bugs in the given code snippet. The fixed code must be placed between ```lisp```. Do not generate any test, main,example usage or check code!"}
{"question_id": "Clisp/59", "category": "Syntax", "subtype": "misused_let", "level": "easy", "example": " >>> segments-intersect? 0 0 1 1 1 0 0 1\n x 0.5\n y 0.5", "docstring": ";; Define a function that accepts 8 real numbers representing the endpoints of two line segments in two-dimensional space. If the line segments do not intersect, return false, or return two values representing the x and y coordinates of the intersection point", "canonical_solution": "(defun segments-intersect? (x1 y1 x2 y2 x3 y3 x4 y4)\n\n\n(let ((denom (- (* (- x2 x1) (- y4 y3)) (* (- y2 y1) (- x4 x3)))))\n(unless (zerop denom)\n(let* ((ua (/ (- (* (- x4 x3) (- y1 y3)) (* (- y4 y3) (- x1 x3))) denom))\n(ub (/ (- (* (- x2 x1) (- y1 y3)) (* (- y2 y1) (- x1 x3))) denom))\n(x-on-segment (+ x1 (* ua (- x2 x1))))\n(y-on-segment (+ y1 (* ua (- y2 y1)))))\n(when (and (>= ua 0) (<= ua 1) (>= ub 0) (<= ub 1))\n(values x-on-segment y-on-segment))))))\n\n(defun float-near-equal (a b &optional (tolerance 1e-5))\n(<= (abs (- a b)) tolerance))", "buggy_code": "(defun segments-intersect? (x1 y1 x2 y2 x3 y3 x4 y4)\n\n\n(let ((denom (- (* (- x2 x1) (- y4 y3)) (* (- y2 y1) (- x4 x3)))))\n(unless (zerop denom)\n(let ((ua (/ (- (* (- x4 x3) (- y1 y3)) (* (- y4 y3) (- x1 x3))) denom))\n(ub (/ (- (* (- x2 x1) (- y1 y3)) (* (- y2 y1) (- x1 x3))) denom))\n(x-on-segment (+ x1 (* ua (- x2 x1))))\n(y-on-segment (+ y1 (* ua (- y2 y1)))))\n(when (and (>= ua 0) (<= ua 1) (>= ub 0) (<= ub 1))\n(values x-on-segment y-on-segment))))))\n\n(defun float-near-equal (a b &optional (tolerance 1e-5))\n(<= (abs (- a b)) tolerance))", "test": "(defun check ()\n(multiple-value-bind (x y) (segments-intersect? 0 0 1 1 1 0 0 1)\n(assert (and (float-near-equal x 0.5) (float-near-equal y 0.5))))\n(assert (null (segments-intersect? 0 0 1 1 2 2 3 3))))\n\n(check)", "instruction": "Observe the following faulty Clisp```lisp\n(defun segments-intersect? (x1 y1 x2 y2 x3 y3 x4 y4)\n\n\n(let ((denom (- (* (- x2 x1) (- y4 y3)) (* (- y2 y1) (- x4 x3)))))\n(unless (zerop denom)\n(let ((ua (/ (- (* (- x4 x3) (- y1 y3)) (* (- y4 y3) (- x1 x3))) denom))\n(ub (/ (- (* (- x2 x1) (- y1 y3)) (* (- y2 y1) (- x1 x3))) denom))\n(x-on-segment (+ x1 (* ua (- x2 x1))))\n(y-on-segment (+ y1 (* ua (- y2 y1)))))\n(when (and (>= ua 0) (<= ua 1) (>= ub 0) (<= ub 1))\n(values x-on-segment y-on-segment))))))\n\n(defun float-near-equal (a b &optional (tolerance 1e-5))\n(<= (abs (- a b)) tolerance))\n```\n Fix bugs in the given code snippet. The fixed code must be placed between ```lisp```. Do not generate any test, main,example usage or check code!"}
{"question_id": "Clisp/60", "category": "Syntax", "subtype": "misused_let", "level": "easy", "example": " >>> construct-preorder \"DBEAC\" \"DEBCA\"\n \"ABCDE\"\n >>> construct-preorder \"HGFEIDBA\" \"HGFIEDBA\"\n \"ABDEFGHI\"", "docstring": ";; This function reconstructs the preorder traversal of a binary tree from its inorder and postorder traversals.\n;; The nodes of the binary tree are represented by distinct uppercase letters.\n;; It is assumed that the tree has no more than 8 nodes.", "canonical_solution": "(defun construct-preorder (inorder postorder)\n\n\n(when (and inorder postorder (not (zerop (length postorder))))\n(let* ((root (char postorder (1- (length postorder))))\n(root-pos (position root inorder)))\n(concatenate 'string\n(string root)\n(construct-preorder (subseq inorder 0 root-pos)\n(subseq postorder 0 root-pos))\n(construct-preorder (subseq inorder (1+ root-pos))\n(subseq postorder root-pos (1- (length postorder))))))))", "buggy_code": "(defun construct-preorder (inorder postorder)\n\n\n(when (and inorder postorder (not (zerop (length postorder))))\n(let ((root (char postorder (1- (length postorder))))\n(root-pos (position root inorder)))\n(concatenate 'string\n(string root)\n(construct-preorder (subseq inorder 0 root-pos)\n(subseq postorder 0 root-pos))\n(construct-preorder (subseq inorder (1+ root-pos))\n(subseq postorder root-pos (1- (length postorder))))))))", "test": "(defun check ()\n(assert (string= (construct-preorder \"DBEAC\" \"DEBCA\") \"ABDEC\"))\n(assert (string= (construct-preorder \"HGFEIDBA\" \"HGFIEDBA\") \"ABDEFGHI\"))\n(assert (string= (construct-preorder \"BADC\" \"BDCA\") \"ABCD\"))\n(assert (string= (construct-preorder \"FBAEDC\" \"FBEADC\") \"CDABFE\"))\n(assert (string= (construct-preorder \"A\" \"A\") \"A\")))\n\n(check)", "instruction": "Observe the following faulty Clisp```lisp\n(defun construct-preorder (inorder postorder)\n\n\n(when (and inorder postorder (not (zerop (length postorder))))\n(let ((root (char postorder (1- (length postorder))))\n(root-pos (position root inorder)))\n(concatenate 'string\n(string root)\n(construct-preorder (subseq inorder 0 root-pos)\n(subseq postorder 0 root-pos))\n(construct-preorder (subseq inorder (1+ root-pos))\n(subseq postorder root-pos (1- (length postorder))))))))\n```\n Fix bugs in the given code snippet. The fixed code must be placed between ```lisp```. Do not generate any test, main,example usage or check code!"}
