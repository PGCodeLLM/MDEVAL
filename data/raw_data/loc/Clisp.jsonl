{"question_id": "Clisp/1", "category": "Syntax", "subtype": "illegal_comment", "level": "medium", "example": " multiple-value-bind (quarters dimes nickels pennies) (make-change 98\n quarters 3\n dimes 2\n nickels 0\n pennies 3", "docstring": ";; Define a function that accepts an integer cents and returns four values, displaying the numbers as 25-, 10-, 5-, 1-, using the minimum number of coins. (Translation: 25- is 25 cents, and so on)", "canonical_solution": "(defun make-change (cents)\n\n\n(let ((quarters (floor cents 25))\n(remaining-after-quarters (mod cents 25)))\n(let ((dimes (floor remaining-after-quarters 10))\n(remaining-after-dimes (mod remaining-after-quarters 10)))\n(let ((nickels (floor remaining-after-dimes 5))\n(pennies (mod remaining-after-dimes 5)))\n(values quarters dimes nickels pennies)))))", "buggy_code": "(defun make-change (cents)\n\n\n//Greedy Algorithm\n(let ((quarters (floor cents 25))\n(remaining-after-quarters (mod cents 25)))\n(let ((dimes (floor remaining-after-quarters 10))\n(remaining-after-dimes (mod remaining-after-quarters 10)))\n(let ((nickels (floor remaining-after-dimes 5))\n(pennies (mod remaining-after-dimes 5)))\n(values quarters dimes nickels pennies)))))", "bug_with_line_numbers": "   1 | (defun make-change (cents)\n   2 | //Greedy Algorithm\n   3 | (let ((quarters (floor cents 25))\n   4 | (remaining-after-quarters (mod cents 25)))\n   5 | (let ((dimes (floor remaining-after-quarters 10))\n   6 | (remaining-after-dimes (mod remaining-after-quarters 10)))\n   7 | (let ((nickels (floor remaining-after-dimes 5))\n   8 | (pennies (mod remaining-after-dimes 5)))\n   9 | (values quarters dimes nickels pennies)))))", "fragment_lines": [2], "fragment_content": ["//Greedy Algorithm"], "test": "(defun check ()\n;; 测试 'make-change' 函数。\n(multiple-value-bind (quarters dimes nickels pennies) (make-change 98)\n(assert (equal quarters 3))\n(assert (equal dimes 2))\n(assert (equal nickels 0))\n(assert (equal pennies 3)))\n(multiple-value-bind (quarters dimes nickels pennies) (make-change 41)\n(assert (equal quarters 1))\n(assert (equal dimes 1))\n(assert (equal nickels 1))\n(assert (equal pennies 1)))\n(multiple-value-bind (quarters dimes nickels pennies) (make-change 3)\n(assert (equal quarters 0))\n(assert (equal dimes 0))\n(assert (equal nickels 0))\n(assert (equal pennies 3))))\n\n(check)", "line_content": {"2": ["//Greedy Algorithm"]}, "instruction": "\nObserve the following faulty Clisp code and the options. The code snippets in the options are all from faulty code . Your task is to select the option(s) for error code snippet(s).\nNote:\n\n- This is an undetermined multiple-choice question, where the answer may include multiple options.\n- Please provide the answer in the form of a Python list, without returning any content other than the Python code block.. For example \n```python\n[\"A\"]\n```\n\nfaulty code:\n```\n   1 | (defun make-change (cents)\n   2 | //Greedy Algorithm\n   3 | (let ((quarters (floor cents 25))\n   4 | (remaining-after-quarters (mod cents 25)))\n   5 | (let ((dimes (floor remaining-after-quarters 10))\n   6 | (remaining-after-dimes (mod remaining-after-quarters 10)))\n   7 | (let ((nickels (floor remaining-after-dimes 5))\n   8 | (pennies (mod remaining-after-dimes 5)))\n   9 | (values quarters dimes nickels pennies)))))\n```\n\noptions:\nA.    4 | (remaining-after-quarters (mod cents 25)))\n\nB.    2 | ['//Greedy Algorithm']\n\nC.    8 | (pennies (mod remaining-after-dimes 5)))\n\nD.    9 | (values quarters dimes nickels pennies)))))\n\n\n", "loc_answer": ["B"]}
{"question_id": "Clisp/2", "category": "Syntax", "subtype": "illegal_comment", "level": "medium", "example": " (total-cigarettes-smoked 4 3)  Returns 5\n (total-cigarettes-smoked 10 4)  Returns 13", "docstring": ";; Calculates the total number of cigarettes Peter can smoke.\n;; 'initial-cigarettes' is the starting number of cigarettes.\n;; 'butt-to-cigarette-ratio' is the number of cigarette butts required to get a new cigarette.\n;; The function returns the total number of cigarettes Peter can smoke.", "canonical_solution": "(defun total-cigarettes-smoked (initial-cigarettes butt-to-cigarette-ratio)\n\n\n(let ((total-smoked initial-cigarettes)\n(butts initial-cigarettes))\n(loop while (>= butts butt-to-cigarette-ratio)\ndo (let ((new-cigarettes (floor butts butt-to-cigarette-ratio)))\n(incf total-smoked new-cigarettes)\n(decf butts (* new-cigarettes butt-to-cigarette-ratio))\n(incf butts new-cigarettes)))\ntotal-smoked))", "buggy_code": "(defun total-cigarettes-smoked (initial-cigarettes butt-to-cigarette-ratio)\n\n\"Calculates the total number of cigarettes Peter can smoke.\n(let ((total-smoked initial-cigarettes)\n(butts initial-cigarettes))\n(loop while (>= butts butt-to-cigarette-ratio)\ndo (let ((new-cigarettes (floor butts butt-to-cigarette-ratio)))\n(incf total-smoked new-cigarettes)\n(decf butts (* new-cigarettes butt-to-cigarette-ratio))\n(incf butts new-cigarettes)))\ntotal-smoked))", "bug_with_line_numbers": "   1 | (defun total-cigarettes-smoked (initial-cigarettes butt-to-cigarette-ratio)\n   2 | \"Calculates the total number of cigarettes Peter can smoke.\n   3 | (let ((total-smoked initial-cigarettes)\n   4 | (butts initial-cigarettes))\n   5 | (loop while (>= butts butt-to-cigarette-ratio)\n   6 | do (let ((new-cigarettes (floor butts butt-to-cigarette-ratio)))\n   7 | (incf total-smoked new-cigarettes)\n   8 | (decf butts (* new-cigarettes butt-to-cigarette-ratio))\n   9 | (incf butts new-cigarettes)))\n  10 | total-smoked))", "fragment_lines": [2], "fragment_content": ["\"Calculates the total number of cigarettes Peter can smoke."], "test": "(defun check ()\n(assert (equal (total-cigarettes-smoked 4 3) 5))\n(assert (equal (total-cigarettes-smoked 10 4) 13))\n(assert (equal (total-cigarettes-smoked 20 5) 24))\n(assert (equal (total-cigarettes-smoked 15 3) 22))\n(assert (equal (total-cigarettes-smoked 7 2) 13))\n(assert (equal (total-cigarettes-smoked 5 5) 6))\n(assert (equal (total-cigarettes-smoked 0 3) 0)))\n\n(check)", "line_content": {"2": ["\"Calculates the total number of cigarettes Peter can smoke."]}, "instruction": "\nObserve the following faulty Clisp code and the options. The code snippets in the options are all from faulty code . Your task is to select the option(s) for error code snippet(s).\nNote:\n\n- This is an undetermined multiple-choice question, where the answer may include multiple options.\n- Please provide the answer in the form of a Python list, without returning any content other than the Python code block.. For example \n```python\n[\"A\"]\n```\n\nfaulty code:\n```\n   1 | (defun total-cigarettes-smoked (initial-cigarettes butt-to-cigarette-ratio)\n   2 | \"Calculates the total number of cigarettes Peter can smoke.\n   3 | (let ((total-smoked initial-cigarettes)\n   4 | (butts initial-cigarettes))\n   5 | (loop while (>= butts butt-to-cigarette-ratio)\n   6 | do (let ((new-cigarettes (floor butts butt-to-cigarette-ratio)))\n   7 | (incf total-smoked new-cigarettes)\n   8 | (decf butts (* new-cigarettes butt-to-cigarette-ratio))\n   9 | (incf butts new-cigarettes)))\n  10 | total-smoked))\n```\n\noptions:\nA.    3 | (let ((total-smoked initial-cigarettes)\n\nB.    2 | ['\"Calculates the total number of cigarettes Peter can smoke.']\n\nC.    4 | (butts initial-cigarettes))\n\nD.    5 | (loop while (>= butts butt-to-cigarette-ratio)\n\n\n", "loc_answer": ["B"]}
{"question_id": "Clisp/3", "category": "Syntax", "subtype": "illegal_separation", "level": "medium", "example": " (calculate-year-end-amount '(290 230 280 200 300 170 340 50 90 80 200 60))  Returns -7", "docstring": ";; Calculates whether Jinjin can follow her savings plan without running out of money in any month.\n;; 'monthly-budgets' is a list of 12 integers representing Jinjin's monthly budget.\n;; If successful, returns the total amount of money Jinjin will have by year-end, including 20% interest on savings.\n;; Otherwise, returns -X, where X is the first month Jinjin runs out of money.\n;; Add monthly allowance\n;; Subtract monthly budget\n;; Check if Jinjin runs out of money\n;; Calculate total with interest", "canonical_solution": "(defun calculate-year-end-amount (monthly-budgets)\n;; Calculates whether Jinjin can follow her savings plan without running out of money in any month.\n;; 'monthly-budgets' is a list of 12 integers representing Jinjin's monthly budget.\n;; If successful, returns the total amount of money Jinjin will have by year-end, including 20% interest on savings.\n;; Otherwise, returns -X, where X is the first month Jinjin runs out of money.\n;; Example:\n;; (calculate-year-end-amount '(290 230 280 200 300 170 340 50 90 80 200 60)) ;; Returns -7\n\n(let ((current-amount 0)\n(total-saved 0))\n(loop for month from 1 to 12\nfor budget in monthly-budgets\ndo (progn\n(incf current-amount 300) ;; Add monthly allowance\n(decf current-amount budget) ;; Subtract monthly budget\n(when (< current-amount 0)\n(return-from calculate-year-end-amount (- month))) ;; Check if Jinjin runs out of money\n(let ((savings (floor current-amount 100)))\n(decf current-amount (* 100 savings))\n(incf total-saved (* 100 savings))))\nfinally (return (+ current-amount (* total-saved 1.2)))))) ;; Calculate total with interest", "buggy_code": "(defun calculate-year-end-amount (monthly-budgets)\n;; Calculates whether Jinjin can follow her savings plan without running out of money in any month.\n;; 'monthly-budgets' is a list of 12 integers representing Jinjin's monthly budget.\n;; If successful, returns the total amount of money Jinjin will have by year-end, including 20% interest on savings.\n;; Otherwise, returns -X, where X is the first month Jinjin runs out of money.\n\n(let ((current-amount 0)\n(total-saved 0))\n(loop for month from 1 to 12\nfor budget in monthly-budgets\ndo (\n(incf current-amount 300) ;; Add monthly allowance\n(decf current-amount budget) ;; Subtract monthly budget\n(when (< current-amount 0)\n(return-from calculate-year-end-amount (- month))) ;; Check if Jinjin runs out of money\n(let ((savings (floor current-amount 100)))\n(decf current-amount (* 100 savings))\n(incf total-saved (* 100 savings))))\nfinally (return (+ current-amount (* total-saved 1.2)))))) ;; Calculate total with interest", "bug_with_line_numbers": "   1 | (defun calculate-year-end-amount (monthly-budgets)\n   2 | (let ((current-amount 0)\n   3 | (total-saved 0))\n   4 | (loop for month from 1 to 12\n   5 | for budget in monthly-budgets\n   6 | do (\n   7 | (incf current-amount 300) \n   8 | (decf current-amount budget) \n   9 | (when (< current-amount 0)\n  10 | (return-from calculate-year-end-amount (- month))) \n  11 | (let ((savings (floor current-amount 100)))\n  12 | (decf current-amount (* 100 savings))\n  13 | (incf total-saved (* 100 savings))))\n  14 | finally (return (+ current-amount (* total-saved 1.2)))))) ", "fragment_lines": [-1], "fragment_content": ["missing critical code snippet"], "test": "(defun check ()\n(assert (equal (calculate-year-end-amount '(290 230 280 200 300 170 340 50 90 80 200 60)) -7))\n(assert (equal (calculate-year-end-amount '(100 100 100 100 100 100 100 100 100 100 100 100)) 2880.0)) ;; Assuming all savings\n(assert (equal (calculate-year-end-amount '(300 300 300 300 300 300 300 300 300 300 300 300)) 0.0)) ;; No savings\n(assert (equal (calculate-year-end-amount '(150 150 150 150 150 150 150 150 150 150 150 150)) 2160.0)) ;; Half savings\n(assert (equal (calculate-year-end-amount '(250 250 250 250 250 250 250 250 250 250 250 250)) 720.0))) ;; Runs out first month\n(check)", "line_content": {"-1": ["missing critical code snippet"]}, "instruction": "\nObserve the following faulty Clisp code and the options. The code snippets in the options are all from faulty code . Your task is to select the option(s) for error code snippet(s).\nNote:\n\n- This is an undetermined multiple-choice question, where the answer may include multiple options.\n- Please provide the answer in the form of a Python list, without returning any content other than the Python code block.. For example \n```python\n[\"A\"]\n```\n\nfaulty code:\n```\n   1 | (defun calculate-year-end-amount (monthly-budgets)\n   2 | (let ((current-amount 0)\n   3 | (total-saved 0))\n   4 | (loop for month from 1 to 12\n   5 | for budget in monthly-budgets\n   6 | do (\n   7 | (incf current-amount 300) \n   8 | (decf current-amount budget) \n   9 | (when (< current-amount 0)\n  10 | (return-from calculate-year-end-amount (- month))) \n  11 | (let ((savings (floor current-amount 100)))\n  12 | (decf current-amount (* 100 savings))\n  13 | (incf total-saved (* 100 savings))))\n  14 | finally (return (+ current-amount (* total-saved 1.2)))))) \n```\n\noptions:\nA.    6 | do (\n\nB.   14 | finally (return (+ current-amount (* total-saved 1.2))))))\n\nC.   12 | (decf current-amount (* 100 savings))\n\nD.   -1 | ['missing critical code snippet']\n\n\n", "loc_answer": ["D"]}
{"question_id": "Clisp/4", "category": "Syntax", "subtype": "illegal_separation", "level": "easy", "example": " >>> count-digit-two 2 22\n 6\n >>> count-digit-two 10 25\n 9", "docstring": ";; This function counts the occurrences of the digit '2' in all integers within a given range [L, R].\n;; Both L and R are inclusive.\n;; It iterates through each number in the range and counts how many times '2' appears in each number.", "canonical_solution": "(defun count-digit-two (L R)\n\n\n(let ((count 0))\n(loop for i from L to R do\n(loop for char across (write-to-string i) do\n(when (char= char #\\2) (incf count))))\ncount))", "buggy_code": "(defun count-digit-two (L R)\n\n(let ((count 0))\n(loop for i from l to r do\n(loop for char across (write-to-string i) do\n(when (char= char \\2) (incf count))))\ncount))", "bug_with_line_numbers": "   1 | (defun count-digit-two (L R)\n   2 | (let ((count 0))\n   3 | (loop for i from l to r do\n   4 | (loop for char across (write-to-string i) do\n   5 | (when (char= char \\2) (incf count))))\n   6 | count))", "fragment_lines": [5], "fragment_content": ["(when (char= char \\2) (incf count))))"], "test": "(defun check ()\n(assert (equal (count-digit-two 2 22) 6))\n(assert (equal (count-digit-two 10 25) 8))\n(assert (equal (count-digit-two 1 100) 20))\n(assert (equal (count-digit-two 29 55) 4))\n(assert (equal (count-digit-two 200 250) 66)))\n\n(check)", "line_content": {"5": ["(when (char= char \\2) (incf count))))"]}, "instruction": "\nObserve the following faulty Clisp code and the options. The code snippets in the options are all from faulty code . Your task is to select the option(s) for error code snippet(s).\nNote:\n\n- This is an undetermined multiple-choice question, where the answer may include multiple options.\n- Please provide the answer in the form of a Python list, without returning any content other than the Python code block.. For example \n```python\n[\"A\"]\n```\n\nfaulty code:\n```\n   1 | (defun count-digit-two (L R)\n   2 | (let ((count 0))\n   3 | (loop for i from l to r do\n   4 | (loop for char across (write-to-string i) do\n   5 | (when (char= char \\2) (incf count))))\n   6 | count))\n```\n\noptions:\nA.    3 | (loop for i from l to r do\n\nB.    1 | (defun count-digit-two (L R)\n\nC.    5 | ['(when (char= char \\\\2) (incf count))))']\n\nD.    4 | (loop for char across (write-to-string i) do\n\n\n", "loc_answer": ["C"]}
{"question_id": "Clisp/5", "category": "Syntax", "subtype": "missing_colons", "level": "easy", "example": " (count-remaining-trees 10 '((2 5) (7 9)))  Returns 4\n (count-remaining-trees 15 '((1 3) (5 10)))  Returns 7", "docstring": ";; Counts the number of trees remaining on a road of length 'road-length' after removing trees in specified 'regions'.\n;; Each region is a list of two integers representing the start and end points on the road.\n;; The function returns the number of trees remaining after the removal.", "canonical_solution": "(defun count-remaining-trees (road-length regions)\n\n\n(let ((tree-map (make-array (1+ road-length) :initial-element t)))\n(dolist (region regions)\n(loop for i from (first region) to (second region)\ndo (setf (aref tree-map i) nil)))\n(count t tree-map)))", "buggy_code": "(defun count-remaining-trees (road-length regions)\n\n\n(let ((tree-map (make-array (1+ road-length) initial-element t)))\n(dolist (region regions)\n(loop for i from (first region) to (second region)\ndo (setf (aref tree-map i) nil)))\n(count t tree-map)))", "bug_with_line_numbers": "   1 | (defun count-remaining-trees (road-length regions)\n   2 | (let ((tree-map (make-array (1+ road-length) initial-element t)))\n   3 | (dolist (region regions)\n   4 | (loop for i from (first region) to (second region)\n   5 | do (setf (aref tree-map i) nil)))\n   6 | (count t tree-map)))", "fragment_lines": [2], "fragment_content": ["(let ((tree-map (make-array (1+ road-length) initial-element t)))"], "test": "(defun check ()\n(assert (equal (count-remaining-trees 10 '((2 5) (7 9))) 4))\n(assert (equal (count-remaining-trees 15 '((1 3) (5 10))) 7))\n(assert (equal (count-remaining-trees 20 '((0 5) (10 15))) 9))\n(assert (equal (count-remaining-trees 30 '((3 6) (8 10) (15 20))) 18))\n(assert (equal (count-remaining-trees 50 '((0 10) (20 30) (40 50))) 18)))\n\n(check)", "line_content": {"2": ["(let ((tree-map (make-array (1+ road-length) initial-element t)))"]}, "instruction": "\nObserve the following faulty Clisp code and the options. The code snippets in the options are all from faulty code . Your task is to select the option(s) for error code snippet(s).\nNote:\n\n- This is an undetermined multiple-choice question, where the answer may include multiple options.\n- Please provide the answer in the form of a Python list, without returning any content other than the Python code block.. For example \n```python\n[\"A\"]\n```\n\nfaulty code:\n```\n   1 | (defun count-remaining-trees (road-length regions)\n   2 | (let ((tree-map (make-array (1+ road-length) initial-element t)))\n   3 | (dolist (region regions)\n   4 | (loop for i from (first region) to (second region)\n   5 | do (setf (aref tree-map i) nil)))\n   6 | (count t tree-map)))\n```\n\noptions:\nA.    1 | (defun count-remaining-trees (road-length regions)\n\nB.    5 | do (setf (aref tree-map i) nil)))\n\nC.    4 | (loop for i from (first region) to (second region)\n\nD.    2 | ['(let ((tree-map (make-array (1+ road-length) initial-element t)))']\n\n\n", "loc_answer": ["D"]}
{"question_id": "Clisp/6", "category": "Syntax", "subtype": "missing_colons", "level": "medium", "example": " >>> create-largest-number '(56 9 45)\n \"95645\"\n >>> create-largest-number '(5 50 56)\n \"56550\"", "docstring": ";; This function takes a list of positive integers and rearranges them to form the largest possible number. \n;; It does this by concatenating the integers in an order such that their digit-wise combination yields the maximum value.", "canonical_solution": "(defun create-largest-number (numbers)\n\n\n(let ((str-numbers (mapcar #'number-to-string numbers)))\n(setf str-numbers (sort str-numbers #'larger-when-concatenated))\n(reduce (lambda (acc x) (concatenate 'string acc x)) str-numbers :initial-value \"\")))\n\n(defun number-to-string (number)\n(write-to-string number))\n\n(defun larger-when-concatenated (a b)\n(string> (concatenate 'string a b) (concatenate 'string b a)))", "buggy_code": "(defun create-largest-number (numbers)\n\n\n(let ((str-numbers (mapcar #'number-to-string numbers)))\n(setf str-numbers (sort str-numbers #'larger-when-concatenated))\n(reduce (lambda (acc x) (concatenate 'string acc x)) str-numbers initial-value \"\")))\n\n(defun number-to-string (number)\n(write-to-string number))\n\n(defun larger-when-concatenated (a b)\n(string> (concatenate 'string a b) (concatenate 'string b a)))", "bug_with_line_numbers": "   1 | (defun create-largest-number (numbers)\n   2 | (let ((str-numbers (mapcar #'number-to-string numbers)))\n   3 | (setf str-numbers (sort str-numbers #'larger-when-concatenated))\n   4 | (reduce (lambda (acc x) (concatenate 'string acc x)) str-numbers initial-value \"\")))\n   5 | (defun number-to-string (number)\n   6 | (write-to-string number))\n   7 | (defun larger-when-concatenated (a b)\n   8 | (string> (concatenate 'string a b) (concatenate 'string b a)))", "fragment_lines": [4], "fragment_content": ["(reduce (lambda (acc x) (concatenate 'string acc x)) str-numbers initial-value \"\")))"], "test": "(defun check ()\n(assert (string= (create-largest-number '(56 9 45)) \"95645\"))\n(assert (string= (create-largest-number '(5 50 56)) \"56550\"))\n(assert (string= (create-largest-number '(3 34 302 50)) \"50343302\"))\n(assert (string= (create-largest-number '(10 2 23)) \"23210\"))\n(assert (string= (create-largest-number '(4 42 40 400)) \"44240400\")))\n\n(check)", "line_content": {"4": ["(reduce (lambda (acc x) (concatenate 'string acc x)) str-numbers initial-value \"\")))"]}, "instruction": "\nObserve the following faulty Clisp code and the options. The code snippets in the options are all from faulty code . Your task is to select the option(s) for error code snippet(s).\nNote:\n\n- This is an undetermined multiple-choice question, where the answer may include multiple options.\n- Please provide the answer in the form of a Python list, without returning any content other than the Python code block.. For example \n```python\n[\"A\"]\n```\n\nfaulty code:\n```\n   1 | (defun create-largest-number (numbers)\n   2 | (let ((str-numbers (mapcar #'number-to-string numbers)))\n   3 | (setf str-numbers (sort str-numbers #'larger-when-concatenated))\n   4 | (reduce (lambda (acc x) (concatenate 'string acc x)) str-numbers initial-value \"\")))\n   5 | (defun number-to-string (number)\n   6 | (write-to-string number))\n   7 | (defun larger-when-concatenated (a b)\n   8 | (string> (concatenate 'string a b) (concatenate 'string b a)))\n```\n\noptions:\nA.    1 | (defun create-largest-number (numbers)\n\nB.    6 | (write-to-string number))\n\nC.    4 | ['(reduce (lambda (acc x) (concatenate \\'string acc x)) str-numbers initial-value \"\")))']\n\nD.    7 | (defun larger-when-concatenated (a b)\n\n\n", "loc_answer": ["C"]}
{"question_id": "Clisp/7", "category": "Syntax", "subtype": "misused ==and=", "level": "hard", "example": " >>> bin-search 3 '#(1 2 3 4 5)\n t", "docstring": ";; Binary search for 'obj' in sorted vector 'vec'.\n;; Returns 't' if 'obj' is found, 'nil' otherwise.", "canonical_solution": "(defun bin-search (obj vec)\n\n\n(let ((low 0)\n(high (1- (length vec))))\n(loop while (<= low high)\nfor mid = (floor (+ low high) 2)\nfor mid-val = (aref vec mid)\ndo (cond ((= obj mid-val) (return-from bin-search t))\n((< obj mid-val) (setf high (1- mid)))\n((> obj mid-val) (setf low (1+ mid)))))\nnil))", "buggy_code": "(defun bin-search (obj vec)\n\n\n(let ((low 0)\n(high (1- (length vec))))\n(loop while (<= low high)\nfor mid = (floor (+ low high) 2)\nfor mid-val = (aref vec mid)\ndo (cond ((== obj mid-val) (return-from bin-search t))\n((< obj mid-val) (setf high (1- mid)))\n((> obj mid-val) (setf low (1+ mid)))))\nnil))", "bug_with_line_numbers": "   1 | (defun bin-search (obj vec)\n   2 | (let ((low 0)\n   3 | (high (1- (length vec))))\n   4 | (loop while (<= low high)\n   5 | for mid = (floor (+ low high) 2)\n   6 | for mid-val = (aref vec mid)\n   7 | do (cond ((== obj mid-val) (return-from bin-search t))\n   8 | ((< obj mid-val) (setf high (1- mid)))\n   9 | ((> obj mid-val) (setf low (1+ mid)))))\n  10 | nil))", "fragment_lines": [7], "fragment_content": ["do (cond ((== obj mid-val) (return-from bin-search t))"], "test": "(defun check ()\n;; Test the 'bin-search' function with various cases.\n(assert (equal (bin-search 3 '#(1 2 3 4 5)) t))\n(assert (equal (bin-search 6 '#(1 2 3 4 5)) nil))\n(assert (equal (bin-search 1 '#(1)) t))\n(assert (equal (bin-search 2 '#(1)) nil))\n(assert (equal (bin-search 0 '#()) nil))\n(assert (equal (bin-search 5 '#(2 4 6 8 10)) nil))\n(assert (equal (bin-search 4 '#(2 4 6 8 10)) t)))\n\n(check)", "line_content": {"7": ["do (cond ((== obj mid-val) (return-from bin-search t))"]}, "instruction": "\nObserve the following faulty Clisp code and the options. The code snippets in the options are all from faulty code . Your task is to select the option(s) for error code snippet(s).\nNote:\n\n- This is an undetermined multiple-choice question, where the answer may include multiple options.\n- Please provide the answer in the form of a Python list, without returning any content other than the Python code block.. For example \n```python\n[\"A\"]\n```\n\nfaulty code:\n```\n   1 | (defun bin-search (obj vec)\n   2 | (let ((low 0)\n   3 | (high (1- (length vec))))\n   4 | (loop while (<= low high)\n   5 | for mid = (floor (+ low high) 2)\n   6 | for mid-val = (aref vec mid)\n   7 | do (cond ((== obj mid-val) (return-from bin-search t))\n   8 | ((< obj mid-val) (setf high (1- mid)))\n   9 | ((> obj mid-val) (setf low (1+ mid)))))\n  10 | nil))\n```\n\noptions:\nA.   10 | nil))\n\nB.    3 | (high (1- (length vec))))\n\nC.    2 | (let ((low 0)\n\nD.    7 | ['do (cond ((== obj mid-val) (return-from bin-search t))']\n\n\n", "loc_answer": ["D"]}
{"question_id": "Clisp/8", "category": "Syntax", "subtype": "misused ==and=", "level": "medium", "example": " >>> count-prime-sums '(1 2 3 4) 2\n 2 ; (1+2) and (3+4) are prime\n >>> count-prime-sums '(1 2 3 4 5 6) 3\n 1 ; Only (1+2+5) is prime", "docstring": ";; This function counts the number of ways to select 'k' integers from a list of 'n' integers such that their sum is a prime number.\n;; It considers all possible combinations of 'k' integers from the list and checks if their sum is prime.", "canonical_solution": "(defun count-prime-sums (numbers k)\n\n\n(count t (mapcar (lambda (comb) (is-prime (reduce '+ comb)))\n(sum-combinations numbers k))))\n(defun is-prime (n)\n(cond ((<= n 1) nil)\n((= n 2) t)\n(t (loop for i from 2 to (isqrt n) never (zerop (mod n i))))))\n\n(defun sum-combinations (lst k)\n(if (= k 0)\n'(())\n(loop for i from 0 below (length lst)\nnconc (mapcar (lambda (x) (cons (nth i lst) x))\n(sum-combinations (subseq lst (1+ i)) (1- k))))))", "buggy_code": "(defun count-prime-sums (numbers k)\n\n\n\n(count t (mapcar (lambda (comb) (is-prime (reduce '+ comb)))\n(sum-combinations numbers k))))\n(defun is-prime (n)\n(cond ((<= n 1) nil)\n((= n 2) t)\n(t (loop for i from 2 to (isqrt n) never (zerop (mod n i))))))\n\n(defun sum-combinations (lst k)\n(if (== k 0)\n'(())\n(loop for i from 0 below (length lst)\nnconc (mapcar (lambda (x) (cons (nth i lst) x))\n(sum-combinations (subseq lst (1+ i)) (1- k))))))", "bug_with_line_numbers": "   1 | (defun count-prime-sums (numbers k)\n   2 | (count t (mapcar (lambda (comb) (is-prime (reduce '+ comb)))\n   3 | (sum-combinations numbers k))))\n   4 | (defun is-prime (n)\n   5 | (cond ((<= n 1) nil)\n   6 | ((= n 2) t)\n   7 | (t (loop for i from 2 to (isqrt n) never (zerop (mod n i))))))\n   8 | (defun sum-combinations (lst k)\n   9 | (if (== k 0)\n  10 | '(())\n  11 | (loop for i from 0 below (length lst)\n  12 | nconc (mapcar (lambda (x) (cons (nth i lst) x))\n  13 | (sum-combinations (subseq lst (1+ i)) (1- k))))))", "fragment_lines": [9], "fragment_content": ["(if (== k 0)"], "test": "(defun check ()\n(assert (equal (count-prime-sums '(3 7 12 19) 3) 1))\n(assert (equal (count-prime-sums '(1 2 3 4) 2) 4))\n(assert (equal (count-prime-sums '(1 2 3 4 5 6) 3) 6))\n(assert (equal (count-prime-sums '(10 20 30 40) 2) 0))\n(assert (equal (count-prime-sums '(11 13 17 19 23 29) 3) 12))) \n\n(check)", "line_content": {"9": ["(if (== k 0)"]}, "instruction": "\nObserve the following faulty Clisp code and the options. The code snippets in the options are all from faulty code . Your task is to select the option(s) for error code snippet(s).\nNote:\n\n- This is an undetermined multiple-choice question, where the answer may include multiple options.\n- Please provide the answer in the form of a Python list, without returning any content other than the Python code block.. For example \n```python\n[\"A\"]\n```\n\nfaulty code:\n```\n   1 | (defun count-prime-sums (numbers k)\n   2 | (count t (mapcar (lambda (comb) (is-prime (reduce '+ comb)))\n   3 | (sum-combinations numbers k))))\n   4 | (defun is-prime (n)\n   5 | (cond ((<= n 1) nil)\n   6 | ((= n 2) t)\n   7 | (t (loop for i from 2 to (isqrt n) never (zerop (mod n i))))))\n   8 | (defun sum-combinations (lst k)\n   9 | (if (== k 0)\n  10 | '(())\n  11 | (loop for i from 0 below (length lst)\n  12 | nconc (mapcar (lambda (x) (cons (nth i lst) x))\n  13 | (sum-combinations (subseq lst (1+ i)) (1- k))))))\n```\n\noptions:\nA.    9 | ['(if (== k 0)']\n\nB.    2 | (count t (mapcar (lambda (comb) (is-prime (reduce '+ comb)))\n\nC.    3 | (sum-combinations numbers k))))\n\nD.    4 | (defun is-prime (n)\n\n\n", "loc_answer": ["A"]}
{"question_id": "Clisp/9", "category": "Syntax", "subtype": "unclosed_parentheses", "level": "medium", "example": ">>> has_close_elements([1.0, 2.0, 3.0], 0.5)\nnil\n>>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\nt", "docstring": ";;Check if in given list of numbers, are any two numbers closer to each other than\n;;given threshold.", "canonical_solution": "(defun has-close-elements (numbers threshold)\n\n\n(loop for i from 0 below (length numbers)\ndo (loop for j from 0 below (length numbers)\ndo (when (and (/= i j)\n(< (abs (- (nth i numbers) (nth j numbers))) threshold))\n(return-from has-close-elements t))))\nnil)", "buggy_code": "(defun has-close-elements (numbers threshold)\n\n\n\n(loop for i from 0 below (length numbers)\ndo (loop for j from 0 below (length numbers)\ndo (when (and (/= i j)\n(< (abs (- (nth i numbers) (nth j numbers))) threshold))\n(return-from has-close-elements t)))\nnil)", "bug_with_line_numbers": "   1 | (defun has-close-elements (numbers threshold)\n   2 | (loop for i from 0 below (length numbers)\n   3 | do (loop for j from 0 below (length numbers)\n   4 | do (when (and (/= i j)\n   5 | (< (abs (- (nth i numbers) (nth j numbers))) threshold))\n   6 | (return-from has-close-elements t)))\n   7 | nil)", "fragment_lines": [6], "fragment_content": ["(return-from has-close-elements t)))"], "test": "(defun check ()\n(assert (equal (has-close-elements '(1.0 2.0 3.9 4.0 5.0 2.2) 0.3) t))\n(assert (equal (has-close-elements '(1.0 2.0 3.9 4.0 5.0 2.2) 0.05) nil))\n(assert (equal (has-close-elements '(1.0 2.0 5.9 4.0 5.0) 0.95) t))\n(assert (equal (has-close-elements '(1.0 2.0 5.9 4.0 5.0) 0.8) nil))\n(assert (equal (has-close-elements '(1.0 2.0 3.0 4.0 5.0 2.0) 0.1) t))\n(assert (equal (has-close-elements '(1.1 2.2 3.1 4.1 5.1) 1.0) t))\n(assert (equal (has-close-elements '(1.1 2.2 3.1 4.1 5.1) 0.5) nil)))\n\n(check)", "line_content": {"6": ["(return-from has-close-elements t)))"]}, "instruction": "\nObserve the following faulty Clisp code and the options. The code snippets in the options are all from faulty code . Your task is to select the option(s) for error code snippet(s).\nNote:\n\n- This is an undetermined multiple-choice question, where the answer may include multiple options.\n- Please provide the answer in the form of a Python list, without returning any content other than the Python code block.. For example \n```python\n[\"A\"]\n```\n\nfaulty code:\n```\n   1 | (defun has-close-elements (numbers threshold)\n   2 | (loop for i from 0 below (length numbers)\n   3 | do (loop for j from 0 below (length numbers)\n   4 | do (when (and (/= i j)\n   5 | (< (abs (- (nth i numbers) (nth j numbers))) threshold))\n   6 | (return-from has-close-elements t)))\n   7 | nil)\n```\n\noptions:\nA.    3 | do (loop for j from 0 below (length numbers)\n\nB.    7 | nil)\n\nC.    6 | ['(return-from has-close-elements t)))']\n\nD.    4 | do (when (and (/= i j)\n\n\n", "loc_answer": ["C"]}
{"question_id": "Clisp/10", "category": "Syntax", "subtype": "unclosed_parentheses", "level": "medium", "example": " multiple-value-bind (quarters dimes nickels pennies) (make-change 98\n quarters 3\n dimes 2\n nickels 0\n pennies 3", "docstring": ";; Define a function that accepts an integer cents and returns four values, displaying the numbers as 25-, 10-, 5-, 1-, using the minimum number of coins. (Translation: 25- is 25 cents, and so on)", "canonical_solution": "(defun make-change (cents)\n\n\n(let ((quarters (floor cents 25))\n(remaining-after-quarters (mod cents 25)))\n(let ((dimes (floor remaining-after-quarters 10))\n(remaining-after-dimes (mod remaining-after-quarters 10)))\n(let ((nickels (floor remaining-after-dimes 5))\n(pennies (mod remaining-after-dimes 5)))\n(values quarters dimes nickels pennies)))))", "buggy_code": "(defun make-change (cents)\n\n\n\n(let ((quarters (round cents 25))\n(remaining-after-quarters (mod cents 25)))\n(let ((dimes (round remaining-after-quarters 10))\n(remaining-after-dimes (mod remaining-after-quarters 10)))\n(let ((nickels (round remaining-after-dimes 5))\n(pennies (mod remaining-after-dimes 5)))\n(values quarters dimes nickels pennies))))", "bug_with_line_numbers": "   1 | (defun make-change (cents)\n   2 | (let ((quarters (round cents 25))\n   3 | (remaining-after-quarters (mod cents 25)))\n   4 | (let ((dimes (round remaining-after-quarters 10))\n   5 | (remaining-after-dimes (mod remaining-after-quarters 10)))\n   6 | (let ((nickels (round remaining-after-dimes 5))\n   7 | (pennies (mod remaining-after-dimes 5)))\n   8 | (values quarters dimes nickels pennies))))", "fragment_lines": [8], "fragment_content": ["(values quarters dimes nickels pennies))))"], "test": "(defun check ()\n;; 测试 'make-change' 函数。\n(multiple-value-bind (quarters dimes nickels pennies) (make-change 98)\n(assert (equal quarters 3))\n(assert (equal dimes 2))\n(assert (equal nickels 0))\n(assert (equal pennies 3)))\n(multiple-value-bind (quarters dimes nickels pennies) (make-change 41)\n(assert (equal quarters 1))\n(assert (equal dimes 1))\n(assert (equal nickels 1))\n(assert (equal pennies 1)))\n(multiple-value-bind (quarters dimes nickels pennies) (make-change 3)\n(assert (equal quarters 0))\n(assert (equal dimes 0))\n(assert (equal nickels 0))\n(assert (equal pennies 3))))\n\n(check)", "line_content": {"8": ["(values quarters dimes nickels pennies))))"]}, "instruction": "\nObserve the following faulty Clisp code and the options. The code snippets in the options are all from faulty code . Your task is to select the option(s) for error code snippet(s).\nNote:\n\n- This is an undetermined multiple-choice question, where the answer may include multiple options.\n- Please provide the answer in the form of a Python list, without returning any content other than the Python code block.. For example \n```python\n[\"A\"]\n```\n\nfaulty code:\n```\n   1 | (defun make-change (cents)\n   2 | (let ((quarters (round cents 25))\n   3 | (remaining-after-quarters (mod cents 25)))\n   4 | (let ((dimes (round remaining-after-quarters 10))\n   5 | (remaining-after-dimes (mod remaining-after-quarters 10)))\n   6 | (let ((nickels (round remaining-after-dimes 5))\n   7 | (pennies (mod remaining-after-dimes 5)))\n   8 | (values quarters dimes nickels pennies))))\n```\n\noptions:\nA.    8 | ['(values quarters dimes nickels pennies))))']\n\nB.    3 | (remaining-after-quarters (mod cents 25)))\n\nC.    6 | (let ((nickels (round remaining-after-dimes 5))\n\nD.    5 | (remaining-after-dimes (mod remaining-after-quarters 10)))\n\n\n", "loc_answer": ["A"]}
{"question_id": "Clisp/11", "category": "Syntax", "subtype": "unclosed_parentheses", "level": "easy", "example": " (find-substring-index \"apple pie\" \"pie\")  Returns 6\n (find-substring-index \"hello world\" \"bye\")  Returns -1", "docstring": ";; Finds the first occurrence of the substring 'needle' within the string 'haystack'.\n;; Returns the index of the first character of the first occurrence of 'needle'.\n;; If 'needle' is not a part of 'haystack', returns -1.", "canonical_solution": "(defun find-substring-index (haystack needle)\n\n\n(let ((hay-len (length haystack))\n(need-len (length needle)))\n(if (zerop need-len)\n0\n(if (> need-len hay-len)\n-1\n(loop for i below (1+ (- hay-len need-len))\nwhen (string= (subseq haystack i (min (+ i need-len) hay-len)) needle)\nreturn i\nfinally (return -1))))))", "buggy_code": "(defun find-substring-index (haystack needle)\n\n\n(let ((hay-len (length haystack))\n(need-len (length needle)))\n(if (zerop need-len)\n0\n(if (> need-len hay-len)\n-1\n(loop for i below (1+ (- hay-len need-len))\nwhen (string= (subseq haystack i (min (+ i need-len) hay-len)) needle)\nreturn i\nfinally (return -1)))))", "bug_with_line_numbers": "   1 | (defun find-substring-index (haystack needle)\n   2 | (let ((hay-len (length haystack))\n   3 | (need-len (length needle)))\n   4 | (if (zerop need-len)\n   5 | 0\n   6 | (if (> need-len hay-len)\n   7 | -1\n   8 | (loop for i below (1+ (- hay-len need-len))\n   9 | when (string= (subseq haystack i (min (+ i need-len) hay-len)) needle)\n  10 | return i\n  11 | finally (return -1)))))", "fragment_lines": [11], "fragment_content": ["finally (return -1)))))"], "test": "(defun check ()\n(assert (equal (find-substring-index \"apple pie\" \"pie\") 6))\n(assert (equal (find-substring-index \"hello world\" \"bye\") -1))\n(assert (equal (find-substring-index \"common lisp\" \"lisp\") 7))\n(assert (equal (find-substring-index \"quick brown fox\" \"brown\") 6))\n(assert (equal (find-substring-index \"abcdef\" \"de\") 3))\n(assert (equal (find-substring-index \"abcdef\" \"xyz\") -1)))\n\n(check)", "line_content": {"11": ["finally (return -1)))))"]}, "instruction": "\nObserve the following faulty Clisp code and the options. The code snippets in the options are all from faulty code . Your task is to select the option(s) for error code snippet(s).\nNote:\n\n- This is an undetermined multiple-choice question, where the answer may include multiple options.\n- Please provide the answer in the form of a Python list, without returning any content other than the Python code block.. For example \n```python\n[\"A\"]\n```\n\nfaulty code:\n```\n   1 | (defun find-substring-index (haystack needle)\n   2 | (let ((hay-len (length haystack))\n   3 | (need-len (length needle)))\n   4 | (if (zerop need-len)\n   5 | 0\n   6 | (if (> need-len hay-len)\n   7 | -1\n   8 | (loop for i below (1+ (- hay-len need-len))\n   9 | when (string= (subseq haystack i (min (+ i need-len) hay-len)) needle)\n  10 | return i\n  11 | finally (return -1)))))\n```\n\noptions:\nA.    9 | when (string= (subseq haystack i (min (+ i need-len) hay-len)) needle)\n\nB.   11 | ['finally (return -1)))))']\n\nC.    2 | (let ((hay-len (length haystack))\n\nD.    8 | (loop for i below (1+ (- hay-len need-len))\n\n\n", "loc_answer": ["B"]}
{"question_id": "Clisp/12", "category": "Syntax", "subtype": "unclosed_parentheses", "level": "medium", "example": " (calculate-year-end-amount '(290 230 280 200 300 170 340 50 90 80 200 60))  Returns -7", "docstring": ";; Calculates whether Jinjin can follow her savings plan without running out of money in any month.\n;; 'monthly-budgets' is a list of 12 integers representing Jinjin's monthly budget.\n;; If successful, returns the total amount of money Jinjin will have by year-end, including 20% interest on savings.\n;; Otherwise, returns -X, where X is the first month Jinjin runs out of money.", "canonical_solution": "(defun calculate-year-end-amount (monthly-budgets)\n;; Calculates whether Jinjin can follow her savings plan without running out of money in any month.\n;; 'monthly-budgets' is a list of 12 integers representing Jinjin's monthly budget.\n;; If successful, returns the total amount of money Jinjin will have by year-end, including 20% interest on savings.\n;; Otherwise, returns -X, where X is the first month Jinjin runs out of money.\n;; Example:\n;; (calculate-year-end-amount '(290 230 280 200 300 170 340 50 90 80 200 60)) ;; Returns -7\n\n(let ((current-amount 0)\n(total-saved 0))\n(loop for month from 1 to 12\nfor budget in monthly-budgets\ndo (progn\n(incf current-amount 300) ;; Add monthly allowance\n(decf current-amount budget) ;; Subtract monthly budget\n(when (< current-amount 0)\n(return-from calculate-year-end-amount (- month))) ;; Check if Jinjin runs out of money\n(let ((savings (floor current-amount 100)))\n(decf current-amount (* 100 savings))\n(incf total-saved (* 100 savings))))\nfinally (return (+ current-amount (* total-saved 1.2)))))) ;; Calculate total with interest", "buggy_code": "(defun calculate-year-end-amount (monthly-budgets)\n\n\n(let ((current-amount 0)\n(total-saved 0))\n(loop for month from 1 to 12\nfor budget in monthly-budgets\ndo (progn\n(incf current-amount 300)\n(decf current-amount budget)\n(when (< current-amount 0)\n(return-from calculate-year-end-amount (- month)))\n(let ((savings (floor current-amount 100)))\n(decf current-amount (* 100 savings))\n(incf total-saved (* 100 savings))))\nfinally (return (+ current-amount (* total-saved 1.2)))))", "bug_with_line_numbers": "   1 | (defun calculate-year-end-amount (monthly-budgets)\n   2 | (let ((current-amount 0)\n   3 | (total-saved 0))\n   4 | (loop for month from 1 to 12\n   5 | for budget in monthly-budgets\n   6 | do (progn\n   7 | (incf current-amount 300)\n   8 | (decf current-amount budget)\n   9 | (when (< current-amount 0)\n  10 | (return-from calculate-year-end-amount (- month)))\n  11 | (let ((savings (floor current-amount 100)))\n  12 | (decf current-amount (* 100 savings))\n  13 | (incf total-saved (* 100 savings))))\n  14 | finally (return (+ current-amount (* total-saved 1.2)))))", "fragment_lines": [14], "fragment_content": ["finally (return (+ current-amount (* total-saved 1.2)))))"], "test": "(defun check ()\n(assert (equal (calculate-year-end-amount '(290 230 280 200 300 170 340 50 90 80 200 60)) -7))\n(assert (equal (calculate-year-end-amount '(100 100 100 100 100 100 100 100 100 100 100 100)) 2880.0)) ;; Assuming all savings\n(assert (equal (calculate-year-end-amount '(300 300 300 300 300 300 300 300 300 300 300 300)) 0.0)) ;; No savings\n(assert (equal (calculate-year-end-amount '(150 150 150 150 150 150 150 150 150 150 150 150)) 2160.0)) ;; Half savings\n(assert (equal (calculate-year-end-amount '(250 250 250 250 250 250 250 250 250 250 250 250)) 720.0))) ;; Runs out first month\n(check)", "line_content": {"14": ["finally (return (+ current-amount (* total-saved 1.2)))))"]}, "instruction": "\nObserve the following faulty Clisp code and the options. The code snippets in the options are all from faulty code . Your task is to select the option(s) for error code snippet(s).\nNote:\n\n- This is an undetermined multiple-choice question, where the answer may include multiple options.\n- Please provide the answer in the form of a Python list, without returning any content other than the Python code block.. For example \n```python\n[\"A\"]\n```\n\nfaulty code:\n```\n   1 | (defun calculate-year-end-amount (monthly-budgets)\n   2 | (let ((current-amount 0)\n   3 | (total-saved 0))\n   4 | (loop for month from 1 to 12\n   5 | for budget in monthly-budgets\n   6 | do (progn\n   7 | (incf current-amount 300)\n   8 | (decf current-amount budget)\n   9 | (when (< current-amount 0)\n  10 | (return-from calculate-year-end-amount (- month)))\n  11 | (let ((savings (floor current-amount 100)))\n  12 | (decf current-amount (* 100 savings))\n  13 | (incf total-saved (* 100 savings))))\n  14 | finally (return (+ current-amount (* total-saved 1.2)))))\n```\n\noptions:\nA.    7 | (incf current-amount 300)\n\nB.   14 | ['finally (return (+ current-amount (* total-saved 1.2)))))']\n\nC.    1 | (defun calculate-year-end-amount (monthly-budgets)\n\nD.   13 | (incf total-saved (* 100 savings))))\n\n\n", "loc_answer": ["B"]}
{"question_id": "Clisp/13", "category": "Syntax", "subtype": "unclosed_parentheses", "level": "easy", "example": " >>> construct-preorder \"DBEAC\" \"DEBCA\"\n \"ABCDE\"\n >>> construct-preorder \"HGFEIDBA\" \"HGFIEDBA\"\n \"ABDEFGHI\"", "docstring": ";; This function reconstructs the preorder traversal of a binary tree from its inorder and postorder traversals.\n;; The nodes of the binary tree are represented by distinct uppercase letters.\n;; It is assumed that the tree has no more than 8 nodes.", "canonical_solution": "(defun construct-preorder (inorder postorder)\n\n\n(when (and inorder postorder (not (zerop (length postorder))))\n(let* ((root (char postorder (1- (length postorder))))\n(root-pos (position root inorder)))\n(concatenate 'string\n(string root)\n(construct-preorder (subseq inorder 0 root-pos)\n(subseq postorder 0 root-pos))\n(construct-preorder (subseq inorder (1+ root-pos))\n(subseq postorder root-pos (1- (length postorder))))))))", "buggy_code": "(defun construct-preorder (inorder postorder)\n\n\n(when (and inorder postorder (not (zerop (length postorder))))\n(let* ((root (char postorder (1- (length postorder))))\n(root-pos (position root inorder)))\n(concatenate 'string\n(string root)\n(construct-preorder (subseq inorder 0 root-pos)\n(subseq postorder 0 root-pos))\n(construct-preorder (subseq inorder (1+ root-pos))\n(subseq postorder root-pos (1- (length postorder)))))))", "bug_with_line_numbers": "   1 | (defun construct-preorder (inorder postorder)\n   2 | (when (and inorder postorder (not (zerop (length postorder))))\n   3 | (let* ((root (char postorder (1- (length postorder))))\n   4 | (root-pos (position root inorder)))\n   5 | (concatenate 'string\n   6 | (string root)\n   7 | (construct-preorder (subseq inorder 0 root-pos)\n   8 | (subseq postorder 0 root-pos))\n   9 | (construct-preorder (subseq inorder (1+ root-pos))\n  10 | (subseq postorder root-pos (1- (length postorder)))))))", "fragment_lines": [10], "fragment_content": ["(subseq postorder root-pos (1- (length postorder)))))))"], "test": "(defun check ()\n(assert (string= (construct-preorder \"DBEAC\" \"DEBCA\") \"ABDEC\"))\n(assert (string= (construct-preorder \"HGFEIDBA\" \"HGFIEDBA\") \"ABDEFGHI\"))\n(assert (string= (construct-preorder \"BADC\" \"BDCA\") \"ABCD\"))\n(assert (string= (construct-preorder \"FBAEDC\" \"FBEADC\") \"CDABFE\"))\n(assert (string= (construct-preorder \"A\" \"A\") \"A\")))\n\n(check)", "line_content": {"10": ["(subseq postorder root-pos (1- (length postorder)))))))"]}, "instruction": "\nObserve the following faulty Clisp code and the options. The code snippets in the options are all from faulty code . Your task is to select the option(s) for error code snippet(s).\nNote:\n\n- This is an undetermined multiple-choice question, where the answer may include multiple options.\n- Please provide the answer in the form of a Python list, without returning any content other than the Python code block.. For example \n```python\n[\"A\"]\n```\n\nfaulty code:\n```\n   1 | (defun construct-preorder (inorder postorder)\n   2 | (when (and inorder postorder (not (zerop (length postorder))))\n   3 | (let* ((root (char postorder (1- (length postorder))))\n   4 | (root-pos (position root inorder)))\n   5 | (concatenate 'string\n   6 | (string root)\n   7 | (construct-preorder (subseq inorder 0 root-pos)\n   8 | (subseq postorder 0 root-pos))\n   9 | (construct-preorder (subseq inorder (1+ root-pos))\n  10 | (subseq postorder root-pos (1- (length postorder)))))))\n```\n\noptions:\nA.    2 | (when (and inorder postorder (not (zerop (length postorder))))\n\nB.    3 | (let* ((root (char postorder (1- (length postorder))))\n\nC.    5 | (concatenate 'string\n\nD.   10 | ['(subseq postorder root-pos (1- (length postorder)))))))']\n\n\n", "loc_answer": ["D"]}
{"question_id": "Clisp/14", "category": "Syntax", "subtype": "unclosed_parentheses", "level": "medium", "example": " >>> count-output-sequences 3\n 5\n >>> count-output-sequences 4\n 14", "docstring": ";; This function calculates the total number of different output sequences that can be obtained by using a stack \n;; with operations push and pop on a sequence of numbers from 1 to n.\n;; The operations are: \n;; 1. Push the next number from the input sequence onto the stack.\n;; 2. Pop the top number from the stack and add it to the output sequence.\n;; It counts all the possible sequences of these operations that result in all numbers being moved from the input sequence to the output sequence.", "canonical_solution": "(defun count-output-sequences (n)\n\n\n(let ((dp (make-array (1+ n) :initial-element 0)))\n(setf (aref dp 0) 1)\n(loop for i from 1 to n do\n(loop for j from 0 to (1- i) do\n(incf (aref dp i) (* (aref dp j) (aref dp (1- (- i j)))))))\n(aref dp n)))", "buggy_code": "(defun count-output-sequences (n)\n\n\n(let ((dp (make-array (1+ n) :initial-element 0)))\n(setf (aref dp 0) 1)\n(loop for i from 1 to n do\n(loop for j from 0 to (1- i) do\n(incf (aref dp i) (* (aref dp j) (aref dp (1- (- i j))))))\n(aref dp n)))", "bug_with_line_numbers": "   1 | (defun count-output-sequences (n)\n   2 | (let ((dp (make-array (1+ n) :initial-element 0)))\n   3 | (setf (aref dp 0) 1)\n   4 | (loop for i from 1 to n do\n   5 | (loop for j from 0 to (1- i) do\n   6 | (incf (aref dp i) (* (aref dp j) (aref dp (1- (- i j))))))\n   7 | (aref dp n)))", "fragment_lines": [6], "fragment_content": ["(incf (aref dp i) (* (aref dp j) (aref dp (1- (- i j))))))"], "test": "(defun check ()\n(assert (equal (count-output-sequences 3) 5))\n(assert (equal (count-output-sequences 4) 14))\n(assert (equal (count-output-sequences 5) 42))\n(assert (equal (count-output-sequences 6) 132))\n(assert (equal (count-output-sequences 7) 429)))\n\n(check)", "line_content": {"6": ["(incf (aref dp i) (* (aref dp j) (aref dp (1- (- i j))))))"]}, "instruction": "\nObserve the following faulty Clisp code and the options. The code snippets in the options are all from faulty code . Your task is to select the option(s) for error code snippet(s).\nNote:\n\n- This is an undetermined multiple-choice question, where the answer may include multiple options.\n- Please provide the answer in the form of a Python list, without returning any content other than the Python code block.. For example \n```python\n[\"A\"]\n```\n\nfaulty code:\n```\n   1 | (defun count-output-sequences (n)\n   2 | (let ((dp (make-array (1+ n) :initial-element 0)))\n   3 | (setf (aref dp 0) 1)\n   4 | (loop for i from 1 to n do\n   5 | (loop for j from 0 to (1- i) do\n   6 | (incf (aref dp i) (* (aref dp j) (aref dp (1- (- i j))))))\n   7 | (aref dp n)))\n```\n\noptions:\nA.    1 | (defun count-output-sequences (n)\n\nB.    5 | (loop for j from 0 to (1- i) do\n\nC.    6 | ['(incf (aref dp i) (* (aref dp j) (aref dp (1- (- i j))))))']\n\nD.    7 | (aref dp n)))\n\n\n", "loc_answer": ["C"]}
{"question_id": "Clisp/15", "category": "Syntax", "subtype": "unclosed_parentheses", "level": "easy", "example": " >>> list-to-dots '(a b c)\n (a . (b . (c . nil)))", "docstring": ";; takes a list and prints it in dot natation", "canonical_solution": "(defun list-to-dots (lst)\n\n\n(if (null lst)\n'nil\n(cons (car lst) (list-to-dots (cdr lst)))))", "buggy_code": "(defun list-to-dots (lst)\n\n\n(if (null lst)\n'nil\n(cons (car lst) (list-to-dots (cdr lst))))", "bug_with_line_numbers": "   1 | (defun list-to-dots (lst)\n   2 | (if (null lst)\n   3 | 'nil\n   4 | (cons (car lst) (list-to-dots (cdr lst))))", "fragment_lines": [4], "fragment_content": ["(cons (car lst) (list-to-dots (cdr lst))))"], "test": "(defun check ()\n;; 测试 'list-to-dots' 函数。\n(assert (equal (list-to-dots '(a b c)) '(a . (b . (c . nil)))))\n(assert (equal (list-to-dots '(1 2 3)) '(1 . (2 . (3 . nil)))))\n(assert (equal (list-to-dots '(x y)) '(x . (y . nil))))\n(assert (equal (list-to-dots '()) 'nil)))\n\n(check)", "line_content": {"4": ["(cons (car lst) (list-to-dots (cdr lst))))"]}, "instruction": "\nObserve the following faulty Clisp code and the options. The code snippets in the options are all from faulty code . Your task is to select the option(s) for error code snippet(s).\nNote:\n\n- This is an undetermined multiple-choice question, where the answer may include multiple options.\n- Please provide the answer in the form of a Python list, without returning any content other than the Python code block.. For example \n```python\n[\"A\"]\n```\n\nfaulty code:\n```\n   1 | (defun list-to-dots (lst)\n   2 | (if (null lst)\n   3 | 'nil\n   4 | (cons (car lst) (list-to-dots (cdr lst))))\n```\n\noptions:\nA.    2 | (if (null lst)\n\nB.    4 | ['(cons (car lst) (list-to-dots (cdr lst))))']\n\nC.    3 | 'nil\n\nD.    1 | (defun list-to-dots (lst)\n\n\n", "loc_answer": ["B"]}
{"question_id": "Clisp/16", "category": "Syntax", "subtype": "unclosed_string", "level": "hard", "example": " >>> represent-as-powers-of-two(10)\n \"2+2(2()+2)\"\n >>> represent-as-powers-of-two(26)\n \"2+2(2()+2)+2(2(2))\"", "docstring": ";; This function takes a positive integer 'n' and returns its representation as a sum of powers of two. \n;; The powers are expressed in a specific format where a^b is represented as a(b), and terms are summed without spaces.\n;; Specifically, 2^0 is represented as 2()\n;; This function joins a list of strings with a given separator.", "canonical_solution": "(defun represent-as-powers-of-two (n)\n;; This function takes a positive integer 'n' and returns its representation as a sum of powers of two. \n;; The powers are expressed in a specific format where a^b is represented as a(b), and terms are summed without spaces.\n;; Specifically, 2^0 is represented as 2()\n;; Example:\n;; >>> represent-as-powers-of-two(10)\n;; \"2+2(2()+2)\"\n;; >>> represent-as-powers-of-two(26)\n;; \"2+2(2()+2)+2(2(2))\"\n\n(let ((result '()) (power 0))\n(loop while (> n 0)\ndo (progn\n(when (> (logand n 1) 0)\n(push (if (= power 1) \"2\" (format nil \"2(~a)\" (represent-as-powers-of-two power))) result))\n(setq power (+ power 1))\n(setq n (ash n -1))))\n(string-join (reverse result) \"+\")))\n(defun string-join (list separator)\n;; This function joins a list of strings with a given separator.\n(with-output-to-string (stream)\n(when list\n(write-string (first list) stream)\n(dolist (item (rest list))\n(write-string separator stream)\n(write-string item stream)))))", "buggy_code": "(defun represent-as-powers-of-two (n)\n;; This function takes a positive integer 'n' and returns its representation as a sum of powers of two. \n;; The powers are expressed in a specific format where a^b is represented as a(b), and terms are summed without spaces.\n;; Specifically, 2^0 is represented as 2()\n\n(let ((result '()) (power 0))\n(loop while (> n 0)\ndo (progn\n(when (> (logand n 1) 0)\n(push (if (= power 1) \"2\" (format nil \"2(~a) (represent-as-powers-of-two power))) result))\n(setq power (+ power 1))\n(setq n (ash n -1))))\n(string-join (reverse result) \"+\")))\n(defun string-join (list separator)\n;; This function joins a list of strings with a given separator.\n(with-output-to-string (stream)\n(when list\n(write-string (first list) stream)\n(dolist (item (rest list))\n(write-string separator stream)\n(write-string item stream)))))", "bug_with_line_numbers": "   1 | (defun represent-as-powers-of-two (n)\n   2 | (let ((result '()) (power 0))\n   3 | (loop while (> n 0)\n   4 | do (progn\n   5 | (when (> (logand n 1) 0)\n   6 | (push (if (= power 1) \"2\" (format nil \"2(~a) (represent-as-powers-of-two power))) result))\n   7 | (setq power (+ power 1))\n   8 | (setq n (ash n -1))))\n   9 | (string-join (reverse result) \"+\")))\n  10 | (defun string-join (list separator)\n  11 | (with-output-to-string (stream)\n  12 | (when list\n  13 | (write-string (first list) stream)\n  14 | (dolist (item (rest list))\n  15 | (write-string separator stream)\n  16 | (write-string item stream)))))", "fragment_lines": [6], "fragment_content": ["(push (if (= power 1) \"2\" (format nil \"2(~a) (represent-as-powers-of-two power))) result))"], "test": "(defun check ()\n(assert (equal (represent-as-powers-of-two 10) \"2+2(2()+2)\"))\n(assert (equal (represent-as-powers-of-two 26) \"2+2(2()+2)+2(2(2))\"))\n(assert (equal (represent-as-powers-of-two 1) \"2()\"))\n(assert (equal (represent-as-powers-of-two 31) \"2()+2+2(2)+2(2()+2)+2(2(2))\"))\n(assert (equal (represent-as-powers-of-two 100) \"2(2)+2(2()+2(2))+2(2+2(2))\")))\n\n(check)", "line_content": {"6": ["(push (if (= power 1) \"2\" (format nil \"2(~a) (represent-as-powers-of-two power))) result))"]}, "instruction": "\nObserve the following faulty Clisp code and the options. The code snippets in the options are all from faulty code . Your task is to select the option(s) for error code snippet(s).\nNote:\n\n- This is an undetermined multiple-choice question, where the answer may include multiple options.\n- Please provide the answer in the form of a Python list, without returning any content other than the Python code block.. For example \n```python\n[\"A\"]\n```\n\nfaulty code:\n```\n   1 | (defun represent-as-powers-of-two (n)\n   2 | (let ((result '()) (power 0))\n   3 | (loop while (> n 0)\n   4 | do (progn\n   5 | (when (> (logand n 1) 0)\n   6 | (push (if (= power 1) \"2\" (format nil \"2(~a) (represent-as-powers-of-two power))) result))\n   7 | (setq power (+ power 1))\n   8 | (setq n (ash n -1))))\n   9 | (string-join (reverse result) \"+\")))\n  10 | (defun string-join (list separator)\n  11 | (with-output-to-string (stream)\n  12 | (when list\n  13 | (write-string (first list) stream)\n  14 | (dolist (item (rest list))\n  15 | (write-string separator stream)\n  16 | (write-string item stream)))))\n```\n\noptions:\nA.    9 | (string-join (reverse result) \"+\")))\n\nB.    6 | ['(push (if (= power 1) \"2\" (format nil \"2(~a) (represent-as-powers-of-two power))) result))']\n\nC.   11 | (with-output-to-string (stream)\n\nD.    7 | (setq power (+ power 1))\n\n\n", "loc_answer": ["B"]}
{"question_id": "Clisp/17", "category": "Reference", "subtype": "faulty_indexing", "level": "hard", "example": " (divisible-five-digit-numbers 15)  Returns (22555 25555 28555 30000)\n (divisible-five-digit-numbers 7)  Returns a list of numbers or 'No' if no such numbers exist", "docstring": ";; Finds all five-digit numbers between 10000 and 30000 where three sub-numbers \n;; (formed by consecutive digits) are divisible by 'k'.\n;; Each sub-number consists of three consecutive digits from the original number.\n;; The function returns a list of such five-digit numbers.", "canonical_solution": "(defun divisible-five-digit-numbers (k)\n\n\n(let ((results '()))\n(loop for num from 10000 to 30000\nwhen (and (zerop (mod (parse-integer (subseq (write-to-string num) 0 3)) k))\n(zerop (mod (parse-integer (subseq (write-to-string num) 1 4)) k))\n(zerop (mod (parse-integer (subseq (write-to-string num) 2 5)) k)))\ndo (push num results))\n(if (null results)\n'No\n(nreverse results))))", "buggy_code": "(defun divisible-five-digit-numbers (k)\n\n\n(let ((results '()))\n(loop for num from 10000 to 30000\nwhen (and (zerop (mod (parse-integer (subseq (write-to-string num) 1 3)) k))\n(zerop (mod (parse-integer (subseq (write-to-string num) 2 4)) k))\n(zerop (mod (parse-integer (subseq (write-to-string num) 3 5)) k)))\ndo (push num results))\n(if (null results)\n'No\n(nreverse results))))", "bug_with_line_numbers": "   1 | (defun divisible-five-digit-numbers (k)\n   2 | (let ((results '()))\n   3 | (loop for num from 10000 to 30000\n   4 | when (and (zerop (mod (parse-integer (subseq (write-to-string num) 1 3)) k))\n   5 | (zerop (mod (parse-integer (subseq (write-to-string num) 2 4)) k))\n   6 | (zerop (mod (parse-integer (subseq (write-to-string num) 3 5)) k)))\n   7 | do (push num results))\n   8 | (if (null results)\n   9 | 'No\n  10 | (nreverse results))))", "fragment_lines": [4, 5, 6], "fragment_content": ["when (and (zerop (mod (parse-integer (subseq (write-to-string num) 1 3)) k))", "(zerop (mod (parse-integer (subseq (write-to-string num) 2 4)) k))", "(zerop (mod (parse-integer (subseq (write-to-string num) 3 5)) k)))"], "test": "(defun check ()\n(assert (equal (divisible-five-digit-numbers 15) '(22555 25555 28555 30000)))\n(assert (equal (divisible-five-digit-numbers 31) '(15589 18682))) ;; No such numbers exist\n(assert (equal (divisible-five-digit-numbers 999) 'No))) ;; No such numbers exist for a large divisor\n\n(check)", "line_content": {"4,5,6": ["when (and (zerop (mod (parse-integer (subseq (write-to-string num) 1 3)) k))", "(zerop (mod (parse-integer (subseq (write-to-string num) 2 4)) k))", "(zerop (mod (parse-integer (subseq (write-to-string num) 3 5)) k)))"]}, "instruction": "\nObserve the following faulty Clisp code and the options. The code snippets in the options are all from faulty code . Your task is to select the option(s) for error code snippet(s).\nNote:\n\n- This is an undetermined multiple-choice question, where the answer may include multiple options.\n- Please provide the answer in the form of a Python list, without returning any content other than the Python code block.. For example \n```python\n[\"A\"]\n```\n\nfaulty code:\n```\n   1 | (defun divisible-five-digit-numbers (k)\n   2 | (let ((results '()))\n   3 | (loop for num from 10000 to 30000\n   4 | when (and (zerop (mod (parse-integer (subseq (write-to-string num) 1 3)) k))\n   5 | (zerop (mod (parse-integer (subseq (write-to-string num) 2 4)) k))\n   6 | (zerop (mod (parse-integer (subseq (write-to-string num) 3 5)) k)))\n   7 | do (push num results))\n   8 | (if (null results)\n   9 | 'No\n  10 | (nreverse results))))\n```\n\noptions:\nA.    4 | when (and (zerop (mod (parse-integer (subseq (write-to-string num) 1 3)) k))\n   5 | (zerop (mod (parse-integer (subseq (write-to-string num) 2 4)) k))\n   6 | (zerop (mod (parse-integer (subseq (write-to-string num) 3 5)) k)))\n\nB.    2 | (let ((results '()))\n\nC.    1 | (defun divisible-five-digit-numbers (k)\n\nD.    3 | (loop for num from 10000 to 30000\n\n\n", "loc_answer": ["A"]}
{"question_id": "Clisp/18", "category": "Reference", "subtype": "faulty_indexing", "level": "medium", "example": " >>> construct-preorder \"DBEAC\" \"DEBCA\"\n \"ABCDE\"\n >>> construct-preorder \"HGFEIDBA\" \"HGFIEDBA\"\n \"ABDEFGHI\"", "docstring": ";; This function reconstructs the preorder traversal of a binary tree from its inorder and postorder traversals.\n;; The nodes of the binary tree are represented by distinct uppercase letters.\n;; It is assumed that the tree has no more than 8 nodes.", "canonical_solution": "(defun construct-preorder (inorder postorder)\n\n\n(when (and inorder postorder (not (zerop (length postorder))))\n(let* ((root (char postorder (1- (length postorder))))\n(root-pos (position root inorder)))\n(concatenate 'string\n(string root)\n(construct-preorder (subseq inorder 0 root-pos)\n(subseq postorder 0 root-pos))\n(construct-preorder (subseq inorder (1+ root-pos))\n(subseq postorder root-pos (1- (length postorder))))))))", "buggy_code": "(defun construct-preorder (inorder postorder)\n\n\n\n(when (and inorder postorder (not (zerop (length postorder))))\n(let* ((root (char postorder (1- (length postorder))))\n(root-pos (position root inorder)))\n(concatenate 'string\n(string root)\n(construct-preorder (subseq inorder 0 root-pos)\n(subseq postorder 0 root-pos))\n(construct-preorder (subseq inorder  root-pos)\n(subseq postorder root-pos (1- (length postorder))))))))", "bug_with_line_numbers": "   1 | (defun construct-preorder (inorder postorder)\n   2 | (when (and inorder postorder (not (zerop (length postorder))))\n   3 | (let* ((root (char postorder (1- (length postorder))))\n   4 | (root-pos (position root inorder)))\n   5 | (concatenate 'string\n   6 | (string root)\n   7 | (construct-preorder (subseq inorder 0 root-pos)\n   8 | (subseq postorder 0 root-pos))\n   9 | (construct-preorder (subseq inorder  root-pos)\n  10 | (subseq postorder root-pos (1- (length postorder))))))))", "fragment_lines": [9], "fragment_content": ["(construct-preorder (subseq inorder  root-pos)"], "test": "(defun check ()\n(assert (string= (construct-preorder \"DBEAC\" \"DEBCA\") \"ABDEC\"))\n(assert (string= (construct-preorder \"HGFEIDBA\" \"HGFIEDBA\") \"ABDEFGHI\"))\n(assert (string= (construct-preorder \"BADC\" \"BDCA\") \"ABCD\"))\n(assert (string= (construct-preorder \"FBAEDC\" \"FBEADC\") \"CDABFE\"))\n(assert (string= (construct-preorder \"A\" \"A\") \"A\")))\n\n(check)", "line_content": {"9": ["(construct-preorder (subseq inorder  root-pos)"]}, "instruction": "\nObserve the following faulty Clisp code and the options. The code snippets in the options are all from faulty code . Your task is to select the option(s) for error code snippet(s).\nNote:\n\n- This is an undetermined multiple-choice question, where the answer may include multiple options.\n- Please provide the answer in the form of a Python list, without returning any content other than the Python code block.. For example \n```python\n[\"A\"]\n```\n\nfaulty code:\n```\n   1 | (defun construct-preorder (inorder postorder)\n   2 | (when (and inorder postorder (not (zerop (length postorder))))\n   3 | (let* ((root (char postorder (1- (length postorder))))\n   4 | (root-pos (position root inorder)))\n   5 | (concatenate 'string\n   6 | (string root)\n   7 | (construct-preorder (subseq inorder 0 root-pos)\n   8 | (subseq postorder 0 root-pos))\n   9 | (construct-preorder (subseq inorder  root-pos)\n  10 | (subseq postorder root-pos (1- (length postorder))))))))\n```\n\noptions:\nA.    1 | (defun construct-preorder (inorder postorder)\n\nB.    9 | ['(construct-preorder (subseq inorder  root-pos)']\n\nC.    4 | (root-pos (position root inorder)))\n\nD.    8 | (subseq postorder 0 root-pos))\n\n\n", "loc_answer": ["B"]}
{"question_id": "Clisp/19", "category": "Reference", "subtype": "function_error", "level": "medium", "example": " >>> parse-date \"16 Aug 1980\"\n 16 8 1980", "docstring": "", "canonical_solution": "(defun parse-date (date-str)\n\"Parse a date string in the format 'DD MMM YYYY' and return a list (day month year).\"\n\n\n(let ((toks (tokens date-str #'constituent 0)))\n(list (parse-integer (first toks):junk-allowed t)\n(parse-month (second toks))\n(parse-integer (third toks)))))\n\n(defun tokens (str test start)\n(let ((p1 (position-if test str :start start)))\n(if p1\n(let ((p2 (position-if #'(lambda (c)\n(not (funcall test c)))\nstr :start p1)))\n(cons (subseq str p1 p2)\n(if p2\n(tokens str test p2)\nnil)))\nnil)))\n(defun constituent (c)\n(and (graphic-char-p c)\n(not (char= c #\\ ))))\n\n(defconstant month-names\n'(\"jan\" \"feb\" \"mar\" \"apr\" \"may\" \"jun\"\n\"jul\" \"aug\" \"sep\" \"oct\" \"nov\" \"dec\"))\n\n(defun parse-month (str)\n\"Parse the month string and return the month number.\"\n(let ((p (position (string-downcase str) month-names :test #'string-equal)))\n(if p\n(1+ p)\n(error \"Invalid month string: ~A\" str))))", "buggy_code": "(defun parse-date (date-str)\n\"Parse a date string in the format 'DD MMM YYYY' and return a list (day month year).\"\n\n\n(let ((toks (tokens date-str #'constituent)))\n(list (parse-integer (first toks):junk-allowed t)\n(parse-month (second toks))\n(parse-integer (third toks)))))\n\n(defun tokens (str test start)\n(let ((p1 (position-if test str :start start)))\n(if p1\n(let ((p2 (position-if #'(lambda (c)\n(not (funcall test c)))\nstr :start p1)))\n(cons (subseq str p1 p2)\n(if p2\n(tokens str test p2)\nnil)))\nnil)))\n\n(defun constituent (c)\n(and (graphic-char-p c)\n(not (char= c #\\ ))))\n\n(defconstant month-names\n'(\"jan\" \"feb\" \"mar\" \"apr\" \"may\" \"jun\"\n\"jul\" \"aug\" \"sep\" \"oct\" \"nov\" \"dec\"))\n\n(defun parse-month (str)\n\"Parse the month string and return the month number.\"\n(let ((p (position (string-downcase str) month-names :test #'string-equal)))\n(if p\n(1+ p)\n(error \"Invalid month string: ~A\" str))))", "bug_with_line_numbers": "   1 | (defun parse-date (date-str)\n   2 | \"Parse a date string in the format 'DD MMM YYYY' and return a list (day month year).\"\n   3 | (let ((toks (tokens date-str #'constituent)))\n   4 | (list (parse-integer (first toks):junk-allowed t)\n   5 | (parse-month (second toks))\n   6 | (parse-integer (third toks)))))\n   7 | (defun tokens (str test start)\n   8 | (let ((p1 (position-if test str :start start)))\n   9 | (if p1\n  10 | (let ((p2 (position-if #'(lambda (c)\n  11 | (not (funcall test c)))\n  12 | str :start p1)))\n  13 | (cons (subseq str p1 p2)\n  14 | (if p2\n  15 | (tokens str test p2)\n  16 | nil)))\n  17 | nil)))\n  18 | (defun constituent (c)\n  19 | (and (graphic-char-p c)\n  20 | (not (char= c #\\ ))))\n  21 | (defconstant month-names\n  22 | '(\"jan\" \"feb\" \"mar\" \"apr\" \"may\" \"jun\"\n  23 | \"jul\" \"aug\" \"sep\" \"oct\" \"nov\" \"dec\"))\n  24 | (defun parse-month (str)\n  25 | \"Parse the month string and return the month number.\"\n  26 | (let ((p (position (string-downcase str) month-names :test #'string-equal)))\n  27 | (if p\n  28 | (1+ p)\n  29 | (error \"Invalid month string: ~A\" str))))", "fragment_lines": [3], "fragment_content": ["(let ((toks (tokens date-str #'constituent)))"], "test": "(defun check ()\n;; Test the 'parse-date' function with various date strings.\n(assert (equal (parse-date \"16 Aug 1980\") '(16 8 1980)))\n(assert (equal (parse-date \"1 Jan 2023\") '(1 1 2023)))\n(assert (equal (parse-date \"25 Dec 1999\") '(25 12 1999)))\n(assert (equal (parse-date \"31 Oct 2025\") '(31 10 2025)))\n(assert (equal (parse-date \"20 Feb 2010\") '(20 2 2010))))\n\n(check)", "line_content": {"3": ["(let ((toks (tokens date-str #'constituent)))"]}, "instruction": "\nObserve the following faulty Clisp code and the options. The code snippets in the options are all from faulty code . Your task is to select the option(s) for error code snippet(s).\nNote:\n\n- This is an undetermined multiple-choice question, where the answer may include multiple options.\n- Please provide the answer in the form of a Python list, without returning any content other than the Python code block.. For example \n```python\n[\"A\"]\n```\n\nfaulty code:\n```\n   1 | (defun parse-date (date-str)\n   2 | \"Parse a date string in the format 'DD MMM YYYY' and return a list (day month year).\"\n   3 | (let ((toks (tokens date-str #'constituent)))\n   4 | (list (parse-integer (first toks):junk-allowed t)\n   5 | (parse-month (second toks))\n   6 | (parse-integer (third toks)))))\n   7 | (defun tokens (str test start)\n   8 | (let ((p1 (position-if test str :start start)))\n   9 | (if p1\n  10 | (let ((p2 (position-if #'(lambda (c)\n  11 | (not (funcall test c)))\n  12 | str :start p1)))\n  13 | (cons (subseq str p1 p2)\n  14 | (if p2\n  15 | (tokens str test p2)\n  16 | nil)))\n  17 | nil)))\n  18 | (defun constituent (c)\n  19 | (and (graphic-char-p c)\n  20 | (not (char= c #\\ ))))\n  21 | (defconstant month-names\n  22 | '(\"jan\" \"feb\" \"mar\" \"apr\" \"may\" \"jun\"\n  23 | \"jul\" \"aug\" \"sep\" \"oct\" \"nov\" \"dec\"))\n  24 | (defun parse-month (str)\n  25 | \"Parse the month string and return the month number.\"\n  26 | (let ((p (position (string-downcase str) month-names :test #'string-equal)))\n  27 | (if p\n  28 | (1+ p)\n  29 | (error \"Invalid month string: ~A\" str))))\n```\n\noptions:\nA.    3 | [\"(let ((toks (tokens date-str #'constituent)))\"]\n\nB.   17 | nil)))\n\nC.    5 | (parse-month (second toks))\n\nD.    1 | (defun parse-date (date-str)\n\n\n", "loc_answer": ["A"]}
{"question_id": "Clisp/20", "category": "Reference", "subtype": "illegal_keyword", "level": "easy", "example": " quicksort '(3 1 4 1 5 9 2 6 5 3 5)\n 1 1 2 3 3 4 5 5 5 6 9", "docstring": ";; Quickly sort the list", "canonical_solution": "(defun quicksort (list)\n\n\n(if (null list)\nnil\n(let ((pivot (first list))\n(rest (rest list)))\n(append (quicksort (remove-if-not #'(lambda (x) (< x pivot)) rest))\n(list pivot)\n(quicksort (remove-if #'(lambda (x) (< x pivot)) rest))))))", "buggy_code": "(defun quicksort (list)\n\n\n(if (null list)\nnull\n(let ((pivot (first list))\n(rest (rest list)))\n(append (quicksort (remove-if-not #'(lambda (x) (< x pivot)) rest))\n(list pivot)\n(quicksort (remove-if #'(lambda (x) (< x pivot)) rest))))))", "bug_with_line_numbers": "   1 | (defun quicksort (list)\n   2 | (if (null list)\n   3 | null\n   4 | (let ((pivot (first list))\n   5 | (rest (rest list)))\n   6 | (append (quicksort (remove-if-not #'(lambda (x) (< x pivot)) rest))\n   7 | (list pivot)\n   8 | (quicksort (remove-if #'(lambda (x) (< x pivot)) rest))))))", "fragment_lines": [2, 3], "fragment_content": ["(if (null list)", "null"], "test": "(defun check ()\n;; 测试 'quicksort' 函数。\n(assert (equal (quicksort '(3 1 4 1 5 9 2 6 5 3 5)) '(1 1 2 3 3 4 5 5 5 6 9)))\n(assert (equal (quicksort '(5 4 3 2 1)) '(1 2 3 4 5)))\n(assert (equal (quicksort '()) '()))\n(assert (equal (quicksort '(1)) '(1))))\n\n(check)\n\n;;fragment:null\n;;level:easy", "line_content": {"2,3": ["(if (null list)", "null"]}, "instruction": "\nObserve the following faulty Clisp code and the options. The code snippets in the options are all from faulty code . Your task is to select the option(s) for error code snippet(s).\nNote:\n\n- This is an undetermined multiple-choice question, where the answer may include multiple options.\n- Please provide the answer in the form of a Python list, without returning any content other than the Python code block.. For example \n```python\n[\"A\"]\n```\n\nfaulty code:\n```\n   1 | (defun quicksort (list)\n   2 | (if (null list)\n   3 | null\n   4 | (let ((pivot (first list))\n   5 | (rest (rest list)))\n   6 | (append (quicksort (remove-if-not #'(lambda (x) (< x pivot)) rest))\n   7 | (list pivot)\n   8 | (quicksort (remove-if #'(lambda (x) (< x pivot)) rest))))))\n```\n\noptions:\nA.    8 | (quicksort (remove-if #'(lambda (x) (< x pivot)) rest))))))\n\nB.    5 | (rest (rest list)))\n\nC.    2 | (if (null list)\n   3 | null\n\nD.    4 | (let ((pivot (first list))\n\n\n", "loc_answer": ["C"]}
{"question_id": "Clisp/21", "category": "Reference", "subtype": "illegal_keyword", "level": "easy", "example": " >>> count-output-sequences 3\n 5\n >>> count-output-sequences 4\n 14", "docstring": ";; This function calculates the total number of different output sequences that can be obtained by using a stack \n;; with operations push and pop on a sequence of numbers from 1 to n.\n;; The operations are: \n;; 1. Push the next number from the input sequence onto the stack.\n;; 2. Pop the top number from the stack and add it to the output sequence.\n;; It counts all the possible sequences of these operations that result in all numbers being moved from the input sequence to the output sequence.", "canonical_solution": "(defun count-output-sequences (n)\n\n\n(let ((dp (make-array (1+ n) :initial-element 0)))\n(setf (aref dp 0) 1)\n(loop for i from 1 to n do\n(loop for j from 0 to (1- i) do\n(incf (aref dp i) (* (aref dp j) (aref dp (1- (- i j)))))))\n(aref dp n)))", "buggy_code": "(defun count-output-sequences (n)\n\n\n(let ((dp (make-array (1+ n) :initialelement 0)))\n(setf (aref dp 0) 1)\n(loop for i from 1 to n do\n(loop for j from 0 to (1- i) do\n(incf (aref dp i) (* (aref dp j) (aref dp (1- (- i j)))))))\n(aref dp n)))", "bug_with_line_numbers": "   1 | (defun count-output-sequences (n)\n   2 | (let ((dp (make-array (1+ n) :initialelement 0)))\n   3 | (setf (aref dp 0) 1)\n   4 | (loop for i from 1 to n do\n   5 | (loop for j from 0 to (1- i) do\n   6 | (incf (aref dp i) (* (aref dp j) (aref dp (1- (- i j)))))))\n   7 | (aref dp n)))", "fragment_lines": [2], "fragment_content": ["(let ((dp (make-array (1+ n) :initialelement 0)))"], "test": "(defun check ()\n(assert (equal (count-output-sequences 3) 5))\n(assert (equal (count-output-sequences 4) 14))\n(assert (equal (count-output-sequences 5) 42))\n(assert (equal (count-output-sequences 6) 132))\n(assert (equal (count-output-sequences 7) 429)))\n\n(check)", "line_content": {"2": ["(let ((dp (make-array (1+ n) :initialelement 0)))"]}, "instruction": "\nObserve the following faulty Clisp code and the options. The code snippets in the options are all from faulty code . Your task is to select the option(s) for error code snippet(s).\nNote:\n\n- This is an undetermined multiple-choice question, where the answer may include multiple options.\n- Please provide the answer in the form of a Python list, without returning any content other than the Python code block.. For example \n```python\n[\"A\"]\n```\n\nfaulty code:\n```\n   1 | (defun count-output-sequences (n)\n   2 | (let ((dp (make-array (1+ n) :initialelement 0)))\n   3 | (setf (aref dp 0) 1)\n   4 | (loop for i from 1 to n do\n   5 | (loop for j from 0 to (1- i) do\n   6 | (incf (aref dp i) (* (aref dp j) (aref dp (1- (- i j)))))))\n   7 | (aref dp n)))\n```\n\noptions:\nA.    6 | (incf (aref dp i) (* (aref dp j) (aref dp (1- (- i j)))))))\n\nB.    2 | ['(let ((dp (make-array (1+ n) :initialelement 0)))']\n\nC.    7 | (aref dp n)))\n\nD.    4 | (loop for i from 1 to n do\n\n\n", "loc_answer": ["B"]}
{"question_id": "Clisp/22", "category": "Reference", "subtype": "undefined_methods", "level": "medium", "example": " >>> parse-date \"16 Aug 1980\"\n 16 8 1980", "docstring": "", "canonical_solution": "(defun parse-date (date-str)\n\"Parse a date string in the format 'DD MMM YYYY' and return a list (day month year).\"\n\n\n(let ((toks (tokens date-str #'constituent 0)))\n(list (parse-integer (first toks):junk-allowed t)\n(parse-month (second toks))\n(parse-integer (third toks)))))\n\n(defun tokens (str test start)\n(let ((p1 (position-if test str :start start)))\n(if p1\n(let ((p2 (position-if #'(lambda (c)\n(not (funcall test c)))\nstr :start p1)))\n(cons (subseq str p1 p2)\n(if p2\n(tokens str test p2)\nnil)))\nnil)))\n(defun constituent (c)\n(and (graphic-char-p c)\n(not (char= c #\\ ))))\n\n(defconstant month-names\n'(\"jan\" \"feb\" \"mar\" \"apr\" \"may\" \"jun\"\n\"jul\" \"aug\" \"sep\" \"oct\" \"nov\" \"dec\"))\n\n(defun parse-month (str)\n\"Parse the month string and return the month number.\"\n(let ((p (position (string-downcase str) month-names :test #'string-equal)))\n(if p\n(1+ p)\n(error \"Invalid month string: ~A\" str))))", "buggy_code": "(defun parse-date (date-str)\n\"Parse a date string in the format 'DD MMM YYYY' and return a list (day month year).\"\n\n(let ((toks (tokens date-str #'constituent 0)))\n(list (parse-integer (first toks):junk-allowed t)\n(parse-month (second toks))\n(parse-integer (third toks)))))\n\n(defun tokens (str test start)\n(let ((p1 (position-if test str :start start)))\n(if p1\n(let ((p2 (position-if #'(lambda (c)\n(not (funcall test c)))\nstr :start p1)))\n(cons (subseq str p1 p2)\n(if p2\n(tokens str test p2)\nnil)))\nnil)))\n\n(defconstant month-names\n'(\"jan\" \"feb\" \"mar\" \"apr\" \"may\" \"jun\"\n\"jul\" \"aug\" \"sep\" \"oct\" \"nov\" \"dec\"))\n\n(defun parse-month (str)\n\"Parse the month string and return the month number.\"\n(let ((p (position (string-downcase str) month-names :test #'string-equal)))\n(if p\n(1+ p)\n(error \"Invalid month string: ~A\" str))))", "bug_with_line_numbers": "   1 | (defun parse-date (date-str)\n   2 | \"Parse a date string in the format 'DD MMM YYYY' and return a list (day month year).\"\n   3 | (let ((toks (tokens date-str #'constituent 0)))\n   4 | (list (parse-integer (first toks):junk-allowed t)\n   5 | (parse-month (second toks))\n   6 | (parse-integer (third toks)))))\n   7 | (defun tokens (str test start)\n   8 | (let ((p1 (position-if test str :start start)))\n   9 | (if p1\n  10 | (let ((p2 (position-if #'(lambda (c)\n  11 | (not (funcall test c)))\n  12 | str :start p1)))\n  13 | (cons (subseq str p1 p2)\n  14 | (if p2\n  15 | (tokens str test p2)\n  16 | nil)))\n  17 | nil)))\n  18 | (defconstant month-names\n  19 | '(\"jan\" \"feb\" \"mar\" \"apr\" \"may\" \"jun\"\n  20 | \"jul\" \"aug\" \"sep\" \"oct\" \"nov\" \"dec\"))\n  21 | (defun parse-month (str)\n  22 | \"Parse the month string and return the month number.\"\n  23 | (let ((p (position (string-downcase str) month-names :test #'string-equal)))\n  24 | (if p\n  25 | (1+ p)\n  26 | (error \"Invalid month string: ~A\" str))))", "fragment_lines": [3], "fragment_content": ["(let ((toks (tokens date-str #'constituent 0)))"], "test": "(defun check ()\n;; Test the 'parse-date' function with various date strings.\n(assert (equal (parse-date \"16 Aug 1980\") '(16 8 1980)))\n(assert (equal (parse-date \"1 Jan 2023\") '(1 1 2023)))\n(assert (equal (parse-date \"25 Dec 1999\") '(25 12 1999)))\n(assert (equal (parse-date \"31 Oct 2025\") '(31 10 2025)))\n(assert (equal (parse-date \"20 Feb 2010\") '(20 2 2010))))\n\n(check)", "line_content": {"3": ["(let ((toks (tokens date-str #'constituent 0)))"]}, "instruction": "\nObserve the following faulty Clisp code and the options. The code snippets in the options are all from faulty code . Your task is to select the option(s) for error code snippet(s).\nNote:\n\n- This is an undetermined multiple-choice question, where the answer may include multiple options.\n- Please provide the answer in the form of a Python list, without returning any content other than the Python code block.. For example \n```python\n[\"A\"]\n```\n\nfaulty code:\n```\n   1 | (defun parse-date (date-str)\n   2 | \"Parse a date string in the format 'DD MMM YYYY' and return a list (day month year).\"\n   3 | (let ((toks (tokens date-str #'constituent 0)))\n   4 | (list (parse-integer (first toks):junk-allowed t)\n   5 | (parse-month (second toks))\n   6 | (parse-integer (third toks)))))\n   7 | (defun tokens (str test start)\n   8 | (let ((p1 (position-if test str :start start)))\n   9 | (if p1\n  10 | (let ((p2 (position-if #'(lambda (c)\n  11 | (not (funcall test c)))\n  12 | str :start p1)))\n  13 | (cons (subseq str p1 p2)\n  14 | (if p2\n  15 | (tokens str test p2)\n  16 | nil)))\n  17 | nil)))\n  18 | (defconstant month-names\n  19 | '(\"jan\" \"feb\" \"mar\" \"apr\" \"may\" \"jun\"\n  20 | \"jul\" \"aug\" \"sep\" \"oct\" \"nov\" \"dec\"))\n  21 | (defun parse-month (str)\n  22 | \"Parse the month string and return the month number.\"\n  23 | (let ((p (position (string-downcase str) month-names :test #'string-equal)))\n  24 | (if p\n  25 | (1+ p)\n  26 | (error \"Invalid month string: ~A\" str))))\n```\n\noptions:\nA.   21 | (defun parse-month (str)\n\nB.   13 | (cons (subseq str p1 p2)\n\nC.    8 | (let ((p1 (position-if test str :start start)))\n\nD.    3 | [\"(let ((toks (tokens date-str #'constituent 0)))\"]\n\n\n", "loc_answer": ["D"]}
{"question_id": "Clisp/23", "category": "Reference", "subtype": "undefined_methods", "level": "hard", "example": " >>> represent-as-powers-of-two(10)\n \"2+2(2()+2)\"\n >>> represent-as-powers-of-two(26)\n \"2+2(2()+2)+2(2(2))\"", "docstring": ";; This function takes a positive integer 'n' and returns its representation as a sum of powers of two. \n;; The powers are expressed in a specific format where a^b is represented as a(b), and terms are summed without spaces.\n;; Specifically, 2^0 is represented as 2()", "canonical_solution": "(defun represent-as-powers-of-two (n)\n;; This function takes a positive integer 'n' and returns its representation as a sum of powers of two. \n;; The powers are expressed in a specific format where a^b is represented as a(b), and terms are summed without spaces.\n;; Specifically, 2^0 is represented as 2()\n;; Example:\n;; >>> represent-as-powers-of-two(10)\n;; \"2+2(2()+2)\"\n;; >>> represent-as-powers-of-two(26)\n;; \"2+2(2()+2)+2(2(2))\"\n\n(let ((result '()) (power 0))\n(loop while (> n 0)\ndo (progn\n(when (> (logand n 1) 0)\n(push (if (= power 1) \"2\" (format nil \"2(~a)\" (represent-as-powers-of-two power))) result))\n(setq power (+ power 1))\n(setq n (ash n -1))))\n(string-join (reverse result) \"+\")))\n(defun string-join (list separator)\n;; This function joins a list of strings with a given separator.\n(with-output-to-string (stream)\n(when list\n(write-string (first list) stream)\n(dolist (item (rest list))\n(write-string separator stream)\n(write-string item stream)))))", "buggy_code": "(defun represent-as-powers-of-two (n)\n\n\n(let ((result '()) (power 0))\n(loop while (> n 0)\ndo (progn\n(when (> (logand n 1) 0)\n(push (if (= power 1) \"2\" (format nil \"2(~a)\" (represent-as-powers-of-two power))) result))\n(setq power (+ power 1))\n(setq n (ash n -1))))\n(string-join (reverse result) \"+\")))", "bug_with_line_numbers": "   1 | (defun represent-as-powers-of-two (n)\n   2 | (let ((result '()) (power 0))\n   3 | (loop while (> n 0)\n   4 | do (progn\n   5 | (when (> (logand n 1) 0)\n   6 | (push (if (= power 1) \"2\" (format nil \"2(~a)\" (represent-as-powers-of-two power))) result))\n   7 | (setq power (+ power 1))\n   8 | (setq n (ash n -1))))\n   9 | (string-join (reverse result) \"+\")))", "fragment_lines": [9], "fragment_content": ["(string-join (reverse result) \"+\")))"], "test": "(defun check ()\n(assert (equal (represent-as-powers-of-two 10) \"2+2(2()+2)\"))\n(assert (equal (represent-as-powers-of-two 26) \"2+2(2()+2)+2(2(2))\"))\n(assert (equal (represent-as-powers-of-two 1) \"2()\"))\n(assert (equal (represent-as-powers-of-two 31) \"2()+2+2(2)+2(2()+2)+2(2(2))\"))\n(assert (equal (represent-as-powers-of-two 100) \"2(2)+2(2()+2(2))+2(2+2(2))\")))\n\n(check)", "line_content": {"9": ["(string-join (reverse result) \"+\")))"]}, "instruction": "\nObserve the following faulty Clisp code and the options. The code snippets in the options are all from faulty code . Your task is to select the option(s) for error code snippet(s).\nNote:\n\n- This is an undetermined multiple-choice question, where the answer may include multiple options.\n- Please provide the answer in the form of a Python list, without returning any content other than the Python code block.. For example \n```python\n[\"A\"]\n```\n\nfaulty code:\n```\n   1 | (defun represent-as-powers-of-two (n)\n   2 | (let ((result '()) (power 0))\n   3 | (loop while (> n 0)\n   4 | do (progn\n   5 | (when (> (logand n 1) 0)\n   6 | (push (if (= power 1) \"2\" (format nil \"2(~a)\" (represent-as-powers-of-two power))) result))\n   7 | (setq power (+ power 1))\n   8 | (setq n (ash n -1))))\n   9 | (string-join (reverse result) \"+\")))\n```\n\noptions:\nA.    5 | (when (> (logand n 1) 0)\n\nB.    9 | ['(string-join (reverse result) \"+\")))']\n\nC.    3 | (loop while (> n 0)\n\nD.    4 | do (progn\n\n\n", "loc_answer": ["B"]}
{"question_id": "Clisp/24", "category": "Reference", "subtype": "undefined_objects", "level": "hard", "example": " >>> move-first-instance-to-front 'b '(a b c d)\n b a c d", "docstring": ";; Define a function that takes two input parameters, object and queue, and can destructively move the first instance of object (eql equivalently) to the beginning of the queue", "canonical_solution": "(defun move-first-instance-to-front (object queue)\n\n\n(cond ((null queue) nil) \n((eql (first queue) object) queue) \n(t \n(let ((prev nil)\n(current queue))\n(loop while (and current (not (eql (first current) object)))\ndo (setq prev current)\n(setq current (rest current)))\n(if current \n(progn\n(when prev (setf (rest prev) (rest current))) \n(cons object (if prev queue (rest current)))) \nqueue)))))", "buggy_code": "(defun move-first-instance-to-front (object queue)\n\n\n(cond ((null queue) nil) \n((eql (first queue) object) queue) \n(t \n(current queue))\n(loop while (and current (not (eql (first current) object)))\ndo (setq prev current)\n(setq current (rest current)))\n(if current \n(progn\n(when prev (setf (rest prev) (rest current))) \n(cons object (if prev queue (rest current)))) \nqueue)))", "bug_with_line_numbers": "   1 | (defun move-first-instance-to-front (object queue)\n   2 | (cond ((null queue) nil) \n   3 | ((eql (first queue) object) queue) \n   4 | (t \n   5 | (current queue))\n   6 | (loop while (and current (not (eql (first current) object)))\n   7 | do (setq prev current)\n   8 | (setq current (rest current)))\n   9 | (if current \n  10 | (progn\n  11 | (when prev (setf (rest prev) (rest current))) \n  12 | (cons object (if prev queue (rest current)))) \n  13 | queue)))", "fragment_lines": [-1], "fragment_content": ["missing critical code snippet"], "test": "(defun check ()\n(assert (equal (move-first-instance-to-front 'b '(a b c d)) '(b a c d)))\n(assert (equal (move-first-instance-to-front 'a '(a b c d)) '(a b c d)))\n(assert (equal (move-first-instance-to-front 'e '(a b c d)) '(a b c d)))\n(assert (equal (move-first-instance-to-front 'd '(a b c d)) '(d a b c))))\n\n(check)", "line_content": {"-1": ["missing critical code snippet"]}, "instruction": "\nObserve the following faulty Clisp code and the options. The code snippets in the options are all from faulty code . Your task is to select the option(s) for error code snippet(s).\nNote:\n\n- This is an undetermined multiple-choice question, where the answer may include multiple options.\n- Please provide the answer in the form of a Python list, without returning any content other than the Python code block.. For example \n```python\n[\"A\"]\n```\n\nfaulty code:\n```\n   1 | (defun move-first-instance-to-front (object queue)\n   2 | (cond ((null queue) nil) \n   3 | ((eql (first queue) object) queue) \n   4 | (t \n   5 | (current queue))\n   6 | (loop while (and current (not (eql (first current) object)))\n   7 | do (setq prev current)\n   8 | (setq current (rest current)))\n   9 | (if current \n  10 | (progn\n  11 | (when prev (setf (rest prev) (rest current))) \n  12 | (cons object (if prev queue (rest current)))) \n  13 | queue)))\n```\n\noptions:\nA.   -1 | ['missing critical code snippet']\n\nB.    6 | (loop while (and current (not (eql (first current) object)))\n\nC.    4 | (t\n\nD.   12 | (cons object (if prev queue (rest current))))\n\n\n", "loc_answer": ["A"]}
{"question_id": "Clisp/25", "category": "Reference", "subtype": "undefined_objects", "level": "easy", "example": " >>> count-digit-two 2 22\n 6\n >>> count-digit-two 10 25\n 9", "docstring": ";; This function counts the occurrences of the digit '2' in all integers within a given range [L, R].\n;; Both L and R are inclusive.\n;; It iterates through each number in the range and counts how many times '2' appears in each number.", "canonical_solution": "(defun count-digit-two (L R)\n\n\n(let ((count 0))\n(loop for i from L to R do\n(loop for char across (write-to-string i) do\n(when (char= char #\\2) (incf count))))\ncount))", "buggy_code": "(defun count-digit-two (L R)\n\n\n(loop for i from L to R do\n(loop for char across (write-to-string i) do\n(when (char= char #\\2) (incf count))))\ncount)", "bug_with_line_numbers": "   1 | (defun count-digit-two (L R)\n   2 | (loop for i from L to R do\n   3 | (loop for char across (write-to-string i) do\n   4 | (when (char= char #\\2) (incf count))))\n   5 | count)", "fragment_lines": [-1], "fragment_content": ["missing critical code snippet"], "test": "(defun check ()\n(assert (equal (count-digit-two 2 22) 6))\n(assert (equal (count-digit-two 10 25) 8))\n(assert (equal (count-digit-two 1 100) 20))\n(assert (equal (count-digit-two 29 55) 4))\n(assert (equal (count-digit-two 200 250) 66)))\n\n(check)", "line_content": {"-1": ["missing critical code snippet"]}, "instruction": "\nObserve the following faulty Clisp code and the options. The code snippets in the options are all from faulty code . Your task is to select the option(s) for error code snippet(s).\nNote:\n\n- This is an undetermined multiple-choice question, where the answer may include multiple options.\n- Please provide the answer in the form of a Python list, without returning any content other than the Python code block.. For example \n```python\n[\"A\"]\n```\n\nfaulty code:\n```\n   1 | (defun count-digit-two (L R)\n   2 | (loop for i from L to R do\n   3 | (loop for char across (write-to-string i) do\n   4 | (when (char= char #\\2) (incf count))))\n   5 | count)\n```\n\noptions:\nA.    4 | (when (char= char #\\2) (incf count))))\n\nB.    3 | (loop for char across (write-to-string i) do\n\nC.    5 | count)\n\nD.   -1 | ['missing critical code snippet']\n\n\n", "loc_answer": ["D"]}
{"question_id": "Clisp/26", "category": "Logic", "subtype": "algorithm_error", "level": "medium", "example": ">>> occurrences '(a b a d a c d c a)\n(a . 4) (c . 2) (d . 2) (b . 1)", "docstring": ";; takes a list and returns a list indicating the number of times each (eql) element appears, sorted from most common element to least common", "canonical_solution": "(defun occurrences (lst)\n\n\n(let ((result nil))\n(dolist (obj lst)\n(if (null (assoc obj result))\n(push (cons obj 1) result)\n(incf (cdr (assoc obj result)))\n))\n(sort result #'(lambda (a b) (if (> (cdr a) (cdr b)) t nil)))))", "buggy_code": "(defun occurrences (lst)\n\n\n(let ((result nil))\n(dolist (obj lst)\n(if (null (assoc obj result))\n(push (cons obj 1) result)\n(incf (cdr (assoc obj result)))\n))\n(sort result #'(lambda (a b) (if (> a b) t nil)))))", "bug_with_line_numbers": "   1 | (defun occurrences (lst)\n   2 | (let ((result nil))\n   3 | (dolist (obj lst)\n   4 | (if (null (assoc obj result))\n   5 | (push (cons obj 1) result)\n   6 | (incf (cdr (assoc obj result)))\n   7 | ))\n   8 | (sort result #'(lambda (a b) (if (> a b) t nil)))))", "fragment_lines": [8], "fragment_content": ["(sort result #'(lambda (a b) (if (> a b) t nil)))))"], "test": "(defun check ()\n;; 测试 'occurrences' 函数。\n(assert (equal (occurrences '(a b a d a c d c a)) '((a . 4) (c . 2) (d . 2) (b . 1))))\n(assert (equal (occurrences '(1 2 2 3 3 3)) '((3 . 3) (2 . 2) (1 . 1))))\n(assert (equal (occurrences '(a b a)) '((a . 2) (b . 1)))))\n\n(check)", "line_content": {"8": ["(sort result #'(lambda (a b) (if (> a b) t nil)))))"]}, "instruction": "\nObserve the following faulty Clisp code and the options. The code snippets in the options are all from faulty code . Your task is to select the option(s) for error code snippet(s).\nNote:\n\n- This is an undetermined multiple-choice question, where the answer may include multiple options.\n- Please provide the answer in the form of a Python list, without returning any content other than the Python code block.. For example \n```python\n[\"A\"]\n```\n\nfaulty code:\n```\n   1 | (defun occurrences (lst)\n   2 | (let ((result nil))\n   3 | (dolist (obj lst)\n   4 | (if (null (assoc obj result))\n   5 | (push (cons obj 1) result)\n   6 | (incf (cdr (assoc obj result)))\n   7 | ))\n   8 | (sort result #'(lambda (a b) (if (> a b) t nil)))))\n```\n\noptions:\nA.    8 | [\"(sort result #'(lambda (a b) (if (> a b) t nil)))))\"]\n\nB.    1 | (defun occurrences (lst)\n\nC.    5 | (push (cons obj 1) result)\n\nD.    2 | (let ((result nil))\n\n\n", "loc_answer": ["A"]}
{"question_id": "Clisp/27", "category": "Logic", "subtype": "algorithm_error", "level": "easy", "example": "quicksort '(3 1 4 1 5 9 2 6 5 3 5)v\n1 1 2 3 3 4 5 5 5 6 9", "docstring": ";; Quickly sort the list", "canonical_solution": "(defun quicksort (list)\n\n\n(if (null list)\nnil\n(let ((pivot (first list))\n(rest (rest list)))\n(append (quicksort (remove-if-not #'(lambda (x) (< x pivot)) rest))\n(list pivot)\n(quicksort (remove-if #'(lambda (x) (< x pivot)) rest))))))", "buggy_code": "(defun quicksort (list)\n\n\n\n(let ((pivot (first list))\n(rest (rest list)))\n(append (quicksort (remove-if-not #'(lambda (x) (< x pivot)) rest))\n(list pivot)\n(quicksort (remove-if #'(lambda (x) (< x pivot)) rest)))))", "bug_with_line_numbers": "   1 | (defun quicksort (list)\n   2 | (let ((pivot (first list))\n   3 | (rest (rest list)))\n   4 | (append (quicksort (remove-if-not #'(lambda (x) (< x pivot)) rest))\n   5 | (list pivot)\n   6 | (quicksort (remove-if #'(lambda (x) (< x pivot)) rest)))))", "fragment_lines": [-1], "fragment_content": ["missing critical code snippet"], "test": "(defun check ()\n;; 测试 'quicksort' 函数。\n(assert (equal (quicksort '(3 1 4 1 5 9 2 6 5 3 5)) '(1 1 2 3 3 4 5 5 5 6 9)))\n(assert (equal (quicksort '(5 4 3 2 1)) '(1 2 3 4 5)))\n(assert (equal (quicksort '()) '()))\n(assert (equal (quicksort '(1)) '(1))))\n\n(check)", "line_content": {"-1": ["missing critical code snippet"]}, "instruction": "\nObserve the following faulty Clisp code and the options. The code snippets in the options are all from faulty code . Your task is to select the option(s) for error code snippet(s).\nNote:\n\n- This is an undetermined multiple-choice question, where the answer may include multiple options.\n- Please provide the answer in the form of a Python list, without returning any content other than the Python code block.. For example \n```python\n[\"A\"]\n```\n\nfaulty code:\n```\n   1 | (defun quicksort (list)\n   2 | (let ((pivot (first list))\n   3 | (rest (rest list)))\n   4 | (append (quicksort (remove-if-not #'(lambda (x) (< x pivot)) rest))\n   5 | (list pivot)\n   6 | (quicksort (remove-if #'(lambda (x) (< x pivot)) rest)))))\n```\n\noptions:\nA.    3 | (rest (rest list)))\n\nB.   -1 | ['missing critical code snippet']\n\nC.    2 | (let ((pivot (first list))\n\nD.    5 | (list pivot)\n\n\n", "loc_answer": ["B"]}
{"question_id": "Clisp/28", "category": "Logic", "subtype": "algorithm_error", "level": "hard", "example": "(divisible-five-digit-numbers 15)  Returns (22555 25555 28555 30000)\n(divisible-five-digit-numbers 7)  Returns a list of numbers or 'No' if no such numbers exist", "docstring": ";; Finds all five-digit numbers between 10000 and 30000 where three sub-numbers \n;; (formed by consecutive digits) are divisible by 'k'.\n;; Each sub-number consists of three consecutive digits from the original number.\n;; The function returns a list of such five-digit numbers.", "canonical_solution": "(defun divisible-five-digit-numbers (k)\n\n\n(let ((results '()))\n(loop for num from 10000 to 30000\nwhen (and (zerop (mod (parse-integer (subseq (write-to-string num) 0 3)) k))\n(zerop (mod (parse-integer (subseq (write-to-string num) 1 4)) k))\n(zerop (mod (parse-integer (subseq (write-to-string num) 2 5)) k)))\ndo (push num results))\n(if (null results)\n'No\n(nreverse results))))", "buggy_code": "(defun divisible-five-digit-numbers (k)\n\n\n(let ((results '()))\n(loop for num from 10000 to 30000\nwhen (and (zerop (mod (parse-integer (subseq (write-to-string num) 0 3)) k))\n(zerop (mod (parse-integer (subseq (write-to-string num) 1 4)) k))\n(zerop (mod (parse-integer (subseq (write-to-string num) 2 5)) k)))\ndo (push num results))\n(if (null results)\n'No\n(results))))", "bug_with_line_numbers": "   1 | (defun divisible-five-digit-numbers (k)\n   2 | (let ((results '()))\n   3 | (loop for num from 10000 to 30000\n   4 | when (and (zerop (mod (parse-integer (subseq (write-to-string num) 0 3)) k))\n   5 | (zerop (mod (parse-integer (subseq (write-to-string num) 1 4)) k))\n   6 | (zerop (mod (parse-integer (subseq (write-to-string num) 2 5)) k)))\n   7 | do (push num results))\n   8 | (if (null results)\n   9 | 'No\n  10 | (results))))", "fragment_lines": [10], "fragment_content": ["(results))))"], "test": "(defun check ()\n(assert (equal (divisible-five-digit-numbers 15) '(22555 25555 28555 30000)))\n(assert (equal (divisible-five-digit-numbers 31) '(15589 18682))) ;; No such numbers exist\n(assert (equal (divisible-five-digit-numbers 999) 'No))) ;; No such numbers exist for a large divisor\n\n(check)", "line_content": {"10": ["(results))))"]}, "instruction": "\nObserve the following faulty Clisp code and the options. The code snippets in the options are all from faulty code . Your task is to select the option(s) for error code snippet(s).\nNote:\n\n- This is an undetermined multiple-choice question, where the answer may include multiple options.\n- Please provide the answer in the form of a Python list, without returning any content other than the Python code block.. For example \n```python\n[\"A\"]\n```\n\nfaulty code:\n```\n   1 | (defun divisible-five-digit-numbers (k)\n   2 | (let ((results '()))\n   3 | (loop for num from 10000 to 30000\n   4 | when (and (zerop (mod (parse-integer (subseq (write-to-string num) 0 3)) k))\n   5 | (zerop (mod (parse-integer (subseq (write-to-string num) 1 4)) k))\n   6 | (zerop (mod (parse-integer (subseq (write-to-string num) 2 5)) k)))\n   7 | do (push num results))\n   8 | (if (null results)\n   9 | 'No\n  10 | (results))))\n```\n\noptions:\nA.    1 | (defun divisible-five-digit-numbers (k)\n\nB.   10 | ['(results))))']\n\nC.    2 | (let ((results '()))\n\nD.    6 | (zerop (mod (parse-integer (subseq (write-to-string num) 2 5)) k)))\n\n\n", "loc_answer": ["B"]}
{"question_id": "Clisp/29", "category": "Logic", "subtype": "algorithm_error", "level": "hard", "example": ">>> count-prime-sums '(1 2 3 4) 2\n2 ; (1+2) and (3+4) are prime\n>>> count-prime-sums '(1 2 3 4 5 6) 3\n1 ; Only (1+2+5) is prime", "docstring": ";; This function counts the number of ways to select 'k' integers from a list of 'n' integers such that their sum is a prime number.\n;; It considers all possible combinations of 'k' integers from the list and checks if their sum is prime.", "canonical_solution": "(defun count-prime-sums (numbers k)\n\n\n(count t (mapcar (lambda (comb) (is-prime (reduce '+ comb)))\n(sum-combinations numbers k))))\n(defun is-prime (n)\n(cond ((<= n 1) nil)\n((= n 2) t)\n(t (loop for i from 2 to (isqrt n) never (zerop (mod n i))))))\n\n(defun sum-combinations (lst k)\n(if (= k 0)\n'(())\n(loop for i from 0 below (length lst)\nnconc (mapcar (lambda (x) (cons (nth i lst) x))\n(sum-combinations (subseq lst (1+ i)) (1- k))))))", "buggy_code": "(defun count-prime-sums (numbers k)\n\n\n\n(length t (mapcar (lambda (comb) (is-prime (reduce '+ comb)))\n(sum-combinations numbers k))))\n(defun is-prime (n)\n(cond ((<= n 1) nil)\n((= n 2) t)\n(t (loop for i from 2 to (isqrt n) never (zerop (mod n i))))))\n\n(defun sum-combinations (lst k)\n(if (= k 0)\n'(())\n(loop for i from 0 below (length lst)\nnconc (mapcar (lambda (x) (cons (nth i lst) x))\n(sum-combinations (subseq lst (1+ i)) (1- k))))))", "bug_with_line_numbers": "   1 | (defun count-prime-sums (numbers k)\n   2 | (length t (mapcar (lambda (comb) (is-prime (reduce '+ comb)))\n   3 | (sum-combinations numbers k))))\n   4 | (defun is-prime (n)\n   5 | (cond ((<= n 1) nil)\n   6 | ((= n 2) t)\n   7 | (t (loop for i from 2 to (isqrt n) never (zerop (mod n i))))))\n   8 | (defun sum-combinations (lst k)\n   9 | (if (= k 0)\n  10 | '(())\n  11 | (loop for i from 0 below (length lst)\n  12 | nconc (mapcar (lambda (x) (cons (nth i lst) x))\n  13 | (sum-combinations (subseq lst (1+ i)) (1- k))))))", "fragment_lines": [2], "fragment_content": ["(length t (mapcar (lambda (comb) (is-prime (reduce '+ comb)))"], "test": "(defun check ()\n(assert (equal (count-prime-sums '(3 7 12 19) 3) 1))\n(assert (equal (count-prime-sums '(1 2 3 4) 2) 4))\n(assert (equal (count-prime-sums '(1 2 3 4 5 6) 3) 6))\n(assert (equal (count-prime-sums '(10 20 30 40) 2) 0))\n(assert (equal (count-prime-sums '(11 13 17 19 23 29) 3) 12))) \n\n(check)", "line_content": {"2": ["(length t (mapcar (lambda (comb) (is-prime (reduce '+ comb)))"]}, "instruction": "\nObserve the following faulty Clisp code and the options. The code snippets in the options are all from faulty code . Your task is to select the option(s) for error code snippet(s).\nNote:\n\n- This is an undetermined multiple-choice question, where the answer may include multiple options.\n- Please provide the answer in the form of a Python list, without returning any content other than the Python code block.. For example \n```python\n[\"A\"]\n```\n\nfaulty code:\n```\n   1 | (defun count-prime-sums (numbers k)\n   2 | (length t (mapcar (lambda (comb) (is-prime (reduce '+ comb)))\n   3 | (sum-combinations numbers k))))\n   4 | (defun is-prime (n)\n   5 | (cond ((<= n 1) nil)\n   6 | ((= n 2) t)\n   7 | (t (loop for i from 2 to (isqrt n) never (zerop (mod n i))))))\n   8 | (defun sum-combinations (lst k)\n   9 | (if (= k 0)\n  10 | '(())\n  11 | (loop for i from 0 below (length lst)\n  12 | nconc (mapcar (lambda (x) (cons (nth i lst) x))\n  13 | (sum-combinations (subseq lst (1+ i)) (1- k))))))\n```\n\noptions:\nA.    1 | (defun count-prime-sums (numbers k)\n\nB.    2 | [\"(length t (mapcar (lambda (comb) (is-prime (reduce '+ comb)))\"]\n\nC.   11 | (loop for i from 0 below (length lst)\n\nD.    8 | (defun sum-combinations (lst k)\n\n\n", "loc_answer": ["B"]}
{"question_id": "Clisp/30", "category": "Logic", "subtype": "condition_error", "level": "hard", "example": ">>> has_close_elements([1.0, 2.0, 3.0], 0.5)\nnil\n>>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\nt", "docstring": ";;Check if in given list of numbers, are any two numbers closer to each other than\n;;given threshold.", "canonical_solution": "(defun has-close-elements (numbers threshold)\n\n\n(loop for i from 0 below (length numbers)\ndo (loop for j from 0 below (length numbers)\ndo (when (and (/= i j)\n(< (abs (- (nth i numbers) (nth j numbers))) threshold))\n(return-from has-close-elements t))))\nnil)", "buggy_code": "(defun has-close-elements (numbers threshold)\n\n\n\n(loop for i from 0 below (length numbers)\ndo (loop for j from 0 below (length numbers)\ndo (when (and (/= i j)\n(> (abs (- (nth i numbers) (nth j numbers))) threshold))\n(return-from has-close-elements t))))\nnil)", "bug_with_line_numbers": "   1 | (defun has-close-elements (numbers threshold)\n   2 | (loop for i from 0 below (length numbers)\n   3 | do (loop for j from 0 below (length numbers)\n   4 | do (when (and (/= i j)\n   5 | (> (abs (- (nth i numbers) (nth j numbers))) threshold))\n   6 | (return-from has-close-elements t))))\n   7 | nil)", "fragment_lines": [5], "fragment_content": ["(> (abs (- (nth i numbers) (nth j numbers))) threshold))"], "test": "(defun check ()\n(assert (equal (has-close-elements '(1.0 2.0 3.9 4.0 5.0 2.2) 0.3) t))\n(assert (equal (has-close-elements '(1.0 2.0 3.9 4.0 5.0 2.2) 0.05) nil))\n(assert (equal (has-close-elements '(1.0 2.0 5.9 4.0 5.0) 0.95) t))\n(assert (equal (has-close-elements '(1.0 2.0 5.9 4.0 5.0) 0.8) nil))\n(assert (equal (has-close-elements '(1.0 2.0 3.0 4.0 5.0 2.0) 0.1) t))\n(assert (equal (has-close-elements '(1.1 2.2 3.1 4.1 5.1) 1.0) t))\n(assert (equal (has-close-elements '(1.1 2.2 3.1 4.1 5.1) 0.5) nil)))\n\n(check)", "line_content": {"5": ["(> (abs (- (nth i numbers) (nth j numbers))) threshold))"]}, "instruction": "\nObserve the following faulty Clisp code and the options. The code snippets in the options are all from faulty code . Your task is to select the option(s) for error code snippet(s).\nNote:\n\n- This is an undetermined multiple-choice question, where the answer may include multiple options.\n- Please provide the answer in the form of a Python list, without returning any content other than the Python code block.. For example \n```python\n[\"A\"]\n```\n\nfaulty code:\n```\n   1 | (defun has-close-elements (numbers threshold)\n   2 | (loop for i from 0 below (length numbers)\n   3 | do (loop for j from 0 below (length numbers)\n   4 | do (when (and (/= i j)\n   5 | (> (abs (- (nth i numbers) (nth j numbers))) threshold))\n   6 | (return-from has-close-elements t))))\n   7 | nil)\n```\n\noptions:\nA.    2 | (loop for i from 0 below (length numbers)\n\nB.    4 | do (when (and (/= i j)\n\nC.    5 | ['(> (abs (- (nth i numbers) (nth j numbers))) threshold))']\n\nD.    1 | (defun has-close-elements (numbers threshold)\n\n\n", "loc_answer": ["C"]}
{"question_id": "Clisp/31", "category": "Logic", "subtype": "condition_error", "level": "easy", "example": ">>> segments-intersect? 0 0 1 1 1 0 0 1\nx 0.5\ny 0.5", "docstring": ";; Define a function that accepts 8 real numbers representing the endpoints of two line segments in two-dimensional space. If the line segments do not intersect, return false, or return two values representing the x and y coordinates of the intersection point", "canonical_solution": "(defun segments-intersect? (x1 y1 x2 y2 x3 y3 x4 y4)\n\n\n(let ((denom (- (* (- x2 x1) (- y4 y3)) (* (- y2 y1) (- x4 x3)))))\n(unless (zerop denom)\n(let* ((ua (/ (- (* (- x4 x3) (- y1 y3)) (* (- y4 y3) (- x1 x3))) denom))\n(ub (/ (- (* (- x2 x1) (- y1 y3)) (* (- y2 y1) (- x1 x3))) denom))\n(x-on-segment (+ x1 (* ua (- x2 x1))))\n(y-on-segment (+ y1 (* ua (- y2 y1)))))\n(when (and (>= ua 0) (<= ua 1) (>= ub 0) (<= ub 1))\n(values x-on-segment y-on-segment))))))\n\n(defun float-near-equal (a b &optional (tolerance 1e-5))\n(<= (abs (- a b)) tolerance))", "buggy_code": "(defun segments-intersect? (x1 y1 x2 y2 x3 y3 x4 y4)\n\n\n(let ((denom (- (* (- x2 x1) (- y4 y3)) (* (- y2 y1) (- x4 x3)))))\n(let* ((ua (/ (- (* (- x4 x3) (- y1 y3)) (* (- y4 y3) (- x1 x3))) denom))\n(ub (/ (- (* (- x2 x1) (- y1 y3)) (* (- y2 y1) (- x1 x3))) denom))\n(x-on-segment (+ x1 (* ua (- x2 x1))))\n(y-on-segment (+ y1 (* ua (- y2 y1)))))\n(when (and (>= ua 0) (<= ua 1) (>= ub 0) (<= ub 1))\n(values x-on-segment y-on-segment)))))\n\n(defun float-near-equal (a b &optional (tolerance 1e-5))\n(<= (abs (- a b)) tolerance))", "bug_with_line_numbers": "   1 | (defun segments-intersect? (x1 y1 x2 y2 x3 y3 x4 y4)\n   2 | (let ((denom (- (* (- x2 x1) (- y4 y3)) (* (- y2 y1) (- x4 x3)))))\n   3 | (let* ((ua (/ (- (* (- x4 x3) (- y1 y3)) (* (- y4 y3) (- x1 x3))) denom))\n   4 | (ub (/ (- (* (- x2 x1) (- y1 y3)) (* (- y2 y1) (- x1 x3))) denom))\n   5 | (x-on-segment (+ x1 (* ua (- x2 x1))))\n   6 | (y-on-segment (+ y1 (* ua (- y2 y1)))))\n   7 | (when (and (>= ua 0) (<= ua 1) (>= ub 0) (<= ub 1))\n   8 | (values x-on-segment y-on-segment)))))\n   9 | (defun float-near-equal (a b &optional (tolerance 1e-5))\n  10 | (<= (abs (- a b)) tolerance))", "fragment_lines": [-1], "fragment_content": ["missing critical code snippet"], "test": "(defun check ()\n(multiple-value-bind (x y) (segments-intersect? 0 0 1 1 1 0 0 1)\n(assert (and (float-near-equal x 0.5) (float-near-equal y 0.5))))\n(assert (null (segments-intersect? 0 0 1 1 2 2 3 3))))\n\n(check)", "line_content": {"-1": ["missing critical code snippet"]}, "instruction": "\nObserve the following faulty Clisp code and the options. The code snippets in the options are all from faulty code . Your task is to select the option(s) for error code snippet(s).\nNote:\n\n- This is an undetermined multiple-choice question, where the answer may include multiple options.\n- Please provide the answer in the form of a Python list, without returning any content other than the Python code block.. For example \n```python\n[\"A\"]\n```\n\nfaulty code:\n```\n   1 | (defun segments-intersect? (x1 y1 x2 y2 x3 y3 x4 y4)\n   2 | (let ((denom (- (* (- x2 x1) (- y4 y3)) (* (- y2 y1) (- x4 x3)))))\n   3 | (let* ((ua (/ (- (* (- x4 x3) (- y1 y3)) (* (- y4 y3) (- x1 x3))) denom))\n   4 | (ub (/ (- (* (- x2 x1) (- y1 y3)) (* (- y2 y1) (- x1 x3))) denom))\n   5 | (x-on-segment (+ x1 (* ua (- x2 x1))))\n   6 | (y-on-segment (+ y1 (* ua (- y2 y1)))))\n   7 | (when (and (>= ua 0) (<= ua 1) (>= ub 0) (<= ub 1))\n   8 | (values x-on-segment y-on-segment)))))\n   9 | (defun float-near-equal (a b &optional (tolerance 1e-5))\n  10 | (<= (abs (- a b)) tolerance))\n```\n\noptions:\nA.    9 | (defun float-near-equal (a b &optional (tolerance 1e-5))\n\nB.    7 | (when (and (>= ua 0) (<= ua 1) (>= ub 0) (<= ub 1))\n\nC.   -1 | ['missing critical code snippet']\n\nD.    2 | (let ((denom (- (* (- x2 x1) (- y4 y3)) (* (- y2 y1) (- x4 x3)))))\n\n\n", "loc_answer": ["C"]}
{"question_id": "Clisp/32", "category": "Logic", "subtype": "condition_error", "level": "hard", "example": "(larger-prime-factor 15)  Returns 5\n(larger-prime-factor 33)  Returns 11", "docstring": ";; Finds the larger prime factor of a positive integer 'n', which is known to be the product of two distinct prime numbers.\n;; The function returns the larger of the two prime factors.", "canonical_solution": "(defun larger-prime-factor (n)\n\n\n(let ((factor 2))\n(loop while (> n factor)\nif (zerop (mod n factor))\ndo (setq n (/ n factor))\nelse\ndo (incf factor))\nn))", "buggy_code": "(defun larger-prime-factor (n)\n\n\n\n(let ((factor 2))\n(loop while (>= n factor)\nif (zerop (mod n factor))\ndo (setq n (/ n factor))\nelse\ndo (incf factor))\nn))", "bug_with_line_numbers": "   1 | (defun larger-prime-factor (n)\n   2 | (let ((factor 2))\n   3 | (loop while (>= n factor)\n   4 | if (zerop (mod n factor))\n   5 | do (setq n (/ n factor))\n   6 | else\n   7 | do (incf factor))\n   8 | n))", "fragment_lines": [3], "fragment_content": ["(loop while (>= n factor)"], "test": "(defun check ()\n(assert (equal (larger-prime-factor 21) 7))\n(assert (equal (larger-prime-factor 15) 5))\n(assert (equal (larger-prime-factor 33) 11))\n(assert (equal (larger-prime-factor 35) 7))\n(assert (equal (larger-prime-factor 77) 11))\n(assert (equal (larger-prime-factor 26) 13)))\n\n(check)", "line_content": {"3": ["(loop while (>= n factor)"]}, "instruction": "\nObserve the following faulty Clisp code and the options. The code snippets in the options are all from faulty code . Your task is to select the option(s) for error code snippet(s).\nNote:\n\n- This is an undetermined multiple-choice question, where the answer may include multiple options.\n- Please provide the answer in the form of a Python list, without returning any content other than the Python code block.. For example \n```python\n[\"A\"]\n```\n\nfaulty code:\n```\n   1 | (defun larger-prime-factor (n)\n   2 | (let ((factor 2))\n   3 | (loop while (>= n factor)\n   4 | if (zerop (mod n factor))\n   5 | do (setq n (/ n factor))\n   6 | else\n   7 | do (incf factor))\n   8 | n))\n```\n\noptions:\nA.    1 | (defun larger-prime-factor (n)\n\nB.    7 | do (incf factor))\n\nC.    3 | ['(loop while (>= n factor)']\n\nD.    8 | n))\n\n\n", "loc_answer": ["C"]}
{"question_id": "Clisp/33", "category": "Logic", "subtype": "operation_error", "level": "medium", "example": "multiple-value-bind (quarters dimes nickels pennies) (make-change 98\nquarters 3\ndimes 2\nnickels 0\npennies 3", "docstring": ";; Define a function that accepts an integer cents and returns four values, displaying the numbers as 25-, 10-, 5-, 1-, using the minimum number of coins. (Translation: 25- is 25 cents, and so on)", "canonical_solution": "(defun make-change (cents)\n\n\n(let ((quarters (floor cents 25))\n(remaining-after-quarters (mod cents 25)))\n(let ((dimes (floor remaining-after-quarters 10))\n(remaining-after-dimes (mod remaining-after-quarters 10)))\n(let ((nickels (floor remaining-after-dimes 5))\n(pennies (mod remaining-after-dimes 5)))\n(values quarters dimes nickels pennies)))))", "buggy_code": "(defun make-change (cents)\n\n\n(let ((quarters (round cents 25))\n(remaining-after-quarters (mod cents 25)))\n(let ((dimes (round remaining-after-quarters 10))\n(remaining-after-dimes (mod remaining-after-quarters 10)))\n(let ((nickels (round remaining-after-dimes 5))\n(pennies (mod remaining-after-dimes 5)))\n(values quarters dimes nickels pennies)))))", "bug_with_line_numbers": "   1 | (defun make-change (cents)\n   2 | (let ((quarters (round cents 25))\n   3 | (remaining-after-quarters (mod cents 25)))\n   4 | (let ((dimes (round remaining-after-quarters 10))\n   5 | (remaining-after-dimes (mod remaining-after-quarters 10)))\n   6 | (let ((nickels (round remaining-after-dimes 5))\n   7 | (pennies (mod remaining-after-dimes 5)))\n   8 | (values quarters dimes nickels pennies)))))", "fragment_lines": [2, 4, 6], "fragment_content": ["(let ((quarters (round cents 25))", "(let ((dimes (round remaining-after-quarters 10))", "(let ((nickels (round remaining-after-dimes 5))"], "test": "(defun check ()\n;; 测试 'make-change' 函数。\n(multiple-value-bind (quarters dimes nickels pennies) (make-change 98)\n(assert (equal quarters 3))\n(assert (equal dimes 2))\n(assert (equal nickels 0))\n(assert (equal pennies 3)))\n(multiple-value-bind (quarters dimes nickels pennies) (make-change 41)\n(assert (equal quarters 1))\n(assert (equal dimes 1))\n(assert (equal nickels 1))\n(assert (equal pennies 1)))\n(multiple-value-bind (quarters dimes nickels pennies) (make-change 3)\n(assert (equal quarters 0))\n(assert (equal dimes 0))\n(assert (equal nickels 0))\n(assert (equal pennies 3))))\n\n(check)", "line_content": {"2": ["(let ((quarters (round cents 25))"], "4": ["(let ((dimes (round remaining-after-quarters 10))"], "6": ["(let ((nickels (round remaining-after-dimes 5))"]}, "instruction": "\nObserve the following faulty Clisp code and the options. The code snippets in the options are all from faulty code . Your task is to select the option(s) for error code snippet(s).\nNote:\n\n- This is an undetermined multiple-choice question, where the answer may include multiple options.\n- Please provide the answer in the form of a Python list, without returning any content other than the Python code block.. For example \n```python\n[\"A\"]\n```\n\nfaulty code:\n```\n   1 | (defun make-change (cents)\n   2 | (let ((quarters (round cents 25))\n   3 | (remaining-after-quarters (mod cents 25)))\n   4 | (let ((dimes (round remaining-after-quarters 10))\n   5 | (remaining-after-dimes (mod remaining-after-quarters 10)))\n   6 | (let ((nickels (round remaining-after-dimes 5))\n   7 | (pennies (mod remaining-after-dimes 5)))\n   8 | (values quarters dimes nickels pennies)))))\n```\n\noptions:\nA.    2 | ['(let ((quarters (round cents 25))']\n\nB.    4 | ['(let ((dimes (round remaining-after-quarters 10))']\n\nC.    3 | (remaining-after-quarters (mod cents 25)))\n\nD.    6 | ['(let ((nickels (round remaining-after-dimes 5))']\n\n\n", "loc_answer": ["A", "B", "D"]}
{"question_id": "Clisp/34", "category": "Logic", "subtype": "operation_error", "level": "medium", "example": ">>> move-first-instance-to-front 'b '(a b c d)\nb a c d", "docstring": ";; Define a function that takes two input parameters, object and queue, and can destructively move the first instance of object (eql equivalently) to the beginning of the queue", "canonical_solution": "(defun move-first-instance-to-front (object queue)\n\n\n(cond ((null queue) nil) \n((eql (first queue) object) queue) \n(t \n(let ((prev nil)\n(current queue))\n(loop while (and current (not (eql (first current) object)))\ndo (setq prev current)\n(setq current (rest current)))\n(if current \n(progn\n(when prev (setf (rest prev) (rest current))) \n(cons object (if prev queue (rest current)))) \nqueue)))))", "buggy_code": "(defun move-first-instance-to-front (object queue)\n\n\n\n(cond ((null queue) nil) \n((eql (first queue) object) queue) \n(t \n(let ((prev nil)\n(current queue))\n(loop while (and current (not (eql (first current) object)))\ndo (setq prev current)\n(setq current (rest current)))\n(if current \n(progn\n(when prev (setq (rest prev) (rest current))) \n(cons object (if prev queue (rest current)))) \nqueue)))))", "bug_with_line_numbers": "   1 | (defun move-first-instance-to-front (object queue)\n   2 | (cond ((null queue) nil) \n   3 | ((eql (first queue) object) queue) \n   4 | (t \n   5 | (let ((prev nil)\n   6 | (current queue))\n   7 | (loop while (and current (not (eql (first current) object)))\n   8 | do (setq prev current)\n   9 | (setq current (rest current)))\n  10 | (if current \n  11 | (progn\n  12 | (when prev (setq (rest prev) (rest current))) \n  13 | (cons object (if prev queue (rest current)))) \n  14 | queue)))))", "fragment_lines": [12], "fragment_content": ["(when prev (setq (rest prev) (rest current)))"], "test": "(defun check ()\n(assert (equal (move-first-instance-to-front 'b '(a b c d)) '(b a c d)))\n(assert (equal (move-first-instance-to-front 'a '(a b c d)) '(a b c d)))\n(assert (equal (move-first-instance-to-front 'e '(a b c d)) '(a b c d)))\n(assert (equal (move-first-instance-to-front 'd '(a b c d)) '(d a b c))))\n\n(check)", "line_content": {"12": ["(when prev (setq (rest prev) (rest current)))"]}, "instruction": "\nObserve the following faulty Clisp code and the options. The code snippets in the options are all from faulty code . Your task is to select the option(s) for error code snippet(s).\nNote:\n\n- This is an undetermined multiple-choice question, where the answer may include multiple options.\n- Please provide the answer in the form of a Python list, without returning any content other than the Python code block.. For example \n```python\n[\"A\"]\n```\n\nfaulty code:\n```\n   1 | (defun move-first-instance-to-front (object queue)\n   2 | (cond ((null queue) nil) \n   3 | ((eql (first queue) object) queue) \n   4 | (t \n   5 | (let ((prev nil)\n   6 | (current queue))\n   7 | (loop while (and current (not (eql (first current) object)))\n   8 | do (setq prev current)\n   9 | (setq current (rest current)))\n  10 | (if current \n  11 | (progn\n  12 | (when prev (setq (rest prev) (rest current))) \n  13 | (cons object (if prev queue (rest current)))) \n  14 | queue)))))\n```\n\noptions:\nA.   12 | ['(when prev (setq (rest prev) (rest current)))']\n\nB.    1 | (defun move-first-instance-to-front (object queue)\n\nC.   11 | (progn\n\nD.    9 | (setq current (rest current)))\n\n\n", "loc_answer": ["A"]}
{"question_id": "Clisp/35", "category": "Logic", "subtype": "operation_error", "level": "easy", "example": "(count-remaining-trees 10 '((2 5) (7 9)))  Returns 4\n(count-remaining-trees 15 '((1 3) (5 10)))  Returns 7", "docstring": ";; Counts the number of trees remaining on a road of length 'road-length' after removing trees in specified 'regions'.\n;; Each region is a list of two integers representing the start and end points on the road.\n;; The function returns the number of trees remaining after the removal.", "canonical_solution": "(defun count-remaining-trees (road-length regions)\n\n\n(let ((tree-map (make-array (1+ road-length) :initial-element t)))\n(dolist (region regions)\n(loop for i from (first region) to (second region)\ndo (setf (aref tree-map i) nil)))\n(count t tree-map)))", "buggy_code": "(defun count-remaining-trees (road-length regions)\n\n\n\n(let ((tree-map (make-array (1+ road-length) :initial-element t)))\n(dolist (region regions)\n(loop for i from (first region) to (second region)\ndo (setq (aref tree-map i) nil)))\n(count t tree-map)))", "bug_with_line_numbers": "   1 | (defun count-remaining-trees (road-length regions)\n   2 | (let ((tree-map (make-array (1+ road-length) :initial-element t)))\n   3 | (dolist (region regions)\n   4 | (loop for i from (first region) to (second region)\n   5 | do (setq (aref tree-map i) nil)))\n   6 | (count t tree-map)))", "fragment_lines": [5], "fragment_content": ["do (setq (aref tree-map i) nil)))"], "test": "(defun check ()\n(assert (equal (count-remaining-trees 10 '((2 5) (7 9))) 4))\n(assert (equal (count-remaining-trees 15 '((1 3) (5 10))) 7))\n(assert (equal (count-remaining-trees 20 '((0 5) (10 15))) 9))\n(assert (equal (count-remaining-trees 30 '((3 6) (8 10) (15 20))) 18))\n(assert (equal (count-remaining-trees 50 '((0 10) (20 30) (40 50))) 18)))\n\n(check)", "line_content": {"5": ["do (setq (aref tree-map i) nil)))"]}, "instruction": "\nObserve the following faulty Clisp code and the options. The code snippets in the options are all from faulty code . Your task is to select the option(s) for error code snippet(s).\nNote:\n\n- This is an undetermined multiple-choice question, where the answer may include multiple options.\n- Please provide the answer in the form of a Python list, without returning any content other than the Python code block.. For example \n```python\n[\"A\"]\n```\n\nfaulty code:\n```\n   1 | (defun count-remaining-trees (road-length regions)\n   2 | (let ((tree-map (make-array (1+ road-length) :initial-element t)))\n   3 | (dolist (region regions)\n   4 | (loop for i from (first region) to (second region)\n   5 | do (setq (aref tree-map i) nil)))\n   6 | (count t tree-map)))\n```\n\noptions:\nA.    4 | (loop for i from (first region) to (second region)\n\nB.    1 | (defun count-remaining-trees (road-length regions)\n\nC.    3 | (dolist (region regions)\n\nD.    5 | ['do (setq (aref tree-map i) nil)))']\n\n\n", "loc_answer": ["D"]}
{"question_id": "Clisp/36", "category": "Logic", "subtype": "operation_error", "level": "hard", "example": "(total-cigarettes-smoked 4 3)  Returns 5\n(total-cigarettes-smoked 10 4)  Returns 13", "docstring": ";; Calculates the total number of cigarettes Peter can smoke.\n;; 'initial-cigarettes' is the starting number of cigarettes.\n;; 'butt-to-cigarette-ratio' is the number of cigarette butts required to get a new cigarette.\n;; The function returns the total number of cigarettes Peter can smoke.", "canonical_solution": "(defun total-cigarettes-smoked (initial-cigarettes butt-to-cigarette-ratio)\n\n\n(let ((total-smoked initial-cigarettes)\n(butts initial-cigarettes))\n(loop while (>= butts butt-to-cigarette-ratio)\ndo (let ((new-cigarettes (floor butts butt-to-cigarette-ratio)))\n(incf total-smoked new-cigarettes)\n(decf butts (* new-cigarettes butt-to-cigarette-ratio))\n(incf butts new-cigarettes)))\ntotal-smoked))", "buggy_code": "(defun total-cigarettes-smoked (initial-cigarettes butt-to-cigarette-ratio)\n\n\n(let ((total-smoked initial-cigarettes)\n(butts initial-cigarettes))\n(loop while (>= butts butt-to-cigarette-ratio)\ndo (let ((new-cigarettes (/ butts butt-to-cigarette-ratio)))\n(incf total-smoked new-cigarettes)\n(decf butts (* new-cigarettes butt-to-cigarette-ratio))\n(incf butts new-cigarettes)))\ntotal-smoked))", "bug_with_line_numbers": "   1 | (defun total-cigarettes-smoked (initial-cigarettes butt-to-cigarette-ratio)\n   2 | (let ((total-smoked initial-cigarettes)\n   3 | (butts initial-cigarettes))\n   4 | (loop while (>= butts butt-to-cigarette-ratio)\n   5 | do (let ((new-cigarettes (/ butts butt-to-cigarette-ratio)))\n   6 | (incf total-smoked new-cigarettes)\n   7 | (decf butts (* new-cigarettes butt-to-cigarette-ratio))\n   8 | (incf butts new-cigarettes)))\n   9 | total-smoked))", "fragment_lines": [5], "fragment_content": ["do (let ((new-cigarettes (/ butts butt-to-cigarette-ratio)))"], "test": "(defun check ()\n(assert (equal (total-cigarettes-smoked 4 3) 5))\n(assert (equal (total-cigarettes-smoked 10 4) 13))\n(assert (equal (total-cigarettes-smoked 20 5) 24))\n(assert (equal (total-cigarettes-smoked 15 3) 22))\n(assert (equal (total-cigarettes-smoked 7 2) 13))\n(assert (equal (total-cigarettes-smoked 5 5) 6))\n(assert (equal (total-cigarettes-smoked 0 3) 0)))\n\n(check)", "line_content": {"5": ["do (let ((new-cigarettes (/ butts butt-to-cigarette-ratio)))"]}, "instruction": "\nObserve the following faulty Clisp code and the options. The code snippets in the options are all from faulty code . Your task is to select the option(s) for error code snippet(s).\nNote:\n\n- This is an undetermined multiple-choice question, where the answer may include multiple options.\n- Please provide the answer in the form of a Python list, without returning any content other than the Python code block.. For example \n```python\n[\"A\"]\n```\n\nfaulty code:\n```\n   1 | (defun total-cigarettes-smoked (initial-cigarettes butt-to-cigarette-ratio)\n   2 | (let ((total-smoked initial-cigarettes)\n   3 | (butts initial-cigarettes))\n   4 | (loop while (>= butts butt-to-cigarette-ratio)\n   5 | do (let ((new-cigarettes (/ butts butt-to-cigarette-ratio)))\n   6 | (incf total-smoked new-cigarettes)\n   7 | (decf butts (* new-cigarettes butt-to-cigarette-ratio))\n   8 | (incf butts new-cigarettes)))\n   9 | total-smoked))\n```\n\noptions:\nA.    1 | (defun total-cigarettes-smoked (initial-cigarettes butt-to-cigarette-ratio)\n\nB.    4 | (loop while (>= butts butt-to-cigarette-ratio)\n\nC.    7 | (decf butts (* new-cigarettes butt-to-cigarette-ratio))\n\nD.    5 | ['do (let ((new-cigarettes (/ butts butt-to-cigarette-ratio)))']\n\n\n", "loc_answer": ["D"]}
{"question_id": "Clisp/37", "category": "Logic", "subtype": "type_error", "level": "hard", "example": "(find-substring-index \"apple pie\" \"pie\")  Returns 6\n(find-substring-index \"hello world\" \"bye\")  Returns -1", "docstring": ";; Finds the first occurrence of the substring 'needle' within the string 'haystack'.\n;; Returns the index of the first character of the first occurrence of 'needle'.\n;; If 'needle' is not a part of 'haystack', returns -1.", "canonical_solution": "(defun find-substring-index (haystack needle)\n\n\n(let ((hay-len (length haystack))\n(need-len (length needle)))\n(if (zerop need-len)\n0\n(if (> need-len hay-len)\n-1\n(loop for i below (1+ (- hay-len need-len))\nwhen (string= (subseq haystack i (min (+ i need-len) hay-len)) needle)\nreturn i\nfinally (return -1))))))", "buggy_code": "(defun find-substring-index (haystack needle)\n\n\n(let ((hay-len (length haystack))\n(need-len (length needle)))\n(if (zerop need-len)\n0\n(if (> need-len hay-len)\n-1\n(loop for i below (1+ (- hay-len need-len))\nwhen (= (subseq haystack i (min (+ i need-len) hay-len)) needle)\nreturn i\nfinally (return -1))))))", "bug_with_line_numbers": "   1 | (defun find-substring-index (haystack needle)\n   2 | (let ((hay-len (length haystack))\n   3 | (need-len (length needle)))\n   4 | (if (zerop need-len)\n   5 | 0\n   6 | (if (> need-len hay-len)\n   7 | -1\n   8 | (loop for i below (1+ (- hay-len need-len))\n   9 | when (= (subseq haystack i (min (+ i need-len) hay-len)) needle)\n  10 | return i\n  11 | finally (return -1))))))", "fragment_lines": [9], "fragment_content": ["when (= (subseq haystack i (min (+ i need-len) hay-len)) needle)"], "test": "(defun check ()\n(assert (equal (find-substring-index \"apple pie\" \"pie\") 6))\n(assert (equal (find-substring-index \"hello world\" \"bye\") -1))\n(assert (equal (find-substring-index \"common lisp\" \"lisp\") 7))\n(assert (equal (find-substring-index \"quick brown fox\" \"brown\") 6))\n(assert (equal (find-substring-index \"abcdef\" \"de\") 3))\n(assert (equal (find-substring-index \"abcdef\" \"xyz\") -1)))\n\n(check)", "line_content": {"9": ["when (= (subseq haystack i (min (+ i need-len) hay-len)) needle)"]}, "instruction": "\nObserve the following faulty Clisp code and the options. The code snippets in the options are all from faulty code . Your task is to select the option(s) for error code snippet(s).\nNote:\n\n- This is an undetermined multiple-choice question, where the answer may include multiple options.\n- Please provide the answer in the form of a Python list, without returning any content other than the Python code block.. For example \n```python\n[\"A\"]\n```\n\nfaulty code:\n```\n   1 | (defun find-substring-index (haystack needle)\n   2 | (let ((hay-len (length haystack))\n   3 | (need-len (length needle)))\n   4 | (if (zerop need-len)\n   5 | 0\n   6 | (if (> need-len hay-len)\n   7 | -1\n   8 | (loop for i below (1+ (- hay-len need-len))\n   9 | when (= (subseq haystack i (min (+ i need-len) hay-len)) needle)\n  10 | return i\n  11 | finally (return -1))))))\n```\n\noptions:\nA.    9 | ['when (= (subseq haystack i (min (+ i need-len) hay-len)) needle)']\n\nB.   10 | return i\n\nC.    7 | -1\n\nD.   11 | finally (return -1))))))\n\n\n", "loc_answer": ["A"]}
{"question_id": "Clisp/38", "category": "Logic", "subtype": "type_error", "level": "medium", "example": ">>> count-digit-two 2 22\n6\n>>> count-digit-two 10 25\n9", "docstring": ";; This function counts the occurrences of the digit '2' in all integers within a given range [L, R].\n;; Both L and R are inclusive.\n;; It iterates through each number in the range and counts how many times '2' appears in each number.", "canonical_solution": "(defun count-digit-two (L R)\n\n\n(let ((count 0))\n(loop for i from L to R do\n(loop for char across (write-to-string i) do\n(when (char= char #\\2) (incf count))))\ncount))", "buggy_code": "(defun count-digit-two (L R)\n\n\n\n(let ((count 0))\n(loop for i from L to R do\n(loop for char across i do\n(when (char= char #\\2) (incf count))))\ncount))", "bug_with_line_numbers": "   1 | (defun count-digit-two (L R)\n   2 | (let ((count 0))\n   3 | (loop for i from L to R do\n   4 | (loop for char across i do\n   5 | (when (char= char #\\2) (incf count))))\n   6 | count))", "fragment_lines": [4], "fragment_content": ["(loop for char across i do"], "test": "(defun check ()\n(assert (equal (count-digit-two 2 22) 6))\n(assert (equal (count-digit-two 10 25) 8))\n(assert (equal (count-digit-two 1 100) 20))\n(assert (equal (count-digit-two 29 55) 4))\n(assert (equal (count-digit-two 200 250) 66)))\n\n(check)", "line_content": {"4": ["(loop for char across i do"]}, "instruction": "\nObserve the following faulty Clisp code and the options. The code snippets in the options are all from faulty code . Your task is to select the option(s) for error code snippet(s).\nNote:\n\n- This is an undetermined multiple-choice question, where the answer may include multiple options.\n- Please provide the answer in the form of a Python list, without returning any content other than the Python code block.. For example \n```python\n[\"A\"]\n```\n\nfaulty code:\n```\n   1 | (defun count-digit-two (L R)\n   2 | (let ((count 0))\n   3 | (loop for i from L to R do\n   4 | (loop for char across i do\n   5 | (when (char= char #\\2) (incf count))))\n   6 | count))\n```\n\noptions:\nA.    5 | (when (char= char #\\2) (incf count))))\n\nB.    3 | (loop for i from L to R do\n\nC.    4 | ['(loop for char across i do']\n\nD.    1 | (defun count-digit-two (L R)\n\n\n", "loc_answer": ["C"]}
{"question_id": "Clisp/39", "category": "Logic", "subtype": "variable_error", "level": "hard", "example": ">>> bin-search 3 '#(1 2 3 4 5)\nt", "docstring": ";; Binary search for 'obj' in sorted vector 'vec'.\n;; Returns 't' if 'obj' is found, 'nil' otherwise.", "canonical_solution": "(defun bin-search (obj vec)\n\n\n(let ((low 0)\n(high (1- (length vec))))\n(loop while (<= low high)\nfor mid = (floor (+ low high) 2)\nfor mid-val = (aref vec mid)\ndo (cond ((= obj mid-val) (return-from bin-search t))\n((< obj mid-val) (setf high (1- mid)))\n((> obj mid-val) (setf low (1+ mid)))))\nnil))", "buggy_code": "(defun bin-search (obj vec)\n\n\n(let ((low 0)\n(high ((length vec))))\n(loop while (<= low high)\nfor mid = (floor (+ low high) 2)\nfor mid-val = (aref vec mid)\ndo (cond ((= obj mid-val) (return-from bin-search t))\n((< obj mid-val) (setf high (1- mid)))\n((> obj mid-val) (setf low (1+ mid)))))\nnil))", "bug_with_line_numbers": "   1 | (defun bin-search (obj vec)\n   2 | (let ((low 0)\n   3 | (high ((length vec))))\n   4 | (loop while (<= low high)\n   5 | for mid = (floor (+ low high) 2)\n   6 | for mid-val = (aref vec mid)\n   7 | do (cond ((= obj mid-val) (return-from bin-search t))\n   8 | ((< obj mid-val) (setf high (1- mid)))\n   9 | ((> obj mid-val) (setf low (1+ mid)))))\n  10 | nil))", "fragment_lines": [3], "fragment_content": ["(high ((length vec))))"], "test": "(defun check ()\n;; Test the 'bin-search' function with various cases.\n(assert (equal (bin-search 3 '#(1 2 3 4 5)) t))\n(assert (equal (bin-search 6 '#(1 2 3 4 5)) nil))\n(assert (equal (bin-search 1 '#(1)) t))\n(assert (equal (bin-search 2 '#(1)) nil))\n(assert (equal (bin-search 0 '#()) nil))\n(assert (equal (bin-search 5 '#(2 4 6 8 10)) nil))\n(assert (equal (bin-search 4 '#(2 4 6 8 10)) t)))\n\n(check)", "line_content": {"3": ["(high ((length vec))))"]}, "instruction": "\nObserve the following faulty Clisp code and the options. The code snippets in the options are all from faulty code . Your task is to select the option(s) for error code snippet(s).\nNote:\n\n- This is an undetermined multiple-choice question, where the answer may include multiple options.\n- Please provide the answer in the form of a Python list, without returning any content other than the Python code block.. For example \n```python\n[\"A\"]\n```\n\nfaulty code:\n```\n   1 | (defun bin-search (obj vec)\n   2 | (let ((low 0)\n   3 | (high ((length vec))))\n   4 | (loop while (<= low high)\n   5 | for mid = (floor (+ low high) 2)\n   6 | for mid-val = (aref vec mid)\n   7 | do (cond ((= obj mid-val) (return-from bin-search t))\n   8 | ((< obj mid-val) (setf high (1- mid)))\n   9 | ((> obj mid-val) (setf low (1+ mid)))))\n  10 | nil))\n```\n\noptions:\nA.    9 | ((> obj mid-val) (setf low (1+ mid)))))\n\nB.    1 | (defun bin-search (obj vec)\n\nC.    3 | ['(high ((length vec))))']\n\nD.   10 | nil))\n\n\n", "loc_answer": ["C"]}
{"question_id": "Clisp/40", "category": "Logic", "subtype": "variable_error", "level": "medium", "example": "(larger-prime-factor 15)  Returns 5\n(larger-prime-factor 33)  Returns 11", "docstring": ";; Finds the larger prime factor of a positive integer 'n', which is known to be the product of two distinct prime numbers.\n;; The function returns the larger of the two prime factors.", "canonical_solution": "(defun larger-prime-factor (n)\n\n\n(let ((factor 2))\n(loop while (> n factor)\nif (zerop (mod n factor))\ndo (setq n (/ n factor))\nelse\ndo (incf factor))\nn))", "buggy_code": "(defun larger-prime-factor (n)\n\n\n(let ((factor 1))\n(loop while (> n factor)\nif (zerop (mod n factor))\ndo (setq n (/ n factor))\nelse\ndo (incf factor))\nn))", "bug_with_line_numbers": "   1 | (defun larger-prime-factor (n)\n   2 | (let ((factor 1))\n   3 | (loop while (> n factor)\n   4 | if (zerop (mod n factor))\n   5 | do (setq n (/ n factor))\n   6 | else\n   7 | do (incf factor))\n   8 | n))", "fragment_lines": [2], "fragment_content": ["(let ((factor 1))"], "test": "(defun check ()\n(assert (equal (larger-prime-factor 21) 7))\n(assert (equal (larger-prime-factor 15) 5))\n(assert (equal (larger-prime-factor 33) 11))\n(assert (equal (larger-prime-factor 35) 7))\n(assert (equal (larger-prime-factor 77) 11))\n(assert (equal (larger-prime-factor 26) 13)))\n\n(check)", "line_content": {"2": ["(let ((factor 1))"]}, "instruction": "\nObserve the following faulty Clisp code and the options. The code snippets in the options are all from faulty code . Your task is to select the option(s) for error code snippet(s).\nNote:\n\n- This is an undetermined multiple-choice question, where the answer may include multiple options.\n- Please provide the answer in the form of a Python list, without returning any content other than the Python code block.. For example \n```python\n[\"A\"]\n```\n\nfaulty code:\n```\n   1 | (defun larger-prime-factor (n)\n   2 | (let ((factor 1))\n   3 | (loop while (> n factor)\n   4 | if (zerop (mod n factor))\n   5 | do (setq n (/ n factor))\n   6 | else\n   7 | do (incf factor))\n   8 | n))\n```\n\noptions:\nA.    6 | else\n\nB.    2 | ['(let ((factor 1))']\n\nC.    5 | do (setq n (/ n factor))\n\nD.    3 | (loop while (> n factor)\n\n\n", "loc_answer": ["B"]}
{"question_id": "Clisp/41", "category": "Multiple", "subtype": "double_bug", "level": "medium", "example": ">>> has_close_elements([1.0, 2.0, 3.0], 0.5)\nnil\n>>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\nt", "docstring": ";;Check if in given list of numbers, are any two numbers closer to each other than\n;;given threshold.", "canonical_solution": "(defun has-close-elements (numbers threshold)\n\n\n(loop for i from 0 below (length numbers)\ndo (loop for j from 0 below (length numbers)\ndo (when (and (/= i j)\n(< (abs (- (nth i numbers) (nth j numbers))) threshold))\n(return-from has-close-elements t))))\nnil)", "buggy_code": "(defun has-close-elements (numbers threshold)\n\n\n(loop for i from 0 below (length numbers)\ndo (loop for j from 0 below (length numbers)\ndo (when (and (!= i j)\n(< (abs (- (nth i numbers) (nth j numbers))) threshold))\n(return-from has-close-element t))))\nnil)", "bug_with_line_numbers": "   1 | (defun has-close-elements (numbers threshold)\n   2 | (loop for i from 0 below (length numbers)\n   3 | do (loop for j from 0 below (length numbers)\n   4 | do (when (and (!= i j)\n   5 | (< (abs (- (nth i numbers) (nth j numbers))) threshold))\n   6 | (return-from has-close-element t))))\n   7 | nil)", "fragment_lines": [4, 6], "fragment_content": ["do (when (and (!= i j)", "(return-from has-close-element t))))"], "test": "(defun check ()\n(assert (equal (has-close-elements '(1.0 2.0 3.9 4.0 5.0 2.2) 0.3) t))\n(assert (equal (has-close-elements '(1.0 2.0 3.9 4.0 5.0 2.2) 0.05) nil))\n(assert (equal (has-close-elements '(1.0 2.0 5.9 4.0 5.0) 0.95) t))\n(assert (equal (has-close-elements '(1.0 2.0 5.9 4.0 5.0) 0.8) nil))\n(assert (equal (has-close-elements '(1.0 2.0 3.0 4.0 5.0 2.0) 0.1) t))\n(assert (equal (has-close-elements '(1.1 2.2 3.1 4.1 5.1) 1.0) t))\n(assert (equal (has-close-elements '(1.1 2.2 3.1 4.1 5.1) 0.5) nil)))\n\n(check)", "line_content": {"4": ["do (when (and (!= i j)"], "6": ["(return-from has-close-element t))))"]}, "instruction": "\nObserve the following faulty Clisp code and the options. The code snippets in the options are all from faulty code . Your task is to select the option(s) for error code snippet(s).\nNote:\n\n- This is an undetermined multiple-choice question, where the answer may include multiple options.\n- Please provide the answer in the form of a Python list, without returning any content other than the Python code block.. For example \n```python\n[\"A\"]\n```\n\nfaulty code:\n```\n   1 | (defun has-close-elements (numbers threshold)\n   2 | (loop for i from 0 below (length numbers)\n   3 | do (loop for j from 0 below (length numbers)\n   4 | do (when (and (!= i j)\n   5 | (< (abs (- (nth i numbers) (nth j numbers))) threshold))\n   6 | (return-from has-close-element t))))\n   7 | nil)\n```\n\noptions:\nA.    6 | ['(return-from has-close-element t))))']\n\nB.    1 | (defun has-close-elements (numbers threshold)\n\nC.    4 | ['do (when (and (!= i j)']\n\nD.    2 | (loop for i from 0 below (length numbers)\n\n\n", "loc_answer": ["C", "A"]}
{"question_id": "Clisp/42", "category": "Multiple", "subtype": "double_bug", "level": "hard", "example": ">>> occurrences '(a b a d a c d c a)\n(a . 4) (c . 2) (d . 2) (b . 1)", "docstring": ";; takes a list and returns a list indicating the number of times each (eql) element appears, sorted from most common element to least common", "canonical_solution": "(defun occurrences (lst)\n\n\n(let ((result nil))\n(dolist (obj lst)\n(if (null (assoc obj result))\n(push (cons obj 1) result)\n(incf (cdr (assoc obj result)))\n))\n(sort result #'(lambda (a b) (if (> (cdr a) (cdr b)) t nil)))))", "buggy_code": "(defun occurrences (lst)\n\n\n(let ((result nil))\n(dolist (obj lst)\n(if (null (assoc obj result))\n(push (cons obj 0) result)\n(incf (cdr (assoc obj result)))\n))\n(sort result #(lambda (a b) (if (> (cdr a) (cdr b)) t nil)))))", "bug_with_line_numbers": "   1 | (defun occurrences (lst)\n   2 | (let ((result nil))\n   3 | (dolist (obj lst)\n   4 | (if (null (assoc obj result))\n   5 | (push (cons obj 0) result)\n   6 | (incf (cdr (assoc obj result)))\n   7 | ))\n   8 | (sort result #(lambda (a b) (if (> (cdr a) (cdr b)) t nil)))))", "fragment_lines": [5, 8], "fragment_content": ["(push (cons obj 0) result)", "(sort result #(lambda (a b) (if (> (cdr a) (cdr b)) t nil)))))"], "test": "(defun check ()\n;; 测试 'occurrences' 函数。\n(assert (equal (occurrences '(a b a d a c d c a)) '((a . 4) (c . 2) (d . 2) (b . 1))))\n(assert (equal (occurrences '(1 2 2 3 3 3)) '((3 . 3) (2 . 2) (1 . 1))))\n(assert (equal (occurrences '(a b a)) '((a . 2) (b . 1)))))\n\n(check)", "line_content": {"5": ["(push (cons obj 0) result)"], "8": ["(sort result #(lambda (a b) (if (> (cdr a) (cdr b)) t nil)))))"]}, "instruction": "\nObserve the following faulty Clisp code and the options. The code snippets in the options are all from faulty code . Your task is to select the option(s) for error code snippet(s).\nNote:\n\n- This is an undetermined multiple-choice question, where the answer may include multiple options.\n- Please provide the answer in the form of a Python list, without returning any content other than the Python code block.. For example \n```python\n[\"A\"]\n```\n\nfaulty code:\n```\n   1 | (defun occurrences (lst)\n   2 | (let ((result nil))\n   3 | (dolist (obj lst)\n   4 | (if (null (assoc obj result))\n   5 | (push (cons obj 0) result)\n   6 | (incf (cdr (assoc obj result)))\n   7 | ))\n   8 | (sort result #(lambda (a b) (if (> (cdr a) (cdr b)) t nil)))))\n```\n\noptions:\nA.    8 | ['(sort result #(lambda (a b) (if (> (cdr a) (cdr b)) t nil)))))']\n\nB.    1 | (defun occurrences (lst)\n\nC.    5 | ['(push (cons obj 0) result)']\n\nD.    4 | (if (null (assoc obj result))\n\n\n", "loc_answer": ["C", "A"]}
{"question_id": "Clisp/43", "category": "Multiple", "subtype": "double_bug", "level": "hard", "example": ">>> move-first-instance-to-front 'b '(a b c d)\nb a c d", "docstring": ";; Define a function that takes two input parameters, object and queue, and can destructively move the first instance of object (eql equivalently) to the beginning of the queue", "canonical_solution": "(defun move-first-instance-to-front (object queue)\n\n\n(cond ((null queue) nil) \n((eql (first queue) object) queue) \n(t \n(let ((prev nil)\n(current queue))\n(loop while (and current (not (eql (first current) object)))\ndo (setq prev current)\n(setq current (rest current)))\n(if current \n(progn\n(when prev (setf (rest prev) (rest current))) \n(cons object (if prev queue (rest current)))) \nqueue)))))", "buggy_code": "(defun move-first-instance-to-front (object queue)\n\n\n(cond ((null queue) nil) \n((eql (first queue) object) queue) \n(t \n(let ((prev nil)\n(current queue))\n(loop while (and current (not (eql (first current) object)))\ndo (setq prev current)\n(setq current (rest current)))\n(progn\n(when prev (setf (rest prev) (rest current))) \n(cons object (if prev queue (rest current)))) \nqueue)))))", "bug_with_line_numbers": "   1 | (defun move-first-instance-to-front (object queue)\n   2 | (cond ((null queue) nil) \n   3 | ((eql (first queue) object) queue) \n   4 | (t \n   5 | (let ((prev nil)\n   6 | (current queue))\n   7 | (loop while (and current (not (eql (first current) object)))\n   8 | do (setq prev current)\n   9 | (setq current (rest current)))\n  10 | (progn\n  11 | (when prev (setf (rest prev) (rest current))) \n  12 | (cons object (if prev queue (rest current)))) \n  13 | queue)))))", "fragment_lines": [-1, 13], "fragment_content": ["missing critical code snippet", "queue)))))"], "test": "(defun check ()\n(assert (equal (move-first-instance-to-front 'b '(a b c d)) '(b a c d)))\n(assert (equal (move-first-instance-to-front 'a '(a b c d)) '(a b c d)))\n(assert (equal (move-first-instance-to-front 'e '(a b c d)) '(a b c d)))\n(assert (equal (move-first-instance-to-front 'd '(a b c d)) '(d a b c))))\n\n(check)", "line_content": {"-1": ["missing critical code snippet"], "13": ["queue)))))"]}, "instruction": "\nObserve the following faulty Clisp code and the options. The code snippets in the options are all from faulty code . Your task is to select the option(s) for error code snippet(s).\nNote:\n\n- This is an undetermined multiple-choice question, where the answer may include multiple options.\n- Please provide the answer in the form of a Python list, without returning any content other than the Python code block.. For example \n```python\n[\"A\"]\n```\n\nfaulty code:\n```\n   1 | (defun move-first-instance-to-front (object queue)\n   2 | (cond ((null queue) nil) \n   3 | ((eql (first queue) object) queue) \n   4 | (t \n   5 | (let ((prev nil)\n   6 | (current queue))\n   7 | (loop while (and current (not (eql (first current) object)))\n   8 | do (setq prev current)\n   9 | (setq current (rest current)))\n  10 | (progn\n  11 | (when prev (setf (rest prev) (rest current))) \n  12 | (cons object (if prev queue (rest current)))) \n  13 | queue)))))\n```\n\noptions:\nA.   13 | ['queue)))))']\n\nB.   -1 | ['missing critical code snippet']\n\nC.    1 | (defun move-first-instance-to-front (object queue)\n\nD.    3 | ((eql (first queue) object) queue)\n\n\n", "loc_answer": ["B", "A"]}
{"question_id": "Clisp/44", "category": "Multiple", "subtype": "double_bug", "level": "medium", "example": "(find-substring-index \"apple pie\" \"pie\")  Returns 6\n(find-substring-index \"hello world\" \"bye\")  Returns -1", "docstring": ";; Finds the first occurrence of the substring 'needle' within the string 'haystack'.\n;; Returns the index of the first character of the first occurrence of 'needle'.\n;; If 'needle' is not a part of 'haystack', returns -1.", "canonical_solution": "(defun find-substring-index (haystack needle)\n\n\n(let ((hay-len (length haystack))\n(need-len (length needle)))\n(if (zerop need-len)\n0\n(if (> need-len hay-len)\n-1\n(loop for i below (1+ (- hay-len need-len))\nwhen (string= (subseq haystack i (min (+ i need-len) hay-len)) needle)\nreturn i\nfinally (return -1))))))", "buggy_code": "(defun find-substring-index (haystack needle)\n\n\n(let ((hay-len (length haystack))\n(need-len (length needle)))\n(if (zerop need-len)\n0\n(if (> need-len hay-len)\n-1\n(loop for i below (1+ (- hay-len need-len))\nwhen (string= (subseq haystack i (min ( i need-len) hay-len)) needle)\nreturn i\nfinally (return -1)))))", "bug_with_line_numbers": "   1 | (defun find-substring-index (haystack needle)\n   2 | (let ((hay-len (length haystack))\n   3 | (need-len (length needle)))\n   4 | (if (zerop need-len)\n   5 | 0\n   6 | (if (> need-len hay-len)\n   7 | -1\n   8 | (loop for i below (1+ (- hay-len need-len))\n   9 | when (string= (subseq haystack i (min ( i need-len) hay-len)) needle)\n  10 | return i\n  11 | finally (return -1)))))", "fragment_lines": [9, 11], "fragment_content": ["when (string= (subseq haystack i (min ( i need-len) hay-len)) needle)", "finally (return -1)))))"], "test": "(defun check ()\n(assert (equal (find-substring-index \"apple pie\" \"pie\") 6))\n(assert (equal (find-substring-index \"hello world\" \"bye\") -1))\n(assert (equal (find-substring-index \"common lisp\" \"lisp\") 7))\n(assert (equal (find-substring-index \"quick brown fox\" \"brown\") 6))\n(assert (equal (find-substring-index \"abcdef\" \"de\") 3))\n(assert (equal (find-substring-index \"abcdef\" \"xyz\") -1))\n(assert (equal (find-substring-index \"pie\" \"apple pie\") -1)))\n\n(check)", "line_content": {"9": ["when (string= (subseq haystack i (min ( i need-len) hay-len)) needle)"], "11": ["finally (return -1)))))"]}, "instruction": "\nObserve the following faulty Clisp code and the options. The code snippets in the options are all from faulty code . Your task is to select the option(s) for error code snippet(s).\nNote:\n\n- This is an undetermined multiple-choice question, where the answer may include multiple options.\n- Please provide the answer in the form of a Python list, without returning any content other than the Python code block.. For example \n```python\n[\"A\"]\n```\n\nfaulty code:\n```\n   1 | (defun find-substring-index (haystack needle)\n   2 | (let ((hay-len (length haystack))\n   3 | (need-len (length needle)))\n   4 | (if (zerop need-len)\n   5 | 0\n   6 | (if (> need-len hay-len)\n   7 | -1\n   8 | (loop for i below (1+ (- hay-len need-len))\n   9 | when (string= (subseq haystack i (min ( i need-len) hay-len)) needle)\n  10 | return i\n  11 | finally (return -1)))))\n```\n\noptions:\nA.   10 | return i\n\nB.   11 | ['finally (return -1)))))']\n\nC.    9 | ['when (string= (subseq haystack i (min ( i need-len) hay-len)) needle)']\n\nD.    4 | (if (zerop need-len)\n\n\n", "loc_answer": ["C", "B"]}
{"question_id": "Clisp/45", "category": "Multiple", "subtype": "double_bug", "level": "hard", "example": "(total-cigarettes-smoked 4 3)  Returns 5\n(total-cigarettes-smoked 10 4)  Returns 13", "docstring": ";; Calculates the total number of cigarettes Peter can smoke.\n;; 'initial-cigarettes' is the starting number of cigarettes.\n;; 'butt-to-cigarette-ratio' is the number of cigarette butts required to get a new cigarette.\n;; The function returns the total number of cigarettes Peter can smoke.", "canonical_solution": "(defun total-cigarettes-smoked (initial-cigarettes butt-to-cigarette-ratio)\n\n\n(let ((total-smoked initial-cigarettes)\n(butts initial-cigarettes))\n(loop while (>= butts butt-to-cigarette-ratio)\ndo (let ((new-cigarettes (floor butts butt-to-cigarette-ratio)))\n(incf total-smoked new-cigarettes)\n(decf butts (* new-cigarettes butt-to-cigarette-ratio))\n(incf butts new-cigarettes)))\ntotal-smoked))", "buggy_code": "(defun total-cigarettes-smoked (initial-cigarettes butt-to-cigarette-ratio)\n\n\n(loop while (>= butts butt-to-cigarette-ratio)\ndo (let ((new-cigarettes (floor butts butt-to-cigarette-ratio)))\n(incf total-smoked new-cigarettes)\n(decf butts (* new-cigarettes butt-to-cigarette-ratio))\n(incf butts new-cigarettes)))\ntotal-smoked))", "bug_with_line_numbers": "   1 | (defun total-cigarettes-smoked (initial-cigarettes butt-to-cigarette-ratio)\n   2 | (loop while (>= butts butt-to-cigarette-ratio)\n   3 | do (let ((new-cigarettes (floor butts butt-to-cigarette-ratio)))\n   4 | (incf total-smoked new-cigarettes)\n   5 | (decf butts (* new-cigarettes butt-to-cigarette-ratio))\n   6 | (incf butts new-cigarettes)))\n   7 | total-smoked))", "fragment_lines": [-1, 7], "fragment_content": ["missing critical code snippet", "total-smoked))"], "test": "(defun check ()\n(assert (equal (total-cigarettes-smoked 4 3) 5))\n(assert (equal (total-cigarettes-smoked 10 4) 13))\n(assert (equal (total-cigarettes-smoked 20 5) 24))\n(assert (equal (total-cigarettes-smoked 15 3) 22))\n(assert (equal (total-cigarettes-smoked 7 2) 13))\n(assert (equal (total-cigarettes-smoked 5 5) 6))\n(assert (equal (total-cigarettes-smoked 0 3) 0)))\n\n(check)", "line_content": {"-1": ["missing critical code snippet"], "7": ["total-smoked))"]}, "instruction": "\nObserve the following faulty Clisp code and the options. The code snippets in the options are all from faulty code . Your task is to select the option(s) for error code snippet(s).\nNote:\n\n- This is an undetermined multiple-choice question, where the answer may include multiple options.\n- Please provide the answer in the form of a Python list, without returning any content other than the Python code block.. For example \n```python\n[\"A\"]\n```\n\nfaulty code:\n```\n   1 | (defun total-cigarettes-smoked (initial-cigarettes butt-to-cigarette-ratio)\n   2 | (loop while (>= butts butt-to-cigarette-ratio)\n   3 | do (let ((new-cigarettes (floor butts butt-to-cigarette-ratio)))\n   4 | (incf total-smoked new-cigarettes)\n   5 | (decf butts (* new-cigarettes butt-to-cigarette-ratio))\n   6 | (incf butts new-cigarettes)))\n   7 | total-smoked))\n```\n\noptions:\nA.   -1 | ['missing critical code snippet']\n\nB.    7 | ['total-smoked))']\n\nC.    1 | (defun total-cigarettes-smoked (initial-cigarettes butt-to-cigarette-ratio)\n\nD.    2 | (loop while (>= butts butt-to-cigarette-ratio)\n\n\n", "loc_answer": ["A", "B"]}
{"question_id": "Clisp/46", "category": "Multiple", "subtype": "double_bug", "level": "hard", "example": ">>> create-largest-number '(56 9 45)\n\"95645\"\n>>> create-largest-number '(5 50 56)\n\"56550\"", "docstring": ";; This function takes a list of positive integers and rearranges them to form the largest possible number. \n;; It does this by concatenating the integers in an order such that their digit-wise combination yields the maximum value.", "canonical_solution": "(defun create-largest-number (numbers)\n\n\n(let ((str-numbers (mapcar #'number-to-string numbers)))\n(setf str-numbers (sort str-numbers #'larger-when-concatenated))\n(reduce (lambda (acc x) (concatenate 'string acc x)) str-numbers :initial-value \"\")))\n\n(defun number-to-string (number)\n(write-to-string number))\n\n(defun larger-when-concatenated (a b)\n(string> (concatenate 'string a b) (concatenate 'string b a)))", "buggy_code": "(defun create-largest-number (numbers)\n\n\n(let ((str-numbers (mapcar #'number-to-string numbers)))\n(setf str-numbers (sort str-numbers #'larger-when-concatenated))\n(reduce (lambda (acc x) (concatenate 'string acc x)) str-numbers :initial-value 0)))\n\n(defun number-to-string (number)\n(write-to-string number))\n\n(defun larger-when-concatenated (a b)\n(string> (concatenate string a b) (concatenate string b a)))", "bug_with_line_numbers": "   1 | (defun create-largest-number (numbers)\n   2 | (let ((str-numbers (mapcar #'number-to-string numbers)))\n   3 | (setf str-numbers (sort str-numbers #'larger-when-concatenated))\n   4 | (reduce (lambda (acc x) (concatenate 'string acc x)) str-numbers :initial-value 0)))\n   5 | (defun number-to-string (number)\n   6 | (write-to-string number))\n   7 | (defun larger-when-concatenated (a b)\n   8 | (string> (concatenate string a b) (concatenate string b a)))", "fragment_lines": [4, 8], "fragment_content": ["(reduce (lambda (acc x) (concatenate 'string acc x)) str-numbers :initial-value 0)))", "(string> (concatenate string a b) (concatenate string b a)))"], "test": "(defun check ()\n(assert (string= (create-largest-number '(56 9 45)) \"95645\"))\n(assert (string= (create-largest-number '(5 50 56)) \"56550\"))\n(assert (string= (create-largest-number '(3 34 302 50)) \"50343302\"))\n(assert (string= (create-largest-number '(10 2 23)) \"23210\"))\n(assert (string= (create-largest-number '(4 42 40 400)) \"44240400\")))\n\n(check)", "line_content": {"4": ["(reduce (lambda (acc x) (concatenate 'string acc x)) str-numbers :initial-value 0)))"], "8": ["(string> (concatenate string a b) (concatenate string b a)))"]}, "instruction": "\nObserve the following faulty Clisp code and the options. The code snippets in the options are all from faulty code . Your task is to select the option(s) for error code snippet(s).\nNote:\n\n- This is an undetermined multiple-choice question, where the answer may include multiple options.\n- Please provide the answer in the form of a Python list, without returning any content other than the Python code block.. For example \n```python\n[\"A\"]\n```\n\nfaulty code:\n```\n   1 | (defun create-largest-number (numbers)\n   2 | (let ((str-numbers (mapcar #'number-to-string numbers)))\n   3 | (setf str-numbers (sort str-numbers #'larger-when-concatenated))\n   4 | (reduce (lambda (acc x) (concatenate 'string acc x)) str-numbers :initial-value 0)))\n   5 | (defun number-to-string (number)\n   6 | (write-to-string number))\n   7 | (defun larger-when-concatenated (a b)\n   8 | (string> (concatenate string a b) (concatenate string b a)))\n```\n\noptions:\nA.    8 | ['(string> (concatenate string a b) (concatenate string b a)))']\n\nB.    3 | (setf str-numbers (sort str-numbers #'larger-when-concatenated))\n\nC.    6 | (write-to-string number))\n\nD.    4 | [\"(reduce (lambda (acc x) (concatenate 'string acc x)) str-numbers :initial-value 0)))\"]\n\n\n", "loc_answer": ["D", "A"]}
{"question_id": "Clisp/47", "category": "Multiple", "subtype": "triple_bug", "level": "medium", "example": " >>> bin-search 3 '#(1 2 3 4 5)\n t", "docstring": ";; Binary search for 'obj' in sorted vector 'vec'.\n;; Returns 't' if 'obj' is found, 'nil' otherwise.", "canonical_solution": "(defun bin-search (obj vec)\n\n\n(let ((low 0)\n(high (1- (length vec))))\n(loop while (<= low high)\nfor mid = (floor (+ low high) 2)\nfor mid-val = (aref vec mid)\ndo (cond ((= obj mid-val) (return-from bin-search t))\n((< obj mid-val) (setf high (1- mid)))\n((> obj mid-val) (setf low (1+ mid)))))\nnil))", "buggy_code": "(defun bin-search (obj vec)\n\n\n(let ((low 1)\n(high (1- (length vec))))\n(loop while (<= low high)\nfor mid = (floor (+ low high) 2)\nfor mid-val = (aref vec mid)\ndo (cond ((= obj mid-val) (return bin-search t))\n((< obj mid-val) (setf high (1- mid)))\n((> obj mid-val) (setf low (1+ mid))))\nnil))", "bug_with_line_numbers": "   1 | (defun bin-search (obj vec)\n   2 | (let ((low 1)\n   3 | (high (1- (length vec))))\n   4 | (loop while (<= low high)\n   5 | for mid = (floor (+ low high) 2)\n   6 | for mid-val = (aref vec mid)\n   7 | do (cond ((= obj mid-val) (return bin-search t))\n   8 | ((< obj mid-val) (setf high (1- mid)))\n   9 | ((> obj mid-val) (setf low (1+ mid))))\n  10 | nil))", "fragment_lines": [2, 7, 9], "fragment_content": ["(let ((low 1)", "do (cond ((= obj mid-val) (return bin-search t))", "((> obj mid-val) (setf low (1+ mid))))"], "test": "(defun check ()\n;; Test the 'bin-search' function with various cases.\n(assert (equal (bin-search 3 '#(1 2 3 4 5)) t))\n(assert (equal (bin-search 6 '#(1 2 3 4 5)) nil))\n(assert (equal (bin-search 1 '#(1)) t))\n(assert (equal (bin-search 2 '#(1)) nil))\n(assert (equal (bin-search 0 '#()) nil))\n(assert (equal (bin-search 5 '#(2 4 6 8 10)) nil))\n(assert (equal (bin-search 4 '#(2 4 6 8 10)) t)))\n\n(check)", "line_content": {"2": ["(let ((low 1)"], "7": ["do (cond ((= obj mid-val) (return bin-search t))"], "9": ["((> obj mid-val) (setf low (1+ mid))))"]}, "instruction": "\nObserve the following faulty Clisp code and the options. The code snippets in the options are all from faulty code . Your task is to select the option(s) for error code snippet(s).\nNote:\n\n- This is an undetermined multiple-choice question, where the answer may include multiple options.\n- Please provide the answer in the form of a Python list, without returning any content other than the Python code block.. For example \n```python\n[\"A\"]\n```\n\nfaulty code:\n```\n   1 | (defun bin-search (obj vec)\n   2 | (let ((low 1)\n   3 | (high (1- (length vec))))\n   4 | (loop while (<= low high)\n   5 | for mid = (floor (+ low high) 2)\n   6 | for mid-val = (aref vec mid)\n   7 | do (cond ((= obj mid-val) (return bin-search t))\n   8 | ((< obj mid-val) (setf high (1- mid)))\n   9 | ((> obj mid-val) (setf low (1+ mid))))\n  10 | nil))\n```\n\noptions:\nA.    9 | ['((> obj mid-val) (setf low (1+ mid))))']\n\nB.    7 | ['do (cond ((= obj mid-val) (return bin-search t))']\n\nC.    2 | ['(let ((low 1)']\n\nD.    5 | for mid = (floor (+ low high) 2)\n\n\n", "loc_answer": ["C", "B", "A"]}
{"question_id": "Clisp/48", "category": "Multiple", "subtype": "triple_bug", "level": "medium", "example": " >>> segments-intersect? 0 0 1 1 1 0 0 1\n x 0.5\n y 0.5", "docstring": ";; Define a function that accepts 8 real numbers representing the endpoints of two line segments in two-dimensional space. If the line segments do not intersect, return false, or return two values representing the x and y coordinates of the intersection point", "canonical_solution": "(defun segments-intersect? (x1 y1 x2 y2 x3 y3 x4 y4)\n\n\n(let ((denom (- (* (- x2 x1) (- y4 y3)) (* (- y2 y1) (- x4 x3)))))\n(unless (zerop denom)\n(let* ((ua (/ (- (* (- x4 x3) (- y1 y3)) (* (- y4 y3) (- x1 x3))) denom))\n(ub (/ (- (* (- x2 x1) (- y1 y3)) (* (- y2 y1) (- x1 x3))) denom))\n(x-on-segment (+ x1 (* ua (- x2 x1))))\n(y-on-segment (+ y1 (* ua (- y2 y1)))))\n(when (and (>= ua 0) (<= ua 1) (>= ub 0) (<= ub 1))\n(values x-on-segment y-on-segment))))))\n\n(defun float-near-equal (a b &optional (tolerance 1e-5))\n(<= (abs (- a b)) tolerance))", "buggy_code": "(defun segments-intersect? (x1 y1 x2 y2 x3 y3 x4 y4)\n\n\n(let ((denom (- (* (- x2 x1) (- y4 y3)) (* (- y2 y1) (- x4 x3)))))\n(unless (zerop denom)\n(let* ((ua ((- (* (- x4 x3) (- y1 y3)) (* (- y4 y3) (- x1 x3))) denom))\n(ub (/ (- (* (- x2 x1) (- y1 y3)) (* (- y2 y1) (- x1 x3))) denom))\n(x-on-segment (+ x1 (* ua (- x1 x2))))\n(y-on-segment (+ y1 (* ua (- y1 y2)))))\n(when (and (>= ua 0) (<= ua 1) (>= ub 0) (<= ub 1))\n(values x-on-segment y-on-segment)))))\n\n(defun float-near-equal (a b &optional (tolerance 1e-5))\n(<= (abs (- a b)) tolerance))", "bug_with_line_numbers": "   1 | (defun segments-intersect? (x1 y1 x2 y2 x3 y3 x4 y4)\n   2 | (let ((denom (- (* (- x2 x1) (- y4 y3)) (* (- y2 y1) (- x4 x3)))))\n   3 | (unless (zerop denom)\n   4 | (let* ((ua ((- (* (- x4 x3) (- y1 y3)) (* (- y4 y3) (- x1 x3))) denom))\n   5 | (ub (/ (- (* (- x2 x1) (- y1 y3)) (* (- y2 y1) (- x1 x3))) denom))\n   6 | (x-on-segment (+ x1 (* ua (- x1 x2))))\n   7 | (y-on-segment (+ y1 (* ua (- y1 y2)))))\n   8 | (when (and (>= ua 0) (<= ua 1) (>= ub 0) (<= ub 1))\n   9 | (values x-on-segment y-on-segment)))))\n  10 | (defun float-near-equal (a b &optional (tolerance 1e-5))\n  11 | (<= (abs (- a b)) tolerance))", "fragment_lines": [4, 6, 7, 9], "fragment_content": ["(let* ((ua ((- (* (- x4 x3) (- y1 y3)) (* (- y4 y3) (- x1 x3))) denom))", "(x-on-segment (+ x1 (* ua (- x1 x2))))", "(y-on-segment (+ y1 (* ua (- y1 y2)))))", "(values x-on-segment y-on-segment)))))"], "test": "(defun check ()\n(multiple-value-bind (x y) (segments-intersect? 0 0 1 1 1 0 0 1)\n(assert (and (float-near-equal x 0.5) (float-near-equal y 0.5))))\n(assert (null (segments-intersect? 0 0 1 1 2 2 3 3))))\n\n(check)", "line_content": {"4": ["(let* ((ua ((- (* (- x4 x3) (- y1 y3)) (* (- y4 y3) (- x1 x3))) denom))"], "6,7": ["(x-on-segment (+ x1 (* ua (- x1 x2))))", "(y-on-segment (+ y1 (* ua (- y1 y2)))))"], "9": ["(values x-on-segment y-on-segment)))))"]}, "instruction": "\nObserve the following faulty Clisp code and the options. The code snippets in the options are all from faulty code . Your task is to select the option(s) for error code snippet(s).\nNote:\n\n- This is an undetermined multiple-choice question, where the answer may include multiple options.\n- Please provide the answer in the form of a Python list, without returning any content other than the Python code block.. For example \n```python\n[\"A\"]\n```\n\nfaulty code:\n```\n   1 | (defun segments-intersect? (x1 y1 x2 y2 x3 y3 x4 y4)\n   2 | (let ((denom (- (* (- x2 x1) (- y4 y3)) (* (- y2 y1) (- x4 x3)))))\n   3 | (unless (zerop denom)\n   4 | (let* ((ua ((- (* (- x4 x3) (- y1 y3)) (* (- y4 y3) (- x1 x3))) denom))\n   5 | (ub (/ (- (* (- x2 x1) (- y1 y3)) (* (- y2 y1) (- x1 x3))) denom))\n   6 | (x-on-segment (+ x1 (* ua (- x1 x2))))\n   7 | (y-on-segment (+ y1 (* ua (- y1 y2)))))\n   8 | (when (and (>= ua 0) (<= ua 1) (>= ub 0) (<= ub 1))\n   9 | (values x-on-segment y-on-segment)))))\n  10 | (defun float-near-equal (a b &optional (tolerance 1e-5))\n  11 | (<= (abs (- a b)) tolerance))\n```\n\noptions:\nA.    6 | (x-on-segment (+ x1 (* ua (- x1 x2))))\n   7 | (y-on-segment (+ y1 (* ua (- y1 y2)))))\n\nB.    4 | ['(let* ((ua ((- (* (- x4 x3) (- y1 y3)) (* (- y4 y3) (- x1 x3))) denom))']\n\nC.    9 | ['(values x-on-segment y-on-segment)))))']\n\nD.    3 | (unless (zerop denom)\n\n\n", "loc_answer": ["B", "A", "C"]}
{"question_id": "Clisp/49", "category": "Multiple", "subtype": "triple_bug", "level": "hard", "example": " (count-remaining-trees 10 '((2 5) (7 9)))  Returns 4\n (count-remaining-trees 15 '((1 3) (5 10)))  Returns 7", "docstring": ";; Counts the number of trees remaining on a road of length 'road-length' after removing trees in specified 'regions'.\n;; Each region is a list of two integers representing the start and end points on the road.\n;; The function returns the number of trees remaining after the removal.", "canonical_solution": "(defun count-remaining-trees (road-length regions)\n\n\n(let ((tree-map (make-array (1+ road-length) :initial-element t)))\n(dolist (region regions)\n(loop for i from (first region) to (second region)\ndo (setf (aref tree-map i) nil)))\n(count t tree-map)))", "buggy_code": "(defun count-remaining-trees (road-length regions)\n\n\n(let ((tree-map (make-array (road-length) :initial-element t)))\n(dolist (region regions)\n(loop for i from (second region) to (first region)\n(setf (aref tree-map i) nil)))\n(count t tree-map)))", "bug_with_line_numbers": "   1 | (defun count-remaining-trees (road-length regions)\n   2 | (let ((tree-map (make-array (road-length) :initial-element t)))\n   3 | (dolist (region regions)\n   4 | (loop for i from (second region) to (first region)\n   5 | (setf (aref tree-map i) nil)))\n   6 | (count t tree-map)))", "fragment_lines": [2, 4, 5], "fragment_content": ["(let ((tree-map (make-array (road-length) :initial-element t)))", "(loop for i from (second region) to (first region)", "(setf (aref tree-map i) nil)))"], "test": "(defun check ()\n(assert (equal (count-remaining-trees 10 '((2 5) (7 9))) 4))\n(assert (equal (count-remaining-trees 15 '((1 3) (5 10))) 7))\n(assert (equal (count-remaining-trees 20 '((0 5) (10 15))) 9))\n(assert (equal (count-remaining-trees 30 '((3 6) (8 10) (15 20))) 18))\n(assert (equal (count-remaining-trees 50 '((0 10) (20 30) (40 50))) 18)))\n\n(check)", "line_content": {"2": ["(let ((tree-map (make-array (road-length) :initial-element t)))"], "4,5": ["(loop for i from (second region) to (first region)", "(setf (aref tree-map i) nil)))"]}, "instruction": "\nObserve the following faulty Clisp code and the options. The code snippets in the options are all from faulty code . Your task is to select the option(s) for error code snippet(s).\nNote:\n\n- This is an undetermined multiple-choice question, where the answer may include multiple options.\n- Please provide the answer in the form of a Python list, without returning any content other than the Python code block.. For example \n```python\n[\"A\"]\n```\n\nfaulty code:\n```\n   1 | (defun count-remaining-trees (road-length regions)\n   2 | (let ((tree-map (make-array (road-length) :initial-element t)))\n   3 | (dolist (region regions)\n   4 | (loop for i from (second region) to (first region)\n   5 | (setf (aref tree-map i) nil)))\n   6 | (count t tree-map)))\n```\n\noptions:\nA.    4 | (loop for i from (second region) to (first region)\n   5 | (setf (aref tree-map i) nil)))\n\nB.    6 | (count t tree-map)))\n\nC.    3 | (dolist (region regions)\n\nD.    2 | ['(let ((tree-map (make-array (road-length) :initial-element t)))']\n\n\n", "loc_answer": ["D", "A"]}
{"question_id": "Clisp/50", "category": "Multiple", "subtype": "triple_bug", "level": "hard", "example": " (larger-prime-factor 15)  Returns 5\n (larger-prime-factor 33)  Returns 11", "docstring": ";; Finds the larger prime factor of a positive integer 'n', which is known to be the product of two distinct prime numbers.\n;; The function returns the larger of the two prime factors.", "canonical_solution": "(defun larger-prime-factor (n)\n\n\n(let ((factor 2))\n(loop while (> n factor)\nif (zerop (mod n factor))\ndo (setq n (/ n factor))\nelse\ndo (incf factor))\nn))", "buggy_code": "(defun larger-prime-factor (n)\n\n\n(let ((factor 1))\n(loop while (>= n factor)\nif (zero (mod n factor))\ndo (setq n (/ n factor))\nelse\ndo (incf factor))\nn))", "bug_with_line_numbers": "   1 | (defun larger-prime-factor (n)\n   2 | (let ((factor 1))\n   3 | (loop while (>= n factor)\n   4 | if (zero (mod n factor))\n   5 | do (setq n (/ n factor))\n   6 | else\n   7 | do (incf factor))\n   8 | n))", "fragment_lines": [2, 3, 4], "fragment_content": ["(let ((factor 1))", "(loop while (>= n factor)", "if (zero (mod n factor))"], "test": "(defun check ()\n(assert (equal (larger-prime-factor 21) 7))\n(assert (equal (larger-prime-factor 15) 5))\n(assert (equal (larger-prime-factor 33) 11))\n(assert (equal (larger-prime-factor 35) 7))\n(assert (equal (larger-prime-factor 77) 11))\n(assert (equal (larger-prime-factor 26) 13)))\n\n(check)", "line_content": {"2,3,4": ["(let ((factor 1))", "(loop while (>= n factor)", "if (zero (mod n factor))"]}, "instruction": "\nObserve the following faulty Clisp code and the options. The code snippets in the options are all from faulty code . Your task is to select the option(s) for error code snippet(s).\nNote:\n\n- This is an undetermined multiple-choice question, where the answer may include multiple options.\n- Please provide the answer in the form of a Python list, without returning any content other than the Python code block.. For example \n```python\n[\"A\"]\n```\n\nfaulty code:\n```\n   1 | (defun larger-prime-factor (n)\n   2 | (let ((factor 1))\n   3 | (loop while (>= n factor)\n   4 | if (zero (mod n factor))\n   5 | do (setq n (/ n factor))\n   6 | else\n   7 | do (incf factor))\n   8 | n))\n```\n\noptions:\nA.    8 | n))\n\nB.    2 | (let ((factor 1))\n   3 | (loop while (>= n factor)\n   4 | if (zero (mod n factor))\n\nC.    5 | do (setq n (/ n factor))\n\nD.    7 | do (incf factor))\n\n\n", "loc_answer": ["B"]}
{"question_id": "Clisp/51", "category": "Multiple", "subtype": "triple_bug", "level": "hard", "example": " >>> count-output-sequences 3\n 5\n >>> count-output-sequences 4\n 14", "docstring": ";; This function calculates the total number of different output sequences that can be obtained by using a stack \n;; with operations push and pop on a sequence of numbers from 1 to n.\n;; The operations are: \n;; 1. Push the next number from the input sequence onto the stack.\n;; 2. Pop the top number from the stack and add it to the output sequence.\n;; It counts all the possible sequences of these operations that result in all numbers being moved from the input sequence to the output sequence.", "canonical_solution": "(defun count-output-sequences (n)\n\n\n(let ((dp (make-array (1+ n) :initial-element 0)))\n(setf (aref dp 0) 1)\n(loop for i from 1 to n do\n(loop for j from 0 to (1- i) do\n(incf (aref dp i) (* (aref dp j) (aref dp (1- (- i j)))))))\n(aref dp n)))", "buggy_code": "(defun count-output-sequences (n)\n\n\n(let ((dp (make-array (n) :initial-element 0)))\n(setf (aref dp 0) 0)\n(loop for i from 1 to n do\n(loop for j from 0 to (1- i) do\n(incf (aref dp i) (* (aref dp j) (aref dp (1- (- i j))))))\n(aref dp n)))", "bug_with_line_numbers": "   1 | (defun count-output-sequences (n)\n   2 | (let ((dp (make-array (n) :initial-element 0)))\n   3 | (setf (aref dp 0) 0)\n   4 | (loop for i from 1 to n do\n   5 | (loop for j from 0 to (1- i) do\n   6 | (incf (aref dp i) (* (aref dp j) (aref dp (1- (- i j))))))\n   7 | (aref dp n)))", "fragment_lines": [2, 3, 6], "fragment_content": ["(let ((dp (make-array (n) :initial-element 0)))", "(setf (aref dp 0) 0)", "(incf (aref dp i) (* (aref dp j) (aref dp (1- (- i j))))))"], "test": "(defun check ()\n(assert (equal (count-output-sequences 3) 5))\n(assert (equal (count-output-sequences 4) 14))\n(assert (equal (count-output-sequences 5) 42))\n(assert (equal (count-output-sequences 6) 132))\n(assert (equal (count-output-sequences 7) 429)))\n\n(check)", "line_content": {"2,3": ["(let ((dp (make-array (n) :initial-element 0)))", "(setf (aref dp 0) 0)"], "6": ["(incf (aref dp i) (* (aref dp j) (aref dp (1- (- i j))))))"]}, "instruction": "\nObserve the following faulty Clisp code and the options. The code snippets in the options are all from faulty code . Your task is to select the option(s) for error code snippet(s).\nNote:\n\n- This is an undetermined multiple-choice question, where the answer may include multiple options.\n- Please provide the answer in the form of a Python list, without returning any content other than the Python code block.. For example \n```python\n[\"A\"]\n```\n\nfaulty code:\n```\n   1 | (defun count-output-sequences (n)\n   2 | (let ((dp (make-array (n) :initial-element 0)))\n   3 | (setf (aref dp 0) 0)\n   4 | (loop for i from 1 to n do\n   5 | (loop for j from 0 to (1- i) do\n   6 | (incf (aref dp i) (* (aref dp j) (aref dp (1- (- i j))))))\n   7 | (aref dp n)))\n```\n\noptions:\nA.    7 | (aref dp n)))\n\nB.    6 | ['(incf (aref dp i) (* (aref dp j) (aref dp (1- (- i j))))))']\n\nC.    2 | (let ((dp (make-array (n) :initial-element 0)))\n   3 | (setf (aref dp 0) 0)\n\nD.    5 | (loop for j from 0 to (1- i) do\n\n\n", "loc_answer": ["C", "B"]}
{"question_id": "Clisp/52", "category": "Multiple", "subtype": "quadruple_bug", "level": "hard", "example": ">>> parse-date \"16 Aug 1980\"\n16 8 1980", "docstring": "", "canonical_solution": "(defun parse-date (date-str)\n\"Parse a date string in the format 'DD MMM YYYY' and return a list (day month year).\"\n\n\n(let ((toks (tokens date-str #'constituent 0)))\n(list (parse-integer (first toks):junk-allowed t)\n(parse-month (second toks))\n(parse-integer (third toks)))))\n\n(defun tokens (str test start)\n(let ((p1 (position-if test str :start start)))\n(if p1\n(let ((p2 (position-if #'(lambda (c)\n(not (funcall test c)))\nstr :start p1)))\n(cons (subseq str p1 p2)\n(if p2\n(tokens str test p2)\nnil)))\nnil)))\n(defun constituent (c)\n(and (graphic-char-p c)\n(not (char= c #\\ ))))\n\n(defconstant month-names\n'(\"jan\" \"feb\" \"mar\" \"apr\" \"may\" \"jun\"\n\"jul\" \"aug\" \"sep\" \"oct\" \"nov\" \"dec\"))\n\n(defun parse-month (str)\n\"Parse the month string and return the month number.\"\n(let ((p (position (string-downcase str) month-names :test #'string-equal)))\n(if p\n(1+ p)\n(error \"Invalid month string: ~A\" str))))", "buggy_code": "(defun parse-date (date-str)\n\"Parse a date string in the format 'DD MMM YYYY' and return a list (day month year).\"\n\n\n(let ((toks (tokens date-str #'constituent)))\n(list (parse-integer (first toks):junk-allowed t)\n(parse-month (second toks))\n(parse-integer (third toks)))))\n\n(defun tokens (str test start)\n(let ((p1 (position-if test str :start start)))\n(if p1\n(let ((p2 (position-if #(lambda (c)\n(not (funcall test c)))\nstr :start p1)))\n(cons (subseq str p1 p2)\n(if p2\n(tokens str test p2)\nnil))))))\n(defun constituent (c)\n(and (graphic-char-p c)\n(not (char= c #\\ ))))\n\n(defconstant month-names\n'(\"jan\" \"feb\" \"mar\" \"apr\" \"may\" \"jun\"\n\"jul\" \"aug\" \"sep\" \"oct\" \"nov\" \"dec\"))\n\n(defun parse-month (str)\n\"Parse the month string and return the month number.\"\n(let ((p (position (string-downcase str) month-names :test #'string-equal)))\n(if p\np\n(error \"Invalid month string: ~A\" str))))", "bug_with_line_numbers": "   1 | (defun parse-date (date-str)\n   2 | \"Parse a date string in the format 'DD MMM YYYY' and return a list (day month year).\"\n   3 | (let ((toks (tokens date-str #'constituent)))\n   4 | (list (parse-integer (first toks):junk-allowed t)\n   5 | (parse-month (second toks))\n   6 | (parse-integer (third toks)))))\n   7 | (defun tokens (str test start)\n   8 | (let ((p1 (position-if test str :start start)))\n   9 | (if p1\n  10 | (let ((p2 (position-if #(lambda (c)\n  11 | (not (funcall test c)))\n  12 | str :start p1)))\n  13 | (cons (subseq str p1 p2)\n  14 | (if p2\n  15 | (tokens str test p2)\n  16 | nil))))))\n  17 | (defun constituent (c)\n  18 | (and (graphic-char-p c)\n  19 | (not (char= c #\\ ))))\n  20 | (defconstant month-names\n  21 | '(\"jan\" \"feb\" \"mar\" \"apr\" \"may\" \"jun\"\n  22 | \"jul\" \"aug\" \"sep\" \"oct\" \"nov\" \"dec\"))\n  23 | (defun parse-month (str)\n  24 | \"Parse the month string and return the month number.\"\n  25 | (let ((p (position (string-downcase str) month-names :test #'string-equal)))\n  26 | (if p\n  27 | p\n  28 | (error \"Invalid month string: ~A\" str))))", "fragment_lines": [-1, 3, 10, 26, 27], "fragment_content": ["missing critical code snippet", "(let ((toks (tokens date-str #'constituent)))", "(let ((p2 (position-if #(lambda (c)", "(if p", "p"], "test": "(defun check ()\n;; Test the 'parse-date' function with various date strings.\n(assert (equal (parse-date \"16 Aug 1980\") '(16 8 1980)))\n(assert (equal (parse-date \"1 Jan 2023\") '(1 1 2023)))\n(assert (equal (parse-date \"25 Dec 1999\") '(25 12 1999)))\n(assert (equal (parse-date \"31 Oct 2025\") '(31 10 2025)))\n(assert (equal (parse-date \"20 Feb 2010\") '(20 2 2010))))\n\n(check)", "line_content": {"-1": ["missing critical code snippet"], "3": ["(let ((toks (tokens date-str #'constituent)))"], "10": ["(let ((p2 (position-if #(lambda (c)"], "26,27": ["(if p", "p"]}, "instruction": "\nObserve the following faulty Clisp code and the options. The code snippets in the options are all from faulty code . Your task is to select the option(s) for error code snippet(s).\nNote:\n\n- This is an undetermined multiple-choice question, where the answer may include multiple options.\n- Please provide the answer in the form of a Python list, without returning any content other than the Python code block.. For example \n```python\n[\"A\"]\n```\n\nfaulty code:\n```\n   1 | (defun parse-date (date-str)\n   2 | \"Parse a date string in the format 'DD MMM YYYY' and return a list (day month year).\"\n   3 | (let ((toks (tokens date-str #'constituent)))\n   4 | (list (parse-integer (first toks):junk-allowed t)\n   5 | (parse-month (second toks))\n   6 | (parse-integer (third toks)))))\n   7 | (defun tokens (str test start)\n   8 | (let ((p1 (position-if test str :start start)))\n   9 | (if p1\n  10 | (let ((p2 (position-if #(lambda (c)\n  11 | (not (funcall test c)))\n  12 | str :start p1)))\n  13 | (cons (subseq str p1 p2)\n  14 | (if p2\n  15 | (tokens str test p2)\n  16 | nil))))))\n  17 | (defun constituent (c)\n  18 | (and (graphic-char-p c)\n  19 | (not (char= c #\\ ))))\n  20 | (defconstant month-names\n  21 | '(\"jan\" \"feb\" \"mar\" \"apr\" \"may\" \"jun\"\n  22 | \"jul\" \"aug\" \"sep\" \"oct\" \"nov\" \"dec\"))\n  23 | (defun parse-month (str)\n  24 | \"Parse the month string and return the month number.\"\n  25 | (let ((p (position (string-downcase str) month-names :test #'string-equal)))\n  26 | (if p\n  27 | p\n  28 | (error \"Invalid month string: ~A\" str))))\n```\n\noptions:\nA.   26 | (if p\n  27 | p\n\nB.   -1 | ['missing critical code snippet']\n\nC.    3 | [\"(let ((toks (tokens date-str #'constituent)))\"]\n\nD.   10 | ['(let ((p2 (position-if #(lambda (c)']\n\n\n", "loc_answer": ["B", "C", "D", "A"]}
{"question_id": "Clisp/53", "category": "Multiple", "subtype": "quadruple_bug", "level": "hard", "example": "quicksort '(3 1 4 1 5 9 2 6 5 3 5)v\n1 1 2 3 3 4 5 5 5 6 9", "docstring": ";; Quickly sort the list", "canonical_solution": "(defun quicksort (list)\n\n\n(if (null list)\nnil\n(let ((pivot (first list))\n(rest (rest list)))\n(append (quicksort (remove-if-not #'(lambda (x) (< x pivot)) rest))\n(list pivot)\n(quicksort (remove-if #'(lambda (x) (< x pivot)) rest))))))", "buggy_code": "(defun quicksort (list)\n\n\n(if (not list)\nnil\n(let ((pivot (first list))\n(rest (rest list)))\n(append (quicksort (remove-if-not #'(lambda (x) (<= x pivot)) rest))\n(quicksort (remove-if #'(lambda (x) (< x pivot)) rest)))))", "bug_with_line_numbers": "   1 | (defun quicksort (list)\n   2 | (if (not list)\n   3 | nil\n   4 | (let ((pivot (first list))\n   5 | (rest (rest list)))\n   6 | (append (quicksort (remove-if-not #'(lambda (x) (<= x pivot)) rest))\n   7 | (quicksort (remove-if #'(lambda (x) (< x pivot)) rest)))))", "fragment_lines": [-1, 2, 6, 7], "fragment_content": ["missing critical code snippet", "(if (not list)", "(append (quicksort (remove-if-not #'(lambda (x) (<= x pivot)) rest))", "(quicksort (remove-if #'(lambda (x) (< x pivot)) rest)))))"], "test": "(defun check ()\n;; 测试 'quicksort' 函数。\n(assert (equal (quicksort '(3 1 4 1 5 9 2 6 5 3 5)) '(1 1 2 3 3 4 5 5 5 6 9)))\n(assert (equal (quicksort '(5 4 3 2 1)) '(1 2 3 4 5)))\n(assert (equal (quicksort '()) '()))\n(assert (equal (quicksort '(1)) '(1))))\n\n(check)", "line_content": {"-1": ["missing critical code snippet"], "2": ["(if (not list)"], "6,7": ["(append (quicksort (remove-if-not #'(lambda (x) (<= x pivot)) rest))", "(quicksort (remove-if #'(lambda (x) (< x pivot)) rest)))))"]}, "instruction": "\nObserve the following faulty Clisp code and the options. The code snippets in the options are all from faulty code . Your task is to select the option(s) for error code snippet(s).\nNote:\n\n- This is an undetermined multiple-choice question, where the answer may include multiple options.\n- Please provide the answer in the form of a Python list, without returning any content other than the Python code block.. For example \n```python\n[\"A\"]\n```\n\nfaulty code:\n```\n   1 | (defun quicksort (list)\n   2 | (if (not list)\n   3 | nil\n   4 | (let ((pivot (first list))\n   5 | (rest (rest list)))\n   6 | (append (quicksort (remove-if-not #'(lambda (x) (<= x pivot)) rest))\n   7 | (quicksort (remove-if #'(lambda (x) (< x pivot)) rest)))))\n```\n\noptions:\nA.   -1 | ['missing critical code snippet']\n\nB.    2 | ['(if (not list)']\n\nC.    5 | (rest (rest list)))\n\nD.    6 | (append (quicksort (remove-if-not #'(lambda (x) (<= x pivot)) rest))\n   7 | (quicksort (remove-if #'(lambda (x) (< x pivot)) rest)))))\n\n\n", "loc_answer": ["A", "B", "D"]}
{"question_id": "Clisp/54", "category": "Multiple", "subtype": "quadruple_bug", "level": "hard", "example": "(calculate-year-end-amount '(290 230 280 200 300 170 340 50 90 80 200 60))  Returns -7", "docstring": ";; Calculates whether Jinjin can follow her savings plan without running out of money in any month.\n;; 'monthly-budgets' is a list of 12 integers representing Jinjin's monthly budget.\n;; If successful, returns the total amount of money Jinjin will have by year-end, including 20% interest on savings.\n;; Otherwise, returns -X, where X is the first month Jinjin runs out of money.", "canonical_solution": "(defun calculate-year-end-amount (monthly-budgets)\n;; Calculates whether Jinjin can follow her savings plan without running out of money in any month.\n;; 'monthly-budgets' is a list of 12 integers representing Jinjin's monthly budget.\n;; If successful, returns the total amount of money Jinjin will have by year-end, including 20% interest on savings.\n;; Otherwise, returns -X, where X is the first month Jinjin runs out of money.\n;; Example:\n;; (calculate-year-end-amount '(290 230 280 200 300 170 340 50 90 80 200 60)) ;; Returns -7\n\n(let ((current-amount 0)\n(total-saved 0))\n(loop for month from 1 to 12\nfor budget in monthly-budgets\ndo (progn\n(incf current-amount 300) ;; Add monthly allowance\n(decf current-amount budget) ;; Subtract monthly budget\n(when (< current-amount 0)\n(return-from calculate-year-end-amount (- month))) ;; Check if Jinjin runs out of money\n(let ((savings (floor current-amount 100)))\n(decf current-amount (* 100 savings))\n(incf total-saved (* 100 savings))))\nfinally (return (+ current-amount (* total-saved 1.2)))))) ;; Calculate total with interest", "buggy_code": "(defun calculate-year-end-amount (monthly-budgets)\n\n\n(let (current-amount 0)\n(total-saved 0))\n(loop for month from 1 to 12\nfor budget in monthly-budgets\ndo (progn\n(incf current-amount 300)\n(decf current-amount budget)\n(when (< current-amount 0)\n(return calculate-year-end-amount (- month)))\n(let* ((savings (floor current-amount 100)))\n(decf current-amount (* 100 savings))\n(incf total-saved (* 100 savings))))\n(return (+ current-amount (* total-saved 0.2))))))", "bug_with_line_numbers": "   1 | (defun calculate-year-end-amount (monthly-budgets)\n   2 | (let (current-amount 0)\n   3 | (total-saved 0))\n   4 | (loop for month from 1 to 12\n   5 | for budget in monthly-budgets\n   6 | do (progn\n   7 | (incf current-amount 300)\n   8 | (decf current-amount budget)\n   9 | (when (< current-amount 0)\n  10 | (return calculate-year-end-amount (- month)))\n  11 | (let* ((savings (floor current-amount 100)))\n  12 | (decf current-amount (* 100 savings))\n  13 | (incf total-saved (* 100 savings))))\n  14 | (return (+ current-amount (* total-saved 0.2))))))", "fragment_lines": [2, 10, 11, 14], "fragment_content": ["(let (current-amount 0)", "(return calculate-year-end-amount (- month)))", "(let* ((savings (floor current-amount 100)))", "(return (+ current-amount (* total-saved 0.2))))))"], "test": "(defun check ()\n(assert (equal (calculate-year-end-amount '(290 230 280 200 300 170 340 50 90 80 200 60)) -7))\n(assert (equal (calculate-year-end-amount '(100 100 100 100 100 100 100 100 100 100 100 100)) 2880.0)) ;; Assuming all savings\n(assert (equal (calculate-year-end-amount '(300 300 300 300 300 300 300 300 300 300 300 300)) 0.0)) ;; No savings\n(assert (equal (calculate-year-end-amount '(150 150 150 150 150 150 150 150 150 150 150 150)) 2160.0)) ;; Half savings\n(assert (equal (calculate-year-end-amount '(250 250 250 250 250 250 250 250 250 250 250 250)) 720.0))) ;; Runs out first month\n(check)", "line_content": {"2": ["(let (current-amount 0)"], "10,11": ["(return calculate-year-end-amount (- month)))", "(let* ((savings (floor current-amount 100)))"], "14": ["(return (+ current-amount (* total-saved 0.2))))))"]}, "instruction": "\nObserve the following faulty Clisp code and the options. The code snippets in the options are all from faulty code . Your task is to select the option(s) for error code snippet(s).\nNote:\n\n- This is an undetermined multiple-choice question, where the answer may include multiple options.\n- Please provide the answer in the form of a Python list, without returning any content other than the Python code block.. For example \n```python\n[\"A\"]\n```\n\nfaulty code:\n```\n   1 | (defun calculate-year-end-amount (monthly-budgets)\n   2 | (let (current-amount 0)\n   3 | (total-saved 0))\n   4 | (loop for month from 1 to 12\n   5 | for budget in monthly-budgets\n   6 | do (progn\n   7 | (incf current-amount 300)\n   8 | (decf current-amount budget)\n   9 | (when (< current-amount 0)\n  10 | (return calculate-year-end-amount (- month)))\n  11 | (let* ((savings (floor current-amount 100)))\n  12 | (decf current-amount (* 100 savings))\n  13 | (incf total-saved (* 100 savings))))\n  14 | (return (+ current-amount (* total-saved 0.2))))))\n```\n\noptions:\nA.    2 | ['(let (current-amount 0)']\n\nB.    7 | (incf current-amount 300)\n\nC.   10 | (return calculate-year-end-amount (- month)))\n  11 | (let* ((savings (floor current-amount 100)))\n\nD.   14 | ['(return (+ current-amount (* total-saved 0.2))))))']\n\n\n", "loc_answer": ["A", "C", "D"]}
{"question_id": "Clisp/55", "category": "Multiple", "subtype": "quadruple_bug", "level": "hard", "example": " >>> represent-as-powers-of-two(10)\n \"2+2(2()+2)\"\n >>> represent-as-powers-of-two(26)\n \"2+2(2()+2)+2(2(2))\"", "docstring": ";; This function takes a positive integer 'n' and returns its representation as a sum of powers of two. \n;; The powers are expressed in a specific format where a^b is represented as a(b), and terms are summed without spaces.\n;; Specifically, 2^0 is represented as 2()\n;; This function joins a list of strings with a given separator.", "canonical_solution": "(defun represent-as-powers-of-two (n)\n;; This function takes a positive integer 'n' and returns its representation as a sum of powers of two. \n;; The powers are expressed in a specific format where a^b is represented as a(b), and terms are summed without spaces.\n;; Specifically, 2^0 is represented as 2()\n;; Example:\n;; >>> represent-as-powers-of-two(10)\n;; \"2+2(2()+2)\"\n;; >>> represent-as-powers-of-two(26)\n;; \"2+2(2()+2)+2(2(2))\"\n\n(let ((result '()) (power 0))\n(loop while (> n 0)\ndo (progn\n(when (> (logand n 1) 0)\n(push (if (= power 1) \"2\" (format nil \"2(~a)\" (represent-as-powers-of-two power))) result))\n(setq power (+ power 1))\n(setq n (ash n -1))))\n(string-join (reverse result) \"+\")))\n(defun string-join (list separator)\n;; This function joins a list of strings with a given separator.\n(with-output-to-string (stream)\n(when list\n(write-string (first list) stream)\n(dolist (item (rest list))\n(write-string separator stream)\n(write-string item stream)))))", "buggy_code": "(defun represent-as-powers-of-two (n)\n;; This function takes a positive integer 'n' and returns its representation as a sum of powers of two. \n;; The powers are expressed in a specific format where a^b is represented as a(b), and terms are summed without spaces.\n;; Specifically, 2^0 is represented as 2()\n\n(let ((result '()) (power 0))\n(loop while (> n 0)\ndo (progn\n(when (> (and n 1) 0)\n(push (if (= power 1) \"2\" (format nil \"2(a)\" (represent-as-powers-of-two power))) result))\n(setq power (+ power 1))\n(setq n (ash n -1))))\n(string-join (reverse result) +)))\n(defun string-join (list separator)\n;; This function joins a list of strings with a given separator.\n(with-output-to-string (stream)\n(when list\n(write-string (first list) stream)\n(dolist (item (rest list))\n(write-string separator stream)\n(write-string item stream)))))", "bug_with_line_numbers": "   1 | (defun represent-as-powers-of-two (n)\n   2 | (let ((result '()) (power 0))\n   3 | (loop while (> n 0)\n   4 | do (progn\n   5 | (when (> (and n 1) 0)\n   6 | (push (if (= power 1) \"2\" (format nil \"2(a)\" (represent-as-powers-of-two power))) result))\n   7 | (setq power (+ power 1))\n   8 | (setq n (ash n -1))))\n   9 | (string-join (reverse result) +)))\n  10 | (defun string-join (list separator)\n  11 | (with-output-to-string (stream)\n  12 | (when list\n  13 | (write-string (first list) stream)\n  14 | (dolist (item (rest list))\n  15 | (write-string separator stream)\n  16 | (write-string item stream)))))", "fragment_lines": [5, 6, 8, 9], "fragment_content": ["(when (> (and n 1) 0)", "(push (if (= power 1) \"2\" (format nil \"2(a)\" (represent-as-powers-of-two power))) result))", "(setq n (ash n -1))))", "(string-join (reverse result) +)))"], "test": "(defun check ()\n(assert (equal (represent-as-powers-of-two 10) \"2+2(2()+2)\"))\n(assert (equal (represent-as-powers-of-two 26) \"2+2(2()+2)+2(2(2))\"))\n(assert (equal (represent-as-powers-of-two 1) \"2()\"))\n(assert (equal (represent-as-powers-of-two 31) \"2()+2+2(2)+2(2()+2)+2(2(2))\"))\n(assert (equal (represent-as-powers-of-two 100) \"2(2)+2(2()+2(2))+2(2+2(2))\")))\n\n(check)", "line_content": {"5,6": ["(when (> (and n 1) 0)", "(push (if (= power 1) \"2\" (format nil \"2(a)\" (represent-as-powers-of-two power))) result))"], "8,9": ["(setq n (ash n -1))))", "(string-join (reverse result) +)))"]}, "instruction": "\nObserve the following faulty Clisp code and the options. The code snippets in the options are all from faulty code . Your task is to select the option(s) for error code snippet(s).\nNote:\n\n- This is an undetermined multiple-choice question, where the answer may include multiple options.\n- Please provide the answer in the form of a Python list, without returning any content other than the Python code block.. For example \n```python\n[\"A\"]\n```\n\nfaulty code:\n```\n   1 | (defun represent-as-powers-of-two (n)\n   2 | (let ((result '()) (power 0))\n   3 | (loop while (> n 0)\n   4 | do (progn\n   5 | (when (> (and n 1) 0)\n   6 | (push (if (= power 1) \"2\" (format nil \"2(a)\" (represent-as-powers-of-two power))) result))\n   7 | (setq power (+ power 1))\n   8 | (setq n (ash n -1))))\n   9 | (string-join (reverse result) +)))\n  10 | (defun string-join (list separator)\n  11 | (with-output-to-string (stream)\n  12 | (when list\n  13 | (write-string (first list) stream)\n  14 | (dolist (item (rest list))\n  15 | (write-string separator stream)\n  16 | (write-string item stream)))))\n```\n\noptions:\nA.    2 | (let ((result '()) (power 0))\n\nB.    5 | (when (> (and n 1) 0)\n   6 | (push (if (= power 1) \"2\" (format nil \"2(a)\" (represent-as-powers-of-two power))) result))\n\nC.    8 | (setq n (ash n -1))))\n   9 | (string-join (reverse result) +)))\n\nD.   11 | (with-output-to-string (stream)\n\n\n", "loc_answer": ["B", "C"]}
{"question_id": "Clisp/56", "category": "Multiple", "subtype": "quadruple_bug", "level": "hard", "example": " >>> count-prime-sums '(1 2 3 4) 2\n 2 ; (1+2) and (3+4) are prime\n >>> count-prime-sums '(1 2 3 4 5 6) 3\n 1 ; Only (1+2+5) is prime", "docstring": ";; This function counts the number of ways to select 'k' integers from a list of 'n' integers such that their sum is a prime number.\n;; It considers all possible combinations of 'k' integers from the list and checks if their sum is prime.", "canonical_solution": "(defun count-prime-sums (numbers k)\n\n\n(count t (mapcar (lambda (comb) (is-prime (reduce '+ comb)))\n(sum-combinations numbers k))))\n(defun is-prime (n)\n(cond ((<= n 1) nil)\n((= n 2) t)\n(t (loop for i from 2 to (isqrt n) never (zerop (mod n i))))))\n\n(defun sum-combinations (lst k)\n(if (= k 0)\n'(())\n(loop for i from 0 below (length lst)\nnconc (mapcar (lambda (x) (cons (nth i lst) x))\n(sum-combinations (subseq lst (1+ i)) (1- k))))))", "buggy_code": "(defun count-prime-sums (numbers k)\n\n\n(count t (mapcar (lambda (comb) (is-prime (reduce '* comb)))\n(sum-combinations numbers k))))\n(defun is-prime (n)\n(cond ((> n 1) nil)\n((= n 2) t)\n(t (loop for i from 2 to (isqrt n) never (zerop (mod n i))))))\n\n(defun sum-combinations (lst k)\n(if (= k 0)\n'(())\n(loop for i from 1 below (length lst)\nnconc (mapcar (lambda (x) (cons (nth i lst) x))\n(sum-combinations (sublist lst (1+ i)) (1- k))))))", "bug_with_line_numbers": "   1 | (defun count-prime-sums (numbers k)\n   2 | (count t (mapcar (lambda (comb) (is-prime (reduce '* comb)))\n   3 | (sum-combinations numbers k))))\n   4 | (defun is-prime (n)\n   5 | (cond ((> n 1) nil)\n   6 | ((= n 2) t)\n   7 | (t (loop for i from 2 to (isqrt n) never (zerop (mod n i))))))\n   8 | (defun sum-combinations (lst k)\n   9 | (if (= k 0)\n  10 | '(())\n  11 | (loop for i from 1 below (length lst)\n  12 | nconc (mapcar (lambda (x) (cons (nth i lst) x))\n  13 | (sum-combinations (sublist lst (1+ i)) (1- k))))))", "fragment_lines": [2, 5, 11, 13], "fragment_content": ["(count t (mapcar (lambda (comb) (is-prime (reduce '* comb)))", "(cond ((> n 1) nil)", "(loop for i from 1 below (length lst)", "(sum-combinations (sublist lst (1+ i)) (1- k))))))"], "test": "(defun check ()\n(assert (equal (count-prime-sums '(3 7 12 19) 3) 1))\n(assert (equal (count-prime-sums '(1 2 3 4) 2) 4))\n(assert (equal (count-prime-sums '(1 2 3 4 5 6) 3) 6))\n(assert (equal (count-prime-sums '(10 20 30 40) 2) 0))\n(assert (equal (count-prime-sums '(11 13 17 19 23 29) 3) 12))) \n\n(check)", "line_content": {"2": ["(count t (mapcar (lambda (comb) (is-prime (reduce '* comb)))"], "5": ["(cond ((> n 1) nil)"], "11": ["(loop for i from 1 below (length lst)"], "13": ["(sum-combinations (sublist lst (1+ i)) (1- k))))))"]}, "instruction": "\nObserve the following faulty Clisp code and the options. The code snippets in the options are all from faulty code . Your task is to select the option(s) for error code snippet(s).\nNote:\n\n- This is an undetermined multiple-choice question, where the answer may include multiple options.\n- Please provide the answer in the form of a Python list, without returning any content other than the Python code block.. For example \n```python\n[\"A\"]\n```\n\nfaulty code:\n```\n   1 | (defun count-prime-sums (numbers k)\n   2 | (count t (mapcar (lambda (comb) (is-prime (reduce '* comb)))\n   3 | (sum-combinations numbers k))))\n   4 | (defun is-prime (n)\n   5 | (cond ((> n 1) nil)\n   6 | ((= n 2) t)\n   7 | (t (loop for i from 2 to (isqrt n) never (zerop (mod n i))))))\n   8 | (defun sum-combinations (lst k)\n   9 | (if (= k 0)\n  10 | '(())\n  11 | (loop for i from 1 below (length lst)\n  12 | nconc (mapcar (lambda (x) (cons (nth i lst) x))\n  13 | (sum-combinations (sublist lst (1+ i)) (1- k))))))\n```\n\noptions:\nA.   13 | ['(sum-combinations (sublist lst (1+ i)) (1- k))))))']\n\nB.   11 | ['(loop for i from 1 below (length lst)']\n\nC.    2 | [\"(count t (mapcar (lambda (comb) (is-prime (reduce '* comb)))\"]\n\nD.    5 | ['(cond ((> n 1) nil)']\n\n\n", "loc_answer": ["C", "D", "B", "A"]}
{"question_id": "Clisp/57", "category": "Special", "subtype": "missing_backtick", "level": "medium", "example": " >>> occurrences '(a b a d a c d c a)\n (a . 4) (c . 2) (d . 2) (b . 1)", "docstring": ";; takes a list and returns a list indicating the number of times each (eql) element appears, sorted from most common element to least common", "canonical_solution": "(defun occurrences (lst)\n\n\n(let ((result nil))\n(dolist (obj lst)\n(if (null (assoc obj result))\n(push (cons obj 1) result)\n(incf (cdr (assoc obj result)))\n))\n(sort result #'(lambda (a b) (if (> (cdr a) (cdr b)) t nil)))))", "buggy_code": "(defun occurrences (lst)\n\n\n(let ((result nil))\n(dolist (obj lst)\n(if (null (assoc obj result))\n(push (cons obj 1) result)\n(incf (cdr (assoc obj result)))\n))\n(sort result #(lambda (a b) (if (> (cdr a) (cdr b)) t nil)))))", "bug_with_line_numbers": "   1 | (defun occurrences (lst)\n   2 | (let ((result nil))\n   3 | (dolist (obj lst)\n   4 | (if (null (assoc obj result))\n   5 | (push (cons obj 1) result)\n   6 | (incf (cdr (assoc obj result)))\n   7 | ))\n   8 | (sort result #(lambda (a b) (if (> (cdr a) (cdr b)) t nil)))))", "fragment_lines": [8], "fragment_content": ["(sort result #(lambda (a b) (if (> (cdr a) (cdr b)) t nil)))))"], "test": "(defun check ()\n;; 测试 'occurrences' 函数。\n(assert (equal (occurrences '(a b a d a c d c a)) '((a . 4) (c . 2) (d . 2) (b . 1))))\n(assert (equal (occurrences '(1 2 2 3 3 3)) '((3 . 3) (2 . 2) (1 . 1))))\n(assert (equal (occurrences '(a b a)) '((a . 2) (b . 1)))))\n\n(check)", "line_content": {"8": ["(sort result #(lambda (a b) (if (> (cdr a) (cdr b)) t nil)))))"]}, "instruction": "\nObserve the following faulty Clisp code and the options. The code snippets in the options are all from faulty code . Your task is to select the option(s) for error code snippet(s).\nNote:\n\n- This is an undetermined multiple-choice question, where the answer may include multiple options.\n- Please provide the answer in the form of a Python list, without returning any content other than the Python code block.. For example \n```python\n[\"A\"]\n```\n\nfaulty code:\n```\n   1 | (defun occurrences (lst)\n   2 | (let ((result nil))\n   3 | (dolist (obj lst)\n   4 | (if (null (assoc obj result))\n   5 | (push (cons obj 1) result)\n   6 | (incf (cdr (assoc obj result)))\n   7 | ))\n   8 | (sort result #(lambda (a b) (if (> (cdr a) (cdr b)) t nil)))))\n```\n\noptions:\nA.    6 | (incf (cdr (assoc obj result)))\n\nB.    3 | (dolist (obj lst)\n\nC.    7 | ))\n\nD.    8 | ['(sort result #(lambda (a b) (if (> (cdr a) (cdr b)) t nil)))))']\n\n\n", "loc_answer": ["D"]}
{"question_id": "Clisp/58", "category": "Special", "subtype": "missing_backtick", "level": "medium", "example": " (divisible-five-digit-numbers 15)  Returns (22555 25555 28555 30000)\n (divisible-five-digit-numbers 7)  Returns a list of numbers or 'No' if no such numbers exist", "docstring": ";; Finds all five-digit numbers between 10000 and 30000 where three sub-numbers \n;; (formed by consecutive digits) are divisible by 'k'.\n;; Each sub-number consists of three consecutive digits from the original number.\n;; The function returns a list of such five-digit numbers.", "canonical_solution": "(defun divisible-five-digit-numbers (k)\n\n\n(let ((results '()))\n(loop for num from 10000 to 30000\nwhen (and (zerop (mod (parse-integer (subseq (write-to-string num) 0 3)) k))\n(zerop (mod (parse-integer (subseq (write-to-string num) 1 4)) k))\n(zerop (mod (parse-integer (subseq (write-to-string num) 2 5)) k)))\ndo (push num results))\n(if (null results)\n'No\n(nreverse results))))", "buggy_code": "(defun divisible-five-digit-numbers (k)\n\n\n(let ((results '()))\n(loop for num from 10000 to 30000\nwhen (and (zerop (mod (parse-integer (subseq (write-to-string num) 0 3)) k))\n(zerop (mod (parse-integer (subseq (write-to-string num) 1 4)) k))\n(zerop (mod (parse-integer (subseq (write-to-string num) 2 5)) k)))\ndo (push num results))\n(if (null results)\nNo\n(nreverse results))))", "bug_with_line_numbers": "   1 | (defun divisible-five-digit-numbers (k)\n   2 | (let ((results '()))\n   3 | (loop for num from 10000 to 30000\n   4 | when (and (zerop (mod (parse-integer (subseq (write-to-string num) 0 3)) k))\n   5 | (zerop (mod (parse-integer (subseq (write-to-string num) 1 4)) k))\n   6 | (zerop (mod (parse-integer (subseq (write-to-string num) 2 5)) k)))\n   7 | do (push num results))\n   8 | (if (null results)\n   9 | No\n  10 | (nreverse results))))", "fragment_lines": [9], "fragment_content": ["No"], "test": "(defun check ()\n(assert (equal (divisible-five-digit-numbers 15) '(22555 25555 28555 30000)))\n(assert (equal (divisible-five-digit-numbers 31) '(15589 18682))) ;; No such numbers exist\n(assert (equal (divisible-five-digit-numbers 999) 'No))) ;; No such numbers exist for a large divisor\n\n(check)", "line_content": {"9": ["No"]}, "instruction": "\nObserve the following faulty Clisp code and the options. The code snippets in the options are all from faulty code . Your task is to select the option(s) for error code snippet(s).\nNote:\n\n- This is an undetermined multiple-choice question, where the answer may include multiple options.\n- Please provide the answer in the form of a Python list, without returning any content other than the Python code block.. For example \n```python\n[\"A\"]\n```\n\nfaulty code:\n```\n   1 | (defun divisible-five-digit-numbers (k)\n   2 | (let ((results '()))\n   3 | (loop for num from 10000 to 30000\n   4 | when (and (zerop (mod (parse-integer (subseq (write-to-string num) 0 3)) k))\n   5 | (zerop (mod (parse-integer (subseq (write-to-string num) 1 4)) k))\n   6 | (zerop (mod (parse-integer (subseq (write-to-string num) 2 5)) k)))\n   7 | do (push num results))\n   8 | (if (null results)\n   9 | No\n  10 | (nreverse results))))\n```\n\noptions:\nA.    6 | (zerop (mod (parse-integer (subseq (write-to-string num) 2 5)) k)))\n\nB.    1 | (defun divisible-five-digit-numbers (k)\n\nC.    9 | ['No']\n\nD.    8 | (if (null results)\n\n\n", "loc_answer": ["C"]}
{"question_id": "Clisp/59", "category": "Special", "subtype": "misused_let", "level": "medium", "example": " >>> segments-intersect? 0 0 1 1 1 0 0 1\n x 0.5\n y 0.5", "docstring": ";; Define a function that accepts 8 real numbers representing the endpoints of two line segments in two-dimensional space. If the line segments do not intersect, return false, or return two values representing the x and y coordinates of the intersection point", "canonical_solution": "(defun segments-intersect? (x1 y1 x2 y2 x3 y3 x4 y4)\n\n\n(let ((denom (- (* (- x2 x1) (- y4 y3)) (* (- y2 y1) (- x4 x3)))))\n(unless (zerop denom)\n(let* ((ua (/ (- (* (- x4 x3) (- y1 y3)) (* (- y4 y3) (- x1 x3))) denom))\n(ub (/ (- (* (- x2 x1) (- y1 y3)) (* (- y2 y1) (- x1 x3))) denom))\n(x-on-segment (+ x1 (* ua (- x2 x1))))\n(y-on-segment (+ y1 (* ua (- y2 y1)))))\n(when (and (>= ua 0) (<= ua 1) (>= ub 0) (<= ub 1))\n(values x-on-segment y-on-segment))))))\n\n(defun float-near-equal (a b &optional (tolerance 1e-5))\n(<= (abs (- a b)) tolerance))", "buggy_code": "(defun segments-intersect? (x1 y1 x2 y2 x3 y3 x4 y4)\n\n\n(let ((denom (- (* (- x2 x1) (- y4 y3)) (* (- y2 y1) (- x4 x3)))))\n(unless (zerop denom)\n(let ((ua (/ (- (* (- x4 x3) (- y1 y3)) (* (- y4 y3) (- x1 x3))) denom))\n(ub (/ (- (* (- x2 x1) (- y1 y3)) (* (- y2 y1) (- x1 x3))) denom))\n(x-on-segment (+ x1 (* ua (- x2 x1))))\n(y-on-segment (+ y1 (* ua (- y2 y1)))))\n(when (and (>= ua 0) (<= ua 1) (>= ub 0) (<= ub 1))\n(values x-on-segment y-on-segment))))))\n\n(defun float-near-equal (a b &optional (tolerance 1e-5))\n(<= (abs (- a b)) tolerance))", "bug_with_line_numbers": "   1 | (defun segments-intersect? (x1 y1 x2 y2 x3 y3 x4 y4)\n   2 | (let ((denom (- (* (- x2 x1) (- y4 y3)) (* (- y2 y1) (- x4 x3)))))\n   3 | (unless (zerop denom)\n   4 | (let ((ua (/ (- (* (- x4 x3) (- y1 y3)) (* (- y4 y3) (- x1 x3))) denom))\n   5 | (ub (/ (- (* (- x2 x1) (- y1 y3)) (* (- y2 y1) (- x1 x3))) denom))\n   6 | (x-on-segment (+ x1 (* ua (- x2 x1))))\n   7 | (y-on-segment (+ y1 (* ua (- y2 y1)))))\n   8 | (when (and (>= ua 0) (<= ua 1) (>= ub 0) (<= ub 1))\n   9 | (values x-on-segment y-on-segment))))))\n  10 | (defun float-near-equal (a b &optional (tolerance 1e-5))\n  11 | (<= (abs (- a b)) tolerance))", "fragment_lines": [4], "fragment_content": ["(let ((ua (/ (- (* (- x4 x3) (- y1 y3)) (* (- y4 y3) (- x1 x3))) denom))"], "test": "(defun check ()\n(multiple-value-bind (x y) (segments-intersect? 0 0 1 1 1 0 0 1)\n(assert (and (float-near-equal x 0.5) (float-near-equal y 0.5))))\n(assert (null (segments-intersect? 0 0 1 1 2 2 3 3))))\n\n(check)", "line_content": {"4": ["(let ((ua (/ (- (* (- x4 x3) (- y1 y3)) (* (- y4 y3) (- x1 x3))) denom))"]}, "instruction": "\nObserve the following faulty Clisp code and the options. The code snippets in the options are all from faulty code . Your task is to select the option(s) for error code snippet(s).\nNote:\n\n- This is an undetermined multiple-choice question, where the answer may include multiple options.\n- Please provide the answer in the form of a Python list, without returning any content other than the Python code block.. For example \n```python\n[\"A\"]\n```\n\nfaulty code:\n```\n   1 | (defun segments-intersect? (x1 y1 x2 y2 x3 y3 x4 y4)\n   2 | (let ((denom (- (* (- x2 x1) (- y4 y3)) (* (- y2 y1) (- x4 x3)))))\n   3 | (unless (zerop denom)\n   4 | (let ((ua (/ (- (* (- x4 x3) (- y1 y3)) (* (- y4 y3) (- x1 x3))) denom))\n   5 | (ub (/ (- (* (- x2 x1) (- y1 y3)) (* (- y2 y1) (- x1 x3))) denom))\n   6 | (x-on-segment (+ x1 (* ua (- x2 x1))))\n   7 | (y-on-segment (+ y1 (* ua (- y2 y1)))))\n   8 | (when (and (>= ua 0) (<= ua 1) (>= ub 0) (<= ub 1))\n   9 | (values x-on-segment y-on-segment))))))\n  10 | (defun float-near-equal (a b &optional (tolerance 1e-5))\n  11 | (<= (abs (- a b)) tolerance))\n```\n\noptions:\nA.    9 | (values x-on-segment y-on-segment))))))\n\nB.    5 | (ub (/ (- (* (- x2 x1) (- y1 y3)) (* (- y2 y1) (- x1 x3))) denom))\n\nC.    4 | ['(let ((ua (/ (- (* (- x4 x3) (- y1 y3)) (* (- y4 y3) (- x1 x3))) denom))']\n\nD.   11 | (<= (abs (- a b)) tolerance))\n\n\n", "loc_answer": ["C"]}
{"question_id": "Clisp/60", "category": "Special", "subtype": "misused_let", "level": "medium", "example": " >>> construct-preorder \"DBEAC\" \"DEBCA\"\n \"ABCDE\"\n >>> construct-preorder \"HGFEIDBA\" \"HGFIEDBA\"\n \"ABDEFGHI\"", "docstring": ";; This function reconstructs the preorder traversal of a binary tree from its inorder and postorder traversals.\n;; The nodes of the binary tree are represented by distinct uppercase letters.\n;; It is assumed that the tree has no more than 8 nodes.", "canonical_solution": "(defun construct-preorder (inorder postorder)\n\n\n(when (and inorder postorder (not (zerop (length postorder))))\n(let* ((root (char postorder (1- (length postorder))))\n(root-pos (position root inorder)))\n(concatenate 'string\n(string root)\n(construct-preorder (subseq inorder 0 root-pos)\n(subseq postorder 0 root-pos))\n(construct-preorder (subseq inorder (1+ root-pos))\n(subseq postorder root-pos (1- (length postorder))))))))", "buggy_code": "(defun construct-preorder (inorder postorder)\n\n\n(when (and inorder postorder (not (zerop (length postorder))))\n(let ((root (char postorder (1- (length postorder))))\n(root-pos (position root inorder)))\n(concatenate 'string\n(string root)\n(construct-preorder (subseq inorder 0 root-pos)\n(subseq postorder 0 root-pos))\n(construct-preorder (subseq inorder (1+ root-pos))\n(subseq postorder root-pos (1- (length postorder))))))))", "bug_with_line_numbers": "   1 | (defun construct-preorder (inorder postorder)\n   2 | (when (and inorder postorder (not (zerop (length postorder))))\n   3 | (let ((root (char postorder (1- (length postorder))))\n   4 | (root-pos (position root inorder)))\n   5 | (concatenate 'string\n   6 | (string root)\n   7 | (construct-preorder (subseq inorder 0 root-pos)\n   8 | (subseq postorder 0 root-pos))\n   9 | (construct-preorder (subseq inorder (1+ root-pos))\n  10 | (subseq postorder root-pos (1- (length postorder))))))))", "fragment_lines": [3], "fragment_content": ["(let ((root (char postorder (1- (length postorder))))"], "test": "(defun check ()\n(assert (string= (construct-preorder \"DBEAC\" \"DEBCA\") \"ABDEC\"))\n(assert (string= (construct-preorder \"HGFEIDBA\" \"HGFIEDBA\") \"ABDEFGHI\"))\n(assert (string= (construct-preorder \"BADC\" \"BDCA\") \"ABCD\"))\n(assert (string= (construct-preorder \"FBAEDC\" \"FBEADC\") \"CDABFE\"))\n(assert (string= (construct-preorder \"A\" \"A\") \"A\")))\n\n(check)", "line_content": {"3": ["(let ((root (char postorder (1- (length postorder))))"]}, "instruction": "\nObserve the following faulty Clisp code and the options. The code snippets in the options are all from faulty code . Your task is to select the option(s) for error code snippet(s).\nNote:\n\n- This is an undetermined multiple-choice question, where the answer may include multiple options.\n- Please provide the answer in the form of a Python list, without returning any content other than the Python code block.. For example \n```python\n[\"A\"]\n```\n\nfaulty code:\n```\n   1 | (defun construct-preorder (inorder postorder)\n   2 | (when (and inorder postorder (not (zerop (length postorder))))\n   3 | (let ((root (char postorder (1- (length postorder))))\n   4 | (root-pos (position root inorder)))\n   5 | (concatenate 'string\n   6 | (string root)\n   7 | (construct-preorder (subseq inorder 0 root-pos)\n   8 | (subseq postorder 0 root-pos))\n   9 | (construct-preorder (subseq inorder (1+ root-pos))\n  10 | (subseq postorder root-pos (1- (length postorder))))))))\n```\n\noptions:\nA.    3 | ['(let ((root (char postorder (1- (length postorder))))']\n\nB.    1 | (defun construct-preorder (inorder postorder)\n\nC.    2 | (when (and inorder postorder (not (zerop (length postorder))))\n\nD.    8 | (subseq postorder 0 root-pos))\n\n\n", "loc_answer": ["A"]}
