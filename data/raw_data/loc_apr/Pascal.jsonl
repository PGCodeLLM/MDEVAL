{"question_id": "Pascal/1", "category": "Syntax", "subtype": "illegal_comment", "level": "easy", "example": "Examples:\n  var max, min: integer;\n  find_max_min(1, 2, 3, max, min);\n  Assert((max = 3) and (min = 1));", "docstring": "Determines the maximum and minimum of three distinct integers.\n\n  Parameters:\n  a, b, c (integers): Input values among which max and min are to be found.\n\n  This procedure assigns the maximum to the variable 'max', and the minimum to the variable 'min'. Since Pascal does not support returning multiple values directly, we pass parameters by reference.", "canonical_solution": "procedure find_max_min(a, b, c: integer; var max, min: integer);begin\n  if a > b then\n  begin\n    if a > c then\n    begin\n      max := a;\n      if b < c then\n        min := b\n      else\n        min := c;\n    end\n    else\n    begin\n      max := c;\n      min := b;\n    end;\n  end\n  else\n  begin\n    if b > c then\n    begin\n      max := b;\n      if a < c then\n        min := a\n      else\n        min := c;\n    end\n    else\n    begin\n      max := c;\n      if a < b then\n        min := a\n      else\n        min := b;\n    end;\n  end;\nend;", "buggy_code": "procedure find_max_min(a, b, c: integer; var max, min: integer);begin\n  if a > b then\n  begin\n    if a > c then\n    begin\n      max := a;\n      if b < c then\n        min := b\n      else\n        min := c;\n    end\n    else\n    begin\n      max := c;\n      min := b;\n    end;\n  end\n  else\n  begin\n    if b > c then\n    begin\n      max := b;\n      //judge a and c if a < c then\n        min := a\n      else\n        min := c;\n    end\n    else\n    begin\n      max := c;\n      if a < b then\n        min := a\n      else\n        min := b;\n    end;\n  end;\nend;", "bug_with_line_numbers": "   1 | procedure find_max_min(a, b, c: integer; var max, min: integer);begin\n   2 |   if a > b then\n   3 |   begin\n   4 |     if a > c then\n   5 |     begin\n   6 |       max := a;\n   7 |       if b < c then\n   8 |         min := b\n   9 |       else\n  10 |         min := c;\n  11 |     end\n  12 |     else\n  13 |     begin\n  14 |       max := c;\n  15 |       min := b;\n  16 |     end;\n  17 |   end\n  18 |   else\n  19 |   begin\n  20 |     if b > c then\n  21 |     begin\n  22 |       max := b;\n  23 |       //judge a and c if a < c then\n  24 |         min := a\n  25 |       else\n  26 |         min := c;\n  27 |     end\n  28 |     else\n  29 |     begin\n  30 |       max := c;\n  31 |       if a < b then\n  32 |         min := a\n  33 |       else\n  34 |         min := b;\n  35 |     end;\n  36 |   end;\n  37 | end;", "fragment_lines": [23], "fragment_content": ["//judge a and c if a < c then"], "test": "procedure check;\nvar\n  max, min: integer;\nbegin\n  find_max_min(1, 2, 3, max, min);\n  Assert((max = 3) and (min = 1), 'Test case 1 failed');\n\n  find_max_min(5, 3, 4, max, min);\n  Assert((max = 5) and (min = 3), 'Test case 2 failed');\n\n  find_max_min(10, -2, 7, max, min);\n  Assert((max = 10) and (min = -2), 'Test case 3 failed');\n\n  find_max_min(-1, -3, -2, max, min);\n  Assert((max = -1) and (min = -3), 'Test case 4 failed');\nend;\n\nbegin\n  check;\n  WriteLn('All tests passed.');\nend.", "instruction": "Observe the following faulty Pascal code\n```pascal\nprocedure find_max_min(a, b, c: integer; var max, min: integer);begin\n  if a > b then\n  begin\n    if a > c then\n    begin\n      max := a;\n      if b < c then\n        min := b\n      else\n        min := c;\n    end\n    else\n    begin\n      max := c;\n      min := b;\n    end;\n  end\n  else\n  begin\n    if b > c then\n    begin\n      max := b;\n      //judge a and c if a < c then\n        min := a\n      else\n        min := c;\n    end\n    else\n    begin\n      max := c;\n      if a < b then\n        min := a\n      else\n        min := b;\n    end;\n  end;\nend;\n```\nKnown, the bug code specifically exists in the following snippet:\n['//judge a and c if a < c then']\nFix bugs in the given code snippet. The complete , fixed code must be placed between ```pascal```. Do not generate any test, main,example usage or check code!\n"}
{"question_id": "Pascal/2", "category": "Syntax", "subtype": "illegal_comment", "level": "medium", "example": "Example:\n    >>> hamming_distance(1,2)\n    2", "docstring": "Calculate the Hamming distance between two integers in binary representation.\n\nParameters:\n- x (Integer): The first positive integer (x <= 1,000,000,000).\n- y (Integer): The second positive integer (y <= 1,000,000,000).\n\nReturns:\nInteger: The Hamming distance between x and y, i.e., the number of bits that \n         need to be flipped to transform x into y in binary.", "canonical_solution": "{$ASSERTIONS ON}\n\nuses\n  SysUtils;\nfunction hamming_distance(x, y: Integer): Integer;var\n  distance: Integer;\n  xor_result: Integer;\nbegin\n  distance := 0;\n  xor_result := x xor y; \n  // Count the number of bits set in xor_result\n  while xor_result <> 0 do\n  begin\n    if xor_result and 1 = 1 then\n      Inc(distance);\n    xor_result := xor_result shr 1;\n  end;\n  hamming_distance := distance;\nend;", "buggy_code": "{$ASSERTIONS ON}\n\nuses\n  SysUtils;\nfunction hamming_distance(x, y: Integer): Integer;var\n  distance: Integer;\n  xor_result: Integer;\nbegin\n  distance := 0;\n  xor_result := x xor y; \n  // Count the number of bits set in xor_result  while xor_result <> 0 do\n  begin\n    if xor_result and 1 = 1 then\n      Inc(distance);\n    xor_result := xor_result shr 1;\n  end;\n  hamming_distance := distance;\nend;", "bug_with_line_numbers": "   1 | {$ASSERTIONS ON}\n   2 | uses\n   3 |   SysUtils;\n   4 | function hamming_distance(x, y: Integer): Integer;var\n   5 |   distance: Integer;\n   6 |   xor_result: Integer;\n   7 | begin\n   8 |   distance := 0;\n   9 |   xor_result := x xor y; \n  10 |   // Count the number of bits set in xor_result  while xor_result <> 0 do\n  11 |   begin\n  12 |     if xor_result and 1 = 1 then\n  13 |       Inc(distance);\n  14 |     xor_result := xor_result shr 1;\n  15 |   end;\n  16 |   hamming_distance := distance;\n  17 | end;", "fragment_lines": [10], "fragment_content": ["// Count the number of bits set in xor_result  while xor_result <> 0 do"], "test": "procedure check;\nbegin\n  Assert(hamming_distance(1, 2) = 2, 'Test Failed: (1, 2)'); // 01 and 10 have 2 different bits\n  Assert(hamming_distance(4, 7) = 2, 'Test Failed: (4, 7)'); // 100 and 111 have 2 different bits\n  Assert(hamming_distance(25, 30) = 3, 'Test Failed: (25, 30)'); // Additional test: 11001 and 11110 have 3 different bits\n  Assert(hamming_distance(0, 0) = 0, 'Test Failed: (0, 0)'); // Additional test: Same numbers have 0 different bits\n  Assert(hamming_distance($7FFF, 0) = 15, 'Test Failed: ($7FFF, 0)'); // Additional test: Max unsigned int and 0 have 32 different bits\nend;\n\nbegin\n  check;\nend.", "instruction": "Observe the following faulty Pascal code\n```pascal\n{$ASSERTIONS ON}\n\nuses\n  SysUtils;\nfunction hamming_distance(x, y: Integer): Integer;var\n  distance: Integer;\n  xor_result: Integer;\nbegin\n  distance := 0;\n  xor_result := x xor y; \n  // Count the number of bits set in xor_result  while xor_result <> 0 do\n  begin\n    if xor_result and 1 = 1 then\n      Inc(distance);\n    xor_result := xor_result shr 1;\n  end;\n  hamming_distance := distance;\nend;\n```\nKnown, the bug code specifically exists in the following snippet:\n['// Count the number of bits set in xor_result  while xor_result <> 0 do']\nFix bugs in the given code snippet. The complete , fixed code must be placed between ```pascal```. Do not generate any test, main,example usage or check code!\n"}
{"question_id": "Pascal/3", "category": "Syntax", "subtype": "illegal_separation", "level": "easy", "example": "Examples:\n  - process_request(1) returns 1\n  - process_request(2) returns 2\n  - process_request(3) returns 6", "docstring": "Calculates the factorial of a given number N modulo 10007.\n  \n  Parameters:\n  - N (integer): An integer representing the input value (N <= 10000).\n  \n  Returns:\n  - integer: The factorial of N modulo 10007.", "canonical_solution": "{$ASSERTIONS ON}\nfunction process_request(n: integer): integer;const\n  MODULO = 10007;\nvar\n  a: array[0..10000] of integer;\n  i: integer;\nbegin\n  a[0] := 1;\n  a[1] := 1;\n  for i := 2 to 10000 do\n  begin\n    a[i] := (a[i-1] * i) mod MODULO;\n  end;\n  \n  process_request := a[n];\nend;", "buggy_code": "{$ASSERTIONS ON}\nfunction process_request(n: integer): integer;const\n  MODULO = 10007;\nvar\n  a: array[0..10000] of integer;\n  i: integer;\nbegin\n  a[0] := 1;\n  a[1] := 1;\n  for i := 2 to 10000 do;\n  begin\n    a[i] := (a[i-1] * i) mod MODULO;\n  end;\n  \n  process_request := a[n];\nend;", "bug_with_line_numbers": "   1 | {$ASSERTIONS ON}\n   2 | function process_request(n: integer): integer;const\n   3 |   MODULO = 10007;\n   4 | var\n   5 |   a: array[0..10000] of integer;\n   6 |   i: integer;\n   7 | begin\n   8 |   a[0] := 1;\n   9 |   a[1] := 1;\n  10 |   for i := 2 to 10000 do;\n  11 |   begin\n  12 |     a[i] := (a[i-1] * i) mod MODULO;\n  13 |   end;\n  14 |   process_request := a[n];\n  15 | end;", "fragment_lines": [10], "fragment_content": ["for i := 2 to 10000 do;"], "test": "procedure check;\nbegin\n  Assert(process_request(0) = 1, 'Test for N = 0 failed');\n  Assert(process_request(1) = 1, 'Test for N = 1 failed');\n  Assert(process_request(2) = 2, 'Test for N = 2 failed');\n  Assert(process_request(3) = 6, 'Test for N = 3 failed');\n  Assert(process_request(4) = 24, 'Test for N = 4 failed');\n  Assert(process_request(10) = 6266, 'Test for N = 10 failed');\n  Assert(process_request(10000) = 6991, 'Test for N = 10000 failed');\nend;\n\nbegin\n  (* Run the tests *)\n  check;\n  // WriteLn('All tests passed.');\nend.", "instruction": "Observe the following faulty Pascal code\n```pascal\n{$ASSERTIONS ON}\nfunction process_request(n: integer): integer;const\n  MODULO = 10007;\nvar\n  a: array[0..10000] of integer;\n  i: integer;\nbegin\n  a[0] := 1;\n  a[1] := 1;\n  for i := 2 to 10000 do;\n  begin\n    a[i] := (a[i-1] * i) mod MODULO;\n  end;\n  \n  process_request := a[n];\nend;\n```\nKnown, the bug code specifically exists in the following snippet:\n['for i := 2 to 10000 do;']\nFix bugs in the given code snippet. The complete , fixed code must be placed between ```pascal```. Do not generate any test, main,example usage or check code!\n"}
{"question_id": "Pascal/4", "category": "Syntax", "subtype": "illegal_separation", "level": "easy", "example": "Examples:\n  >>> hamming_distance(1,2)\n  2", "docstring": "Calculate the Hamming distance between two integers in binary representation.\n\nParameters:\n- x (Integer): The first positive integer (x <= 1,000,000,000).\n- y (Integer): The second positive integer (y <= 1,000,000,000).\n\nReturns:\nInteger: The Hamming distance between x and y, i.e., the number of bits that \n         need to be flipped to transform x into y in binary.", "canonical_solution": "{$ASSERTIONS ON}\n\nuses\n  SysUtils;\nfunction hamming_distance(x, y: Integer): Integer;var\n  distance: Integer;\n  xor_result: Integer;\nbegin\n  distance := 0;\n  xor_result := x xor y; \n  while xor_result <> 0 do\n  begin\n    if xor_result and 1 = 1 then\n      Inc(distance);\n    xor_result := xor_result shr 1;\n  end;\n  hamming_distance := distance;\nend;", "buggy_code": "{$ASSERTIONS ON}\n\nuses\n  SysUtils;\nfunction hamming_distance(x, y: Integer): Integer;var\n  distance: Integer;\n  xor_result: Integer;\nbegin\n  distance := 0;\n  xor_result := x xor y; \n  while xor_result <> 0 do\n  begin\n    if xor_result and 1 = 1 then\n      Inc(distance)\n    xor_result := xor_result shr 1;\n  end;\n  hamming_distance := distance;\nend;", "bug_with_line_numbers": "   1 | {$ASSERTIONS ON}\n   2 | uses\n   3 |   SysUtils;\n   4 | function hamming_distance(x, y: Integer): Integer;var\n   5 |   distance: Integer;\n   6 |   xor_result: Integer;\n   7 | begin\n   8 |   distance := 0;\n   9 |   xor_result := x xor y; \n  10 |   while xor_result <> 0 do\n  11 |   begin\n  12 |     if xor_result and 1 = 1 then\n  13 |       Inc(distance)\n  14 |     xor_result := xor_result shr 1;\n  15 |   end;\n  16 |   hamming_distance := distance;\n  17 | end;", "fragment_lines": [13], "fragment_content": ["Inc(distance)"], "test": "procedure check;\nbegin\n  Assert(hamming_distance(1, 2) = 2, 'Test Failed: (1, 2)'); // 01 and 10 have 2 different bits\n  Assert(hamming_distance(4, 7) = 2, 'Test Failed: (4, 7)'); // 100 and 111 have 2 different bits\n  Assert(hamming_distance(25, 30) = 3, 'Test Failed: (25, 30)'); // Additional test: 11001 and 11110 have 3 different bits\n  Assert(hamming_distance(0, 0) = 0, 'Test Failed: (0, 0)'); // Additional test: Same numbers have 0 different bits\n  Assert(hamming_distance($7FFF, 0) = 15, 'Test Failed: ($7FFF, 0)'); // Additional test: Max unsigned int and 0 have 32 different bits\nend;\n\nbegin\n  check;\nend.", "instruction": "Observe the following faulty Pascal code\n```pascal\n{$ASSERTIONS ON}\n\nuses\n  SysUtils;\nfunction hamming_distance(x, y: Integer): Integer;var\n  distance: Integer;\n  xor_result: Integer;\nbegin\n  distance := 0;\n  xor_result := x xor y; \n  while xor_result <> 0 do\n  begin\n    if xor_result and 1 = 1 then\n      Inc(distance)\n    xor_result := xor_result shr 1;\n  end;\n  hamming_distance := distance;\nend;\n```\nKnown, the bug code specifically exists in the following snippet:\n['Inc(distance)']\nFix bugs in the given code snippet. The complete , fixed code must be placed between ```pascal```. Do not generate any test, main,example usage or check code!\n"}
{"question_id": "Pascal/5", "category": "Syntax", "subtype": "misused ==and=", "level": "easy", "example": "* Example usage:\n * >>> calculate_even_sum([1, 4, 3, 2, 5], 5)\n * 6", "docstring": "* Calculate the sum of even numbers in a given list.\n * Parameters:\n * - numbers: An array of integers.\n * - size: The number of elements in the array.\n * Returns:\n * The sum of even numbers in the input array.", "canonical_solution": "{$ASSERTIONS ON}\nfunction calculate_even_sum(numbers: array of Integer; size: Integer): Integer;var\n  i, ans: Integer;\nbegin\n  ans := 0;\n  for i := 0 to size - 1 do\n  begin\n    if (numbers[i] mod 2) = 0 then\n    begin\n      ans := ans + numbers[i];\n    end;\n  end;\n  calculate_even_sum := ans;\nend;", "buggy_code": "{$ASSERTIONS ON}\nfunction calculate_even_sum(numbers: array of Integer; size: Integer): Integer;var\n  i, ans: Integer;\nbegin\n  ans := 0;\n  for i := 0 to size - 1 do\n  begin\n    if (numbers[i] mod 2) == 0 then\n    begin\n      ans := ans + numbers[i];\n    end;\n  end;\n  calculate_even_sum := ans;\nend;", "bug_with_line_numbers": "   1 | {$ASSERTIONS ON}\n   2 | function calculate_even_sum(numbers: array of Integer; size: Integer): Integer;var\n   3 |   i, ans: Integer;\n   4 | begin\n   5 |   ans := 0;\n   6 |   for i := 0 to size - 1 do\n   7 |   begin\n   8 |     if (numbers[i] mod 2) == 0 then\n   9 |     begin\n  10 |       ans := ans + numbers[i];\n  11 |     end;\n  12 |   end;\n  13 |   calculate_even_sum := ans;\n  14 | end;", "fragment_lines": [8], "fragment_content": ["if (numbers[i] mod 2) == 0 then"], "test": "procedure check;\nvar\n  sample1: array[0..4] of Integer = (1, 4, 3, 2, 5);\n  sample2: array[0..3] of Integer = (2, 2, 0, 0);\n  sample3: array[0..2] of Integer = (7, 11, 19);\n  sample4: array[0..4] of Integer = (12, 14, 16, 18, 20);\nbegin\n  Assert(calculate_even_sum(sample1, 5) = 6);\n  Assert(calculate_even_sum(sample2, 4) = 4);\n  Assert(calculate_even_sum(sample3, 3) = 0);\n  Assert(calculate_even_sum(sample4, 5) = 12 + 14 + 16 + 18 + 20);\nend;\n\nbegin\n  check;\nend.", "instruction": "Observe the following faulty Pascal code\n```pascal\n{$ASSERTIONS ON}\nfunction calculate_even_sum(numbers: array of Integer; size: Integer): Integer;var\n  i, ans: Integer;\nbegin\n  ans := 0;\n  for i := 0 to size - 1 do\n  begin\n    if (numbers[i] mod 2) == 0 then\n    begin\n      ans := ans + numbers[i];\n    end;\n  end;\n  calculate_even_sum := ans;\nend;\n```\nKnown, the bug code specifically exists in the following snippet:\n['if (numbers[i] mod 2) == 0 then']\nFix bugs in the given code snippet. The complete , fixed code must be placed between ```pascal```. Do not generate any test, main,example usage or check code!\n"}
{"question_id": "Pascal/6", "category": "Syntax", "subtype": "unclosed_parentheses", "level": "easy", "example": "Examples:\n    >>> calculate_triangle_area(3, 5, 4)\n    6.00", "docstring": "Calculates the area of a triangle given the lengths of its three sides.\n\nParameters:\n- a (real): Length of side 'a'.\n- b (real): Length of side 'b'.\n- c (real): Length of side 'c'.\n\nReturns:\n- real: If the sides can form a triangle, returns the calculated area rounded to 2 decimal places.\n         Otherwise, returns -1 indicating that the sides do not form a triangle.", "canonical_solution": "{$ASSERTIONS ON}\n\nuses \n  Math, SysUtils;\nfunction calculate_triangle_area(a, b, c: real): real;\nvar\n  s: real;begin\n  if (a + b > c) and (a + c > b) and (b + c > a) then\n  begin\n    s := (a + b + c) / 2;\n    calculate_triangle_area := sqrt(s * (s - a) * (s - b) * (s - c));\n  end\n  else\n    calculate_triangle_area := -1; (* Not a triangle *)\nend;", "buggy_code": "{$ASSERTIONS ON}\n\nuses \n  Math, SysUtils;\nfunction calculate_triangle_area(a, b, c: real): real;\nvar\n  s: real;begin\n  if (a + b > c) and (a + c > b) and (b + c > a) then\n  begin\n    s := (a + b + c) / 2;\n    calculate_triangle_area := sqrt(s * (s - a) * (s - b) * (s - c);\n  end\n  else\n    calculate_triangle_area := -1; (* Not a triangle *)\nend;", "bug_with_line_numbers": "   1 | {$ASSERTIONS ON}\n   2 | uses \n   3 |   Math, SysUtils;\n   4 | function calculate_triangle_area(a, b, c: real): real;\n   5 | var\n   6 |   s: real;begin\n   7 |   if (a + b > c) and (a + c > b) and (b + c > a) then\n   8 |   begin\n   9 |     s := (a + b + c) / 2;\n  10 |     calculate_triangle_area := sqrt(s * (s - a) * (s - b) * (s - c);\n  11 |   end\n  12 |   else\n  13 |     calculate_triangle_area := -1; (* Not a triangle *)\n  14 | end;", "fragment_lines": [10], "fragment_content": ["calculate_triangle_area := sqrt(s * (s - a) * (s - b) * (s - c);"], "test": "procedure check;\nvar\n  area: real;\nbegin\n  (* Triangle with sides 3, 5, 4 should return area 6 *)\n  area := calculate_triangle_area(3, 5, 4);\n  Assert(abs(area - 6) < 1e-6);\n\n  (* Not a triangle with sides 1, 1, 4 should return -1 *)\n  area := calculate_triangle_area(1, 1, 4);\n  Assert(area = -1);\n\n  (* Triangle with sides 7, 24, 25 should return area 84 *)\n  area := calculate_triangle_area(7, 24, 25);\n  Assert(abs(area - 84) < 1e-6);\n\n  (* Triangle with sides 10.5, 6.2, 7.3 should return a calculated area *)\n  area := calculate_triangle_area(10.5, 6.2, 7.3);\n  (* For precision issues, we test if the calculated area is close enough to the expected value *)\n  Assert(abs(area - 22.15) < 1e-2);\n  \nend;\n\n(* Main *)\nbegin\n  check;\nend.", "instruction": "Observe the following faulty Pascal code\n```pascal\n{$ASSERTIONS ON}\n\nuses \n  Math, SysUtils;\nfunction calculate_triangle_area(a, b, c: real): real;\nvar\n  s: real;begin\n  if (a + b > c) and (a + c > b) and (b + c > a) then\n  begin\n    s := (a + b + c) / 2;\n    calculate_triangle_area := sqrt(s * (s - a) * (s - b) * (s - c);\n  end\n  else\n    calculate_triangle_area := -1; (* Not a triangle *)\nend;\n```\nKnown, the bug code specifically exists in the following snippet:\n['calculate_triangle_area := sqrt(s * (s - a) * (s - b) * (s - c);']\nFix bugs in the given code snippet. The complete , fixed code must be placed between ```pascal```. Do not generate any test, main,example usage or check code!\n"}
{"question_id": "Pascal/7", "category": "Syntax", "subtype": "unclosed_parentheses", "level": "medium", "example": "Examples:\n    >>> countPowerNumbers(99, 1)\n    99", "docstring": "Given two positive integers n and k, find the number of positive integers x,\nwhere 1 <= x <= n, that can be expressed as x = a^b with a and b being positive\nintegers and b >= k. Different legal representations of the same number are counted\nonly once.", "canonical_solution": "function countPowerNumbers(n, k: integer): integer;var\n  count, x, i, m: integer;\n  t: int64;\n  mp: array of boolean;\nbegin\n  count := 0;\n  x := 0;\n  SetLength(mp, n + 1);\n  i := 2;\n  while i * i * i <= n do\n  begin\n    t := i * i;\n    m := 2;\n    while t <= n div i do\n    begin\n      t := t * i;\n      Inc(m);\n      if (m < k) or (mp[t]) then\n        continue;\n\n      if trunc(sqrt(t)) * trunc(sqrt(t)) = t then\n        Inc(x);\n\n      mp[t] := true;\n      Inc(count);\n    end;\n    i := i + 1;\n  end;\n\n  if k = 1 then\n  begin\n    count := n;\n  end\n  else if k >= 3 then\n  begin\n    count := count + 1;\n  end\n  else\n  begin\n    count := count + trunc(sqrt(n)) - x;\n  end;\n\n  countPowerNumbers := count;\nend;", "buggy_code": "function countPowerNumbers(n, k: integer): integer;var\n  count, x, i, m: integer;\n  t: int64;\n  mp: array of boolean;\nbegin\n  count := 0;\n  x := 0;\n  SetLength(mp, n + 1);\n  i := 2;\n  while i * i * i <= n do\n  begin\n    t := i * i;\n    m := 2;\n    while t <= n div i do\n    begin\n      t := t * i;\n      Inc(m);\n      if (m < k) or (mp[t]) then\n        continue;\n\n      if trunc(sqrt(t)) * trunc(sqrt(t) = t then\n        Inc(x);\n\n      mp[t] := true;\n      Inc(count);\n    end;\n    i := i + 1;\n  end;\n\n  if k = 1 then\n  begin\n    count := n;\n  end\n  else if k >= 3 then\n  begin\n    count := count + 1;\n  end\n  else\n  begin\n    count := count + trunc(sqrt(n)) - x;\n  end;\n\n  countPowerNumbers := count;\nend;", "bug_with_line_numbers": "   1 | function countPowerNumbers(n, k: integer): integer;var\n   2 |   count, x, i, m: integer;\n   3 |   t: int64;\n   4 |   mp: array of boolean;\n   5 | begin\n   6 |   count := 0;\n   7 |   x := 0;\n   8 |   SetLength(mp, n + 1);\n   9 |   i := 2;\n  10 |   while i * i * i <= n do\n  11 |   begin\n  12 |     t := i * i;\n  13 |     m := 2;\n  14 |     while t <= n div i do\n  15 |     begin\n  16 |       t := t * i;\n  17 |       Inc(m);\n  18 |       if (m < k) or (mp[t]) then\n  19 |         continue;\n  20 |       if trunc(sqrt(t)) * trunc(sqrt(t) = t then\n  21 |         Inc(x);\n  22 |       mp[t] := true;\n  23 |       Inc(count);\n  24 |     end;\n  25 |     i := i + 1;\n  26 |   end;\n  27 |   if k = 1 then\n  28 |   begin\n  29 |     count := n;\n  30 |   end\n  31 |   else if k >= 3 then\n  32 |   begin\n  33 |     count := count + 1;\n  34 |   end\n  35 |   else\n  36 |   begin\n  37 |     count := count + trunc(sqrt(n)) - x;\n  38 |   end;\n  39 |   countPowerNumbers := count;\n  40 | end;", "fragment_lines": [20], "fragment_content": ["if trunc(sqrt(t)) * trunc(sqrt(t) = t then"], "test": "procedure check;\nbegin\n  Assert(countPowerNumbers(99, 1) = 99);\n  Assert(countPowerNumbers(99, 3) = 7);\n  Assert(countPowerNumbers(99, 2) = 12);\n  Assert(countPowerNumbers(10, 1) = 10);\n  Assert(countPowerNumbers(10, 2) = 4);\n  Assert(countPowerNumbers(500, 1) = 500);\n  Assert(countPowerNumbers(500, 2) = 30);\n  Assert(countPowerNumbers(500, 3) = 13);\n  Assert(countPowerNumbers(1000, 1) = 1000);\n  Assert(countPowerNumbers(1000, 2) = 41);\n  Assert(countPowerNumbers(1000, 3) = 17);\n  Assert(countPowerNumbers(1000, 93) = 1);\n  Assert(countPowerNumbers(50, 2) = 10);\n  Assert(countPowerNumbers(50, 3) = 5);\n  Assert(countPowerNumbers(2, 3) = 1);\nend;\n\nbegin\n  check;\nend.", "instruction": "Observe the following faulty Pascal code\n```pascal\nfunction countPowerNumbers(n, k: integer): integer;var\n  count, x, i, m: integer;\n  t: int64;\n  mp: array of boolean;\nbegin\n  count := 0;\n  x := 0;\n  SetLength(mp, n + 1);\n  i := 2;\n  while i * i * i <= n do\n  begin\n    t := i * i;\n    m := 2;\n    while t <= n div i do\n    begin\n      t := t * i;\n      Inc(m);\n      if (m < k) or (mp[t]) then\n        continue;\n\n      if trunc(sqrt(t)) * trunc(sqrt(t) = t then\n        Inc(x);\n\n      mp[t] := true;\n      Inc(count);\n    end;\n    i := i + 1;\n  end;\n\n  if k = 1 then\n  begin\n    count := n;\n  end\n  else if k >= 3 then\n  begin\n    count := count + 1;\n  end\n  else\n  begin\n    count := count + trunc(sqrt(n)) - x;\n  end;\n\n  countPowerNumbers := count;\nend;\n```\nKnown, the bug code specifically exists in the following snippet:\n['if trunc(sqrt(t)) * trunc(sqrt(t) = t then']\nFix bugs in the given code snippet. The complete , fixed code must be placed between ```pascal```. Do not generate any test, main,example usage or check code!\n"}
{"question_id": "Pascal/8", "category": "Syntax", "subtype": "unclosed_parentheses", "level": "easy", "example": "Example:\n    >>> expectedCuts(3, 3, 4)\n    3", "docstring": "Given a rectangle paper of size n x m placed on a plane Cartesian coordinate system with its bottom-left corner at (0,0) and top-right corner at (n,m), \ncalculate the expected number of operations to cut the paper so that the remaining area is less than k. \nIn each operation, a randomly chosen line parallel to the axes passes through points with Int64 coordinates and cuts the paper, \ndiscarding the bottom or right part of the paper along this line. The answer should be modulo 10^9+7.", "canonical_solution": "function expectedCuts(n, m: Int64; k: Int64): Int64;const\n  MD = 1000000007;\nvar\n  vv: array[1..200001] of Int64; \n  i, j: Int64;\n  ans: Int64;\n\nbegin\n  vv[1] := 1;\n  for i := 2 to High(vv) do\n    vv[i] := (Int64(vv[i - MD mod i]) * (MD div i + 1)) mod MD;\n\n  if k > Int64(n) * m then\n  begin\n    expectedCuts := 0;\n    Exit;\n  end;\n\n  ans := 1;\n  for i := Int64((k + m - 1) div m) to n - 1 do\n    ans := (ans + vv[i + Int64((k + Int64(i) - 1) div Int64(i)) - 1]) mod MD;\n  for j := Int64((k + n - 1) div n) to m - 1 do\n    ans := (ans + vv[Int64((k + Int64(j) - 1) div Int64(j)) + j - 1]) mod MD;\n\n  expectedCuts := ans;\nend;", "buggy_code": "function expectedCuts(n, m: Int64; k: Int64): Int64;const\n  MD = 1000000007;\nvar\n  vv: array[1..200001] of Int64;\n  i, j: Int64;\n  ans: Int64;\n\nbegin\n  vv[1] := 1;\n  for i := 2 to High(vv) do\n    vv[i] := (Int64(vv[i - MD mod i]) * (MD div i + 1)) mod MD;\n\n  if k > Int64(n) * m then\n  begin\n    expectedCuts := 0;\n    Exit;\n  end;\n\n  ans := 1;\n  for i := Int64((k + m - 1) div m) to n - 1 do\n    ans := (ans + vv[i + Int64((k + Int64(i) - 1) div Int64(i) - 1]) mod MD;\n  for j := Int64((k + n - 1) div n) to m - 1 do\n    ans := (ans + vv[Int64((k + Int64(j) - 1) div Int64(j)) + j - 1]) mod MD;\n\n  expectedCuts := ans;\nend;", "bug_with_line_numbers": "   1 | function expectedCuts(n, m: Int64; k: Int64): Int64;const\n   2 |   MD = 1000000007;\n   3 | var\n   4 |   vv: array[1..200001] of Int64;\n   5 |   i, j: Int64;\n   6 |   ans: Int64;\n   7 | begin\n   8 |   vv[1] := 1;\n   9 |   for i := 2 to High(vv) do\n  10 |     vv[i] := (Int64(vv[i - MD mod i]) * (MD div i + 1)) mod MD;\n  11 |   if k > Int64(n) * m then\n  12 |   begin\n  13 |     expectedCuts := 0;\n  14 |     Exit;\n  15 |   end;\n  16 |   ans := 1;\n  17 |   for i := Int64((k + m - 1) div m) to n - 1 do\n  18 |     ans := (ans + vv[i + Int64((k + Int64(i) - 1) div Int64(i) - 1]) mod MD;\n  19 |   for j := Int64((k + n - 1) div n) to m - 1 do\n  20 |     ans := (ans + vv[Int64((k + Int64(j) - 1) div Int64(j)) + j - 1]) mod MD;\n  21 |   expectedCuts := ans;\n  22 | end;", "fragment_lines": [18], "fragment_content": ["ans := (ans + vv[i + Int64((k + Int64(i) - 1) div Int64(i) - 1]) mod MD;"], "test": "procedure check;\nbegin\n  Assert(expectedCuts(2, 4, 10) = 0);\n  Assert(expectedCuts(2, 4, 8) = 1);\n  Assert(expectedCuts(2, 4, 2) = 833333342);\n  Assert(expectedCuts(2, 4, 6) = 250000003);\n  Assert(expectedCuts(3, 3, 4) = 666666673);\n  Assert(expectedCuts(5, 5, 12) = 666666673);\n  Assert(expectedCuts(6, 7, 20) = 722222229);\n  Assert(expectedCuts(8, 8, 30) = 72727275);\n  Assert(expectedCuts(10, 10, 50) = 714285721);\n  Assert(expectedCuts(1, 10, 5) = 945634929);\n  Assert(expectedCuts(10, 1, 5) = 945634929);\nend;\n\nbegin\n  check;\nend.", "instruction": "Observe the following faulty Pascal code\n```pascal\nfunction expectedCuts(n, m: Int64; k: Int64): Int64;const\n  MD = 1000000007;\nvar\n  vv: array[1..200001] of Int64;\n  i, j: Int64;\n  ans: Int64;\n\nbegin\n  vv[1] := 1;\n  for i := 2 to High(vv) do\n    vv[i] := (Int64(vv[i - MD mod i]) * (MD div i + 1)) mod MD;\n\n  if k > Int64(n) * m then\n  begin\n    expectedCuts := 0;\n    Exit;\n  end;\n\n  ans := 1;\n  for i := Int64((k + m - 1) div m) to n - 1 do\n    ans := (ans + vv[i + Int64((k + Int64(i) - 1) div Int64(i) - 1]) mod MD;\n  for j := Int64((k + n - 1) div n) to m - 1 do\n    ans := (ans + vv[Int64((k + Int64(j) - 1) div Int64(j)) + j - 1]) mod MD;\n\n  expectedCuts := ans;\nend;\n```\nKnown, the bug code specifically exists in the following snippet:\n['ans := (ans + vv[i + Int64((k + Int64(i) - 1) div Int64(i) - 1]) mod MD;']\nFix bugs in the given code snippet. The complete , fixed code must be placed between ```pascal```. Do not generate any test, main,example usage or check code!\n"}
{"question_id": "Pascal/9", "category": "Syntax", "subtype": "misused ==and=", "level": "easy", "example": "Examples:\n  var max, min: integer;\n  find_max_min(1, 2, 3, max, min);\n  Assert((max = 3) and (min = 1));", "docstring": "Determines the maximum and minimum of three distinct integers.\n\n  Parameters:\n  a, b, c (integers): Input values among which max and min are to be found.\n\n  This procedure assigns the maximum to the variable 'max', and the minimum to the variable 'min'. Since Pascal does not support returning multiple values directly, we pass parameters by reference.", "canonical_solution": "procedure find_max_min(a, b, c: integer; var max, min: integer);begin\n  if a > b then\n  begin\n    if a > c then\n    begin\n      max := a;\n      if b < c then\n        min := b\n      else\n        min := c;\n    end\n    else\n    begin\n      max := c;\n      min := b;\n    end;\n  end\n  else\n  begin\n    if b > c then\n    begin\n      max := b;\n      if a < c then\n        min := a\n      else\n        min := c;\n    end\n    else\n    begin\n      max := c;\n      if a < b then\n        min := a\n      else\n        min := b;\n    end;\n  end;\nend;", "buggy_code": "procedure find_max_min(a, b, c: integer; var max, min: integer);begin\n  if a > b then\n  begin\n    if a > c then\n    begin\n      max := a;\n      if b < c then\n        min := b\n      else\n        min := c;\n    end\n    else\n    begin\n      max := c;\n      min := b;\n    end;\n  end\n  else\n  begin\n    if b > c then\n    begin\n      max := b;\n      if a < c then\n        min := a\n      else\n        min := c;\n    end\n    else\n    begin\n      max = c;\n      if a < b then\n        min = a\n      else\n        min = b;\n    end;\n  end;\nend;", "bug_with_line_numbers": "   1 | procedure find_max_min(a, b, c: integer; var max, min: integer);begin\n   2 |   if a > b then\n   3 |   begin\n   4 |     if a > c then\n   5 |     begin\n   6 |       max := a;\n   7 |       if b < c then\n   8 |         min := b\n   9 |       else\n  10 |         min := c;\n  11 |     end\n  12 |     else\n  13 |     begin\n  14 |       max := c;\n  15 |       min := b;\n  16 |     end;\n  17 |   end\n  18 |   else\n  19 |   begin\n  20 |     if b > c then\n  21 |     begin\n  22 |       max := b;\n  23 |       if a < c then\n  24 |         min := a\n  25 |       else\n  26 |         min := c;\n  27 |     end\n  28 |     else\n  29 |     begin\n  30 |       max = c;\n  31 |       if a < b then\n  32 |         min = a\n  33 |       else\n  34 |         min = b;\n  35 |     end;\n  36 |   end;\n  37 | end;", "fragment_lines": [30, 32, 34], "fragment_content": ["max = c;", "min = a", "min = b;"], "test": "procedure check;\nvar\n  max, min: integer;\nbegin\n  find_max_min(1, 2, 3, max, min);\n  Assert((max = 3) and (min = 1), 'Test case 1 failed');\n\n  find_max_min(5, 3, 4, max, min);\n  Assert((max = 5) and (min = 3), 'Test case 2 failed');\n\n  find_max_min(10, -2, 7, max, min);\n  Assert((max = 10) and (min = -2), 'Test case 3 failed');\n\n  find_max_min(-1, -3, -2, max, min);\n  Assert((max = -1) and (min = -3), 'Test case 4 failed');\nend;\n\nbegin\n  check;\n  WriteLn('All tests passed.');\nend.", "instruction": "Observe the following faulty Pascal code\n```pascal\nprocedure find_max_min(a, b, c: integer; var max, min: integer);begin\n  if a > b then\n  begin\n    if a > c then\n    begin\n      max := a;\n      if b < c then\n        min := b\n      else\n        min := c;\n    end\n    else\n    begin\n      max := c;\n      min := b;\n    end;\n  end\n  else\n  begin\n    if b > c then\n    begin\n      max := b;\n      if a < c then\n        min := a\n      else\n        min := c;\n    end\n    else\n    begin\n      max = c;\n      if a < b then\n        min = a\n      else\n        min = b;\n    end;\n  end;\nend;\n```\nKnown, the bug code specifically exists in the following snippet:\n['max = c;', 'min = a', 'min = b;']\nFix bugs in the given code snippet. The complete , fixed code must be placed between ```pascal```. Do not generate any test, main,example usage or check code!\n"}
{"question_id": "Pascal/10", "category": "Syntax", "subtype": "misused ==and=", "level": "easy", "example": "Examples:\n  - process_request(1) returns 1\n  - process_request(2) returns 2\n  - process_request(3) returns 6", "docstring": "Calculates the factorial of a given number N modulo 10007.\n  \n  Parameters:\n  - N (integer): An integer representing the input value (N <= 10000).\n  \n  Returns:\n  - integer: The factorial of N modulo 10007.", "canonical_solution": "function process_request(n: integer): integer;const\n  MODULO = 10007;\nvar\n  a: array[0..10000] of integer;\n  i: integer;\nbegin\n  a[0] := 1;\n  a[1] := 1;\n  for i := 2 to 10000 do\n  begin\n    a[i] := (a[i-1] * i) mod MODULO;\n  end;\n  \n  process_request := a[n];\nend;", "buggy_code": "function process_request(n: integer): integer;const\n  MODULO = 10007;\nvar\n  a: array[0..10000] of integer;\n  i: integer;\nbegin\n  a[0] := 1;\n  a[1] := 1;\n  for i = 2 to 10000 do\n  begin\n    a[i] := (a[i-1] * i) mod MODULO;\n  end;\n  \n  process_request := a[n];\nend;", "bug_with_line_numbers": "   1 | function process_request(n: integer): integer;const\n   2 |   MODULO = 10007;\n   3 | var\n   4 |   a: array[0..10000] of integer;\n   5 |   i: integer;\n   6 | begin\n   7 |   a[0] := 1;\n   8 |   a[1] := 1;\n   9 |   for i = 2 to 10000 do\n  10 |   begin\n  11 |     a[i] := (a[i-1] * i) mod MODULO;\n  12 |   end;\n  13 |   process_request := a[n];\n  14 | end;", "fragment_lines": [9], "fragment_content": ["for i = 2 to 10000 do"], "test": "procedure check;\nbegin\n  Assert(process_request(0) = 1, 'Test for N = 0 failed');\n  Assert(process_request(1) = 1, 'Test for N = 1 failed');\n  Assert(process_request(2) = 2, 'Test for N = 2 failed');\n  Assert(process_request(3) = 6, 'Test for N = 3 failed');\n  Assert(process_request(4) = 24, 'Test for N = 4 failed');\n  Assert(process_request(10) = 6266, 'Test for N = 10 failed');\n  Assert(process_request(10000) = 6991, 'Test for N = 10000 failed');\nend;\n\nbegin\n  (* Run the tests *)\n  check;\n  // WriteLn('All tests passed.');\nend.", "instruction": "Observe the following faulty Pascal code\n```pascal\nfunction process_request(n: integer): integer;const\n  MODULO = 10007;\nvar\n  a: array[0..10000] of integer;\n  i: integer;\nbegin\n  a[0] := 1;\n  a[1] := 1;\n  for i = 2 to 10000 do\n  begin\n    a[i] := (a[i-1] * i) mod MODULO;\n  end;\n  \n  process_request := a[n];\nend;\n```\nKnown, the bug code specifically exists in the following snippet:\n['for i = 2 to 10000 do']\nFix bugs in the given code snippet. The complete , fixed code must be placed between ```pascal```. Do not generate any test, main,example usage or check code!\n"}
{"question_id": "Pascal/11", "category": "Syntax", "subtype": "misused ==and=", "level": "easy", "example": "Example usage:\n    Is_Square(1, [9]) should return true (1 in Pascal), because 9 is a perfect square.", "docstring": "The task is to determine if it is possible to assemble the wooden squares from n buckets,\nwhere each bucket contains a number of squares with a side length of 1, into a single larger square.\nThe function receives the length of the list and an array of numbers as input.", "canonical_solution": "{$ASSERTIONS ON}\n\nuses\n  Math, SysUtils;\nfunction Is_Square(length: integer; const squares: array of integer): boolean;var\n  sum: Int64;\n  root, i: integer;\nbegin\n  sum := 0;\n  for i := 0 to length - 1 do\n  begin\n    sum := sum + squares[i];\n  end;\n  root := Trunc(Sqrt(sum));\n  Is_Square := (root * root = sum);\nend;", "buggy_code": "{$ASSERTIONS ON}\n\nuses\n  Math, SysUtils;\nfunction Is_Square(length: integer; const squares: array of integer): boolean;var\n  sum: Int64;\n  root, i: integer;\nbegin\n  sum := 0;\n  for i := 0 to length - 1 do\n  begin\n    sum := sum + squares[i];\n  end;\n  root := Trunc(Sqrt(sum));\n  Is_Square := (root * root := sum);\nend;", "bug_with_line_numbers": "   1 | {$ASSERTIONS ON}\n   2 | uses\n   3 |   Math, SysUtils;\n   4 | function Is_Square(length: integer; const squares: array of integer): boolean;var\n   5 |   sum: Int64;\n   6 |   root, i: integer;\n   7 | begin\n   8 |   sum := 0;\n   9 |   for i := 0 to length - 1 do\n  10 |   begin\n  11 |     sum := sum + squares[i];\n  12 |   end;\n  13 |   root := Trunc(Sqrt(sum));\n  14 |   Is_Square := (root * root := sum);\n  15 | end;", "fragment_lines": [14], "fragment_content": ["Is_Square := (root * root := sum);"], "test": "procedure check;\nbegin\n  Assert(Is_Square(1, [9]) = true);\n  Assert(Is_Square(2, [14, 2]) = true);\n  Assert(Is_Square(2, [7, 7]) = false);\n  Assert(Is_Square(7, [1, 2, 3, 4, 5, 6, 7]) = false);\n  Assert(Is_Square(6, [1, 3, 5, 7, 9, 11]) = true);\n  Assert(Is_Square(4, [2, 2, 2, 2]) = false);\n  Assert(Is_Square(3, [4, 5, 6]) = false);\n  Assert(Is_Square(4, [16, 9, 4, 1]) = false);\n  Assert(Is_Square(5, [1, 1, 1, 1, 1]) = false);\n  Assert(Is_Square(2, [25, 25]) = false);\n  Assert(Is_Square(3, [10, 10, 5]) = true);\nend;\n\nbegin\n  check;\nend.", "instruction": "Observe the following faulty Pascal code\n```pascal\n{$ASSERTIONS ON}\n\nuses\n  Math, SysUtils;\nfunction Is_Square(length: integer; const squares: array of integer): boolean;var\n  sum: Int64;\n  root, i: integer;\nbegin\n  sum := 0;\n  for i := 0 to length - 1 do\n  begin\n    sum := sum + squares[i];\n  end;\n  root := Trunc(Sqrt(sum));\n  Is_Square := (root * root := sum);\nend;\n```\nKnown, the bug code specifically exists in the following snippet:\n['Is_Square := (root * root := sum);']\nFix bugs in the given code snippet. The complete , fixed code must be placed between ```pascal```. Do not generate any test, main,example usage or check code!\n"}
{"question_id": "Pascal/12", "category": "Syntax", "subtype": "misused ==and=", "level": "easy", "example": "Example:\n    >>> maxModeSum(3, [1, 2, 3])\n    Should return 17\n    An example sequence that reaches this maximum value is (3,2,3,1,2,2).", "docstring": "Given n positive integers representing the count of each number from 1 to n, \nfind the maximum sum of the mode for all prefixes of a sequence constructed from these numbers. \nThe mode is the largest number among the most frequent elements in a sequence.", "canonical_solution": "function maxModeSum(n: int64; const counts: array of int64): int64;var\n  f: array[0..99999] of int64;\n  mx, i: int64;\n  ans : int64;\nbegin\n  ans := 0;\n  mx := 0;\n  for i := 0 to n do f[i] := 0;\n\n  for i := n downto 1 do\n  begin\n    while mx < counts[i - 1] do\n    begin\n      mx := mx + 1;\n      f[mx] := f[mx - 1] + i;\n    end;\n    ans := ans + f[counts[i - 1]];\n  end;\n  maxModeSum := ans;\nend;", "buggy_code": "function maxModeSum(n: int64; const counts: array of int64): int64;var\n  f: array[0..99999] of int64;\n  mx, i: int64;\n  ans : int64;\nbegin\n  ans := 0;\n  mx := 0;\n  for i := 0 to n do f[i] = 0;\n\n  for i := n downto 1 do\n  begin\n    while mx < counts[i - 1] do\n    begin\n      mx := mx + 1;\n      f[mx] := f[mx - 1] + i;\n    end;\n    ans := ans + f[counts[i - 1]];\n  end;\n  maxModeSum := ans;\nend;", "bug_with_line_numbers": "   1 | function maxModeSum(n: int64; const counts: array of int64): int64;var\n   2 |   f: array[0..99999] of int64;\n   3 |   mx, i: int64;\n   4 |   ans : int64;\n   5 | begin\n   6 |   ans := 0;\n   7 |   mx := 0;\n   8 |   for i := 0 to n do f[i] = 0;\n   9 |   for i := n downto 1 do\n  10 |   begin\n  11 |     while mx < counts[i - 1] do\n  12 |     begin\n  13 |       mx := mx + 1;\n  14 |       f[mx] := f[mx - 1] + i;\n  15 |     end;\n  16 |     ans := ans + f[counts[i - 1]];\n  17 |   end;\n  18 |   maxModeSum := ans;\n  19 | end;", "fragment_lines": [8], "fragment_content": ["for i := 0 to n do f[i] = 0;"], "test": "procedure check;\nbegin\n  Assert(maxModeSum(3, [1, 3, 2]) = 17);\n  Assert(maxModeSum(4, [4, 1, 2, 3]) = 37);\n  Assert(maxModeSum(2, [1, 1]) = 4);\n  Assert(maxModeSum(5, [1, 2, 3, 4, 5]) = 75);\n  Assert(maxModeSum(1, [100000]) = 100000);\n  Assert(maxModeSum(5, [5, 3, 2, 4, 1]) = 62);\n  Assert(maxModeSum(3, [100000, 100000, 100000]) = 900000);\n  Assert(maxModeSum(3, [2, 2, 5]) = 27);\n  Assert(maxModeSum(4, [4, 4, 4, 4]) = 64);\n  Assert(maxModeSum(6, [1, 2, 3, 4, 5, 6]) = 126);\n  Assert(maxModeSum(3, [3, 1, 2]) = 16);\nend;\n\n(* Main *)\nbegin\n  check;\nend.", "instruction": "Observe the following faulty Pascal code\n```pascal\nfunction maxModeSum(n: int64; const counts: array of int64): int64;var\n  f: array[0..99999] of int64;\n  mx, i: int64;\n  ans : int64;\nbegin\n  ans := 0;\n  mx := 0;\n  for i := 0 to n do f[i] = 0;\n\n  for i := n downto 1 do\n  begin\n    while mx < counts[i - 1] do\n    begin\n      mx := mx + 1;\n      f[mx] := f[mx - 1] + i;\n    end;\n    ans := ans + f[counts[i - 1]];\n  end;\n  maxModeSum := ans;\nend;\n```\nKnown, the bug code specifically exists in the following snippet:\n['for i := 0 to n do f[i] = 0;']\nFix bugs in the given code snippet. The complete , fixed code must be placed between ```pascal```. Do not generate any test, main,example usage or check code!\n"}
{"question_id": "Pascal/13", "category": "Syntax", "subtype": "misused ==and=", "level": "medium", "example": "Examples:\n    >>> calculate_triangle_area(3, 5, 4)\n    6.00", "docstring": "Calculates the area of a triangle given the lengths of its three sides.\n\nParameters:\n- a (real): Length of side 'a'.\n- b (real): Length of side 'b'.\n- c (real): Length of side 'c'.\n\nReturns:\n- real: If the sides can form a triangle, returns the calculated area rounded to 2 decimal places.\n         Otherwise, returns -1 indicating that the sides do not form a triangle.", "canonical_solution": "{$ASSERTIONS ON}\n\nuses \n  Math, SysUtils;\nfunction calculate_triangle_area(a, b, c: real): real;\nvar\n  s: real;begin\n  if (a + b > c) and (a + c > b) and (b + c > a) then\n  begin\n    s := (a + b + c) / 2;\n    calculate_triangle_area := sqrt(s * (s - a) * (s - b) * (s - c));\n  end\n  else\n    calculate_triangle_area := -1; (* Not a triangle *)\nend;", "buggy_code": "{$ASSERTIONS ON}\n\nuses \n  Math, SysUtils;\nfunction calculate_triangle_area(a, b, c: real): real;\nvar\n  s: real;begin\n  if (a + b > c) and (a + c > b) and (b + c > a) then\n  begin\n    s = (a + b + c) / 2;\n    calculate_triangle_area := sqrt(s * (s - a) * (s - b) * (s - c));\n  end\n  else\n    calculate_triangle_area := -1; (* Not a triangle *)\nend;", "bug_with_line_numbers": "   1 | {$ASSERTIONS ON}\n   2 | uses \n   3 |   Math, SysUtils;\n   4 | function calculate_triangle_area(a, b, c: real): real;\n   5 | var\n   6 |   s: real;begin\n   7 |   if (a + b > c) and (a + c > b) and (b + c > a) then\n   8 |   begin\n   9 |     s = (a + b + c) / 2;\n  10 |     calculate_triangle_area := sqrt(s * (s - a) * (s - b) * (s - c));\n  11 |   end\n  12 |   else\n  13 |     calculate_triangle_area := -1; (* Not a triangle *)\n  14 | end;", "fragment_lines": [9], "fragment_content": ["s = (a + b + c) / 2;"], "test": "procedure check;\nvar\n  area: real;\nbegin\n  (* Triangle with sides 3, 5, 4 should return area 6 *)\n  area := calculate_triangle_area(3, 5, 4);\n  Assert(abs(area - 6) < 1e-6);\n\n  (* Not a triangle with sides 1, 1, 4 should return -1 *)\n  area := calculate_triangle_area(1, 1, 4);\n  Assert(area = -1);\n\n  (* Triangle with sides 7, 24, 25 should return area 84 *)\n  area := calculate_triangle_area(7, 24, 25);\n  Assert(abs(area - 84) < 1e-6);\n\n  (* Triangle with sides 10.5, 6.2, 7.3 should return a calculated area *)\n  area := calculate_triangle_area(10.5, 6.2, 7.3);\n  (* For precision issues, we test if the calculated area is close enough to the expected value *)\n  Assert(abs(area - 22.15) < 1e-2);\n  \nend;\n\n(* Main *)\nbegin\n  check;\nend.", "instruction": "Observe the following faulty Pascal code\n```pascal\n{$ASSERTIONS ON}\n\nuses \n  Math, SysUtils;\nfunction calculate_triangle_area(a, b, c: real): real;\nvar\n  s: real;begin\n  if (a + b > c) and (a + c > b) and (b + c > a) then\n  begin\n    s = (a + b + c) / 2;\n    calculate_triangle_area := sqrt(s * (s - a) * (s - b) * (s - c));\n  end\n  else\n    calculate_triangle_area := -1; (* Not a triangle *)\nend;\n```\nKnown, the bug code specifically exists in the following snippet:\n['s = (a + b + c) / 2;']\nFix bugs in the given code snippet. The complete , fixed code must be placed between ```pascal```. Do not generate any test, main,example usage or check code!\n"}
{"question_id": "Pascal/14", "category": "Special", "subtype": "Misused begin/end", "level": "easy", "example": "Examples:\n>>> count_valid_coin_toss_sequences(1)\n2", "docstring": "Function that counts the number of valid coin toss sequences\nwithout consecutive heads. It calculates possible combinations\nfor a given number of tosses.\n\nParameters:\n- n: an integer representing the number of coin tosses.\n\nReturns:\nThe count of valid sequences as an unsigned 64-bit integer.", "canonical_solution": "{$ASSERTIONS ON}\nfunction count_valid_coin_toss_sequences(n: integer): int64;var\n  a: array[0..40, 0..1] of int64;\n  i: integer;\nbegin\n  a[1][0] := 1;\n  a[1][1] := 1;\n\n  for i := 2 to n do\n  begin\n    a[i][0] := a[i - 1][0] + a[i - 1][1];\n    a[i][1] := a[i - 1][0];\n  end;\n\n  count_valid_coin_toss_sequences := a[n][0] + a[n][1];\nend;", "buggy_code": "{$ASSERTIONS ON}\nfunction count_valid_coin_toss_sequences(n: integer): int64;var\n  a: array[0..40, 0..1] of int64;\n  i: integer;\nbegin\n  a[1][0] := 1;\n  a[1][1] := 1;\n\n  for i := 2 to n do\n  begin\n    a[i][0] := a[i - 1][0] + a[i - 1][1];\n    a[i][1] := a[i - 1][0];\n\n  count_valid_coin_toss_sequences := a[n][0] + a[n][1];\nend;", "bug_with_line_numbers": "   1 | {$ASSERTIONS ON}\n   2 | function count_valid_coin_toss_sequences(n: integer): int64;var\n   3 |   a: array[0..40, 0..1] of int64;\n   4 |   i: integer;\n   5 | begin\n   6 |   a[1][0] := 1;\n   7 |   a[1][1] := 1;\n   8 |   for i := 2 to n do\n   9 |   begin\n  10 |     a[i][0] := a[i - 1][0] + a[i - 1][1];\n  11 |     a[i][1] := a[i - 1][0];\n  12 |   count_valid_coin_toss_sequences := a[n][0] + a[n][1];\n  13 | end;", "fragment_lines": [-1], "fragment_content": ["missing critical code snippet"], "test": "procedure check;\nbegin\n  Assert(count_valid_coin_toss_sequences(1) = 2);\n  Assert(count_valid_coin_toss_sequences(2) = 3);\n  Assert(count_valid_coin_toss_sequences(3) = 5);\n  Assert(count_valid_coin_toss_sequences(4) = 8);\n  Assert(count_valid_coin_toss_sequences(5) = 13);\n  Assert(count_valid_coin_toss_sequences(40) = 267914296);\n  Assert(count_valid_coin_toss_sequences(39) = 165580141);\n  Assert(count_valid_coin_toss_sequences(38) = 102334155);\n\n  (* Uncomment the line below to add output for successful tests *)\n  WriteLn('All tests passed!');\nend;\n\nbegin\n  check;\nend.", "instruction": "Observe the following faulty Pascal code\n```pascal\n{$ASSERTIONS ON}\nfunction count_valid_coin_toss_sequences(n: integer): int64;var\n  a: array[0..40, 0..1] of int64;\n  i: integer;\nbegin\n  a[1][0] := 1;\n  a[1][1] := 1;\n\n  for i := 2 to n do\n  begin\n    a[i][0] := a[i - 1][0] + a[i - 1][1];\n    a[i][1] := a[i - 1][0];\n\n  count_valid_coin_toss_sequences := a[n][0] + a[n][1];\nend;\n```\nKnown, the bug code specifically exists in the following snippet:\n['missing critical code snippet']\nFix bugs in the given code snippet. The complete , fixed code must be placed between ```pascal```. Do not generate any test, main,example usage or check code!\n"}
{"question_id": "Pascal/15", "category": "Special", "subtype": "Misused begin/end", "level": "easy", "example": "Examples:\n  var max, min: integer;\n  find_max_min(1, 2, 3, max, min);\n  Assert((max = 3) and (min = 1));", "docstring": "Determines the maximum and minimum of three distinct integers.\n\n  Parameters:\n  a, b, c (integers): Input values among which max and min are to be found.\n\n  This procedure assigns the maximum to the variable 'max', and the minimum to the variable 'min'. Since Pascal does not support returning multiple values directly, we pass parameters by reference.", "canonical_solution": "procedure find_max_min(a, b, c: integer; var max, min: integer);begin\n  if a > b then\n  begin\n    if a > c then\n    begin\n      max := a;\n      if b < c then\n        min := b\n      else\n        min := c;\n    end\n    else\n    begin\n      max := c;\n      min := b;\n    end;\n  end\n  else\n  begin\n    if b > c then\n    begin\n      max := b;\n      if a < c then\n        min := a\n      else\n        min := c;\n    end\n    else\n    begin\n      max := c;\n      if a < b then\n        min := a\n      else\n        min := b;\n    end;\n  end;\nend;", "buggy_code": "procedure find_max_min(a, b, c: integer; var max, min: integer);begin\n  if a > b then\n  begin\n    if a > c then\n      max := a;\n      if b < c then\n        min := b\n      else\n        min := c;\n    else\n    begin\n      max := c;\n      min := b;\n    end;\n  end\n  else\n  begin\n    if b > c then\n    begin\n      max := b;\n      if a < c then\n        min := a\n      else\n        min := c;\n    end\n    else\n    begin\n      max := c;\n      if a < b then\n        min := a\n      else\n        min := b;\n    end;\n  end;\nend;", "bug_with_line_numbers": "   1 | procedure find_max_min(a, b, c: integer; var max, min: integer);begin\n   2 |   if a > b then\n   3 |   begin\n   4 |     if a > c then\n   5 |       max := a;\n   6 |       if b < c then\n   7 |         min := b\n   8 |       else\n   9 |         min := c;\n  10 |     else\n  11 |     begin\n  12 |       max := c;\n  13 |       min := b;\n  14 |     end;\n  15 |   end\n  16 |   else\n  17 |   begin\n  18 |     if b > c then\n  19 |     begin\n  20 |       max := b;\n  21 |       if a < c then\n  22 |         min := a\n  23 |       else\n  24 |         min := c;\n  25 |     end\n  26 |     else\n  27 |     begin\n  28 |       max := c;\n  29 |       if a < b then\n  30 |         min := a\n  31 |       else\n  32 |         min := b;\n  33 |     end;\n  34 |   end;\n  35 | end;", "fragment_lines": [-1], "fragment_content": ["missing critical code snippet"], "test": "procedure check;\nvar\n  max, min: integer;\nbegin\n  find_max_min(1, 2, 3, max, min);\n  Assert((max = 3) and (min = 1), 'Test case 1 failed');\n\n  find_max_min(5, 3, 4, max, min);\n  Assert((max = 5) and (min = 3), 'Test case 2 failed');\n\n  find_max_min(10, -2, 7, max, min);\n  Assert((max = 10) and (min = -2), 'Test case 3 failed');\n\n  find_max_min(-1, -3, -2, max, min);\n  Assert((max = -1) and (min = -3), 'Test case 4 failed');\nend;\n\nbegin\n  check;\n  WriteLn('All tests passed.');\nend.", "instruction": "Observe the following faulty Pascal code\n```pascal\nprocedure find_max_min(a, b, c: integer; var max, min: integer);begin\n  if a > b then\n  begin\n    if a > c then\n      max := a;\n      if b < c then\n        min := b\n      else\n        min := c;\n    else\n    begin\n      max := c;\n      min := b;\n    end;\n  end\n  else\n  begin\n    if b > c then\n    begin\n      max := b;\n      if a < c then\n        min := a\n      else\n        min := c;\n    end\n    else\n    begin\n      max := c;\n      if a < b then\n        min := a\n      else\n        min := b;\n    end;\n  end;\nend;\n```\nKnown, the bug code specifically exists in the following snippet:\n['missing critical code snippet']\nFix bugs in the given code snippet. The complete , fixed code must be placed between ```pascal```. Do not generate any test, main,example usage or check code!\n"}
{"question_id": "Pascal/16", "category": "Reference", "subtype": "faulty_indexing", "level": "easy", "example": "Examples:\n>>> count_valid_coin_toss_sequences(1)\n2", "docstring": "Function that counts the number of valid coin toss sequences\nwithout consecutive heads. It calculates possible combinations\nfor a given number of tosses.\n\nParameters:\n- n: an integer representing the number of coin tosses.\n\nReturns:\nThe count of valid sequences as an unsigned 64-bit integer.", "canonical_solution": "{$ASSERTIONS ON}\nfunction count_valid_coin_toss_sequences(n: integer): int64;var\n  a: array[0..40, 0..1] of int64;\n  i: integer;\nbegin\n  a[1][0] := 1;\n  a[1][1] := 1;\n\n  for i := 2 to n do\n  begin\n    a[i][0] := a[i - 1][0] + a[i - 1][1];\n    a[i][1] := a[i - 1][0];\n  end;\n\n  count_valid_coin_toss_sequences := a[n][0] + a[n][1];\nend;", "buggy_code": "{$ASSERTIONS ON}\nfunction count_valid_coin_toss_sequences(n: integer): int64;var\n  a: array[0..40, 0..1] of int64;\n  i: integer;\nbegin\n  a[1][0] := 1;\n  a[1][1] := 1;\n\n  for i := 2 to n do\n  begin\n    a[i][0] := a[i - 1][1] + a[i - 1][2];\n    a[i][1] := a[i - 1][1];\n  end;\n\n  count_valid_coin_toss_sequences := a[n][0] + a[n][1];\nend;", "bug_with_line_numbers": "   1 | {$ASSERTIONS ON}\n   2 | function count_valid_coin_toss_sequences(n: integer): int64;var\n   3 |   a: array[0..40, 0..1] of int64;\n   4 |   i: integer;\n   5 | begin\n   6 |   a[1][0] := 1;\n   7 |   a[1][1] := 1;\n   8 |   for i := 2 to n do\n   9 |   begin\n  10 |     a[i][0] := a[i - 1][1] + a[i - 1][2];\n  11 |     a[i][1] := a[i - 1][1];\n  12 |   end;\n  13 |   count_valid_coin_toss_sequences := a[n][0] + a[n][1];\n  14 | end;", "fragment_lines": [10, 11], "fragment_content": ["a[i][0] := a[i - 1][1] + a[i - 1][2];", "a[i][1] := a[i - 1][1];"], "test": "procedure check;\nbegin\n  Assert(count_valid_coin_toss_sequences(1) = 2);\n  Assert(count_valid_coin_toss_sequences(2) = 3);\n  Assert(count_valid_coin_toss_sequences(3) = 5);\n  Assert(count_valid_coin_toss_sequences(4) = 8);\n  Assert(count_valid_coin_toss_sequences(5) = 13);\n  Assert(count_valid_coin_toss_sequences(40) = 267914296);\n  Assert(count_valid_coin_toss_sequences(39) = 165580141);\n  Assert(count_valid_coin_toss_sequences(38) = 102334155);\n\n  (* Uncomment the line below to add output for successful tests *)\n  // WriteLn('All tests passed!');\nend;\n\nbegin\n  check;\nend.", "instruction": "Observe the following faulty Pascal code\n```pascal\n{$ASSERTIONS ON}\nfunction count_valid_coin_toss_sequences(n: integer): int64;var\n  a: array[0..40, 0..1] of int64;\n  i: integer;\nbegin\n  a[1][0] := 1;\n  a[1][1] := 1;\n\n  for i := 2 to n do\n  begin\n    a[i][0] := a[i - 1][1] + a[i - 1][2];\n    a[i][1] := a[i - 1][1];\n  end;\n\n  count_valid_coin_toss_sequences := a[n][0] + a[n][1];\nend;\n```\nKnown, the bug code specifically exists in the following snippet:\n['a[i][0] := a[i - 1][1] + a[i - 1][2];', 'a[i][1] := a[i - 1][1];']\nFix bugs in the given code snippet. The complete , fixed code must be placed between ```pascal```. Do not generate any test, main,example usage or check code!\n"}
{"question_id": "Pascal/17", "category": "Reference", "subtype": "faulty_indexing", "level": "easy", "example": "Example usage:\n    Is_Square(1, [9]) should return true (1 in Pascal), because 9 is a perfect square.", "docstring": "The task is to determine if it is possible to assemble the wooden squares from n buckets,\nwhere each bucket contains a number of squares with a side length of 1, into a single larger square.\nThe function receives the length of the list and an array of numbers as input.", "canonical_solution": "{$ASSERTIONS ON}\n\nuses\n  Math, SysUtils;\nfunction Is_Square(length: integer; const squares: array of integer): boolean;var\n  sum: Int64;\n  root, i: integer;\nbegin\n  sum := 0;\n  for i := 0 to length - 1 do\n  begin\n    sum := sum + squares[i];\n  end;\n  root := Trunc(Sqrt(sum));\n  Is_Square := (root * root = sum);\nend;", "buggy_code": "{$ASSERTIONS ON}\n\nuses\n  Math, SysUtils;\nfunction Is_Square(length: integer; const squares: array of integer): boolean;var\n  sum: Int64;\n  root, i: integer;\nbegin\n  sum := 0;\n  for i := 0 to length  do\n  begin\n    sum := sum + squares[i];\n  end;\n  root := Trunc(Sqrt(sum));\n  Is_Square := (root * root = sum);\nend;", "bug_with_line_numbers": "   1 | {$ASSERTIONS ON}\n   2 | uses\n   3 |   Math, SysUtils;\n   4 | function Is_Square(length: integer; const squares: array of integer): boolean;var\n   5 |   sum: Int64;\n   6 |   root, i: integer;\n   7 | begin\n   8 |   sum := 0;\n   9 |   for i := 0 to length  do\n  10 |   begin\n  11 |     sum := sum + squares[i];\n  12 |   end;\n  13 |   root := Trunc(Sqrt(sum));\n  14 |   Is_Square := (root * root = sum);\n  15 | end;", "fragment_lines": [9], "fragment_content": ["for i := 0 to length  do"], "test": "procedure check;\nbegin\n  Assert(Is_Square(1, [9]) = true);\n  Assert(Is_Square(2, [14, 2]) = true);\n  Assert(Is_Square(2, [7, 7]) = false);\n  Assert(Is_Square(7, [1, 2, 3, 4, 5, 6, 7]) = false);\n  Assert(Is_Square(6, [1, 3, 5, 7, 9, 11]) = true);\n  Assert(Is_Square(4, [2, 2, 2, 2]) = false);\n  Assert(Is_Square(3, [4, 5, 6]) = false);\n  Assert(Is_Square(4, [16, 9, 4, 1]) = false);\n  Assert(Is_Square(5, [1, 1, 1, 1, 1]) = false);\n  Assert(Is_Square(2, [25, 25]) = false);\n  Assert(Is_Square(3, [10, 10, 5]) = true);\nend;\n\nbegin\n  check;\nend.", "instruction": "Observe the following faulty Pascal code\n```pascal\n{$ASSERTIONS ON}\n\nuses\n  Math, SysUtils;\nfunction Is_Square(length: integer; const squares: array of integer): boolean;var\n  sum: Int64;\n  root, i: integer;\nbegin\n  sum := 0;\n  for i := 0 to length  do\n  begin\n    sum := sum + squares[i];\n  end;\n  root := Trunc(Sqrt(sum));\n  Is_Square := (root * root = sum);\nend;\n```\nKnown, the bug code specifically exists in the following snippet:\n['for i := 0 to length  do']\nFix bugs in the given code snippet. The complete , fixed code must be placed between ```pascal```. Do not generate any test, main,example usage or check code!\n"}
{"question_id": "Pascal/18", "category": "Reference", "subtype": "undefined_objects", "level": "medium", "example": "Examples:\n    >>> apocalypseYear(6, [3, 2, 4, 5, 9, 18])\n    36", "docstring": "Given a sequence of n events, each occurring with a periodicity of a_i years,\nthe problem is to find the year Yn when the nth event occurs, under the\ncondition that the countdown for event i+1 can only commence in the year\nimmediately following the occurrence of event i.", "canonical_solution": "{$ASSERTIONS ON}\nfunction apocalypseYear(n: Int64; signs: array of Int64): Int64;var\n  i, period, nextOccurrence, year: Int64;\nbegin\n  year := 0;\n  for i := 0 to n-1  do\n  begin\n    period := signs[i];\n    nextOccurrence := (year div period + 1) * period;\n    year := nextOccurrence;\n  end;\n  apocalypseYear := year;\nend;", "buggy_code": "{$ASSERTIONS ON}\nfunction apocalypseYear(n: Int64; signs: array of Int64): Int64;var\n  i, period, nextOccurrence, year: Int64;\nbegin\n  for i := 0 to n  do\n  begin\n    period := signs[i];\n    nextOccurrence := (year div period + 1) * period;\n    year := nextOccurrence;\n  end;\n  apocalypseYear := year;\nend;", "bug_with_line_numbers": "   1 | {$ASSERTIONS ON}\n   2 | function apocalypseYear(n: Int64; signs: array of Int64): Int64;var\n   3 |   i, period, nextOccurrence, year: Int64;\n   4 | begin\n   5 |   for i := 0 to n  do\n   6 |   begin\n   7 |     period := signs[i];\n   8 |     nextOccurrence := (year div period + 1) * period;\n   9 |     year := nextOccurrence;\n  10 |   end;\n  11 |   apocalypseYear := year;\n  12 | end;", "fragment_lines": [-1], "fragment_content": ["missing critical code snippet"], "test": "procedure check;\nbegin\n  Assert(apocalypseYear(6, [3, 2, 4, 5, 9, 18]) = 36);\n  Assert(apocalypseYear(5, [1, 2, 3, 4, 5]) = 5);\n  Assert(apocalypseYear(5, [1, 1, 1, 1, 1]) = 5);\n  Assert(apocalypseYear(6, [50, 30, 711, 200, 503, 1006]) = 2012);\n  Assert(apocalypseYear(2, [1, 2]) = 2);\n  Assert(apocalypseYear(3, [3, 1, 2]) = 6);\n  Assert(apocalypseYear(3, [2, 3, 4]) = 4);\n  Assert(apocalypseYear(4, [1, 2, 3, 4]) = 4);\n  Assert(apocalypseYear(4, [5, 7, 11, 13]) = 13);\n  Assert(apocalypseYear(5, [2, 2, 2, 2, 2]) = 10);\n  Assert(apocalypseYear(3, [6, 10, 15]) = 15);\n  Assert(apocalypseYear(3, [4, 6, 14]) = 14);\n  Assert(apocalypseYear(4, [50, 30, 711, 200]) = 800);\n  Assert(apocalypseYear(6, [1, 1, 1, 1, 1, 1]) = 6);\n  Assert(apocalypseYear(2, [1000000, 999999]) = 1999998);\nend;\n\nbegin\n  check;\nend.", "instruction": "Observe the following faulty Pascal code\n```pascal\n{$ASSERTIONS ON}\nfunction apocalypseYear(n: Int64; signs: array of Int64): Int64;var\n  i, period, nextOccurrence, year: Int64;\nbegin\n  for i := 0 to n  do\n  begin\n    period := signs[i];\n    nextOccurrence := (year div period + 1) * period;\n    year := nextOccurrence;\n  end;\n  apocalypseYear := year;\nend;\n```\nKnown, the bug code specifically exists in the following snippet:\n['missing critical code snippet']\nFix bugs in the given code snippet. The complete , fixed code must be placed between ```pascal```. Do not generate any test, main,example usage or check code!\n"}
{"question_id": "Pascal/19", "category": "Reference", "subtype": "undefined_objects", "level": "medium", "example": "Examples:\n  var max, min: integer;\n  find_max_min(1, 2, 3, max, min);\n  Assert((max = 3) and (min = 1));", "docstring": "Determines the maximum and minimum of three distinct integers.\n\n  Parameters:\n  a, b, c (integers): Input values among which max and min are to be found.\n\n  This procedure assigns the maximum to the variable 'max', and the minimum to the variable 'min'. Since Pascal does not support returning multiple values directly, we pass parameters by reference.", "canonical_solution": "procedure find_max_min(a, b, c: integer; var max, min: integer);begin\n  if a > b then\n  begin\n    if a > c then\n    begin\n      max := a;\n      if b < c then\n        min := b\n      else\n        min := c;\n    end\n    else\n    begin\n      max := c;\n      min := b;\n    end;\n  end\n  else\n  begin\n    if b > c then\n    begin\n      max := b;\n      if a < c then\n        min := a\n      else\n        min := c;\n    end\n    else\n    begin\n      max := c;\n      if a < b then\n        min := a\n      else\n        min := b;\n    end;\n  end;\nend;", "buggy_code": "procedure find_max_min(a, b, c: integer);begin\n  if a > b then\n  begin\n    if a > c then\n    begin\n      max := a;\n      if b < c then\n        min := b\n      else\n        min := c;\n    end\n    else\n    begin\n      max := c;\n      min := b;\n    end;\n  end\n  else\n  begin\n    if b > c then\n    begin\n      max := b;\n      if a < c then\n        min := a\n      else\n        min := c;\n    end\n    else\n    begin\n      max := c;\n      if a < b then\n        min := a\n      else\n        min := b;\n    end;\n  end;\nend;", "bug_with_line_numbers": "   1 | procedure find_max_min(a, b, c: integer);begin\n   2 |   if a > b then\n   3 |   begin\n   4 |     if a > c then\n   5 |     begin\n   6 |       max := a;\n   7 |       if b < c then\n   8 |         min := b\n   9 |       else\n  10 |         min := c;\n  11 |     end\n  12 |     else\n  13 |     begin\n  14 |       max := c;\n  15 |       min := b;\n  16 |     end;\n  17 |   end\n  18 |   else\n  19 |   begin\n  20 |     if b > c then\n  21 |     begin\n  22 |       max := b;\n  23 |       if a < c then\n  24 |         min := a\n  25 |       else\n  26 |         min := c;\n  27 |     end\n  28 |     else\n  29 |     begin\n  30 |       max := c;\n  31 |       if a < b then\n  32 |         min := a\n  33 |       else\n  34 |         min := b;\n  35 |     end;\n  36 |   end;\n  37 | end;", "fragment_lines": [1], "fragment_content": ["procedure find_max_min(a, b, c: integer);begin"], "test": "procedure check;\nvar\n  max, min: integer;\nbegin\n  find_max_min(1, 2, 3, max, min);\n  Assert((max = 3) and (min = 1), 'Test case 1 failed');\n\n  find_max_min(5, 3, 4, max, min);\n  Assert((max = 5) and (min = 3), 'Test case 2 failed');\n\n  find_max_min(10, -2, 7, max, min);\n  Assert((max = 10) and (min = -2), 'Test case 3 failed');\n\n  find_max_min(-1, -3, -2, max, min);\n  Assert((max = -1) and (min = -3), 'Test case 4 failed');\nend;\n\nbegin\n  check;\n  WriteLn('All tests passed.');\nend.", "instruction": "Observe the following faulty Pascal code\n```pascal\nprocedure find_max_min(a, b, c: integer);begin\n  if a > b then\n  begin\n    if a > c then\n    begin\n      max := a;\n      if b < c then\n        min := b\n      else\n        min := c;\n    end\n    else\n    begin\n      max := c;\n      min := b;\n    end;\n  end\n  else\n  begin\n    if b > c then\n    begin\n      max := b;\n      if a < c then\n        min := a\n      else\n        min := c;\n    end\n    else\n    begin\n      max := c;\n      if a < b then\n        min := a\n      else\n        min := b;\n    end;\n  end;\nend;\n```\nKnown, the bug code specifically exists in the following snippet:\n['procedure find_max_min(a, b, c: integer);begin']\nFix bugs in the given code snippet. The complete , fixed code must be placed between ```pascal```. Do not generate any test, main,example usage or check code!\n"}
{"question_id": "Pascal/20", "category": "Logic", "subtype": "algorithm_error", "level": "hard", "example": "Examples:\n    - minRoundsToSameChar('aab') -> 1", "docstring": "Function: minRoundsToSameChar\n  Given a string consisting of lowercase English letters, this function\n  calculates the minimum number of rounds needed to modify the string so\n  that all of its characters are the same. In each round, you can change\n  one character to another character.", "canonical_solution": "{$ASSERTIONS ON}\n\nuses\n  SysUtils;\nfunction minRoundsToSameChar(s: AnsiString): Integer;var\n  charCount: array[0..25] of Integer;\n  i, maxCount: Integer;\nbegin\n\n  for i := 0 to 25 do\n    charCount[i] := 0;\n\n  for i := 1 to Length(s) do\n    Inc(charCount[Ord(s[i]) - Ord('a')]);\n\n  maxCount := 0;\n  for i := 0 to 25 do\n    if charCount[i] > 0 then\n      Inc(maxCount);\n  minRoundsToSameChar := maxCount - 1;\nend;", "buggy_code": "{$ASSERTIONS ON}\n\nuses\n  SysUtils;\nfunction minRoundsToSameChar(s: AnsiString): Integer;var\n  charCount: array[0..25] of Integer;\n  i, maxCount: Integer;\nbegin\n\n  for i := 0 to 25 do\n    charCount[i] := 0;\n\n  for i := 1 to Length(s) do\n    Inc(charCount[Ord(s[i])]);\n\n  maxCount := 0;\n  for i := 0 to 25 do\n    if charCount[i] > 0 then\n      Inc(maxCount);\n  minRoundsToSameChar := maxCount - 1;\nend;", "bug_with_line_numbers": "   1 | {$ASSERTIONS ON}\n   2 | uses\n   3 |   SysUtils;\n   4 | function minRoundsToSameChar(s: AnsiString): Integer;var\n   5 |   charCount: array[0..25] of Integer;\n   6 |   i, maxCount: Integer;\n   7 | begin\n   8 |   for i := 0 to 25 do\n   9 |     charCount[i] := 0;\n  10 |   for i := 1 to Length(s) do\n  11 |     Inc(charCount[Ord(s[i])]);\n  12 |   maxCount := 0;\n  13 |   for i := 0 to 25 do\n  14 |     if charCount[i] > 0 then\n  15 |       Inc(maxCount);\n  16 |   minRoundsToSameChar := maxCount - 1;\n  17 | end;", "fragment_lines": [11], "fragment_content": ["Inc(charCount[Ord(s[i])]);"], "test": "procedure check;\nbegin\n  Assert(minRoundsToSameChar('aab') = 1);\n  Assert(minRoundsToSameChar('abc') = 2);\n  Assert(minRoundsToSameChar('aaa') = 0);\n  Assert(minRoundsToSameChar('abab') = 1);\n  Assert(minRoundsToSameChar('zzzzz') = 0);\nend;\n\nbegin\n  check;\nend.", "instruction": "Observe the following faulty Pascal code\n```pascal\n{$ASSERTIONS ON}\n\nuses\n  SysUtils;\nfunction minRoundsToSameChar(s: AnsiString): Integer;var\n  charCount: array[0..25] of Integer;\n  i, maxCount: Integer;\nbegin\n\n  for i := 0 to 25 do\n    charCount[i] := 0;\n\n  for i := 1 to Length(s) do\n    Inc(charCount[Ord(s[i])]);\n\n  maxCount := 0;\n  for i := 0 to 25 do\n    if charCount[i] > 0 then\n      Inc(maxCount);\n  minRoundsToSameChar := maxCount - 1;\nend;\n```\nKnown, the bug code specifically exists in the following snippet:\n['Inc(charCount[Ord(s[i])]);']\nFix bugs in the given code snippet. The complete , fixed code must be placed between ```pascal```. Do not generate any test, main,example usage or check code!\n"}
{"question_id": "Pascal/21", "category": "Logic", "subtype": "algorithm_error", "level": "hard", "example": "Examples:\n    >>> count_coloring_methods(1,1)\n    1", "docstring": "Counts the number of different coloring methods for a series of n squares\n  using m colors. The coloring must ensure that adjacent squares, as well\n  as the first and last squares, are of different colors.\n  \n  Parameters:\n  - n (integer): The number of squares.\n  - m (integer): The number of colors.\n\n  Returns:\n  The count of different compatible coloring methods.\n  The result is computed modulo 1000003.", "canonical_solution": "{$ASSERTIONS ON}\nfunction count_coloring_methods(n, m: integer): int64;var\n  f: array[1..1111] of int64;\n  i: integer;\nbegin\n  if n = 1 then Exit(m);\n  if n = 2 then Exit((int64(m) * (m - 1)) mod 1000003);\n  f[1] := m;\n  f[2] := (int64(m) * (m - 1)) mod 1000003;\n  f[3] := (int64(f[2]) * (m - 2)) mod 1000003;\n  \n  for i := 4 to n do begin\n    f[i] := ((int64(f[i - 1]) * (m - 2)) mod 1000003 +\n             (int64(f[i - 2]) * (m - 1)) mod 1000003) mod 1000003;\n  end;\n  \n  count_coloring_methods := f[n];\nend;", "buggy_code": "{$ASSERTIONS ON}\nfunction count_coloring_methods(n, m: integer): int64;var\n  f: array[1..1111] of int64;\n  i: integer;\nbegin\n  if n = 1 then Exit(m);\n  if n = 2 then Exit((int64(m) * (m - 1)) mod 1000003);\n  f[1] := m;\n  f[2] := (int64(m) * (m - 1)) mod 1000003;\n\n  for i := 3 to n do begin\n    f[i] := ((int64(f[i - 1]) * (m - 2)) mod 1000003 +\n             (int64(f[i - 2]) * (m - 1)) mod 1000003) mod 1000003;\n  end;\n  \n  count_coloring_methods := f[n];\nend;", "bug_with_line_numbers": "   1 | {$ASSERTIONS ON}\n   2 | function count_coloring_methods(n, m: integer): int64;var\n   3 |   f: array[1..1111] of int64;\n   4 |   i: integer;\n   5 | begin\n   6 |   if n = 1 then Exit(m);\n   7 |   if n = 2 then Exit((int64(m) * (m - 1)) mod 1000003);\n   8 |   f[1] := m;\n   9 |   f[2] := (int64(m) * (m - 1)) mod 1000003;\n  10 |   for i := 3 to n do begin\n  11 |     f[i] := ((int64(f[i - 1]) * (m - 2)) mod 1000003 +\n  12 |              (int64(f[i - 2]) * (m - 1)) mod 1000003) mod 1000003;\n  13 |   end;\n  14 |   count_coloring_methods := f[n];\n  15 | end;", "fragment_lines": [9, 10], "fragment_content": ["f[2] := (int64(m) * (m - 1)) mod 1000003;", "for i := 3 to n do begin"], "test": "procedure check;\nbegin\n  // WriteLn(count_coloring_methods(1000, 10));\n  Assert(count_coloring_methods(1, 1) = 1);\n  Assert(count_coloring_methods(2, 2) = 2);\n  Assert(count_coloring_methods(3, 3) = 6);\n  Assert(count_coloring_methods(4, 2) = 2);\n  Assert(count_coloring_methods(1000, 10) = 566585); // Expected result not confirmed\n  \n  // Additional test cases\n  Assert(count_coloring_methods(2, 3) = 6);\n  Assert(count_coloring_methods(1000, 1000) = 67911);\n  Assert(count_coloring_methods(999, 66) = 501817);\n  Assert(count_coloring_methods(5, 3) = 30); // Example of an expected output\nend;\n\nbegin\n  check;\n  // Uncomment the line below if you want to print a success message\n  // Writeln('All tests passed!');\nend.", "instruction": "Observe the following faulty Pascal code\n```pascal\n{$ASSERTIONS ON}\nfunction count_coloring_methods(n, m: integer): int64;var\n  f: array[1..1111] of int64;\n  i: integer;\nbegin\n  if n = 1 then Exit(m);\n  if n = 2 then Exit((int64(m) * (m - 1)) mod 1000003);\n  f[1] := m;\n  f[2] := (int64(m) * (m - 1)) mod 1000003;\n\n  for i := 3 to n do begin\n    f[i] := ((int64(f[i - 1]) * (m - 2)) mod 1000003 +\n             (int64(f[i - 2]) * (m - 1)) mod 1000003) mod 1000003;\n  end;\n  \n  count_coloring_methods := f[n];\nend;\n```\nKnown, the bug code specifically exists in the following snippet:\n['f[2] := (int64(m) * (m - 1)) mod 1000003;', 'for i := 3 to n do begin']\nFix bugs in the given code snippet. The complete , fixed code must be placed between ```pascal```. Do not generate any test, main,example usage or check code!\n"}
{"question_id": "Pascal/22", "category": "Logic", "subtype": "algorithm_error", "level": "medium", "example": "Examples:\n    >>> apocalypseYear(6, [3, 2, 4, 5, 9, 18])\n    36", "docstring": "Given a sequence of n events, each occurring with a periodicity of a_i years,\nthe problem is to find the year Yn when the nth event occurs, under the\ncondition that the countdown for event i+1 can only commence in the year\nimmediately following the occurrence of event i.", "canonical_solution": "{$ASSERTIONS ON}\nfunction apocalypseYear(n: Int64; signs: array of Int64): Int64;var\n  i, period, nextOccurrence, year: Int64;\nbegin\n  year := 0;\n  for i := 0 to n-1  do\n  begin\n    period := signs[i];\n    nextOccurrence := (year div period + 1) * period;\n    year := nextOccurrence;\n  end;\n  apocalypseYear := year;\nend;", "buggy_code": "{$ASSERTIONS ON}\nfunction apocalypseYear(n: Int64; signs: array of Int64): Int64;var\n  i, period, nextOccurrence, year: Int64;\nbegin\n  year := 0;\n  for i := 0 to n  do\n  begin\n    period := signs[i];\n    nextOccurrence := (year div period) * period;\n    year := nextOccurrence;\n  end;\n  apocalypseYear := year;\nend;", "bug_with_line_numbers": "   1 | {$ASSERTIONS ON}\n   2 | function apocalypseYear(n: Int64; signs: array of Int64): Int64;var\n   3 |   i, period, nextOccurrence, year: Int64;\n   4 | begin\n   5 |   year := 0;\n   6 |   for i := 0 to n  do\n   7 |   begin\n   8 |     period := signs[i];\n   9 |     nextOccurrence := (year div period) * period;\n  10 |     year := nextOccurrence;\n  11 |   end;\n  12 |   apocalypseYear := year;\n  13 | end;", "fragment_lines": [9], "fragment_content": ["nextOccurrence := (year div period) * period;"], "test": "procedure check;\nbegin\n  Assert(apocalypseYear(6, [3, 2, 4, 5, 9, 18]) = 36);\n  Assert(apocalypseYear(5, [1, 2, 3, 4, 5]) = 5);\n  Assert(apocalypseYear(5, [1, 1, 1, 1, 1]) = 5);\n  Assert(apocalypseYear(6, [50, 30, 711, 200, 503, 1006]) = 2012);\n  Assert(apocalypseYear(2, [1, 2]) = 2);\n  Assert(apocalypseYear(3, [3, 1, 2]) = 6);\n  Assert(apocalypseYear(3, [2, 3, 4]) = 4);\n  Assert(apocalypseYear(4, [1, 2, 3, 4]) = 4);\n  Assert(apocalypseYear(4, [5, 7, 11, 13]) = 13);\n  Assert(apocalypseYear(5, [2, 2, 2, 2, 2]) = 10);\n  Assert(apocalypseYear(3, [6, 10, 15]) = 15);\n  Assert(apocalypseYear(3, [4, 6, 14]) = 14);\n  Assert(apocalypseYear(4, [50, 30, 711, 200]) = 800);\n  Assert(apocalypseYear(6, [1, 1, 1, 1, 1, 1]) = 6);\n  Assert(apocalypseYear(2, [1000000, 999999]) = 1999998);\nend;\n\nbegin\n  check;\nend.", "instruction": "Observe the following faulty Pascal code\n```pascal\n{$ASSERTIONS ON}\nfunction apocalypseYear(n: Int64; signs: array of Int64): Int64;var\n  i, period, nextOccurrence, year: Int64;\nbegin\n  year := 0;\n  for i := 0 to n  do\n  begin\n    period := signs[i];\n    nextOccurrence := (year div period) * period;\n    year := nextOccurrence;\n  end;\n  apocalypseYear := year;\nend;\n```\nKnown, the bug code specifically exists in the following snippet:\n['nextOccurrence := (year div period) * period;']\nFix bugs in the given code snippet. The complete , fixed code must be placed between ```pascal```. Do not generate any test, main,example usage or check code!\n"}
{"question_id": "Pascal/23", "category": "Logic", "subtype": "algorithm_error", "level": "medium", "example": "Examples:\n    >>> makeEqualAgain(3, [1, 2, 1])\n    1\n    >>> makeEqualAgain(5, [5, 5, 1, 5, 5])\n    1", "docstring": "You are given an array a of n integers. You can perform at most one operation where \nyou select three integers i, j, x (1 <= i <= j <= n) and replace all elements from \na[i] to a[j] with x, at a cost of (j - i + 1). Find the minimum cost to make all \nelements in the array equal.", "canonical_solution": "{$ASSERTIONS ON}\n\nuses\n  SysUtils;\nfunction makeEqualAgain(n: Integer; a: array of Integer): Integer;var\n  p, q, c, d, k: Integer;\nbegin\n  k := n;\n  p := 1;\n  q := 0;\n  for p := 1 to k - 1 do begin\n    if a[p] <> a[p - 1] then\n      Break;\n  end;\n  for q := k - 1 downto p - 1 do begin\n    if a[q] <> a[p - 1] then\n      Break;\n  end;\n  for d := k - 2 downto 0 do begin\n    if a[d] <> a[d + 1] then\n      Break;\n  end;\n  for c := 0 to d - 1 do begin\n    if a[c] <> a[c + 1] then\n      Break;\n  end;\n  if q - p + 1 < d - c + 1 then\n    makeEqualAgain := q - p + 1\n  else\n    makeEqualAgain := d - c + 1;\nend;", "buggy_code": "{$ASSERTIONS ON}\n\nuses\n  SysUtils;\nfunction makeEqualAgain(n: Integer; a: array of Integer): Integer;var\n  p, q, c, d, k: Integer;\nbegin\n  k := n;\n  p := 1;\n  q := 0;\n  for p := 1 to k - 1 do begin\n    if a[p] <> a[p - 1] then\n      Break;\n  end;\n  for q := k - 1 downto p - 1 do begin\n    if a[q] <> a[p - 1] then\n      Break;\n  end;\n  for c := 0 to d - 1 do begin\n    if a[c] <> a[c + 1] then\n      Break;\n  end;\n  if q - p + 1 < d - c + 1 then\n    makeEqualAgain := q - p + 1\n  else\n    makeEqualAgain := d - c + 1;\nend;", "bug_with_line_numbers": "   1 | {$ASSERTIONS ON}\n   2 | uses\n   3 |   SysUtils;\n   4 | function makeEqualAgain(n: Integer; a: array of Integer): Integer;var\n   5 |   p, q, c, d, k: Integer;\n   6 | begin\n   7 |   k := n;\n   8 |   p := 1;\n   9 |   q := 0;\n  10 |   for p := 1 to k - 1 do begin\n  11 |     if a[p] <> a[p - 1] then\n  12 |       Break;\n  13 |   end;\n  14 |   for q := k - 1 downto p - 1 do begin\n  15 |     if a[q] <> a[p - 1] then\n  16 |       Break;\n  17 |   end;\n  18 |   for c := 0 to d - 1 do begin\n  19 |     if a[c] <> a[c + 1] then\n  20 |       Break;\n  21 |   end;\n  22 |   if q - p + 1 < d - c + 1 then\n  23 |     makeEqualAgain := q - p + 1\n  24 |   else\n  25 |     makeEqualAgain := d - c + 1;\n  26 | end;", "fragment_lines": [-1], "fragment_content": ["missing critical code snippet"], "test": "procedure check;\nvar\n  test1 :array[0..2] of Integer = (1, 2, 1);\n  test2 :array[0..4] of Integer= (5, 5, 1, 5, 5);\n  test3 :array[0..3] of Integer= (1, 1, 1, 1);\n  test4 :array[0..5] of Integer= (2, 2, 2, 3, 2, 2);\n  test5 :array[0..0] of Integer= (1);\n  test6 :array[0..1] of Integer= (1, 2);\n  test7 :array[0..3] of Integer= (1, 2, 2, 1);\n  test8 :array[0..6] of Integer= (4, 4, 4, 3, 3, 4, 4);\n  test9 :array[0..5] of Integer= (5, 4, 4, 4, 5, 5);\n  test10 :array[0..6] of Integer=(1, 2, 1, 2, 1, 2, 1);\n  a1 :array[0..5] of Integer= (1, 2, 3, 4, 5, 1);\n  a2 :array[0..6] of Integer= (1, 1, 1, 1, 1, 1, 1);\n  a3 :array[0..7] of Integer= (8, 8, 8, 1, 2, 8, 8, 8);\n  a4 :array[0..2] of Integer= (1, 2, 3);\n  a5 :array[0..6] of Integer= (4, 3, 2, 7, 1, 1, 3);\n  a6 :array[0..8] of Integer= (9, 9, 2, 9, 2, 5, 5, 5, 3);\nbegin\n  Assert(makeEqualAgain(6, a1) = 4);\n  Assert(makeEqualAgain(7, a2) = 0);\n  Assert(makeEqualAgain(8, a3) = 2);\n  Assert(makeEqualAgain(3, a4) = 2);\n  Assert(makeEqualAgain(7, a5) = 6);\n  Assert(makeEqualAgain(9, a6) = 7);\n\n  Assert(makeEqualAgain(3, test1) = 1);\n  Assert(makeEqualAgain(5, test2) = 1);\n  Assert(makeEqualAgain(4, test3) = 0);\n  Assert(makeEqualAgain(6, test4) = 1);\n  Assert(makeEqualAgain(1, test5) = 0);\n  Assert(makeEqualAgain(2, test6) = 1);\n  Assert(makeEqualAgain(4, test7) = 2);\n  Assert(makeEqualAgain(7, test8) = 2);\n  Assert(makeEqualAgain(6, test9) = 3);\n  Assert(makeEqualAgain(7, test10) = 5);\nend;\n\nbegin\n  check;\nend.", "instruction": "Observe the following faulty Pascal code\n```pascal\n{$ASSERTIONS ON}\n\nuses\n  SysUtils;\nfunction makeEqualAgain(n: Integer; a: array of Integer): Integer;var\n  p, q, c, d, k: Integer;\nbegin\n  k := n;\n  p := 1;\n  q := 0;\n  for p := 1 to k - 1 do begin\n    if a[p] <> a[p - 1] then\n      Break;\n  end;\n  for q := k - 1 downto p - 1 do begin\n    if a[q] <> a[p - 1] then\n      Break;\n  end;\n  for c := 0 to d - 1 do begin\n    if a[c] <> a[c + 1] then\n      Break;\n  end;\n  if q - p + 1 < d - c + 1 then\n    makeEqualAgain := q - p + 1\n  else\n    makeEqualAgain := d - c + 1;\nend;\n```\nKnown, the bug code specifically exists in the following snippet:\n['missing critical code snippet']\nFix bugs in the given code snippet. The complete , fixed code must be placed between ```pascal```. Do not generate any test, main,example usage or check code!\n"}
{"question_id": "Pascal/24", "category": "Logic", "subtype": "algorithm_error", "level": "medium", "example": "Example:\n   >>> countTriplets([1, 5, 7])\n   1", "docstring": "Given an array of n distinct integers representing the heights of Kira's friends,\n   find the number of ways to choose a triplet (a, b, c) such that the greatest common divisor (GCD)\n   of the maximum and minimum values of the triplet is 1.", "canonical_solution": "{$ASSERTIONS ON}\n\nuses\n  SysUtils, Math;\nfunction countTriplets(heights: array of integer; n: integer): integer;var\n  i, j, k, minVal, maxVal, a, b, t, count: integer;\nbegin\n  count := 0;\n  for i := 0 to n - 1 do\n  begin\n    for j := i + 1 to n - 1 do\n    begin\n      for k := j + 1 to n - 1 do\n      begin\n        minVal := Min(Min(heights[i], heights[j]), heights[k]);\n        maxVal := Max(Max(heights[i], heights[j]), heights[k]);\n        a := minVal;\n        b := maxVal;\n\n        while b <> 0 do\n        begin\n          t := b;\n          b := a mod b;\n          a := t;\n        end;\n\n        if a = 1 then\n          Inc(count);\n      end;\n    end;\n  end;\n  countTriplets := count;\nend;", "buggy_code": "{$ASSERTIONS ON}\n\nuses\n  SysUtils, Math;\nfunction countTriplets(heights: array of integer; n: integer): integer;var\n  i, j, k, minVal, maxVal, a, b, t, count: integer;\nbegin\n  count := 0;\n  for i := 0 to n - 1 do\n  begin\n    for j := i + 1 to n - 1 do\n    begin\n      for k := j + 1 to n - 1 do\n      begin\n        minVal := Min(Min(heights[i], heights[j]), heights[k]);\n        maxVal := Max(Max(heights[i], heights[j]), heights[k]);\n        a := minVal;\n        b := maxVal;\n\n        while b <> 0 do\n        begin\n          t := b;\n          b := a;\n          a := t;\n        end;\n\n        if a = 1 then\n          Inc(count);\n      end;\n    end;\n  end;\n  countTriplets := count;\nend;", "bug_with_line_numbers": "   1 | {$ASSERTIONS ON}\n   2 | uses\n   3 |   SysUtils, Math;\n   4 | function countTriplets(heights: array of integer; n: integer): integer;var\n   5 |   i, j, k, minVal, maxVal, a, b, t, count: integer;\n   6 | begin\n   7 |   count := 0;\n   8 |   for i := 0 to n - 1 do\n   9 |   begin\n  10 |     for j := i + 1 to n - 1 do\n  11 |     begin\n  12 |       for k := j + 1 to n - 1 do\n  13 |       begin\n  14 |         minVal := Min(Min(heights[i], heights[j]), heights[k]);\n  15 |         maxVal := Max(Max(heights[i], heights[j]), heights[k]);\n  16 |         a := minVal;\n  17 |         b := maxVal;\n  18 |         while b <> 0 do\n  19 |         begin\n  20 |           t := b;\n  21 |           b := a;\n  22 |           a := t;\n  23 |         end;\n  24 |         if a = 1 then\n  25 |           Inc(count);\n  26 |       end;\n  27 |     end;\n  28 |   end;\n  29 |   countTriplets := count;\n  30 | end;", "fragment_lines": [21], "fragment_content": ["b := a;"], "test": "procedure check;\nbegin\n  Assert(countTriplets([1, 5, 7], 3) = 1);\n  Assert(countTriplets([1, 6, 2, 3], 4) = 3);\n  Assert(countTriplets([16, 4, 8, 2], 4) = 0);\n  Assert(countTriplets([10, 1, 6, 7, 9, 8, 4, 3, 5, 2], 10) = 77);\n  Assert(countTriplets([4, 5, 9, 11, 14], 5) = 7);\n  Assert(countTriplets([15, 10, 6, 9, 7, 3, 12, 8, 11, 1, 2], 11) = 104);\n  Assert(countTriplets([3, 7, 11, 13], 4) = 4);\n  Assert(countTriplets([5, 12, 13, 17, 19], 5) = 10);\n  Assert(countTriplets([2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12], 11) = 87);\n  Assert(countTriplets([1, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17], 11) = 122);\nend;\n\nbegin\n  check;\nend.", "instruction": "Observe the following faulty Pascal code\n```pascal\n{$ASSERTIONS ON}\n\nuses\n  SysUtils, Math;\nfunction countTriplets(heights: array of integer; n: integer): integer;var\n  i, j, k, minVal, maxVal, a, b, t, count: integer;\nbegin\n  count := 0;\n  for i := 0 to n - 1 do\n  begin\n    for j := i + 1 to n - 1 do\n    begin\n      for k := j + 1 to n - 1 do\n      begin\n        minVal := Min(Min(heights[i], heights[j]), heights[k]);\n        maxVal := Max(Max(heights[i], heights[j]), heights[k]);\n        a := minVal;\n        b := maxVal;\n\n        while b <> 0 do\n        begin\n          t := b;\n          b := a;\n          a := t;\n        end;\n\n        if a = 1 then\n          Inc(count);\n      end;\n    end;\n  end;\n  countTriplets := count;\nend;\n```\nKnown, the bug code specifically exists in the following snippet:\n['b := a;']\nFix bugs in the given code snippet. The complete , fixed code must be placed between ```pascal```. Do not generate any test, main,example usage or check code!\n"}
{"question_id": "Pascal/25", "category": "Logic", "subtype": "algorithm_error", "level": "hard", "example": "Examples:\n      >>> countHandshakes(3, [2, 1, 0])\n      0", "docstring": "Given a sequence of student IDs entering a classroom, where the IDs range from 0 to N-1,\n  calculate the total number of handshakes that occur. Each student will shake hands with every\n  student already in the classroom with a smaller ID number. The sequence represents the order\n  in which students enter the classroom.", "canonical_solution": "{$ASSERTIONS ON}\n\nuses\n  SysUtils, Math;\n\nconst\n  N = 10000;\nfunction countHandshakes(n: Integer; order: array of Integer): Int64;const\n  MAX_N = 10000;\nvar\n  ans: Int64;\n  tr: array[1..MAX_N] of Integer;\n  i, j, x: Integer;\nbegin\n  ans := 0;\n  for i := 1 to MAX_N do\n    tr[i] := 0;\n  for i := 0 to n - 1 do\n  begin\n    x := order[i] + 1;\n    j := x - 1;\n    while j > 0 do\n    begin\n      ans := ans + tr[j];\n      j := j - (j and -j);\n    end;\n    j := x;\n    while j <= n do\n    begin\n      Inc(tr[j]);\n      j := j + (j and -j);\n    end;\n  end;\n  countHandshakes := ans;\nend;", "buggy_code": "{$ASSERTIONS ON}\n\nuses\n  SysUtils, Math;\n\nconst\n  N = 10000; \nfunction countHandshakes(n: Integer; order: array of Integer): Int64;const\n  MAX_N = 10000;\nvar\n  ans: Int64;\n  tr: array[1..MAX_N] of Integer;\n  i, j, x: Integer;\nbegin\n  ans := 0;\n  for i := 1 to MAX_N do\n    tr[i] := 0;\n  for i := 0 to n - 1 do\n  begin\n    x := order[i]; \n    j := x - 1;\n    while j > 0 do\n    begin\n      ans := ans + tr[j];\n      j := j - (j and -j);\n    end;\n    j := x;\n    while j <= n do\n    begin\n      Inc(tr[j]);\n      j := j + (j and -j);\n    end;\n  end;\n  countHandshakes := ans;\nend;", "bug_with_line_numbers": "   1 | {$ASSERTIONS ON}\n   2 | uses\n   3 |   SysUtils, Math;\n   4 | const\n   5 |   N = 10000; \n   6 | function countHandshakes(n: Integer; order: array of Integer): Int64;const\n   7 |   MAX_N = 10000;\n   8 | var\n   9 |   ans: Int64;\n  10 |   tr: array[1..MAX_N] of Integer;\n  11 |   i, j, x: Integer;\n  12 | begin\n  13 |   ans := 0;\n  14 |   for i := 1 to MAX_N do\n  15 |     tr[i] := 0;\n  16 |   for i := 0 to n - 1 do\n  17 |   begin\n  18 |     x := order[i]; \n  19 |     j := x - 1;\n  20 |     while j > 0 do\n  21 |     begin\n  22 |       ans := ans + tr[j];\n  23 |       j := j - (j and -j);\n  24 |     end;\n  25 |     j := x;\n  26 |     while j <= n do\n  27 |     begin\n  28 |       Inc(tr[j]);\n  29 |       j := j + (j and -j);\n  30 |     end;\n  31 |   end;\n  32 |   countHandshakes := ans;\n  33 | end;", "fragment_lines": [18], "fragment_content": ["x := order[i];"], "test": "procedure check;\nbegin\n  Assert(countHandshakes(4, [2, 1, 3, 0]) = 2);\n  Assert(countHandshakes(6, [0, 1, 2, 3, 4, 5]) = 15);\n  Assert(countHandshakes(3, [1, 2, 0]) = 1);\n  Assert(countHandshakes(4, [3, 2, 1, 0]) = 0);\n  Assert(countHandshakes(4, [0, 1, 2, 3]) = 6);\n  Assert(countHandshakes(6, [5, 4, 3, 2, 1, 0]) = 0);\n  Assert(countHandshakes(4, [0, 2, 1, 3]) = 5);\n  Assert(countHandshakes(5, [3, 1, 4, 2, 0]) = 3);\n  Assert(countHandshakes(4, [1, 0, 3, 2]) = 4);\n  Assert(countHandshakes(3, [2, 0, 1]) = 1);\n  Assert(countHandshakes(5, [1, 3, 0, 2, 4]) = 7);\n  Assert(countHandshakes(5, [4, 3, 2, 1, 0]) = 0);\nend;\n\nbegin\n  check;\nend.", "instruction": "Observe the following faulty Pascal code\n```pascal\n{$ASSERTIONS ON}\n\nuses\n  SysUtils, Math;\n\nconst\n  N = 10000; \nfunction countHandshakes(n: Integer; order: array of Integer): Int64;const\n  MAX_N = 10000;\nvar\n  ans: Int64;\n  tr: array[1..MAX_N] of Integer;\n  i, j, x: Integer;\nbegin\n  ans := 0;\n  for i := 1 to MAX_N do\n    tr[i] := 0;\n  for i := 0 to n - 1 do\n  begin\n    x := order[i]; \n    j := x - 1;\n    while j > 0 do\n    begin\n      ans := ans + tr[j];\n      j := j - (j and -j);\n    end;\n    j := x;\n    while j <= n do\n    begin\n      Inc(tr[j]);\n      j := j + (j and -j);\n    end;\n  end;\n  countHandshakes := ans;\nend;\n```\nKnown, the bug code specifically exists in the following snippet:\n['x := order[i];']\nFix bugs in the given code snippet. The complete , fixed code must be placed between ```pascal```. Do not generate any test, main,example usage or check code!\n"}
{"question_id": "Pascal/26", "category": "Logic", "subtype": "algorithm_error", "level": "medium", "example": "Examples:\n      >>> classify_integer('24')\n      6", "docstring": "Classify the integer x as follows:\n    - If x is a single-digit number, x belongs to its own class.\n    - Otherwise, sum the digits of x, get a new x, and continue this process iteratively \n      until the class is determined.\n\n  @param x: The string representation of the integer to be classified.\n  @return: The class to which the integer x belongs.", "canonical_solution": "{$ASSERTIONS ON}\nuses\n  SysUtils, StrUtils;\nfunction classify_integer(x: string): Integer;\nvar\n  n, i, a, t: Integer;begin\n  n := 0;\n  for i := 1 to Length(x) do\n    n := n + Ord(x[i]) - Ord('0');\n  while n > 9 do\n  begin\n    t := n;\n    a := 0;\n    while t > 0 do\n    begin\n      a := a + (t mod 10);\n      t := t div 10;\n    end;\n    n := a;\n  end;\n  classify_integer := n;\nend;", "buggy_code": "{$ASSERTIONS ON}\nuses\n  SysUtils, StrUtils;\nfunction classify_integer(x: string): Integer;\nvar\n  n, i, a, t: Integer;begin\n  n := 0;\n  for i := 1 to Length(x) do\n    n := n + Ord(x[i]) - Ord('0');\n  while n > 9 do\n  begin\n    t := n;\n    a := 0;\n    while t > 0 do\n    begin\n      a := a + t;\n      t := t div 10;\n    end;\n    n := a;\n  end;\n  classify_integer := n;\nend;", "bug_with_line_numbers": "   1 | {$ASSERTIONS ON}\n   2 | uses\n   3 |   SysUtils, StrUtils;\n   4 | function classify_integer(x: string): Integer;\n   5 | var\n   6 |   n, i, a, t: Integer;begin\n   7 |   n := 0;\n   8 |   for i := 1 to Length(x) do\n   9 |     n := n + Ord(x[i]) - Ord('0');\n  10 |   while n > 9 do\n  11 |   begin\n  12 |     t := n;\n  13 |     a := 0;\n  14 |     while t > 0 do\n  15 |     begin\n  16 |       a := a + t;\n  17 |       t := t div 10;\n  18 |     end;\n  19 |     n := a;\n  20 |   end;\n  21 |   classify_integer := n;\n  22 | end;", "fragment_lines": [16], "fragment_content": ["a := a + t;"], "test": "procedure check;\nbegin\n  Assert(classify_integer('24') = 6);\n  Assert(classify_integer('39') = 3);\n  Assert(classify_integer('123456789') = 9);\n  Assert(classify_integer('123456789012345678901234567890') = 9);\n  Assert(classify_integer('12345') = 6);\n  Assert(classify_integer('999999999') = 9);\nend;\n\nbegin\n  check;\nend.", "instruction": "Observe the following faulty Pascal code\n```pascal\n{$ASSERTIONS ON}\nuses\n  SysUtils, StrUtils;\nfunction classify_integer(x: string): Integer;\nvar\n  n, i, a, t: Integer;begin\n  n := 0;\n  for i := 1 to Length(x) do\n    n := n + Ord(x[i]) - Ord('0');\n  while n > 9 do\n  begin\n    t := n;\n    a := 0;\n    while t > 0 do\n    begin\n      a := a + t;\n      t := t div 10;\n    end;\n    n := a;\n  end;\n  classify_integer := n;\nend;\n```\nKnown, the bug code specifically exists in the following snippet:\n['a := a + t;']\nFix bugs in the given code snippet. The complete , fixed code must be placed between ```pascal```. Do not generate any test, main,example usage or check code!\n"}
{"question_id": "Pascal/27", "category": "Logic", "subtype": "algorithm_error", "level": "hard", "example": "Example:\n   >>> countTriplets([1, 5, 7])\n   1", "docstring": "Given an array of n distinct integers representing the heights of Kira's friends,\n   find the number of ways to choose a triplet (a, b, c) such that the greatest common divisor (GCD)\n   of the maximum and minimum values of the triplet is 1.", "canonical_solution": "{$ASSERTIONS ON}\n\nuses\n  SysUtils, Math;\nfunction countTriplets(heights: array of integer; n: integer): integer;var\n  i, j, k, minVal, maxVal, a, b, t, count: integer;\nbegin\n  count := 0;\n  for i := 0 to n - 1 do\n  begin\n    for j := i + 1 to n - 1 do\n    begin\n      for k := j + 1 to n - 1 do\n      begin\n        minVal := Min(Min(heights[i], heights[j]), heights[k]);\n        maxVal := Max(Max(heights[i], heights[j]), heights[k]);\n        a := minVal;\n        b := maxVal;\n\n        while b <> 0 do\n        begin\n          t := b;\n          b := a mod b;\n          a := t;\n        end;\n\n        if a = 1 then\n          Inc(count);\n      end;\n    end;\n  end;\n  countTriplets := count;\nend;", "buggy_code": "{$ASSERTIONS ON}\n\nuses\n  SysUtils, Math;\nfunction countTriplets(heights: array of integer; n: integer): integer;var\n  i, j, k, minVal, maxVal, a, b, t, count: integer;\nbegin\n  count := 0;\n  for i := 0 to n - 1 do\n  begin\n    for j := i + 1 to n - 1 do\n    begin\n      for k := j + 1 to n - 1 do\n      begin\n        minVal := Min(Max(heights[i], heights[j]), heights[k]);\n        maxVal := Max(Min(heights[i], heights[j]), heights[k]);\n        a := minVal;\n        b := maxVal;\n\n        while b <> 0 do\n        begin\n          t := b;\n          b := a mod b;\n          a := t;\n        end;\n\n        if a = 1 then\n          Inc(count);\n      end;\n    end;\n  end;\n  countTriplets := count;\nend;", "bug_with_line_numbers": "   1 | {$ASSERTIONS ON}\n   2 | uses\n   3 |   SysUtils, Math;\n   4 | function countTriplets(heights: array of integer; n: integer): integer;var\n   5 |   i, j, k, minVal, maxVal, a, b, t, count: integer;\n   6 | begin\n   7 |   count := 0;\n   8 |   for i := 0 to n - 1 do\n   9 |   begin\n  10 |     for j := i + 1 to n - 1 do\n  11 |     begin\n  12 |       for k := j + 1 to n - 1 do\n  13 |       begin\n  14 |         minVal := Min(Max(heights[i], heights[j]), heights[k]);\n  15 |         maxVal := Max(Min(heights[i], heights[j]), heights[k]);\n  16 |         a := minVal;\n  17 |         b := maxVal;\n  18 |         while b <> 0 do\n  19 |         begin\n  20 |           t := b;\n  21 |           b := a mod b;\n  22 |           a := t;\n  23 |         end;\n  24 |         if a = 1 then\n  25 |           Inc(count);\n  26 |       end;\n  27 |     end;\n  28 |   end;\n  29 |   countTriplets := count;\n  30 | end;", "fragment_lines": [14, 15], "fragment_content": ["minVal := Min(Max(heights[i], heights[j]), heights[k]);", "maxVal := Max(Min(heights[i], heights[j]), heights[k]);"], "test": "procedure check;\nbegin\n  Assert(countTriplets([1, 5, 7], 3) = 1);\n  Assert(countTriplets([1, 6, 2, 3], 4) = 3);\n  Assert(countTriplets([16, 4, 8, 2], 4) = 0);\n  Assert(countTriplets([10, 1, 6, 7, 9, 8, 4, 3, 5, 2], 10) = 77);\n  Assert(countTriplets([4, 5, 9, 11, 14], 5) = 7);\n  Assert(countTriplets([15, 10, 6, 9, 7, 3, 12, 8, 11, 1, 2], 11) = 104);\n  Assert(countTriplets([3, 7, 11, 13], 4) = 4);\n  Assert(countTriplets([5, 12, 13, 17, 19], 5) = 10);\n  Assert(countTriplets([2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12], 11) = 87);\n  Assert(countTriplets([1, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17], 11) = 122);\nend;\n\nbegin\n  check;\nend.", "instruction": "Observe the following faulty Pascal code\n```pascal\n{$ASSERTIONS ON}\n\nuses\n  SysUtils, Math;\nfunction countTriplets(heights: array of integer; n: integer): integer;var\n  i, j, k, minVal, maxVal, a, b, t, count: integer;\nbegin\n  count := 0;\n  for i := 0 to n - 1 do\n  begin\n    for j := i + 1 to n - 1 do\n    begin\n      for k := j + 1 to n - 1 do\n      begin\n        minVal := Min(Max(heights[i], heights[j]), heights[k]);\n        maxVal := Max(Min(heights[i], heights[j]), heights[k]);\n        a := minVal;\n        b := maxVal;\n\n        while b <> 0 do\n        begin\n          t := b;\n          b := a mod b;\n          a := t;\n        end;\n\n        if a = 1 then\n          Inc(count);\n      end;\n    end;\n  end;\n  countTriplets := count;\nend;\n```\nKnown, the bug code specifically exists in the following snippet:\n['minVal := Min(Max(heights[i], heights[j]), heights[k]);', 'maxVal := Max(Min(heights[i], heights[j]), heights[k]);']\nFix bugs in the given code snippet. The complete , fixed code must be placed between ```pascal```. Do not generate any test, main,example usage or check code!\n"}
{"question_id": "Pascal/28", "category": "Logic", "subtype": "algorithm_error", "level": "medium", "example": "Examples:\n      >>> countHandshakes(3, [2, 1, 0])\n      0", "docstring": "Given a sequence of student IDs entering a classroom, where the IDs range from 0 to N-1,\n  calculate the total number of handshakes that occur. Each student will shake hands with every\n  student already in the classroom with a smaller ID number. The sequence represents the order\n  in which students enter the classroom.", "canonical_solution": "{$ASSERTIONS ON}\n\nuses\n  SysUtils, Math;\n\nconst\n  N = 10000;\nfunction countHandshakes(n: Integer; order: array of Integer): Int64;const\n  MAX_N = 10000;\nvar\n  ans: Int64;\n  tr: array[1..MAX_N] of Integer;\n  i, j, x: Integer;\nbegin\n  ans := 0;\n  for i := 1 to MAX_N do\n    tr[i] := 0;\n  for i := 0 to n - 1 do\n  begin\n    x := order[i] + 1;\n    j := x - 1;\n    while j > 0 do\n    begin\n      ans := ans + tr[j];\n      j := j - (j and -j);\n    end;\n    j := x;\n    while j <= n do\n    begin\n      Inc(tr[j]);\n      j := j + (j and -j);\n    end;\n  end;\n  countHandshakes := ans;\nend;", "buggy_code": "{$ASSERTIONS ON}\n\nuses\n  SysUtils, Math;\n\nconst\n  N = 10000; \nfunction countHandshakes(n: Integer; order: array of Integer): Int64;const\n  MAX_N = 10000;\nvar\n  ans: Int64;\n  tr: array[1..MAX_N] of Integer;\n  i, j, x: Integer;\nbegin\n  ans := 0;\n  for i := 1 to MAX_N do\n    tr[i] := 0;\n  for i := 0 to n - 1 do\n  begin\n    x := order[i] + 1;\n    j := x - 1;\n    while j > 0 do\n    begin\n      ans := ans + tr[j];\n      j := j - (j and -j);\n    end;\n    j := x;\n    while j <= n do\n    begin\n      j := j + (j and -j);\n    end;\n  end;\n  countHandshakes := ans;\nend;", "bug_with_line_numbers": "   1 | {$ASSERTIONS ON}\n   2 | uses\n   3 |   SysUtils, Math;\n   4 | const\n   5 |   N = 10000; \n   6 | function countHandshakes(n: Integer; order: array of Integer): Int64;const\n   7 |   MAX_N = 10000;\n   8 | var\n   9 |   ans: Int64;\n  10 |   tr: array[1..MAX_N] of Integer;\n  11 |   i, j, x: Integer;\n  12 | begin\n  13 |   ans := 0;\n  14 |   for i := 1 to MAX_N do\n  15 |     tr[i] := 0;\n  16 |   for i := 0 to n - 1 do\n  17 |   begin\n  18 |     x := order[i] + 1;\n  19 |     j := x - 1;\n  20 |     while j > 0 do\n  21 |     begin\n  22 |       ans := ans + tr[j];\n  23 |       j := j - (j and -j);\n  24 |     end;\n  25 |     j := x;\n  26 |     while j <= n do\n  27 |     begin\n  28 |       j := j + (j and -j);\n  29 |     end;\n  30 |   end;\n  31 |   countHandshakes := ans;\n  32 | end;", "fragment_lines": [-1], "fragment_content": ["missing critical code snippet"], "test": "procedure check;\nbegin\n  Assert(countHandshakes(4, [2, 1, 3, 0]) = 2);\n  Assert(countHandshakes(6, [0, 1, 2, 3, 4, 5]) = 15);\n  Assert(countHandshakes(3, [1, 2, 0]) = 1);\n  Assert(countHandshakes(4, [3, 2, 1, 0]) = 0);\n  Assert(countHandshakes(4, [0, 1, 2, 3]) = 6);\n  Assert(countHandshakes(6, [5, 4, 3, 2, 1, 0]) = 0);\n  Assert(countHandshakes(4, [0, 2, 1, 3]) = 5);\n  Assert(countHandshakes(5, [3, 1, 4, 2, 0]) = 3);\n  Assert(countHandshakes(4, [1, 0, 3, 2]) = 4);\n  Assert(countHandshakes(3, [2, 0, 1]) = 1);\n  Assert(countHandshakes(5, [1, 3, 0, 2, 4]) = 7);\n  Assert(countHandshakes(5, [4, 3, 2, 1, 0]) = 0);\nend;\n\nbegin\n  check;\nend.", "instruction": "Observe the following faulty Pascal code\n```pascal\n{$ASSERTIONS ON}\n\nuses\n  SysUtils, Math;\n\nconst\n  N = 10000; \nfunction countHandshakes(n: Integer; order: array of Integer): Int64;const\n  MAX_N = 10000;\nvar\n  ans: Int64;\n  tr: array[1..MAX_N] of Integer;\n  i, j, x: Integer;\nbegin\n  ans := 0;\n  for i := 1 to MAX_N do\n    tr[i] := 0;\n  for i := 0 to n - 1 do\n  begin\n    x := order[i] + 1;\n    j := x - 1;\n    while j > 0 do\n    begin\n      ans := ans + tr[j];\n      j := j - (j and -j);\n    end;\n    j := x;\n    while j <= n do\n    begin\n      j := j + (j and -j);\n    end;\n  end;\n  countHandshakes := ans;\nend;\n```\nKnown, the bug code specifically exists in the following snippet:\n['missing critical code snippet']\nFix bugs in the given code snippet. The complete , fixed code must be placed between ```pascal```. Do not generate any test, main,example usage or check code!\n"}
{"question_id": "Pascal/29", "category": "Logic", "subtype": "algorithm_error", "level": "hard", "example": "Examples:\n    - minRoundsToSameChar('aab') -> 1", "docstring": "Function: minRoundsToSameChar\n  Given a string consisting of lowercase English letters, this function\n  calculates the minimum number of rounds needed to modify the string so\n  that all of its characters are the same. In each round, you can change\n  one character to another character.", "canonical_solution": "{$ASSERTIONS ON}\n\nuses\n  SysUtils;\nfunction minRoundsToSameChar(s: AnsiString): Integer;var\n  charCount: array[0..25] of Integer;\n  i, maxCount: Integer;\nbegin\n\n  for i := 0 to 25 do\n    charCount[i] := 0;\n\n  for i := 1 to Length(s) do\n    Inc(charCount[Ord(s[i]) - Ord('a')]);\n\n  maxCount := 0;\n  for i := 0 to 25 do\n    if charCount[i] > 0 then\n      Inc(maxCount);\n  minRoundsToSameChar := maxCount - 1;\nend;", "buggy_code": "{$ASSERTIONS ON}\n\nuses\n  SysUtils;\nfunction minRoundsToSameChar(s: AnsiString): Integer;var\n  charCount: array[0..25] of Integer;\n  i, maxCount: Integer;\nbegin\n\n  for i := 0 to 25 do\n    charCount[i] := 0;\n\n  for i := 1 to Length(s) do\n    Inc(charCount[Ord(s[i]) - Ord('a')]);\n\n  maxCount := 0;\n  for i := 0 to 25 do\n    if charCount[i] > 0 then\n      Inc(maxCount);\n  minRoundsToSameChar := maxCount;\nend;", "bug_with_line_numbers": "   1 | {$ASSERTIONS ON}\n   2 | uses\n   3 |   SysUtils;\n   4 | function minRoundsToSameChar(s: AnsiString): Integer;var\n   5 |   charCount: array[0..25] of Integer;\n   6 |   i, maxCount: Integer;\n   7 | begin\n   8 |   for i := 0 to 25 do\n   9 |     charCount[i] := 0;\n  10 |   for i := 1 to Length(s) do\n  11 |     Inc(charCount[Ord(s[i]) - Ord('a')]);\n  12 |   maxCount := 0;\n  13 |   for i := 0 to 25 do\n  14 |     if charCount[i] > 0 then\n  15 |       Inc(maxCount);\n  16 |   minRoundsToSameChar := maxCount;\n  17 | end;", "fragment_lines": [16], "fragment_content": ["minRoundsToSameChar := maxCount;"], "test": "procedure check;\nbegin\n  Assert(minRoundsToSameChar('aab') = 1);\n  Assert(minRoundsToSameChar('abc') = 2);\n  Assert(minRoundsToSameChar('aaa') = 0);\n  Assert(minRoundsToSameChar('abab') = 1);\n  Assert(minRoundsToSameChar('zzzzz') = 0);\nend;\n\nbegin\n  check;\nend.", "instruction": "Observe the following faulty Pascal code\n```pascal\n{$ASSERTIONS ON}\n\nuses\n  SysUtils;\nfunction minRoundsToSameChar(s: AnsiString): Integer;var\n  charCount: array[0..25] of Integer;\n  i, maxCount: Integer;\nbegin\n\n  for i := 0 to 25 do\n    charCount[i] := 0;\n\n  for i := 1 to Length(s) do\n    Inc(charCount[Ord(s[i]) - Ord('a')]);\n\n  maxCount := 0;\n  for i := 0 to 25 do\n    if charCount[i] > 0 then\n      Inc(maxCount);\n  minRoundsToSameChar := maxCount;\nend;\n```\nKnown, the bug code specifically exists in the following snippet:\n['minRoundsToSameChar := maxCount;']\nFix bugs in the given code snippet. The complete , fixed code must be placed between ```pascal```. Do not generate any test, main,example usage or check code!\n"}
{"question_id": "Pascal/30", "category": "Logic", "subtype": "algorithm_error", "level": "easy", "example": "Example:\n  Assert(decodeNumbers('0000') = 4);", "docstring": "Decode a series of numbers to reveal the pattern and understand the actual values\n  each digit represents.\n  0000=4 8888=8 1234=1 5678=3 9012=2 1357=0 2468=4\n  \n  Parameters:\n  - data_str: A string representing a series of numbers. Length does not exceed 100.\n  \n  Returns:\n  integer: The result of each data string corresponding to the right-hand side of the equation.", "canonical_solution": "{$ASSERTIONS ON}\nfunction decodeNumbers(data_str: AnsiString): Integer;var\n  a: array[0..9] of Integer = (1, 0, 0, 0, 1, 0, 1, 0, 2, 1);\n  ans, i: Integer;\nbegin\n  ans := 0;\n  for i := 1 to Length(data_str) do\n  begin\n    ans := ans + a[Ord(data_str[i]) - Ord('0')];\n  end;\n  decodeNumbers := ans;\nend;", "buggy_code": "{$ASSERTIONS ON}\nfunction decodeNumbers(data_str: AnsiString): Integer;var\n  a: array[0..9] of Integer = (1, 0, 0, 0, 1, 0, 1, 0, 2, 1);\n  ans, i: Integer;\nbegin\n  ans := 0;\n  for i := 1 to Length(data_str) do\n  begin\n    ans := ans + a[Ord(data_str[i])];\n  end;\n  decodeNumbers := ans;\nend;", "bug_with_line_numbers": "   1 | {$ASSERTIONS ON}\n   2 | function decodeNumbers(data_str: AnsiString): Integer;var\n   3 |   a: array[0..9] of Integer = (1, 0, 0, 0, 1, 0, 1, 0, 2, 1);\n   4 |   ans, i: Integer;\n   5 | begin\n   6 |   ans := 0;\n   7 |   for i := 1 to Length(data_str) do\n   8 |   begin\n   9 |     ans := ans + a[Ord(data_str[i])];\n  10 |   end;\n  11 |   decodeNumbers := ans;\n  12 | end;", "fragment_lines": [9], "fragment_content": ["ans := ans + a[Ord(data_str[i])];"], "test": "procedure check;\nbegin\n  Assert(decodeNumbers('0000') = 4);\n  Assert(decodeNumbers('8888') = 8);\n  Assert(decodeNumbers('1234') = 1);\n  Assert(decodeNumbers('5678') = 3);\n  Assert(decodeNumbers('9012') = 2);\n  Assert(decodeNumbers('1357') = 0);\n  Assert(decodeNumbers('2468') = 4);\n  // Additional test samples\n  Assert(decodeNumbers('9999') = 4);\n  Assert(decodeNumbers('1111') = 0);\n  Assert(decodeNumbers('2222') = 0);\n  Assert(decodeNumbers('3333') = 0);\n  Assert(decodeNumbers('4444') = 4);\n  Assert(decodeNumbers('5555') = 0);\n  Assert(decodeNumbers('6666') = 4);\n  Assert(decodeNumbers('7777') = 0);\n  Assert(decodeNumbers('0001') = 3);\n  Assert(decodeNumbers('2301') = 1);\nend;\n\nbegin\n  check;\nend.", "instruction": "Observe the following faulty Pascal code\n```pascal\n{$ASSERTIONS ON}\nfunction decodeNumbers(data_str: AnsiString): Integer;var\n  a: array[0..9] of Integer = (1, 0, 0, 0, 1, 0, 1, 0, 2, 1);\n  ans, i: Integer;\nbegin\n  ans := 0;\n  for i := 1 to Length(data_str) do\n  begin\n    ans := ans + a[Ord(data_str[i])];\n  end;\n  decodeNumbers := ans;\nend;\n```\nKnown, the bug code specifically exists in the following snippet:\n['ans := ans + a[Ord(data_str[i])];']\nFix bugs in the given code snippet. The complete , fixed code must be placed between ```pascal```. Do not generate any test, main,example usage or check code!\n"}
{"question_id": "Pascal/31", "category": "Logic", "subtype": "algorithm_error", "level": "hard", "example": "Examples:\n    >>> countPowerNumbers(99, 1)\n    99", "docstring": "Given two positive integers n and k, find the number of positive integers x,\nwhere 1 <= x <= n, that can be expressed as x = a^b with a and b being positive\nintegers and b >= k. Different legal representations of the same number are counted\nonly once.", "canonical_solution": "{$ASSERTIONS ON}\nfunction countPowerNumbers(n, k: integer): integer;var\n  count, x, i, m: integer;\n  t: int64;\n  mp: array of boolean;\nbegin\n  count := 0;\n  x := 0;\n  SetLength(mp, n + 1);\n  i := 2;\n  while i * i * i <= n do\n  begin\n    t := i * i;\n    m := 2;\n    while t <= n div i do\n    begin\n      t := t * i;\n      Inc(m);\n      if (m < k) or (mp[t]) then\n        continue;\n\n      if trunc(sqrt(t)) * trunc(sqrt(t)) = t then\n        Inc(x);\n\n      mp[t] := true;\n      Inc(count);\n    end;\n    i := i + 1;\n  end;\n\n  if k = 1 then\n  begin\n    count := n;\n  end\n  else if k >= 3 then\n  begin\n    count := count + 1;\n  end\n  else\n  begin\n    count := count + trunc(sqrt(n)) - x;\n  end;\n\n  countPowerNumbers := count;\nend;", "buggy_code": "{$ASSERTIONS ON}\nfunction countPowerNumbers(n, k: integer): integer;var\n  count, x, i, m: integer;\n  t: int64;\n  mp: array of boolean;\nbegin\n  count := 0;\n  x := 0;\n  SetLength(mp, n + 1);\n  i := 2;\n  while i * i * i <= n do\n  begin\n    t := i * i;\n    m := 2;\n    while t <= n div i do\n    begin\n      t := t * i;\n      Inc(m);\n\n\n      if trunc(sqrt(t)) * trunc(sqrt(t)) = t then\n        Inc(x);\n\n      mp[t] := true;\n      Inc(count);\n    end;\n    i := i + 1;\n  end;\n\n  if k = 1 then\n  begin\n    count := n;\n  end\n  else if k >= 3 then\n  begin\n    count := count + 1;\n  end\n  else\n  begin\n    count := count + trunc(sqrt(n)) - x;\n  end;\n\n  countPowerNumbers := count;\nend;", "bug_with_line_numbers": "   1 | function countPowerNumbers(n, k: integer): integer;var\n   2 |   count, x, i, m: integer;\n   3 |   t: int64;\n   4 |   mp: array of boolean;\n   5 | begin\n   6 |   count := 0;\n   7 |   x := 0;\n   8 |   SetLength(mp, n + 1);\n   9 |   i := 2;\n  10 |   while i * i * i <= n do\n  11 |   begin\n  12 |     t := i * i;\n  13 |     m := 2;\n  14 |     while t <= n div i do\n  15 |     begin\n  16 |       t := t * i;\n  17 |       Inc(m);\n  18 |       if trunc(sqrt(t)) * trunc(sqrt(t)) = t then\n  19 |         Inc(x);\n  20 |       mp[t] := true;\n  21 |       Inc(count);\n  22 |     end;\n  23 |     i := i + 1;\n  24 |   end;\n  25 |   if k = 1 then\n  26 |   begin\n  27 |     count := n;\n  28 |   end\n  29 |   else if k >= 3 then\n  30 |   begin\n  31 |     count := count + 1;\n  32 |   end\n  33 |   else\n  34 |   begin\n  35 |     count := count + trunc(sqrt(n)) - x;\n  36 |   end;\n  37 |   countPowerNumbers := count;\n  38 | end;", "fragment_lines": [-1], "fragment_content": ["missing critical code snippet"], "test": "procedure check;\nbegin\n  Assert(countPowerNumbers(99, 1) = 99);\n  Assert(countPowerNumbers(99, 3) = 7);\n  Assert(countPowerNumbers(99, 2) = 12);\n  Assert(countPowerNumbers(10, 1) = 10);\n  Assert(countPowerNumbers(10, 2) = 4);\n  Assert(countPowerNumbers(500, 1) = 500);\n  Assert(countPowerNumbers(500, 2) = 30);\n  Assert(countPowerNumbers(500, 3) = 13);\n  Assert(countPowerNumbers(1000, 1) = 1000);\n  Assert(countPowerNumbers(1000, 2) = 41);\n  Assert(countPowerNumbers(1000, 3) = 17);\n  Assert(countPowerNumbers(1000, 93) = 1);\n  Assert(countPowerNumbers(50, 2) = 10);\n  Assert(countPowerNumbers(50, 3) = 5);\n  Assert(countPowerNumbers(2, 3) = 1);\nend;\n\nbegin\n  check;\nend.", "instruction": "Observe the following faulty Pascal code\n```pascal\n{$ASSERTIONS ON}\nfunction countPowerNumbers(n, k: integer): integer;var\n  count, x, i, m: integer;\n  t: int64;\n  mp: array of boolean;\nbegin\n  count := 0;\n  x := 0;\n  SetLength(mp, n + 1);\n  i := 2;\n  while i * i * i <= n do\n  begin\n    t := i * i;\n    m := 2;\n    while t <= n div i do\n    begin\n      t := t * i;\n      Inc(m);\n\n\n      if trunc(sqrt(t)) * trunc(sqrt(t)) = t then\n        Inc(x);\n\n      mp[t] := true;\n      Inc(count);\n    end;\n    i := i + 1;\n  end;\n\n  if k = 1 then\n  begin\n    count := n;\n  end\n  else if k >= 3 then\n  begin\n    count := count + 1;\n  end\n  else\n  begin\n    count := count + trunc(sqrt(n)) - x;\n  end;\n\n  countPowerNumbers := count;\nend;\n```\nKnown, the bug code specifically exists in the following snippet:\n['missing critical code snippet']\nFix bugs in the given code snippet. The complete , fixed code must be placed between ```pascal```. Do not generate any test, main,example usage or check code!\n"}
{"question_id": "Pascal/32", "category": "Logic", "subtype": "algorithm_error", "level": "medium", "example": "Examples:\n       >>> minOperations(5, [1, 2, 3, 2, 1])\n       2", "docstring": "Given a 1 by n pixel image where each pixel has a color represented by an integer,\n   you can pick a color and change all connected pixels of the same color to the chosen color.\n   Two pixels are connected if they are adjacent and have the same color.\n   Find the minimum number of operations required to make all pixels the same color.\n\n   Note: For each color, there are at most 20 pixels of that color.", "canonical_solution": "{$ASSERTIONS ON}\nfunction minOperations(n: Integer; pixels: array of Integer): Integer;var\n  pre, u: array of Integer;\n  f: array of array of int64;\n  i, j, len, l: Integer;\nbegin\n  SetLength(pre, n + 1);\n  SetLength(u, n + 1);\n  SetLength(f, n + 1, n + 1);\n\n  for i := 1 to n do\n  begin\n    pre[i] := 0;\n    u[i] := 0;\n  end;\n\n  for i := 1 to n do\n  begin\n    pre[i] := u[pixels[i - 1]];\n    u[pixels[i - 1]] := i;\n  end;\n\n  for i := 1 to n do\n    for j := 1 to n do\n      if i <> j then f[i, j] := 10000000\n      else f[i, j] := 0;\n  for len := 2 to n do\n    for i := 1 to n - len + 1 do\n    begin\n      j := i + len - 1;\n      f[i, j] := f[i, j - 1] + 1;\n      l := pre[j];\n      while l >= i do\n      begin\n        if f[i, j] < f[i, l] + f[l + 1, j] then\n          f[i, j] := f[i, j]\n        else\n          f[i, j] := f[i, l] + f[l + 1, j];\n        l := pre[l];\n      end;\n    end;\n\n  minOperations := f[1, n];\nend;", "buggy_code": "{$ASSERTIONS ON}\nfunction minOperations(n: Integer; pixels: array of Integer): Integer;var\n  pre, u: array of Integer;\n  f: array of array of int64;\n  i, j, len, l: Integer;\nbegin\n  SetLength(pre, n + 1);\n  SetLength(u, n + 1);\n  SetLength(f, n + 1, n + 1);\n\n  for i := 1 to n do\n  begin\n    pre[i] := 0;\n    u[i] := 0;\n  end;\n\n  for i := 1 to n do\n  begin\n    pre[i] := u[pixels[i - 1]];\n    u[pixels[i - 1]] := i;\n  end;\n\n  for i := 1 to n do\n    for j := 1 to n do\n      if i <> j then f[i, j] := 10000000\n      else f[i, j] := 0;\n  for len := 2 to n do\n    for i := 1 to n - len + 1 do\n    begin\n      j := i + len;\n      f[i, j] := f[i, j - 1] + 1;\n      l := pre[j];\n      while l >= i do\n      begin\n        if f[i, j] < f[i, l] + f[l + 1, j] then\n          f[i, j] := f[i, j]\n        else\n          f[i, j] := f[i, l] + f[l + 1, j];\n        l := pre[l];\n      end;\n    end;\n\n  minOperations := f[1, n];\nend;", "bug_with_line_numbers": "   1 | {$ASSERTIONS ON}\n   2 | function minOperations(n: Integer; pixels: array of Integer): Integer;var\n   3 |   pre, u: array of Integer;\n   4 |   f: array of array of int64;\n   5 |   i, j, len, l: Integer;\n   6 | begin\n   7 |   SetLength(pre, n + 1);\n   8 |   SetLength(u, n + 1);\n   9 |   SetLength(f, n + 1, n + 1);\n  10 |   for i := 1 to n do\n  11 |   begin\n  12 |     pre[i] := 0;\n  13 |     u[i] := 0;\n  14 |   end;\n  15 |   for i := 1 to n do\n  16 |   begin\n  17 |     pre[i] := u[pixels[i - 1]];\n  18 |     u[pixels[i - 1]] := i;\n  19 |   end;\n  20 |   for i := 1 to n do\n  21 |     for j := 1 to n do\n  22 |       if i <> j then f[i, j] := 10000000\n  23 |       else f[i, j] := 0;\n  24 |   for len := 2 to n do\n  25 |     for i := 1 to n - len + 1 do\n  26 |     begin\n  27 |       j := i + len;\n  28 |       f[i, j] := f[i, j - 1] + 1;\n  29 |       l := pre[j];\n  30 |       while l >= i do\n  31 |       begin\n  32 |         if f[i, j] < f[i, l] + f[l + 1, j] then\n  33 |           f[i, j] := f[i, j]\n  34 |         else\n  35 |           f[i, j] := f[i, l] + f[l + 1, j];\n  36 |         l := pre[l];\n  37 |       end;\n  38 |     end;\n  39 |   minOperations := f[1, n];\n  40 | end;", "fragment_lines": [27], "fragment_content": ["j := i + len;"], "test": "procedure check;\nbegin\n  Assert(minOperations(5, [1, 2, 3, 2, 1]) = 2);\n  Assert(minOperations(4, [1, 1, 2, 2]) = 1);\n  Assert(minOperations(5, [1, 2, 1, 4, 2]) = 3);\n  Assert(minOperations(5, [5, 5, 5, 5, 5]) = 0);\n  Assert(minOperations(6, [1, 1, 1, 2, 2, 2]) = 1);\n  Assert(minOperations(7, [1, 3, 3, 3, 2, 2, 2]) = 2);\n  Assert(minOperations(8, [4, 4, 4, 4, 3, 3, 3, 3]) = 1);\n  Assert(minOperations(9, [1, 2, 3, 4, 5, 6, 7, 8, 9]) = 8);\n  Assert(minOperations(10, [1, 2, 1, 2, 1, 2, 1, 2, 1, 2]) = 5);\n  Assert(minOperations(3, [3, 3, 3]) = 0);\n  Assert(minOperations(4, [2, 1, 1, 2]) = 1);\nend;\n\nbegin\n  check;\nend.", "instruction": "Observe the following faulty Pascal code\n```pascal\n{$ASSERTIONS ON}\nfunction minOperations(n: Integer; pixels: array of Integer): Integer;var\n  pre, u: array of Integer;\n  f: array of array of int64;\n  i, j, len, l: Integer;\nbegin\n  SetLength(pre, n + 1);\n  SetLength(u, n + 1);\n  SetLength(f, n + 1, n + 1);\n\n  for i := 1 to n do\n  begin\n    pre[i] := 0;\n    u[i] := 0;\n  end;\n\n  for i := 1 to n do\n  begin\n    pre[i] := u[pixels[i - 1]];\n    u[pixels[i - 1]] := i;\n  end;\n\n  for i := 1 to n do\n    for j := 1 to n do\n      if i <> j then f[i, j] := 10000000\n      else f[i, j] := 0;\n  for len := 2 to n do\n    for i := 1 to n - len + 1 do\n    begin\n      j := i + len;\n      f[i, j] := f[i, j - 1] + 1;\n      l := pre[j];\n      while l >= i do\n      begin\n        if f[i, j] < f[i, l] + f[l + 1, j] then\n          f[i, j] := f[i, j]\n        else\n          f[i, j] := f[i, l] + f[l + 1, j];\n        l := pre[l];\n      end;\n    end;\n\n  minOperations := f[1, n];\nend;\n```\nKnown, the bug code specifically exists in the following snippet:\n['j := i + len;']\nFix bugs in the given code snippet. The complete , fixed code must be placed between ```pascal```. Do not generate any test, main,example usage or check code!\n"}
{"question_id": "Pascal/33", "category": "Logic", "subtype": "condition_error", "level": "medium", "example": "Example:\n   >>> countTriplets([1, 5, 7])\n   1", "docstring": "Given an array of n distinct integers representing the heights of Kira's friends,\n   find the number of ways to choose a triplet (a, b, c) such that the greatest common divisor (GCD)\n   of the maximum and minimum values of the triplet is 1.", "canonical_solution": "{$ASSERTIONS ON}\n\nuses\n  SysUtils, Math;\nfunction countTriplets(heights: array of integer; n: integer): integer;var\n  i, j, k, minVal, maxVal, a, b, t, count: integer;\nbegin\n  count := 0;\n  for i := 0 to n - 1 do\n  begin\n    for j := i + 1 to n - 1 do\n    begin\n      for k := j + 1 to n - 1 do\n      begin\n        minVal := Min(Min(heights[i], heights[j]), heights[k]);\n        maxVal := Max(Max(heights[i], heights[j]), heights[k]);\n        a := minVal;\n        b := maxVal;\n\n        while b <> 0 do\n        begin\n          t := b;\n          b := a mod b;\n          a := t;\n        end;\n\n        if a = 1 then\n          Inc(count);\n      end;\n    end;\n  end;\n  countTriplets := count;\nend;", "buggy_code": "{$ASSERTIONS ON}\n\nuses\n  SysUtils, Math;\nfunction countTriplets(heights: array of integer; n: integer): integer;var\n  i, j, k, minVal, maxVal, a, b, t, count: integer;\nbegin\n  count := 0;\n  for i := 0 to n - 1 do\n  begin\n    for j := i + 1 to n - 1 do\n    begin\n      for k := i + 1 to n - 1 do\n      begin\n        minVal := Min(Min(heights[i], heights[j]), heights[k]);\n        maxVal := Max(Max(heights[i], heights[j]), heights[k]);\n        a := minVal;\n        b := maxVal;\n\n        while b <> 0 do\n        begin\n          t := b;\n          b := a mod b;\n          a := t;\n        end;\n\n        if a = 1 then\n          Inc(count);\n      end;\n    end;\n  end;\n  countTriplets := count;\nend;", "bug_with_line_numbers": "   1 | {$ASSERTIONS ON}\n   2 | uses\n   3 |   SysUtils, Math;\n   4 | function countTriplets(heights: array of integer; n: integer): integer;var\n   5 |   i, j, k, minVal, maxVal, a, b, t, count: integer;\n   6 | begin\n   7 |   count := 0;\n   8 |   for i := 0 to n - 1 do\n   9 |   begin\n  10 |     for j := i + 1 to n - 1 do\n  11 |     begin\n  12 |       for k := i + 1 to n - 1 do\n  13 |       begin\n  14 |         minVal := Min(Min(heights[i], heights[j]), heights[k]);\n  15 |         maxVal := Max(Max(heights[i], heights[j]), heights[k]);\n  16 |         a := minVal;\n  17 |         b := maxVal;\n  18 |         while b <> 0 do\n  19 |         begin\n  20 |           t := b;\n  21 |           b := a mod b;\n  22 |           a := t;\n  23 |         end;\n  24 |         if a = 1 then\n  25 |           Inc(count);\n  26 |       end;\n  27 |     end;\n  28 |   end;\n  29 |   countTriplets := count;\n  30 | end;", "fragment_lines": [12], "fragment_content": ["for k := i + 1 to n - 1 do"], "test": "procedure check;\nbegin\n  Assert(countTriplets([1, 5, 7], 3) = 1);\n  Assert(countTriplets([1, 6, 2, 3], 4) = 3);\n  Assert(countTriplets([16, 4, 8, 2], 4) = 0);\n  Assert(countTriplets([10, 1, 6, 7, 9, 8, 4, 3, 5, 2], 10) = 77);\n  Assert(countTriplets([4, 5, 9, 11, 14], 5) = 7);\n  Assert(countTriplets([15, 10, 6, 9, 7, 3, 12, 8, 11, 1, 2], 11) = 104);\n  Assert(countTriplets([3, 7, 11, 13], 4) = 4);\n  Assert(countTriplets([5, 12, 13, 17, 19], 5) = 10);\n  Assert(countTriplets([2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12], 11) = 87);\n  Assert(countTriplets([1, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17], 11) = 122);\nend;\n\nbegin\n  check;\nend.", "instruction": "Observe the following faulty Pascal code\n```pascal\n{$ASSERTIONS ON}\n\nuses\n  SysUtils, Math;\nfunction countTriplets(heights: array of integer; n: integer): integer;var\n  i, j, k, minVal, maxVal, a, b, t, count: integer;\nbegin\n  count := 0;\n  for i := 0 to n - 1 do\n  begin\n    for j := i + 1 to n - 1 do\n    begin\n      for k := i + 1 to n - 1 do\n      begin\n        minVal := Min(Min(heights[i], heights[j]), heights[k]);\n        maxVal := Max(Max(heights[i], heights[j]), heights[k]);\n        a := minVal;\n        b := maxVal;\n\n        while b <> 0 do\n        begin\n          t := b;\n          b := a mod b;\n          a := t;\n        end;\n\n        if a = 1 then\n          Inc(count);\n      end;\n    end;\n  end;\n  countTriplets := count;\nend;\n```\nKnown, the bug code specifically exists in the following snippet:\n['for k := i + 1 to n - 1 do']\nFix bugs in the given code snippet. The complete , fixed code must be placed between ```pascal```. Do not generate any test, main,example usage or check code!\n"}
{"question_id": "Pascal/34", "category": "Logic", "subtype": "condition_error", "level": "hard", "example": "example:\n    >>> expectedCuts(3, 3, 4)\n    3", "docstring": "Given a rectangle paper of size n x m placed on a plane Cartesian coordinate system with its bottom-left corner at (0,0) and top-right corner at (n,m), \ncalculate the expected number of operations to cut the paper so that the remaining area is less than k. \nIn each operation, a randomly chosen line parallel to the axes passes through points with Int64 coordinates and cuts the paper, \ndiscarding the bottom or right part of the paper along this line. The answer should be modulo 10^9+7.", "canonical_solution": "{$ASSERTIONS ON}\nfunction expectedCuts(n, m: Int64; k: Int64): Int64;const\n  MD = 1000000007;\nvar\n  vv: array[1..200001] of Int64; \n  i, j: Int64;\n  ans: Int64;\n\nbegin\n  vv[1] := 1;\n  for i := 2 to High(vv) do\n    vv[i] := (Int64(vv[i - MD mod i]) * (MD div i + 1)) mod MD;\n\n  if k > Int64(n) * m then\n  begin\n    expectedCuts := 0;\n    Exit;\n  end;\n\n  ans := 1;\n  for i := Int64((k + m - 1) div m) to n - 1 do\n    ans := (ans + vv[i + Int64((k + Int64(i) - 1) div Int64(i)) - 1]) mod MD;\n  for j := Int64((k + n - 1) div n) to m - 1 do\n    ans := (ans + vv[Int64((k + Int64(j) - 1) div Int64(j)) + j - 1]) mod MD;\n\n  expectedCuts := ans;\nend;", "buggy_code": "{$ASSERTIONS ON}\nfunction expectedCuts(n, m: Int64; k: Int64): Int64;const\n  MD = 1000000007;\nvar\n  vv: array[1..200001] of Int64; \n  i, j: Int64;\n  ans: Int64;\n\nbegin\n  vv[1] := 1;\n  for i := 2 to High(vv) do\n    vv[i] := (Int64(vv[i - MD mod i]) * (MD div i + 1)) mod MD;\n\n  if k > Int64(n) then\n  begin\n    expectedCuts := 0;\n    Exit;\n  end;\n\n  ans := 1;\n  for i := Int64((k + m - 1) div m) to n - 1 do\n    ans := (ans + vv[i + Int64((k + Int64(i) - 1) div Int64(i)) - 1]) mod MD;\n  for j := Int64((k + n - 1) div n) to m - 1 do\n    ans := (ans + vv[Int64((k + Int64(j) - 1) div Int64(j)) + j - 1]) mod MD;\n\n  expectedCuts := ans;\nend;", "bug_with_line_numbers": "   1 | function expectedCuts(n, m: Int64; k: Int64): Int64;const\n   2 |   MD = 1000000007;\n   3 | var\n   4 |   vv: array[1..200001] of Int64; \n   5 |   i, j: Int64;\n   6 |   ans: Int64;\n   7 | begin\n   8 |   vv[1] := 1;\n   9 |   for i := 2 to High(vv) do\n  10 |     vv[i] := (Int64(vv[i - MD mod i]) * (MD div i + 1)) mod MD;\n  11 |   if k > Int64(n) then\n  12 |   begin\n  13 |     expectedCuts := 0;\n  14 |     Exit;\n  15 |   end;\n  16 |   ans := 1;\n  17 |   for i := Int64((k + m - 1) div m) to n - 1 do\n  18 |     ans := (ans + vv[i + Int64((k + Int64(i) - 1) div Int64(i)) - 1]) mod MD;\n  19 |   for j := Int64((k + n - 1) div n) to m - 1 do\n  20 |     ans := (ans + vv[Int64((k + Int64(j) - 1) div Int64(j)) + j - 1]) mod MD;\n  21 |   expectedCuts := ans;\n  22 | end;", "fragment_lines": [11], "fragment_content": ["if k > Int64(n) then"], "test": "procedure check;\nbegin\n  Assert(expectedCuts(2, 4, 10) = 0);\n  Assert(expectedCuts(2, 4, 8) = 1);\n  Assert(expectedCuts(2, 4, 2) = 833333342);\n  Assert(expectedCuts(2, 4, 6) = 250000003);\n  Assert(expectedCuts(3, 3, 4) = 666666673);\n  Assert(expectedCuts(5, 5, 12) = 666666673);\n  Assert(expectedCuts(6, 7, 20) = 722222229);\n  Assert(expectedCuts(8, 8, 30) = 72727275);\n  Assert(expectedCuts(10, 10, 50) = 714285721);\n  Assert(expectedCuts(1, 10, 5) = 945634929);\n  Assert(expectedCuts(10, 1, 5) = 945634929);\nend;\n\nbegin\n  check;\nend.", "instruction": "Observe the following faulty Pascal code\n```pascal\n{$ASSERTIONS ON}\nfunction expectedCuts(n, m: Int64; k: Int64): Int64;const\n  MD = 1000000007;\nvar\n  vv: array[1..200001] of Int64; \n  i, j: Int64;\n  ans: Int64;\n\nbegin\n  vv[1] := 1;\n  for i := 2 to High(vv) do\n    vv[i] := (Int64(vv[i - MD mod i]) * (MD div i + 1)) mod MD;\n\n  if k > Int64(n) then\n  begin\n    expectedCuts := 0;\n    Exit;\n  end;\n\n  ans := 1;\n  for i := Int64((k + m - 1) div m) to n - 1 do\n    ans := (ans + vv[i + Int64((k + Int64(i) - 1) div Int64(i)) - 1]) mod MD;\n  for j := Int64((k + n - 1) div n) to m - 1 do\n    ans := (ans + vv[Int64((k + Int64(j) - 1) div Int64(j)) + j - 1]) mod MD;\n\n  expectedCuts := ans;\nend;\n```\nKnown, the bug code specifically exists in the following snippet:\n['if k > Int64(n) then']\nFix bugs in the given code snippet. The complete , fixed code must be placed between ```pascal```. Do not generate any test, main,example usage or check code!\n"}
{"question_id": "Pascal/35", "category": "Logic", "subtype": "condition_error", "level": "medium", "example": "Examples:\n    >>> calculate_triangle_area(3, 5, 4)\n    6.00", "docstring": "Calculates the area of a triangle given the lengths of its three sides.\n\nParameters:\n- a (real): Length of side 'a'.\n- b (real): Length of side 'b'.\n- c (real): Length of side 'c'.\n\nReturns:\n- real: If the sides can form a triangle, returns the calculated area rounded to 2 decimal places.\n         Otherwise, returns -1 indicating that the sides do not form a triangle.", "canonical_solution": "{$ASSERTIONS ON}\n\nuses \n  Math, SysUtils;\nfunction calculate_triangle_area(a, b, c: real): real;\nvar\n  s: real;begin\n  if (a + b > c) and (a + c > b) and (b + c > a) then\n  begin\n    s := (a + b + c) / 2;\n    calculate_triangle_area := sqrt(s * (s - a) * (s - b) * (s - c));\n  end\n  else\n    calculate_triangle_area := -1; (* Not a triangle *)\nend;", "buggy_code": "{$ASSERTIONS ON}\n\nuses \n  Math, SysUtils;\nfunction calculate_triangle_area(a, b, c: real): real;\nvar\n  s: real;begin\n  if (a + c > b) and (b + c > a) then\n  begin\n    s := (a + b + c) / 2;\n    calculate_triangle_area := sqrt(s * (s - a) * (s - b) * (s - c));\n  end\n  else\n    calculate_triangle_area := -1; (* Not a triangle *)\nend;", "bug_with_line_numbers": "   1 | {$ASSERTIONS ON}\n   2 | uses \n   3 |   Math, SysUtils;\n   4 | function calculate_triangle_area(a, b, c: real): real;\n   5 | var\n   6 |   s: real;begin\n   7 |   if (a + c > b) and (b + c > a) then\n   8 |   begin\n   9 |     s := (a + b + c) / 2;\n  10 |     calculate_triangle_area := sqrt(s * (s - a) * (s - b) * (s - c));\n  11 |   end\n  12 |   else\n  13 |     calculate_triangle_area := -1; (* Not a triangle *)\n  14 | end;", "fragment_lines": [7], "fragment_content": ["if (a + c > b) and (b + c > a) then"], "test": "procedure check;\nvar\n  area: real;\nbegin\n  (* Triangle with sides 3, 5, 4 should return area 6 *)\n  area := calculate_triangle_area(3, 5, 4);\n  Assert(abs(area - 6) < 1e-6);\n\n  (* Not a triangle with sides 1, 1, 4 should return -1 *)\n  area := calculate_triangle_area(1, 1, 4);\n  Assert(area = -1);\n\n  (* Triangle with sides 7, 24, 25 should return area 84 *)\n  area := calculate_triangle_area(7, 24, 25);\n  Assert(abs(area - 84) < 1e-6);\n\n  (* Triangle with sides 10.5, 6.2, 7.3 should return a calculated area *)\n  area := calculate_triangle_area(10.5, 6.2, 7.3);\n  (* For precision issues, we test if the calculated area is close enough to the expected value *)\n  Assert(abs(area - 22.15) < 1e-2);\n  \nend;\n\n(* Main *)\nbegin\n  check;\nend.", "instruction": "Observe the following faulty Pascal code\n```pascal\n{$ASSERTIONS ON}\n\nuses \n  Math, SysUtils;\nfunction calculate_triangle_area(a, b, c: real): real;\nvar\n  s: real;begin\n  if (a + c > b) and (b + c > a) then\n  begin\n    s := (a + b + c) / 2;\n    calculate_triangle_area := sqrt(s * (s - a) * (s - b) * (s - c));\n  end\n  else\n    calculate_triangle_area := -1; (* Not a triangle *)\nend;\n```\nKnown, the bug code specifically exists in the following snippet:\n['if (a + c > b) and (b + c > a) then']\nFix bugs in the given code snippet. The complete , fixed code must be placed between ```pascal```. Do not generate any test, main,example usage or check code!\n"}
{"question_id": "Pascal/36", "category": "Logic", "subtype": "condition_error", "level": "hard", "example": "Examples:\n       >>> minOperations(5, [1, 2, 3, 2, 1])\n       2", "docstring": "Given a 1 by n pixel image where each pixel has a color represented by an integer,\n   you can pick a color and change all connected pixels of the same color to the chosen color.\n   Two pixels are connected if they are adjacent and have the same color.\n   Find the minimum number of operations required to make all pixels the same color.\n\n   Note: For each color, there are at most 20 pixels of that color.", "canonical_solution": "{$ASSERTIONS ON}\nfunction minOperations(n: Integer; pixels: array of Integer): Integer;var\n  pre, u: array of Integer;\n  f: array of array of int64;\n  i, j, len, l: Integer;\nbegin\n  SetLength(pre, n + 1);\n  SetLength(u, n + 1);\n  SetLength(f, n + 1, n + 1);\n\n  for i := 1 to n do\n  begin\n    pre[i] := 0;\n    u[i] := 0;\n  end;\n\n  for i := 1 to n do\n  begin\n    pre[i] := u[pixels[i - 1]];\n    u[pixels[i - 1]] := i;\n  end;\n\n  for i := 1 to n do\n    for j := 1 to n do\n      if i <> j then f[i, j] := 10000000\n      else f[i, j] := 0;\n  for len := 2 to n do\n    for i := 1 to n - len + 1 do\n    begin\n      j := i + len - 1;\n      f[i, j] := f[i, j - 1] + 1;\n      l := pre[j];\n      while l >= i do\n      begin\n        if f[i, j] < f[i, l] + f[l + 1, j] then\n          f[i, j] := f[i, j]\n        else\n          f[i, j] := f[i, l] + f[l + 1, j];\n        l := pre[l];\n      end;\n    end;\n\n  minOperations := f[1, n];\nend;", "buggy_code": "{$ASSERTIONS ON}\nfunction minOperations(n: Integer; pixels: array of Integer): Integer;var\n  pre, u: array of Integer;\n  f: array of array of int64;\n  i, j, len, l: Integer;\nbegin\n  SetLength(pre, n + 1);\n  SetLength(u, n + 1);\n  SetLength(f, n + 1, n + 1);\n\n  for i := 1 to n do\n  begin\n    pre[i] := 0;\n    u[i] := 0;\n  end;\n\n  for i := 1 to n do\n  begin\n    pre[i] := u[pixels[i - 1]];\n    u[pixels[i - 1]] := i;\n  end;\n\n  for i := 1 to n do\n    for j := 1 to n do\n      if i <> j then f[i, j] := 10000000\n      else f[i, j] := 0;\n  for len := 1 to n do\n    for i := 1 to n - len + 1 do\n    begin\n      j := i + len - 1;\n      f[i, j] := f[i, j - 1] + 1;\n      l := pre[j];\n      while l >= i do\n      begin\n        if f[i, j] < f[i, l] + f[l + 1, j] then\n          f[i, j] := f[i, j]\n        else\n          f[i, j] := f[i, l] + f[l + 1, j];\n        l := pre[l];\n      end;\n    end;\n\n  minOperations := f[1, n];\nend;", "bug_with_line_numbers": "   1 | {$ASSERTIONS ON}\n   2 | function minOperations(n: Integer; pixels: array of Integer): Integer;var\n   3 |   pre, u: array of Integer;\n   4 |   f: array of array of int64;\n   5 |   i, j, len, l: Integer;\n   6 | begin\n   7 |   SetLength(pre, n + 1);\n   8 |   SetLength(u, n + 1);\n   9 |   SetLength(f, n + 1, n + 1);\n  10 |   for i := 1 to n do\n  11 |   begin\n  12 |     pre[i] := 0;\n  13 |     u[i] := 0;\n  14 |   end;\n  15 |   for i := 1 to n do\n  16 |   begin\n  17 |     pre[i] := u[pixels[i - 1]];\n  18 |     u[pixels[i - 1]] := i;\n  19 |   end;\n  20 |   for i := 1 to n do\n  21 |     for j := 1 to n do\n  22 |       if i <> j then f[i, j] := 10000000\n  23 |       else f[i, j] := 0;\n  24 |   for len := 1 to n do\n  25 |     for i := 1 to n - len + 1 do\n  26 |     begin\n  27 |       j := i + len - 1;\n  28 |       f[i, j] := f[i, j - 1] + 1;\n  29 |       l := pre[j];\n  30 |       while l >= i do\n  31 |       begin\n  32 |         if f[i, j] < f[i, l] + f[l + 1, j] then\n  33 |           f[i, j] := f[i, j]\n  34 |         else\n  35 |           f[i, j] := f[i, l] + f[l + 1, j];\n  36 |         l := pre[l];\n  37 |       end;\n  38 |     end;\n  39 |   minOperations := f[1, n];\n  40 | end;", "fragment_lines": [24], "fragment_content": ["for len := 1 to n do"], "test": "procedure check;\nbegin\n  Assert(minOperations(5, [1, 2, 3, 2, 1]) = 2);\n  Assert(minOperations(4, [1, 1, 2, 2]) = 1);\n  Assert(minOperations(5, [1, 2, 1, 4, 2]) = 3);\n  Assert(minOperations(5, [5, 5, 5, 5, 5]) = 0);\n  Assert(minOperations(6, [1, 1, 1, 2, 2, 2]) = 1);\n  Assert(minOperations(7, [1, 3, 3, 3, 2, 2, 2]) = 2);\n  Assert(minOperations(8, [4, 4, 4, 4, 3, 3, 3, 3]) = 1);\n  Assert(minOperations(9, [1, 2, 3, 4, 5, 6, 7, 8, 9]) = 8);\n  Assert(minOperations(10, [1, 2, 1, 2, 1, 2, 1, 2, 1, 2]) = 5);\n  Assert(minOperations(3, [3, 3, 3]) = 0);\n  Assert(minOperations(4, [2, 1, 1, 2]) = 1);\nend;\n\nbegin\n  check;\nend.", "instruction": "Observe the following faulty Pascal code\n```pascal\n{$ASSERTIONS ON}\nfunction minOperations(n: Integer; pixels: array of Integer): Integer;var\n  pre, u: array of Integer;\n  f: array of array of int64;\n  i, j, len, l: Integer;\nbegin\n  SetLength(pre, n + 1);\n  SetLength(u, n + 1);\n  SetLength(f, n + 1, n + 1);\n\n  for i := 1 to n do\n  begin\n    pre[i] := 0;\n    u[i] := 0;\n  end;\n\n  for i := 1 to n do\n  begin\n    pre[i] := u[pixels[i - 1]];\n    u[pixels[i - 1]] := i;\n  end;\n\n  for i := 1 to n do\n    for j := 1 to n do\n      if i <> j then f[i, j] := 10000000\n      else f[i, j] := 0;\n  for len := 1 to n do\n    for i := 1 to n - len + 1 do\n    begin\n      j := i + len - 1;\n      f[i, j] := f[i, j - 1] + 1;\n      l := pre[j];\n      while l >= i do\n      begin\n        if f[i, j] < f[i, l] + f[l + 1, j] then\n          f[i, j] := f[i, j]\n        else\n          f[i, j] := f[i, l] + f[l + 1, j];\n        l := pre[l];\n      end;\n    end;\n\n  minOperations := f[1, n];\nend;\n```\nKnown, the bug code specifically exists in the following snippet:\n['for len := 1 to n do']\nFix bugs in the given code snippet. The complete , fixed code must be placed between ```pascal```. Do not generate any test, main,example usage or check code!\n"}
{"question_id": "Pascal/37", "category": "Logic", "subtype": "condition_error", "level": "medium", "example": "Examples:\n      >>> countHandshakes(3, [2, 1, 0])\n      0", "docstring": "Given a sequence of student IDs entering a classroom, where the IDs range from 0 to N-1,\n  calculate the total number of handshakes that occur. Each student will shake hands with every\n  student already in the classroom with a smaller ID number. The sequence represents the order\n  in which students enter the classroom.", "canonical_solution": "{$ASSERTIONS ON}\n\nuses\n  SysUtils, Math;\n\nconst\n  N = 10000; \nfunction countHandshakes(n: Integer; order: array of Integer): Int64;const\n  MAX_N = 10000;\nvar\n  ans: Int64;\n  tr: array[1..MAX_N] of Integer;\n  i, j, x: Integer;\nbegin\n  ans := 0;\n  for i := 1 to MAX_N do\n    tr[i] := 0;\n  for i := 0 to n - 1 do\n  begin\n    x := order[i] + 1;\n    j := x - 1;\n    while j > 0 do\n    begin\n      ans := ans + tr[j];\n      j := j - (j and -j);\n    end;\n    j := x;\n    while j <= n do\n    begin\n      Inc(tr[j]);\n      j := j + (j and -j);\n    end;\n  end;\n  countHandshakes := ans;\nend;", "buggy_code": "{$ASSERTIONS ON}\n\nuses\n  SysUtils, Math;\n\nconst\n  N = 10000;\nfunction countHandshakes(n: Integer; order: array of Integer): Int64;const\n  MAX_N = 10000;\nvar\n  ans: Int64;\n  tr: array[1..MAX_N] of Integer;\n  i, j, x: Integer;\nbegin\n  ans := 0;\n  for i := 1 to MAX_N do\n    tr[i] := 0;\n  for i := 0 to n - 1 do\n  begin\n    x := order[i] + 1;\n    j := x - 1;\n    while j >= 0 do\n    begin\n      ans := ans + tr[j];\n      j := j - (j and -j);\n    end;\n    j := x;\n    while j <= n do\n    begin\n      Inc(tr[j]);\n      j := j + (j and -j);\n    end;\n  end;\n  countHandshakes := ans;\nend;", "bug_with_line_numbers": "   1 | {$ASSERTIONS ON}\n   2 | uses\n   3 |   SysUtils, Math;\n   4 | const\n   5 |   N = 10000;\n   6 | function countHandshakes(n: Integer; order: array of Integer): Int64;const\n   7 |   MAX_N = 10000;\n   8 | var\n   9 |   ans: Int64;\n  10 |   tr: array[1..MAX_N] of Integer;\n  11 |   i, j, x: Integer;\n  12 | begin\n  13 |   ans := 0;\n  14 |   for i := 1 to MAX_N do\n  15 |     tr[i] := 0;\n  16 |   for i := 0 to n - 1 do\n  17 |   begin\n  18 |     x := order[i] + 1;\n  19 |     j := x - 1;\n  20 |     while j >= 0 do\n  21 |     begin\n  22 |       ans := ans + tr[j];\n  23 |       j := j - (j and -j);\n  24 |     end;\n  25 |     j := x;\n  26 |     while j <= n do\n  27 |     begin\n  28 |       Inc(tr[j]);\n  29 |       j := j + (j and -j);\n  30 |     end;\n  31 |   end;\n  32 |   countHandshakes := ans;\n  33 | end;", "fragment_lines": [20], "fragment_content": ["while j >= 0 do"], "test": "procedure check;\nbegin\n  Assert(countHandshakes(4, [2, 1, 3, 0]) = 2);\n  Assert(countHandshakes(6, [0, 1, 2, 3, 4, 5]) = 15);\n  Assert(countHandshakes(3, [1, 2, 0]) = 1);\n  Assert(countHandshakes(4, [3, 2, 1, 0]) = 0);\n  Assert(countHandshakes(4, [0, 1, 2, 3]) = 6);\n  Assert(countHandshakes(6, [5, 4, 3, 2, 1, 0]) = 0);\n  Assert(countHandshakes(4, [0, 2, 1, 3]) = 5);\n  Assert(countHandshakes(5, [3, 1, 4, 2, 0]) = 3);\n  Assert(countHandshakes(4, [1, 0, 3, 2]) = 4);\n  Assert(countHandshakes(3, [2, 0, 1]) = 1);\n  Assert(countHandshakes(5, [1, 3, 0, 2, 4]) = 7);\n  Assert(countHandshakes(5, [4, 3, 2, 1, 0]) = 0);\nend;\n\nbegin\n  check;\nend.", "instruction": "Observe the following faulty Pascal code\n```pascal\n{$ASSERTIONS ON}\n\nuses\n  SysUtils, Math;\n\nconst\n  N = 10000;\nfunction countHandshakes(n: Integer; order: array of Integer): Int64;const\n  MAX_N = 10000;\nvar\n  ans: Int64;\n  tr: array[1..MAX_N] of Integer;\n  i, j, x: Integer;\nbegin\n  ans := 0;\n  for i := 1 to MAX_N do\n    tr[i] := 0;\n  for i := 0 to n - 1 do\n  begin\n    x := order[i] + 1;\n    j := x - 1;\n    while j >= 0 do\n    begin\n      ans := ans + tr[j];\n      j := j - (j and -j);\n    end;\n    j := x;\n    while j <= n do\n    begin\n      Inc(tr[j]);\n      j := j + (j and -j);\n    end;\n  end;\n  countHandshakes := ans;\nend;\n```\nKnown, the bug code specifically exists in the following snippet:\n['while j >= 0 do']\nFix bugs in the given code snippet. The complete , fixed code must be placed between ```pascal```. Do not generate any test, main,example usage or check code!\n"}
{"question_id": "Pascal/38", "category": "Logic", "subtype": "condition_error", "level": "medium", "example": "Examples:\n>>> count_valid_coin_toss_sequences(1)\n2", "docstring": "Function that counts the number of valid coin toss sequences\nwithout consecutive heads. It calculates possible combinations\nfor a given number of tosses.\n\nParameters:\n- n: an integer representing the number of coin tosses.\n\nReturns:\nThe count of valid sequences as an unsigned 64-bit integer.", "canonical_solution": "{$ASSERTIONS ON}\nfunction count_valid_coin_toss_sequences(n: integer): int64;var\n  a: array[0..40, 0..1] of int64;\n  i: integer;\nbegin\n  a[1][0] := 1;\n  a[1][1] := 1;\n\n  for i := 2 to n do\n  begin\n    a[i][0] := a[i - 1][0] + a[i - 1][1];\n    a[i][1] := a[i - 1][0];\n  end;\n\n  count_valid_coin_toss_sequences := a[n][0] + a[n][1];\nend;", "buggy_code": "{$ASSERTIONS ON}\nfunction count_valid_coin_toss_sequences(n: integer): int64;var\n  a: array[0..40, 0..1] of int64;\n  i: integer;\nbegin\n  a[1][0] := 1;\n  a[1][1] := 1;\n\n  for i := 1 to n do\n  begin\n    a[i][0] := a[i - 1][0] + a[i - 1][1];\n    a[i][1] := a[i - 1][0];\n  end;\n\n  count_valid_coin_toss_sequences := a[n][0] + a[n][1];\nend;", "bug_with_line_numbers": "   1 | {$ASSERTIONS ON}\n   2 | function count_valid_coin_toss_sequences(n: integer): int64;var\n   3 |   a: array[0..40, 0..1] of int64;\n   4 |   i: integer;\n   5 | begin\n   6 |   a[1][0] := 1;\n   7 |   a[1][1] := 1;\n   8 |   for i := 1 to n do\n   9 |   begin\n  10 |     a[i][0] := a[i - 1][0] + a[i - 1][1];\n  11 |     a[i][1] := a[i - 1][0];\n  12 |   end;\n  13 |   count_valid_coin_toss_sequences := a[n][0] + a[n][1];\n  14 | end;", "fragment_lines": [8], "fragment_content": ["for i := 1 to n do"], "test": "procedure check;\nbegin\n  Assert(count_valid_coin_toss_sequences(1) = 2);\n  Assert(count_valid_coin_toss_sequences(2) = 3);\n  Assert(count_valid_coin_toss_sequences(3) = 5);\n  Assert(count_valid_coin_toss_sequences(4) = 8);\n  Assert(count_valid_coin_toss_sequences(5) = 13);\n  Assert(count_valid_coin_toss_sequences(40) = 267914296);\n  Assert(count_valid_coin_toss_sequences(39) = 165580141);\n  Assert(count_valid_coin_toss_sequences(38) = 102334155);\n\n  (* Uncomment the line below to add output for successful tests *)\n  // WriteLn('All tests passed!');\nend;\n\nbegin\n  check;\nend.", "instruction": "Observe the following faulty Pascal code\n```pascal\n{$ASSERTIONS ON}\nfunction count_valid_coin_toss_sequences(n: integer): int64;var\n  a: array[0..40, 0..1] of int64;\n  i: integer;\nbegin\n  a[1][0] := 1;\n  a[1][1] := 1;\n\n  for i := 1 to n do\n  begin\n    a[i][0] := a[i - 1][0] + a[i - 1][1];\n    a[i][1] := a[i - 1][0];\n  end;\n\n  count_valid_coin_toss_sequences := a[n][0] + a[n][1];\nend;\n```\nKnown, the bug code specifically exists in the following snippet:\n['for i := 1 to n do']\nFix bugs in the given code snippet. The complete , fixed code must be placed between ```pascal```. Do not generate any test, main,example usage or check code!\n"}
{"question_id": "Pascal/39", "category": "Logic", "subtype": "condition_error", "level": "hard", "example": "Examples:\n    >>> countPermutations(2, 1, [1, 2])\n    2", "docstring": "Given a permutation q of n elements and an integer k, find the number of permutations p of n elements such that f(p) = q, where f(p) is the lexicographically smallest permutation that can be obtained by dividing p into exactly k non-empty contiguous segments and sorting each segment(that is, choose $ k-1 $ breakpoints $ 1\\le x_1 < x_2 < \\cdots < x_{k-1} < n $, and divide it into $ [1, x_1], (x_1, x_2], \\cdots, (x_{k-1}, n] $). The result should be modulo 998244353.", "canonical_solution": "{$ASSERTIONS ON}\nuses\n  SysUtils;\nfunction countPermutations(n, k: int64; qq: array of int64): int64;var\n  P, i, j, m, ans, c, kk: int64;\n  q, jc, f: array[0..504] of int64;\n  dp: array[0..504, 0..504] of int64;\nbegin\n  P := 998244353;\n  ans := 0;\n  for i := 0 to n+2 do\n  begin\n    q[i] := 0;\n    jc[i] := 0;\n    f[i] := 0;\n    for j := 0 to n+2 do\n      dp[i][j] := 0;\n  end;\n\n  for i := 1 to n do\n    q[i] := qq[i - 1];\n  dp[0][0] := 1;\n  f[0] := 1;\n  jc[0] := 1;\n  for i := 1 to n do\n    jc[i] := (jc[i - 1] * i) mod P;\n  for i := 1 to n do\n  begin\n    f[i] := jc[i];\n    for j := 1 to i - 1 do\n      f[i] := (f[i] + P - (f[j] * jc[i - j]) mod P) mod P;\n  end;\n  for i := 1 to n do\n  begin\n    for j := 0 to i - 1 do\n      for kk := 1 to n do\n        dp[i][kk] := (dp[i][kk] + (dp[j][kk - 1] * f[i - j]) mod P) mod P;\n  end;\n  m := 0;\n  for i := 1 to n do\n    if q[i] > q[i + 1] then\n    begin\n      m := i;\n      break;\n    end;\n  if m = n then\n  begin\n    for i := k to n do\n    begin\n      ans := (ans + dp[n][i]) mod P;\n    end\n  end\n  else\n  begin\n    for i := m + 1 to n do\n    begin\n      if ((i xor (m + 1) <> 0) and ((q[i - 1] > q[i]) or (q[i] < q[m]))) then\n        break;\n      c := k + i - n - 1;\n      if c >= 0 then\n        ans := (ans + (dp[m][c] * jc[i - m - 1]) mod P) mod P;\n    end;\n  end;\n  countPermutations := ans;\nend;", "buggy_code": "{$ASSERTIONS ON}\nuses\n  SysUtils;\nfunction countPermutations(n, k: int64; qq: array of int64): int64;var\n  P, i, j, m, ans, c, kk: int64;\n  q, jc, f: array[0..504] of int64;\n  dp: array[0..504, 0..504] of int64;\nbegin\n  P := 998244353;\n  ans := 0;\n  for i := 0 to n+2 do\n  begin\n    q[i] := 0;\n    jc[i] := 0;\n    f[i] := 0;\n    for j := 0 to n+2 do\n      dp[i][j] := 0;\n  end;\n\n  for i := 1 to n do\n    q[i] := qq[i - 1];\n  dp[0][0] := 1;\n  f[0] := 1;\n  jc[0] := 1;\n  for i := 1 to n do\n    jc[i] := (jc[i - 1] * i) mod P;\n  for i := 1 to n do\n  begin\n    f[i] := jc[i];\n    for j := 1 to i - 1 do\n      f[i] := (f[i] + P - (f[j] * jc[i - j]) mod P) mod P;\n  end;\n  for i := 1 to n do\n  begin\n    for j := 0 to i - 1 do\n      for kk := 1 to n do\n        dp[i][kk] := (dp[i][kk] + (dp[j][kk - 1] * f[i - j]) mod P) mod P;\n  end;\n  m := 0;\n  for i := 1 to n do\n    if q[i] > q[i + 1] then\n    begin\n      m := i;\n      break;\n    end;\n  if m = n then\n  begin\n    for i := k to n do\n    begin\n      ans := (ans + dp[n][i]) mod P;\n    end\n  end\n  else\n  begin\n    for i := m + 1 to n do\n    begin\n      if ((i xor (m + 1) <> 0) and ((q[i - 1] > q[i]) or (q[i] > q[m]))) then\n        break;\n      c := k + i - n - 1;\n      if c >= 0 then\n        ans := (ans + (dp[m][c] * jc[i - m - 1]) mod P) mod P;\n    end;\n  end;\n  countPermutations := ans;\nend;", "bug_with_line_numbers": "   1 | {$ASSERTIONS ON}\n   2 | uses\n   3 |   SysUtils;\n   4 | function countPermutations(n, k: int64; qq: array of int64): int64;var\n   5 |   P, i, j, m, ans, c, kk: int64;\n   6 |   q, jc, f: array[0..504] of int64;\n   7 |   dp: array[0..504, 0..504] of int64;\n   8 | begin\n   9 |   P := 998244353;\n  10 |   ans := 0;\n  11 |   for i := 0 to n+2 do\n  12 |   begin\n  13 |     q[i] := 0;\n  14 |     jc[i] := 0;\n  15 |     f[i] := 0;\n  16 |     for j := 0 to n+2 do\n  17 |       dp[i][j] := 0;\n  18 |   end;\n  19 |   for i := 1 to n do\n  20 |     q[i] := qq[i - 1];\n  21 |   dp[0][0] := 1;\n  22 |   f[0] := 1;\n  23 |   jc[0] := 1;\n  24 |   for i := 1 to n do\n  25 |     jc[i] := (jc[i - 1] * i) mod P;\n  26 |   for i := 1 to n do\n  27 |   begin\n  28 |     f[i] := jc[i];\n  29 |     for j := 1 to i - 1 do\n  30 |       f[i] := (f[i] + P - (f[j] * jc[i - j]) mod P) mod P;\n  31 |   end;\n  32 |   for i := 1 to n do\n  33 |   begin\n  34 |     for j := 0 to i - 1 do\n  35 |       for kk := 1 to n do\n  36 |         dp[i][kk] := (dp[i][kk] + (dp[j][kk - 1] * f[i - j]) mod P) mod P;\n  37 |   end;\n  38 |   m := 0;\n  39 |   for i := 1 to n do\n  40 |     if q[i] > q[i + 1] then\n  41 |     begin\n  42 |       m := i;\n  43 |       break;\n  44 |     end;\n  45 |   if m = n then\n  46 |   begin\n  47 |     for i := k to n do\n  48 |     begin\n  49 |       ans := (ans + dp[n][i]) mod P;\n  50 |     end\n  51 |   end\n  52 |   else\n  53 |   begin\n  54 |     for i := m + 1 to n do\n  55 |     begin\n  56 |       if ((i xor (m + 1) <> 0) and ((q[i - 1] > q[i]) or (q[i] > q[m]))) then\n  57 |         break;\n  58 |       c := k + i - n - 1;\n  59 |       if c >= 0 then\n  60 |         ans := (ans + (dp[m][c] * jc[i - m - 1]) mod P) mod P;\n  61 |     end;\n  62 |   end;\n  63 |   countPermutations := ans;\n  64 | end;", "fragment_lines": [56], "fragment_content": ["if ((i xor (m + 1) <> 0) and ((q[i - 1] > q[i]) or (q[i] > q[m]))) then"], "test": "procedure testCountPermutations;\nvar\n  q1: array[0..1] of int64 = (1, 2);\n  q2:array[0..2] of int64= (3, 1, 2);\n  q3:array[0..5] of int64= (1, 2, 3, 6, 5, 4);\n  q4:array[0..5] of int64= (1, 2, 3, 4, 5, 6);\n  q5:array[0..5] of int64= (1, 2, 5, 3, 4, 5);\n  q6:array[0..8] of int64= (1, 2, 3, 4, 5, 6, 7, 8, 9);\n  q7:array[0..8] of int64= (1, 2, 3, 4, 5, 6, 7, 9, 8);\nbegin\n  Assert(countPermutations(2, 1, q1) = 2);\n  Assert(countPermutations(3, 3, q2) = 1);\n  Assert(countPermutations(6, 3, q3) = 13);\n  Assert(countPermutations(6, 1, q4) = 720); \n  Assert(countPermutations(6, 3, q5) = 0); \n  Assert(countPermutations(9, 9, q6) = 1); \n  Assert(countPermutations(9, 2, q7) = 29093);\nend;\n\nbegin\n  testCountPermutations;\nend.", "instruction": "Observe the following faulty Pascal code\n```pascal\n{$ASSERTIONS ON}\nuses\n  SysUtils;\nfunction countPermutations(n, k: int64; qq: array of int64): int64;var\n  P, i, j, m, ans, c, kk: int64;\n  q, jc, f: array[0..504] of int64;\n  dp: array[0..504, 0..504] of int64;\nbegin\n  P := 998244353;\n  ans := 0;\n  for i := 0 to n+2 do\n  begin\n    q[i] := 0;\n    jc[i] := 0;\n    f[i] := 0;\n    for j := 0 to n+2 do\n      dp[i][j] := 0;\n  end;\n\n  for i := 1 to n do\n    q[i] := qq[i - 1];\n  dp[0][0] := 1;\n  f[0] := 1;\n  jc[0] := 1;\n  for i := 1 to n do\n    jc[i] := (jc[i - 1] * i) mod P;\n  for i := 1 to n do\n  begin\n    f[i] := jc[i];\n    for j := 1 to i - 1 do\n      f[i] := (f[i] + P - (f[j] * jc[i - j]) mod P) mod P;\n  end;\n  for i := 1 to n do\n  begin\n    for j := 0 to i - 1 do\n      for kk := 1 to n do\n        dp[i][kk] := (dp[i][kk] + (dp[j][kk - 1] * f[i - j]) mod P) mod P;\n  end;\n  m := 0;\n  for i := 1 to n do\n    if q[i] > q[i + 1] then\n    begin\n      m := i;\n      break;\n    end;\n  if m = n then\n  begin\n    for i := k to n do\n    begin\n      ans := (ans + dp[n][i]) mod P;\n    end\n  end\n  else\n  begin\n    for i := m + 1 to n do\n    begin\n      if ((i xor (m + 1) <> 0) and ((q[i - 1] > q[i]) or (q[i] > q[m]))) then\n        break;\n      c := k + i - n - 1;\n      if c >= 0 then\n        ans := (ans + (dp[m][c] * jc[i - m - 1]) mod P) mod P;\n    end;\n  end;\n  countPermutations := ans;\nend;\n```\nKnown, the bug code specifically exists in the following snippet:\n['if ((i xor (m + 1) <> 0) and ((q[i - 1] > q[i]) or (q[i] > q[m]))) then']\nFix bugs in the given code snippet. The complete , fixed code must be placed between ```pascal```. Do not generate any test, main,example usage or check code!\n"}
{"question_id": "Pascal/40", "category": "Logic", "subtype": "operation_error", "level": "medium", "example": "Example:\n    >>> maxModeSum(3, [1, 2, 3])\n    Should return 17\n    An example sequence that reaches this maximum value is (3,2,3,1,2,2).", "docstring": "Given n positive integers representing the count of each number from 1 to n, \nfind the maximum sum of the mode for all prefixes of a sequence constructed from these numbers. \nThe mode is the largest number among the most frequent elements in a sequence.", "canonical_solution": "{$ASSERTIONS ON}\nfunction maxModeSum(n: int64; const counts: array of int64): int64;var\n  f: array[0..99999] of int64;\n  mx, i: int64;\n  ans : int64;\nbegin\n  ans := 0;\n  mx := 0;\n  for i := 0 to n do f[i] := 0;\n\n  for i := n downto 1 do\n  begin\n    while mx < counts[i - 1] do\n    begin\n      mx := mx + 1;\n      f[mx] := f[mx - 1] + i;\n    end;\n    ans := ans + f[counts[i - 1]];\n  end;\n  maxModeSum := ans;\nend;", "buggy_code": "{$ASSERTIONS ON}\nfunction maxModeSum(n: int64; const counts: array of int64): int64;var\n  f: array[0..99999] of int64;\n  mx, i: int64;\n  ans : int64;\nbegin\n  ans := 0;\n  mx := 0;\n  for i := 0 to n do f[i] := 0;\n\n  for i := n to 1 do\n  begin\n    while mx < counts[i - 1] do\n    begin\n      mx := mx + 1;\n      f[mx] := f[mx - 1] + i;\n    end;\n    ans := ans + f[counts[i - 1]];\n  end;\n  maxModeSum := ans;\nend;", "bug_with_line_numbers": "   1 | function maxModeSum(n: int64; const counts: array of int64): int64;var\n   2 |   f: array[0..99999] of int64;\n   3 |   mx, i: int64;\n   4 |   ans : int64;\n   5 | begin\n   6 |   ans := 0;\n   7 |   mx := 0;\n   8 |   for i := 0 to n do f[i] := 0;\n   9 |   for i := n to 1 do\n  10 |   begin\n  11 |     while mx < counts[i - 1] do\n  12 |     begin\n  13 |       mx := mx + 1;\n  14 |       f[mx] := f[mx - 1] + i;\n  15 |     end;\n  16 |     ans := ans + f[counts[i - 1]];\n  17 |   end;\n  18 |   maxModeSum := ans;\n  19 | end;", "fragment_lines": [9], "fragment_content": ["for i := n to 1 do"], "test": "procedure check;\nbegin\n  Assert(maxModeSum(3, [1, 3, 2]) = 17);\n  Assert(maxModeSum(4, [4, 1, 2, 3]) = 37);\n  Assert(maxModeSum(2, [1, 1]) = 4);\n  Assert(maxModeSum(5, [1, 2, 3, 4, 5]) = 75);\n  Assert(maxModeSum(1, [100000]) = 100000);\n  Assert(maxModeSum(5, [5, 3, 2, 4, 1]) = 62);\n  Assert(maxModeSum(3, [100000, 100000, 100000]) = 900000);\n  Assert(maxModeSum(3, [2, 2, 5]) = 27);\n  Assert(maxModeSum(4, [4, 4, 4, 4]) = 64);\n  Assert(maxModeSum(6, [1, 2, 3, 4, 5, 6]) = 126);\n  Assert(maxModeSum(3, [3, 1, 2]) = 16);\nend;\n\n(* Main *)\nbegin\n  check;\nend.", "instruction": "Observe the following faulty Pascal code\n```pascal\n{$ASSERTIONS ON}\nfunction maxModeSum(n: int64; const counts: array of int64): int64;var\n  f: array[0..99999] of int64;\n  mx, i: int64;\n  ans : int64;\nbegin\n  ans := 0;\n  mx := 0;\n  for i := 0 to n do f[i] := 0;\n\n  for i := n to 1 do\n  begin\n    while mx < counts[i - 1] do\n    begin\n      mx := mx + 1;\n      f[mx] := f[mx - 1] + i;\n    end;\n    ans := ans + f[counts[i - 1]];\n  end;\n  maxModeSum := ans;\nend;\n```\nKnown, the bug code specifically exists in the following snippet:\n['for i := n to 1 do']\nFix bugs in the given code snippet. The complete , fixed code must be placed between ```pascal```. Do not generate any test, main,example usage or check code!\n"}
{"question_id": "Pascal/41", "category": "Logic", "subtype": "operation_error", "level": "medium", "example": "Examples:\n    >>> makeEqualAgain(3, [1, 2, 1])\n    1\n    >>> makeEqualAgain(5, [5, 5, 1, 5, 5])\n    1", "docstring": "You are given an array a of n integers. You can perform at most one operation where \nyou select three integers i, j, x (1 <= i <= j <= n) and replace all elements from \na[i] to a[j] with x, at a cost of (j - i + 1). Find the minimum cost to make all \nelements in the array equal.", "canonical_solution": "{$ASSERTIONS ON}\n\nuses\n  SysUtils;\nfunction makeEqualAgain(n: Integer; a: array of Integer): Integer;var\n  p, q, c, d, k: Integer;\nbegin\n  k := n;\n  p := 1;\n  q := 0;\n  for p := 1 to k - 1 do begin\n    if a[p] <> a[p - 1] then\n      Break;\n  end;\n  for q := k - 1 downto p - 1 do begin\n    if a[q] <> a[p - 1] then\n      Break;\n  end;\n  for d := k - 2 downto 0 do begin\n    if a[d] <> a[d + 1] then\n      Break;\n  end;\n  for c := 0 to d - 1 do begin\n    if a[c] <> a[c + 1] then\n      Break;\n  end;\n  if q - p + 1 < d - c + 1 then\n    makeEqualAgain := q - p + 1\n  else\n    makeEqualAgain := d - c + 1;\nend;", "buggy_code": "{$ASSERTIONS ON}\n\nuses\n  SysUtils;\nfunction makeEqualAgain(n: Integer; a: array of Integer): Integer;var\n  p, q, c, d, k: Integer;\nbegin\n  k := n;\n  p := 1;\n  q := 0;\n  for p := 1 to k - 1 do begin\n    if a[p] != a[p - 1] then\n      Break;\n  end;\n  for q := k - 1 downto p - 1 do begin\n    if a[q] <> a[p - 1] then\n      Break;\n  end;\n  for d := k - 2 downto 0 do begin\n    if a[d] <> a[d + 1] then\n      Break;\n  end;\n  for c := 0 to d - 1 do begin\n    if a[c] <> a[c + 1] then\n      Break;\n  end;\n  if q - p + 1 < d - c + 1 then\n    makeEqualAgain := q - p + 1\n  else\n    makeEqualAgain := d - c + 1;\nend;", "bug_with_line_numbers": "   1 | {$ASSERTIONS ON}\n   2 | uses\n   3 |   SysUtils;\n   4 | function makeEqualAgain(n: Integer; a: array of Integer): Integer;var\n   5 |   p, q, c, d, k: Integer;\n   6 | begin\n   7 |   k := n;\n   8 |   p := 1;\n   9 |   q := 0;\n  10 |   for p := 1 to k - 1 do begin\n  11 |     if a[p] != a[p - 1] then\n  12 |       Break;\n  13 |   end;\n  14 |   for q := k - 1 downto p - 1 do begin\n  15 |     if a[q] <> a[p - 1] then\n  16 |       Break;\n  17 |   end;\n  18 |   for d := k - 2 downto 0 do begin\n  19 |     if a[d] <> a[d + 1] then\n  20 |       Break;\n  21 |   end;\n  22 |   for c := 0 to d - 1 do begin\n  23 |     if a[c] <> a[c + 1] then\n  24 |       Break;\n  25 |   end;\n  26 |   if q - p + 1 < d - c + 1 then\n  27 |     makeEqualAgain := q - p + 1\n  28 |   else\n  29 |     makeEqualAgain := d - c + 1;\n  30 | end;", "fragment_lines": [11], "fragment_content": ["if a[p] != a[p - 1] then"], "test": "procedure check;\nvar\n  test1 :array[0..2] of Integer = (1, 2, 1);\n  test2 :array[0..4] of Integer= (5, 5, 1, 5, 5);\n  test3 :array[0..3] of Integer= (1, 1, 1, 1);\n  test4 :array[0..5] of Integer= (2, 2, 2, 3, 2, 2);\n  test5 :array[0..0] of Integer= (1);\n  test6 :array[0..1] of Integer= (1, 2);\n  test7 :array[0..3] of Integer= (1, 2, 2, 1);\n  test8 :array[0..6] of Integer= (4, 4, 4, 3, 3, 4, 4);\n  test9 :array[0..5] of Integer= (5, 4, 4, 4, 5, 5);\n  test10 :array[0..6] of Integer=(1, 2, 1, 2, 1, 2, 1);\n  a1 :array[0..5] of Integer= (1, 2, 3, 4, 5, 1);\n  a2 :array[0..6] of Integer= (1, 1, 1, 1, 1, 1, 1);\n  a3 :array[0..7] of Integer= (8, 8, 8, 1, 2, 8, 8, 8);\n  a4 :array[0..2] of Integer= (1, 2, 3);\n  a5 :array[0..6] of Integer= (4, 3, 2, 7, 1, 1, 3);\n  a6 :array[0..8] of Integer= (9, 9, 2, 9, 2, 5, 5, 5, 3);\nbegin\n  Assert(makeEqualAgain(6, a1) = 4);\n  Assert(makeEqualAgain(7, a2) = 0);\n  Assert(makeEqualAgain(8, a3) = 2);\n  Assert(makeEqualAgain(3, a4) = 2);\n  Assert(makeEqualAgain(7, a5) = 6);\n  Assert(makeEqualAgain(9, a6) = 7);\n\n  Assert(makeEqualAgain(3, test1) = 1);\n  Assert(makeEqualAgain(5, test2) = 1);\n  Assert(makeEqualAgain(4, test3) = 0);\n  Assert(makeEqualAgain(6, test4) = 1);\n  Assert(makeEqualAgain(1, test5) = 0);\n  Assert(makeEqualAgain(2, test6) = 1);\n  Assert(makeEqualAgain(4, test7) = 2);\n  Assert(makeEqualAgain(7, test8) = 2);\n  Assert(makeEqualAgain(6, test9) = 3);\n  Assert(makeEqualAgain(7, test10) = 5);\nend;\n\nbegin\n  check;\nend.", "instruction": "Observe the following faulty Pascal code\n```pascal\n{$ASSERTIONS ON}\n\nuses\n  SysUtils;\nfunction makeEqualAgain(n: Integer; a: array of Integer): Integer;var\n  p, q, c, d, k: Integer;\nbegin\n  k := n;\n  p := 1;\n  q := 0;\n  for p := 1 to k - 1 do begin\n    if a[p] != a[p - 1] then\n      Break;\n  end;\n  for q := k - 1 downto p - 1 do begin\n    if a[q] <> a[p - 1] then\n      Break;\n  end;\n  for d := k - 2 downto 0 do begin\n    if a[d] <> a[d + 1] then\n      Break;\n  end;\n  for c := 0 to d - 1 do begin\n    if a[c] <> a[c + 1] then\n      Break;\n  end;\n  if q - p + 1 < d - c + 1 then\n    makeEqualAgain := q - p + 1\n  else\n    makeEqualAgain := d - c + 1;\nend;\n```\nKnown, the bug code specifically exists in the following snippet:\n['if a[p] != a[p - 1] then']\nFix bugs in the given code snippet. The complete , fixed code must be placed between ```pascal```. Do not generate any test, main,example usage or check code!\n"}
{"question_id": "Pascal/42", "category": "Logic", "subtype": "type_error", "level": "medium", "example": "Examples:\n      >>> classify_integer('24')\n      6", "docstring": "Classify the integer x as follows:\n    - If x is a single-digit number, x belongs to its own class.\n    - Otherwise, sum the digits of x, get a new x, and continue this process iteratively \n      until the class is determined.\n\n  @param x: The string representation of the integer to be classified.\n  @return: The class to which the integer x belongs.", "canonical_solution": "{$ASSERTIONS ON}\nuses\n  SysUtils, StrUtils;\nfunction classify_integer(x: string): Integer;\nvar\n  n, i, a, t: Integer;begin\n  n := 0;\n  for i := 1 to Length(x) do\n    n := n + Ord(x[i]) - Ord('0');\n  while n > 9 do\n  begin\n    t := n;\n    a := 0;\n    while t > 0 do\n    begin\n      a := a + (t mod 10);\n      t := t div 10;\n    end;\n    n := a;\n  end;\n  classify_integer := n;\nend;", "buggy_code": "{$ASSERTIONS ON}\nuses\n  SysUtils, StrUtils;\nfunction classify_integer(x: string): Integer;\nvar\n  n, i, a, t: Integer;begin\n  n := 0;\n  for i := 1 to Length(x) do\n    n := n + x[i];\n  while n > 9 do\n  begin\n    t := n;\n    a := 0;\n    while t > 0 do\n    begin\n      a := a + (t mod 10);\n      t := t div 10;\n    end;\n    n := a;\n  end;\n  classify_integer := n;\nend;", "bug_with_line_numbers": "   1 | {$ASSERTIONS ON}\n   2 | uses\n   3 |   SysUtils, StrUtils;\n   4 | function classify_integer(x: string): Integer;\n   5 | var\n   6 |   n, i, a, t: Integer;begin\n   7 |   n := 0;\n   8 |   for i := 1 to Length(x) do\n   9 |     n := n + x[i];\n  10 |   while n > 9 do\n  11 |   begin\n  12 |     t := n;\n  13 |     a := 0;\n  14 |     while t > 0 do\n  15 |     begin\n  16 |       a := a + (t mod 10);\n  17 |       t := t div 10;\n  18 |     end;\n  19 |     n := a;\n  20 |   end;\n  21 |   classify_integer := n;\n  22 | end;", "fragment_lines": [9], "fragment_content": ["n := n + x[i];"], "test": "procedure check;\nbegin\n  Assert(classify_integer('24') = 6);\n  Assert(classify_integer('39') = 3);\n  Assert(classify_integer('123456789') = 9);\n  Assert(classify_integer('123456789012345678901234567890') = 9);\n  Assert(classify_integer('12345') = 6);\n  Assert(classify_integer('999999999') = 9);\nend;\n\nbegin\n  check;\nend.", "instruction": "Observe the following faulty Pascal code\n```pascal\n{$ASSERTIONS ON}\nuses\n  SysUtils, StrUtils;\nfunction classify_integer(x: string): Integer;\nvar\n  n, i, a, t: Integer;begin\n  n := 0;\n  for i := 1 to Length(x) do\n    n := n + x[i];\n  while n > 9 do\n  begin\n    t := n;\n    a := 0;\n    while t > 0 do\n    begin\n      a := a + (t mod 10);\n      t := t div 10;\n    end;\n    n := a;\n  end;\n  classify_integer := n;\nend;\n```\nKnown, the bug code specifically exists in the following snippet:\n['n := n + x[i];']\nFix bugs in the given code snippet. The complete , fixed code must be placed between ```pascal```. Do not generate any test, main,example usage or check code!\n"}
{"question_id": "Pascal/43", "category": "Logic", "subtype": "type_error", "level": "medium", "example": "Example usage:\n  Assert(decodeNumbers('0000') = 4);", "docstring": "Decode a series of numbers to reveal the pattern and understand the actual values\n  each digit represents.\n  0000=4 8888=8 1234=1 5678=3 9012=2 1357=0 2468=4\n  \n  Parameters:\n  - data_str: A string representing a series of numbers. Length does not exceed 100.\n  \n  Returns:\n  integer: The result of each data string corresponding to the right-hand side of the equation.", "canonical_solution": "{$ASSERTIONS ON}\nfunction decodeNumbers(data_str: AnsiString): Integer;var\n  a: array[0..9] of Integer = (1, 0, 0, 0, 1, 0, 1, 0, 2, 1);\n  ans, i: Integer;\nbegin\n  ans := 0;\n  for i := 1 to Length(data_str) do\n  begin\n    ans := ans + a[Ord(data_str[i]) - Ord('0')];\n  end;\n  decodeNumbers := ans;\nend;", "buggy_code": "{$ASSERTIONS ON}\nfunction decodeNumbers(data_str: AnsiString): Integer;var\n  a: array[0..9] of Integer = (1, 0, 0, 0, 1, 0, 1, 0, 2, 1);\n  ans, i: Integer;\nbegin\n  ans := 0;\n  for i := 1 to Length(data_str) do\n  begin\n    ans := ans + a[data_str[i] - '0'];\n  end;\n  decodeNumbers := ans;\nend;", "bug_with_line_numbers": "   1 | {$ASSERTIONS ON}\n   2 | function decodeNumbers(data_str: AnsiString): Integer;var\n   3 |   a: array[0..9] of Integer = (1, 0, 0, 0, 1, 0, 1, 0, 2, 1);\n   4 |   ans, i: Integer;\n   5 | begin\n   6 |   ans := 0;\n   7 |   for i := 1 to Length(data_str) do\n   8 |   begin\n   9 |     ans := ans + a[data_str[i] - '0'];\n  10 |   end;\n  11 |   decodeNumbers := ans;\n  12 | end;", "fragment_lines": [9], "fragment_content": ["ans := ans + a[data_str[i] - '0'];"], "test": "procedure check;\nbegin\n  Assert(decodeNumbers('0000') = 4);\n  Assert(decodeNumbers('8888') = 8);\n  Assert(decodeNumbers('1234') = 1);\n  Assert(decodeNumbers('5678') = 3);\n  Assert(decodeNumbers('9012') = 2);\n  Assert(decodeNumbers('1357') = 0);\n  Assert(decodeNumbers('2468') = 4);\n  // Additional test samples\n  Assert(decodeNumbers('9999') = 4);\n  Assert(decodeNumbers('1111') = 0);\n  Assert(decodeNumbers('2222') = 0);\n  Assert(decodeNumbers('3333') = 0);\n  Assert(decodeNumbers('4444') = 4);\n  Assert(decodeNumbers('5555') = 0);\n  Assert(decodeNumbers('6666') = 4);\n  Assert(decodeNumbers('7777') = 0);\n  Assert(decodeNumbers('0001') = 3);\n  Assert(decodeNumbers('2301') = 1);\nend;\n\nbegin\n  check;\nend.", "instruction": "Observe the following faulty Pascal code\n```pascal\n{$ASSERTIONS ON}\nfunction decodeNumbers(data_str: AnsiString): Integer;var\n  a: array[0..9] of Integer = (1, 0, 0, 0, 1, 0, 1, 0, 2, 1);\n  ans, i: Integer;\nbegin\n  ans := 0;\n  for i := 1 to Length(data_str) do\n  begin\n    ans := ans + a[data_str[i] - '0'];\n  end;\n  decodeNumbers := ans;\nend;\n```\nKnown, the bug code specifically exists in the following snippet:\n[\"ans := ans + a[data_str[i] - '0'];\"]\nFix bugs in the given code snippet. The complete , fixed code must be placed between ```pascal```. Do not generate any test, main,example usage or check code!\n"}
{"question_id": "Pascal/44", "category": "Logic", "subtype": "variable_error", "level": "medium", "example": "Examples:\n    >>> hamming_distance(1,2)\n    2", "docstring": "Calculate the Hamming distance between two integers in binary representation.\n\nParameters:\n- x (Integer): The first positive integer (x <= 1,000,000,000).\n- y (Integer): The second positive integer (y <= 1,000,000,000).\n\nReturns:\nInteger: The Hamming distance between x and y, i.e., the number of bits that \n         need to be flipped to transform x into y in binary.", "canonical_solution": "{$ASSERTIONS ON}\n\nuses\n  SysUtils;\nfunction hamming_distance(x, y: Integer): Integer;var\n  distance: Integer;\n  xor_result: Integer;\nbegin\n  distance := 0;\n  xor_result := x xor y; \n  while xor_result <> 0 do\n  begin\n    if xor_result and 1 = 1 then\n      Inc(distance);\n    xor_result := xor_result shr 1;\n  end;\n  hamming_distance := distance;\nend;", "buggy_code": "{$ASSERTIONS ON}\n\nuses\n  SysUtils;\nfunction hamming_distance(x, y: Integer): Integer;var\n  distance: Integer;\n  xor_result: Integer;\nbegin\n  xor_result := x xor y; \n  while xor_result <> 0 do\n  begin\n    if xor_result and 1 = 1 then\n      Inc(distance);\n    xor_result := xor_result shr 1;\n  end;\n  hamming_distance := distance;\nend;", "bug_with_line_numbers": "   1 | {$ASSERTIONS ON}\n   2 | uses\n   3 |   SysUtils;\n   4 | function hamming_distance(x, y: Integer): Integer;var\n   5 |   distance: Integer;\n   6 |   xor_result: Integer;\n   7 | begin\n   8 |   xor_result := x xor y; \n   9 |   while xor_result <> 0 do\n  10 |   begin\n  11 |     if xor_result and 1 = 1 then\n  12 |       Inc(distance);\n  13 |     xor_result := xor_result shr 1;\n  14 |   end;\n  15 |   hamming_distance := distance;\n  16 | end;", "fragment_lines": [12], "fragment_content": ["Inc(distance);"], "test": "procedure check;\nbegin\n  Assert(hamming_distance(1, 2) = 2, 'Test Failed: (1, 2)'); // 01 and 10 have 2 different bits\n  Assert(hamming_distance(4, 7) = 2, 'Test Failed: (4, 7)'); // 100 and 111 have 2 different bits\n  Assert(hamming_distance(25, 30) = 3, 'Test Failed: (25, 30)'); // Additional test: 11001 and 11110 have 3 different bits\n  Assert(hamming_distance(0, 0) = 0, 'Test Failed: (0, 0)'); // Additional test: Same numbers have 0 different bits\n  Assert(hamming_distance($7FFF, 0) = 15, 'Test Failed: ($7FFF, 0)'); // Additional test: Max unsigned int and 0 have 32 different bits\nend;\n\nbegin\n  check;\nend.", "instruction": "Observe the following faulty Pascal code\n```pascal\n{$ASSERTIONS ON}\n\nuses\n  SysUtils;\nfunction hamming_distance(x, y: Integer): Integer;var\n  distance: Integer;\n  xor_result: Integer;\nbegin\n  xor_result := x xor y; \n  while xor_result <> 0 do\n  begin\n    if xor_result and 1 = 1 then\n      Inc(distance);\n    xor_result := xor_result shr 1;\n  end;\n  hamming_distance := distance;\nend;\n```\nKnown, the bug code specifically exists in the following snippet:\n['Inc(distance);']\nFix bugs in the given code snippet. The complete , fixed code must be placed between ```pascal```. Do not generate any test, main,example usage or check code!\n"}
{"question_id": "Pascal/45", "category": "Logic", "subtype": "variable_error", "level": "easy", "example": "Examples:\n    >>> newModuloFactorial(3, 7)\n    6", "docstring": "This problem introduces a new modulo operation, denoted by \"⊕\". Calculation of x ⊕ y:\n- If x is not a multiple of y, the result is x mod y.\n- Otherwise, if x is a multiple of y, divide x by y until it's no longer a multiple, resulting in x'.\n  The result is then x' mod y.\nFor instance, 4⊕5=4, 20⊕5=4, and 100⊕5=4.\nGiven a prime number p and an integer n, compute the value of n! ⊕ p, where n! is the factorial of n.", "canonical_solution": "{$ASSERTIONS ON}\nfunction newModuloFactorial(n, p: QWord): QWord;var\n  i: QWord;\n  pj: array of QWord;\n  ans: QWord;\nbegin\n  SetLength(pj, p);\n  pj[0] := 1;\n  pj[1] := 1;\n  for i := 2 to p - 1 do\n    pj[i] := (i * pj[i - 1]) mod p;\n\n  ans := 1;\n  while n > 0 do\n  begin\n    ans := (ans * pj[n mod p]) mod p;\n    if (n div p) and 1 = 1 then\n      ans := p - ans;\n    n := n div p;\n  end;\n  newModuloFactorial := ans;\nend;", "buggy_code": "{$ASSERTIONS ON}\nfunction newModuloFactorial(n, p: QWord): QWord;var\n  i: QWord;\n  pj: array of QWord;\n  ans: QWord;\nbegin\n  pj[0] := 1;\n  pj[1] := 1;\n  for i := 2 to p - 1 do\n    pj[i] := (i * pj[i - 1]) mod p;\n\n  ans := 1;\n  while n > 0 do\n  begin\n    ans := (ans * pj[n mod p]) mod p;\n    if (n div p) and 1 = 1 then\n      ans := p - ans;\n    n := n div p;\n  end;\n  newModuloFactorial := ans;\nend;", "bug_with_line_numbers": "   1 | {$ASSERTIONS ON}\n   2 | function newModuloFactorial(n, p: QWord): QWord;var\n   3 |   i: QWord;\n   4 |   pj: array of QWord;\n   5 |   ans: QWord;\n   6 | begin\n   7 |   pj[0] := 1;\n   8 |   pj[1] := 1;\n   9 |   for i := 2 to p - 1 do\n  10 |     pj[i] := (i * pj[i - 1]) mod p;\n  11 |   ans := 1;\n  12 |   while n > 0 do\n  13 |   begin\n  14 |     ans := (ans * pj[n mod p]) mod p;\n  15 |     if (n div p) and 1 = 1 then\n  16 |       ans := p - ans;\n  17 |     n := n div p;\n  18 |   end;\n  19 |   newModuloFactorial := ans;\n  20 | end;", "fragment_lines": [-1], "fragment_content": ["missing critical code snippet"], "test": "procedure check;\nbegin\n  Assert(newModuloFactorial(3, 7) = 6);\n  Assert(newModuloFactorial(10, 3) = 1);\n  Assert(newModuloFactorial(11, 7) = 4);\n  Assert(newModuloFactorial(45, 7) = 1);\n  Assert(newModuloFactorial(14, 7) = 2);\n  Assert(newModuloFactorial(1919, 10007) = 3152);\n  Assert(newModuloFactorial(810, 10007) = 3679);\n  Assert(newModuloFactorial(3, 7) = 6);\n  Assert(newModuloFactorial(10, 3) = 1);\n  Assert(newModuloFactorial(1, 2) = 1);\n  Assert(newModuloFactorial(5, 11) = 10);\n  Assert(newModuloFactorial(6, 13) = 5);\n  Assert(newModuloFactorial(8, 17) = 13);\n  Assert(newModuloFactorial(15, 19) = 16);\n  Assert(newModuloFactorial(21, 23) = 1);\n  Assert(newModuloFactorial(30, 29) = 28);\n  Assert(newModuloFactorial(100, 101) = 100);\nend;\n\nbegin\n  check;\n  WriteLn('All tests passed successfully.');\nend.", "instruction": "Observe the following faulty Pascal code\n```pascal\n{$ASSERTIONS ON}\nfunction newModuloFactorial(n, p: QWord): QWord;var\n  i: QWord;\n  pj: array of QWord;\n  ans: QWord;\nbegin\n  pj[0] := 1;\n  pj[1] := 1;\n  for i := 2 to p - 1 do\n    pj[i] := (i * pj[i - 1]) mod p;\n\n  ans := 1;\n  while n > 0 do\n  begin\n    ans := (ans * pj[n mod p]) mod p;\n    if (n div p) and 1 = 1 then\n      ans := p - ans;\n    n := n div p;\n  end;\n  newModuloFactorial := ans;\nend;\n```\nKnown, the bug code specifically exists in the following snippet:\n['missing critical code snippet']\nFix bugs in the given code snippet. The complete , fixed code must be placed between ```pascal```. Do not generate any test, main,example usage or check code!\n"}
{"question_id": "Pascal/46", "category": "Logic", "subtype": "variable_error", "level": "easy", "example": "* Example:\n * >>> calculate_even_sum([1, 4, 3, 2, 5], 5)\n * 6", "docstring": "* Calculate the sum of even numbers in a given list.\n * Parameters:\n * - numbers: An array of integers.\n * - size: The number of elements in the array.\n * Returns:\n * The sum of even numbers in the input array.", "canonical_solution": "{$ASSERTIONS ON}\nfunction calculate_even_sum(numbers: array of Integer; size: Integer): Integer;var\n  i, ans: Integer;\nbegin\n  ans := 0;\n  for i := 0 to size - 1 do\n  begin\n    if (numbers[i] mod 2) = 0 then\n    begin\n      ans := ans + numbers[i];\n    end;\n  end;\n  calculate_even_sum := ans;\nend;", "buggy_code": "{$ASSERTIONS ON}\nfunction calculate_even_sum(numbers: array of Integer; size: Integer): Integer;var\n  i, ans: Integer;\nbegin\n  for i := 0 to size - 1 do\n  begin\n    if (numbers[i] mod 2) = 0 then\n    begin\n      ans := ans + numbers[i];\n    end;\n  end;\n  calculate_even_sum := ans;\nend;", "bug_with_line_numbers": "   1 | {$ASSERTIONS ON}\n   2 | function calculate_even_sum(numbers: array of Integer; size: Integer): Integer;var\n   3 |   i, ans: Integer;\n   4 | begin\n   5 |   for i := 0 to size - 1 do\n   6 |   begin\n   7 |     if (numbers[i] mod 2) = 0 then\n   8 |     begin\n   9 |       ans := ans + numbers[i];\n  10 |     end;\n  11 |   end;\n  12 |   calculate_even_sum := ans;\n  13 | end;", "fragment_lines": [9], "fragment_content": ["ans := ans + numbers[i];"], "test": "procedure check;\nvar\n  sample1: array[0..4] of Integer = (1, 4, 3, 2, 5);\n  sample2: array[0..3] of Integer = (2, 2, 0, 0);\n  sample3: array[0..2] of Integer = (7, 11, 19);\n  sample4: array[0..4] of Integer = (12, 14, 16, 18, 20);\nbegin\n  Assert(calculate_even_sum(sample1, 5) = 6);\n  Assert(calculate_even_sum(sample2, 4) = 4);\n  Assert(calculate_even_sum(sample3, 3) = 0);\n  Assert(calculate_even_sum(sample4, 5) = 12 + 14 + 16 + 18 + 20);\nend;\n\nbegin\n  check;\nend.", "instruction": "Observe the following faulty Pascal code\n```pascal\n{$ASSERTIONS ON}\nfunction calculate_even_sum(numbers: array of Integer; size: Integer): Integer;var\n  i, ans: Integer;\nbegin\n  for i := 0 to size - 1 do\n  begin\n    if (numbers[i] mod 2) = 0 then\n    begin\n      ans := ans + numbers[i];\n    end;\n  end;\n  calculate_even_sum := ans;\nend;\n```\nKnown, the bug code specifically exists in the following snippet:\n['ans := ans + numbers[i];']\nFix bugs in the given code snippet. The complete , fixed code must be placed between ```pascal```. Do not generate any test, main,example usage or check code!\n"}
{"question_id": "Pascal/47", "category": "Logic", "subtype": "variable_error", "level": "easy", "example": "Example usage:\n  Assert(decodeNumbers('0000') = 4);", "docstring": "Decode a series of numbers to reveal the pattern and understand the actual values\n  each digit represents.\n  0000=4 8888=8 1234=1 5678=3 9012=2 1357=0 2468=4\n  \n  Parameters:\n  - data_str: A string representing a series of numbers. Length does not exceed 100.\n  \n  Returns:\n  integer: The result of each data string corresponding to the right-hand side of the equation.", "canonical_solution": "{$ASSERTIONS ON}\nfunction decodeNumbers(data_str: AnsiString): Integer;var\n  a: array[0..9] of Integer = (1, 0, 0, 0, 1, 0, 1, 0, 2, 1);\n  ans, i: Integer;\nbegin\n  ans := 0;\n  for i := 1 to Length(data_str) do\n  begin\n    ans := ans + a[Ord(data_str[i]) - Ord('0')];\n  end;\n  decodeNumbers := ans;\nend;", "buggy_code": "{$ASSERTIONS ON}\nfunction decodeNumbers(data_str: AnsiString): Integer;var\n  a: array[0..9] of Integer = (1, 0, 0, 0, 1, 0, 1, 0, 2, 1);\n  ans, i: Integer;\nbegin\n  for i := 1 to Length(data_str) do\n  begin\n    ans := ans + a[Ord(data_str[i]) - Ord('0')];\n  end;\n  decodeNumbers := ans;\nend;", "bug_with_line_numbers": "   1 | {$ASSERTIONS ON}\n   2 | function decodeNumbers(data_str: AnsiString): Integer;var\n   3 |   a: array[0..9] of Integer = (1, 0, 0, 0, 1, 0, 1, 0, 2, 1);\n   4 |   ans, i: Integer;\n   5 | begin\n   6 |   for i := 1 to Length(data_str) do\n   7 |   begin\n   8 |     ans := ans + a[Ord(data_str[i]) - Ord('0')];\n   9 |   end;\n  10 |   decodeNumbers := ans;\n  11 | end;", "fragment_lines": [8], "fragment_content": ["ans := ans + a[Ord(data_str[i]) - Ord('0')];"], "test": "procedure check;\nbegin\n  Assert(decodeNumbers('0000') = 4);\n  Assert(decodeNumbers('8888') = 8);\n  Assert(decodeNumbers('1234') = 1);\n  Assert(decodeNumbers('5678') = 3);\n  Assert(decodeNumbers('9012') = 2);\n  Assert(decodeNumbers('1357') = 0);\n  Assert(decodeNumbers('2468') = 4);\n  // Additional test samples\n  Assert(decodeNumbers('9999') = 4);\n  Assert(decodeNumbers('1111') = 0);\n  Assert(decodeNumbers('2222') = 0);\n  Assert(decodeNumbers('3333') = 0);\n  Assert(decodeNumbers('4444') = 4);\n  Assert(decodeNumbers('5555') = 0);\n  Assert(decodeNumbers('6666') = 4);\n  Assert(decodeNumbers('7777') = 0);\n  Assert(decodeNumbers('0001') = 3);\n  Assert(decodeNumbers('2301') = 1);\nend;\n\nbegin\n  check;\nend.", "instruction": "Observe the following faulty Pascal code\n```pascal\n{$ASSERTIONS ON}\nfunction decodeNumbers(data_str: AnsiString): Integer;var\n  a: array[0..9] of Integer = (1, 0, 0, 0, 1, 0, 1, 0, 2, 1);\n  ans, i: Integer;\nbegin\n  for i := 1 to Length(data_str) do\n  begin\n    ans := ans + a[Ord(data_str[i]) - Ord('0')];\n  end;\n  decodeNumbers := ans;\nend;\n```\nKnown, the bug code specifically exists in the following snippet:\n[\"ans := ans + a[Ord(data_str[i]) - Ord('0')];\"]\nFix bugs in the given code snippet. The complete , fixed code must be placed between ```pascal```. Do not generate any test, main,example usage or check code!\n"}
{"question_id": "Pascal/48", "category": "Logic", "subtype": "variable_error", "level": "hard", "example": "Examples:\n    >>> countPermutations(2, 1, [1, 2])\n    2", "docstring": "Given a permutation q of n elements and an integer k, find the number of permutations p of n elements such that f(p) = q, where f(p) is the lexicographically smallest permutation that can be obtained by dividing p into exactly k non-empty contiguous segments and sorting each segment(that is, choose $ k-1 $ breakpoints $ 1\\le x_1 < x_2 < \\cdots < x_{k-1} < n $, and divide it into $ [1, x_1], (x_1, x_2], \\cdots, (x_{k-1}, n] $). The result should be modulo 998244353.", "canonical_solution": "{$ASSERTIONS ON}\nuses\n  SysUtils;\nfunction countPermutations(n, k: int64; qq: array of int64): int64;var\n  P, i, j, m, ans, c, kk: int64;\n  q, jc, f: array[0..504] of int64;\n  dp: array[0..504, 0..504] of int64;\nbegin\n  P := 998244353;\n  ans := 0;\n  for i := 0 to n+2 do\n  begin\n    q[i] := 0;\n    jc[i] := 0;\n    f[i] := 0;\n    for j := 0 to n+2 do\n      dp[i][j] := 0;\n  end;\n\n  for i := 1 to n do\n    q[i] := qq[i - 1];\n  dp[0][0] := 1;\n  f[0] := 1;\n  jc[0] := 1;\n  for i := 1 to n do\n    jc[i] := (jc[i - 1] * i) mod P;\n  for i := 1 to n do\n  begin\n    f[i] := jc[i];\n    for j := 1 to i - 1 do\n      f[i] := (f[i] + P - (f[j] * jc[i - j]) mod P) mod P;\n  end;\n  for i := 1 to n do\n  begin\n    for j := 0 to i - 1 do\n      for kk := 1 to n do\n        dp[i][kk] := (dp[i][kk] + (dp[j][kk - 1] * f[i - j]) mod P) mod P;\n  end;\n  m := 0;\n  for i := 1 to n do\n    if q[i] > q[i + 1] then\n    begin\n      m := i;\n      break;\n    end;\n  if m = n then\n  begin\n    for i := k to n do\n    begin\n      ans := (ans + dp[n][i]) mod P;\n    end\n  end\n  else\n  begin\n    for i := m + 1 to n do\n    begin\n      if ((i xor (m + 1) <> 0) and ((q[i - 1] > q[i]) or (q[i] < q[m]))) then\n        break;\n      c := k + i - n - 1;\n      if c >= 0 then\n        ans := (ans + (dp[m][c] * jc[i - m - 1]) mod P) mod P;\n    end;\n  end;\n  countPermutations := ans;\nend;", "buggy_code": "{$ASSERTIONS ON}\nuses\n  SysUtils;\nfunction countPermutations(n, k: int64; qq: array of int64): int64;var\n  P, i, j, m, ans, c, kk: int64;\n  q, jc, f: array[0..504] of int64;\n  dp: array[0..504, 0..504] of int64;\nbegin\n  P := 998244353;\n  ans := 0;\n  for i := 0 to n+2 do\n  begin\n    q[i] := 0;\n    jc[i] := 0;\n    f[i] := 0;\n  end;\n\n  for i := 1 to n do\n    q[i] := qq[i - 1];\n  dp[0][0] := 1;\n  f[0] := 1;\n  jc[0] := 1;\n  for i := 1 to n do\n    jc[i] := (jc[i - 1] * i) mod P;\n  for i := 1 to n do\n  begin\n    f[i] := jc[i];\n    for j := 1 to i - 1 do\n      f[i] := (f[i] + P - (f[j] * jc[i - j]) mod P) mod P;\n  end;\n  for i := 1 to n do\n  begin\n    for j := 0 to i - 1 do\n      for kk := 1 to n do\n        dp[i][kk] := (dp[i][kk] + (dp[j][kk - 1] * f[i - j]) mod P) mod P;\n  end;\n  m := 0;\n  for i := 1 to n do\n    if q[i] > q[i + 1] then\n    begin\n      m := i;\n      break;\n    end;\n  if m = n then\n  begin\n    for i := k to n do\n    begin\n      ans := (ans + dp[n][i]) mod P;\n    end\n  end\n  else\n  begin\n    for i := m + 1 to n do\n    begin\n      if ((i xor (m + 1) <> 0) and ((q[i - 1] > q[i]) or (q[i] < q[m]))) then\n        break;\n      c := k + i - n - 1;\n      if c >= 0 then\n        ans := (ans + (dp[m][c] * jc[i - m - 1]) mod P) mod P;\n    end;\n  end;\n  countPermutations := ans;\nend;", "bug_with_line_numbers": "   1 | {$ASSERTIONS ON}\n   2 | uses\n   3 |   SysUtils;\n   4 | function countPermutations(n, k: int64; qq: array of int64): int64;var\n   5 |   P, i, j, m, ans, c, kk: int64;\n   6 |   q, jc, f: array[0..504] of int64;\n   7 |   dp: array[0..504, 0..504] of int64;\n   8 | begin\n   9 |   P := 998244353;\n  10 |   ans := 0;\n  11 |   for i := 0 to n+2 do\n  12 |   begin\n  13 |     q[i] := 0;\n  14 |     jc[i] := 0;\n  15 |     f[i] := 0;\n  16 |   end;\n  17 |   for i := 1 to n do\n  18 |     q[i] := qq[i - 1];\n  19 |   dp[0][0] := 1;\n  20 |   f[0] := 1;\n  21 |   jc[0] := 1;\n  22 |   for i := 1 to n do\n  23 |     jc[i] := (jc[i - 1] * i) mod P;\n  24 |   for i := 1 to n do\n  25 |   begin\n  26 |     f[i] := jc[i];\n  27 |     for j := 1 to i - 1 do\n  28 |       f[i] := (f[i] + P - (f[j] * jc[i - j]) mod P) mod P;\n  29 |   end;\n  30 |   for i := 1 to n do\n  31 |   begin\n  32 |     for j := 0 to i - 1 do\n  33 |       for kk := 1 to n do\n  34 |         dp[i][kk] := (dp[i][kk] + (dp[j][kk - 1] * f[i - j]) mod P) mod P;\n  35 |   end;\n  36 |   m := 0;\n  37 |   for i := 1 to n do\n  38 |     if q[i] > q[i + 1] then\n  39 |     begin\n  40 |       m := i;\n  41 |       break;\n  42 |     end;\n  43 |   if m = n then\n  44 |   begin\n  45 |     for i := k to n do\n  46 |     begin\n  47 |       ans := (ans + dp[n][i]) mod P;\n  48 |     end\n  49 |   end\n  50 |   else\n  51 |   begin\n  52 |     for i := m + 1 to n do\n  53 |     begin\n  54 |       if ((i xor (m + 1) <> 0) and ((q[i - 1] > q[i]) or (q[i] < q[m]))) then\n  55 |         break;\n  56 |       c := k + i - n - 1;\n  57 |       if c >= 0 then\n  58 |         ans := (ans + (dp[m][c] * jc[i - m - 1]) mod P) mod P;\n  59 |     end;\n  60 |   end;\n  61 |   countPermutations := ans;\n  62 | end;", "fragment_lines": [-1], "fragment_content": ["missing critical code snippet"], "test": "procedure testCountPermutations;\nvar\n  q1: array[0..1] of int64 = (1, 2);\n  q2:array[0..2] of int64= (3, 1, 2);\n  q3:array[0..5] of int64= (1, 2, 3, 6, 5, 4);\n  q4:array[0..5] of int64= (1, 2, 3, 4, 5, 6);\n  q5:array[0..5] of int64= (1, 2, 5, 3, 4, 5);\n  q6:array[0..8] of int64= (1, 2, 3, 4, 5, 6, 7, 8, 9);\n  q7:array[0..8] of int64= (1, 2, 3, 4, 5, 6, 7, 9, 8);\nbegin\n  Assert(countPermutations(2, 1, q1) = 2);\n  Assert(countPermutations(3, 3, q2) = 1);\n  Assert(countPermutations(6, 3, q3) = 13);\n  Assert(countPermutations(6, 1, q4) = 720); \n  Assert(countPermutations(6, 3, q5) = 0); \n  Assert(countPermutations(9, 9, q6) = 1); \n  Assert(countPermutations(9, 2, q7) = 29093);\nend;\n\nbegin\n  testCountPermutations;\nend.", "instruction": "Observe the following faulty Pascal code\n```pascal\n{$ASSERTIONS ON}\nuses\n  SysUtils;\nfunction countPermutations(n, k: int64; qq: array of int64): int64;var\n  P, i, j, m, ans, c, kk: int64;\n  q, jc, f: array[0..504] of int64;\n  dp: array[0..504, 0..504] of int64;\nbegin\n  P := 998244353;\n  ans := 0;\n  for i := 0 to n+2 do\n  begin\n    q[i] := 0;\n    jc[i] := 0;\n    f[i] := 0;\n  end;\n\n  for i := 1 to n do\n    q[i] := qq[i - 1];\n  dp[0][0] := 1;\n  f[0] := 1;\n  jc[0] := 1;\n  for i := 1 to n do\n    jc[i] := (jc[i - 1] * i) mod P;\n  for i := 1 to n do\n  begin\n    f[i] := jc[i];\n    for j := 1 to i - 1 do\n      f[i] := (f[i] + P - (f[j] * jc[i - j]) mod P) mod P;\n  end;\n  for i := 1 to n do\n  begin\n    for j := 0 to i - 1 do\n      for kk := 1 to n do\n        dp[i][kk] := (dp[i][kk] + (dp[j][kk - 1] * f[i - j]) mod P) mod P;\n  end;\n  m := 0;\n  for i := 1 to n do\n    if q[i] > q[i + 1] then\n    begin\n      m := i;\n      break;\n    end;\n  if m = n then\n  begin\n    for i := k to n do\n    begin\n      ans := (ans + dp[n][i]) mod P;\n    end\n  end\n  else\n  begin\n    for i := m + 1 to n do\n    begin\n      if ((i xor (m + 1) <> 0) and ((q[i - 1] > q[i]) or (q[i] < q[m]))) then\n        break;\n      c := k + i - n - 1;\n      if c >= 0 then\n        ans := (ans + (dp[m][c] * jc[i - m - 1]) mod P) mod P;\n    end;\n  end;\n  countPermutations := ans;\nend;\n```\nKnown, the bug code specifically exists in the following snippet:\n['missing critical code snippet']\nFix bugs in the given code snippet. The complete , fixed code must be placed between ```pascal```. Do not generate any test, main,example usage or check code!\n"}
{"question_id": "Pascal/49", "category": "Multiple", "subtype": "double_bug", "level": "medium", "example": "Example usage:\n    Is_Square(1, [9]) should return true (1 in Pascal), because 9 is a perfect square.", "docstring": "The task is to determine if it is possible to assemble the wooden squares from n buckets,\nwhere each bucket contains a number of squares with a side length of 1, into a single larger square.\nThe function receives the length of the list and an array of numbers as input.", "canonical_solution": "{$ASSERTIONS ON}\n\nuses\n  Math, SysUtils;\nfunction Is_Square(length: integer; const squares: array of integer): boolean;var\n  sum: Int64;\n  root, i: integer;\nbegin\n  sum := 0;\n  for i := 0 to length - 1 do\n  begin\n    sum := sum + squares[i];\n  end;\n  root := Trunc(Sqrt(sum));\n  Is_Square := (root * root = sum);\nend;", "buggy_code": "{$ASSERTIONS ON}\n\nuses\n  Math, SysUtils;\nfunction Is_Square(length: integer; const squares: array of integer): boolean;var\n  sum: Int64;\n  root, i: integer;\nbegin\n  sum := 0;\n  for i := 0 to length - 1 do\n  begin\n    sum := sum + squares[i];\n  end\n  root := Trunc(Sqrt(sum))+1;\n  Is_Square := (root * root == sum);\nend;", "bug_with_line_numbers": "   1 | {$ASSERTIONS ON}\n   2 | uses\n   3 |   Math, SysUtils;\n   4 | function Is_Square(length: integer; const squares: array of integer): boolean;var\n   5 |   sum: Int64;\n   6 |   root, i: integer;\n   7 | begin\n   8 |   sum := 0;\n   9 |   for i := 0 to length - 1 do\n  10 |   begin\n  11 |     sum := sum + squares[i];\n  12 |   end\n  13 |   root := Trunc(Sqrt(sum))+1;\n  14 |   Is_Square := (root * root == sum);\n  15 | end;", "fragment_lines": [12, 13, 14], "fragment_content": ["end", "root := Trunc(Sqrt(sum))+1;", "Is_Square := (root * root == sum);"], "test": "procedure check;\nbegin\n  Assert(Is_Square(1, [9]) = true);\n  Assert(Is_Square(2, [14, 2]) = true);\n  Assert(Is_Square(2, [7, 7]) = false);\n  Assert(Is_Square(7, [1, 2, 3, 4, 5, 6, 7]) = false);\n  Assert(Is_Square(6, [1, 3, 5, 7, 9, 11]) = true);\n  Assert(Is_Square(4, [2, 2, 2, 2]) = false);\n  Assert(Is_Square(3, [4, 5, 6]) = false);\n  Assert(Is_Square(4, [16, 9, 4, 1]) = false);\n  Assert(Is_Square(5, [1, 1, 1, 1, 1]) = false);\n  Assert(Is_Square(2, [25, 25]) = false);\n  Assert(Is_Square(3, [10, 10, 5]) = true);\nend;\n\nbegin\n  check;\nend.", "instruction": "Observe the following faulty Pascal code\n```pascal\n{$ASSERTIONS ON}\n\nuses\n  Math, SysUtils;\nfunction Is_Square(length: integer; const squares: array of integer): boolean;var\n  sum: Int64;\n  root, i: integer;\nbegin\n  sum := 0;\n  for i := 0 to length - 1 do\n  begin\n    sum := sum + squares[i];\n  end\n  root := Trunc(Sqrt(sum))+1;\n  Is_Square := (root * root == sum);\nend;\n```\nKnown, the bug code specifically exists in the following snippet:\n['end', 'root := Trunc(Sqrt(sum))+1;', 'Is_Square := (root * root == sum);']\nFix bugs in the given code snippet. The complete , fixed code must be placed between ```pascal```. Do not generate any test, main,example usage or check code!\n"}
{"question_id": "Pascal/50", "category": "Multiple", "subtype": "double_bug", "level": "medium", "example": "Examples:\n    >>> newModuloFactorial(3, 7)\n    6", "docstring": "This problem introduces a new modulo operation, denoted by \"⊕\". Calculation of x ⊕ y:\n- If x is not a multiple of y, the result is x mod y.\n- Otherwise, if x is a multiple of y, divide x by y until it's no longer a multiple, resulting in x'.\n  The result is then x' mod y.\nFor instance, 4⊕5=4, 20⊕5=4, and 100⊕5=4.\nGiven a prime number p and an integer n, compute the value of n! ⊕ p, where n! is the factorial of n.", "canonical_solution": "{$ASSERTIONS ON}\nfunction newModuloFactorial(n, p: QWord): QWord;var\n  i: QWord;\n  pj: array of QWord;\n  ans: QWord;\nbegin\n  SetLength(pj, p);\n  pj[0] := 1;\n  pj[1] := 1;\n  for i := 2 to p - 1 do\n    pj[i] := (i * pj[i - 1]) mod p;\n\n  ans := 1;\n  while n > 0 do\n  begin\n    ans := (ans * pj[n mod p]) mod p;\n    if (n div p) and 1 = 1 then\n      ans := p - ans;\n    n := n div p;\n  end;\n  newModuloFactorial := ans;\nend;", "buggy_code": "{$ASSERTIONS ON}\nfunction newModuloFactorial(n, p: QWord): QWord;var\n  i: QWord;\n  pj: array of QWord;\n  ans: QWord;\nbegin\n  SetLength(pj, p);\n  pj[0] := 1;\n  pj[1] := 1;\n  for i := 1 to p - 1 do\n    pj[i] := (i * pj[i - 1]) mod p;\n\n  ans := 0;\n  while n > 0 do\n  begin\n    ans := (ans * pj[n mod p]) mod p;\n    if (n div p) and 1 = 1 then\n      ans := p - ans;\n    n := n div p;\n  end;\n  newModuloFactorial := ans;\nend;", "bug_with_line_numbers": "   1 | {$ASSERTIONS ON}\n   2 | function newModuloFactorial(n, p: QWord): QWord;var\n   3 |   i: QWord;\n   4 |   pj: array of QWord;\n   5 |   ans: QWord;\n   6 | begin\n   7 |   SetLength(pj, p);\n   8 |   pj[0] := 1;\n   9 |   pj[1] := 1;\n  10 |   for i := 1 to p - 1 do\n  11 |     pj[i] := (i * pj[i - 1]) mod p;\n  12 |   ans := 0;\n  13 |   while n > 0 do\n  14 |   begin\n  15 |     ans := (ans * pj[n mod p]) mod p;\n  16 |     if (n div p) and 1 = 1 then\n  17 |       ans := p - ans;\n  18 |     n := n div p;\n  19 |   end;\n  20 |   newModuloFactorial := ans;\n  21 | end;", "fragment_lines": [10, 12], "fragment_content": ["for i := 1 to p - 1 do", "ans := 0;"], "test": "procedure check;\nbegin\n  Assert(newModuloFactorial(3, 7) = 6);\n  Assert(newModuloFactorial(10, 3) = 1);\n  Assert(newModuloFactorial(11, 7) = 4);\n  Assert(newModuloFactorial(45, 7) = 1);\n  Assert(newModuloFactorial(14, 7) = 2);\n  Assert(newModuloFactorial(1919, 10007) = 3152);\n  Assert(newModuloFactorial(810, 10007) = 3679);\n  Assert(newModuloFactorial(3, 7) = 6);\n  Assert(newModuloFactorial(10, 3) = 1);\n  Assert(newModuloFactorial(1, 2) = 1);\n  Assert(newModuloFactorial(5, 11) = 10);\n  Assert(newModuloFactorial(6, 13) = 5);\n  Assert(newModuloFactorial(8, 17) = 13);\n  Assert(newModuloFactorial(15, 19) = 16);\n  Assert(newModuloFactorial(21, 23) = 1);\n  Assert(newModuloFactorial(30, 29) = 28);\n  Assert(newModuloFactorial(100, 101) = 100);\nend;\n\nbegin\n  check;\n  WriteLn('All tests passed successfully.');\nend.", "instruction": "Observe the following faulty Pascal code\n```pascal\n{$ASSERTIONS ON}\nfunction newModuloFactorial(n, p: QWord): QWord;var\n  i: QWord;\n  pj: array of QWord;\n  ans: QWord;\nbegin\n  SetLength(pj, p);\n  pj[0] := 1;\n  pj[1] := 1;\n  for i := 1 to p - 1 do\n    pj[i] := (i * pj[i - 1]) mod p;\n\n  ans := 0;\n  while n > 0 do\n  begin\n    ans := (ans * pj[n mod p]) mod p;\n    if (n div p) and 1 = 1 then\n      ans := p - ans;\n    n := n div p;\n  end;\n  newModuloFactorial := ans;\nend;\n```\nKnown, the bug code specifically exists in the following snippet:\n['for i := 1 to p - 1 do', 'ans := 0;']\nFix bugs in the given code snippet. The complete , fixed code must be placed between ```pascal```. Do not generate any test, main,example usage or check code!\n"}
{"question_id": "Pascal/51", "category": "Multiple", "subtype": "double_bug", "level": "medium", "example": "Examples:\n      >>> classify_integer('24')\n      6", "docstring": "Classify the integer x as follows:\n    - If x is a single-digit number, x belongs to its own class.\n    - Otherwise, sum the digits of x, get a new x, and continue this process iteratively \n      until the class is determined.\n\n  @param x: The string representation of the integer to be classified.\n  @return: The class to which the integer x belongs.", "canonical_solution": "{$ASSERTIONS ON}\nuses\n  SysUtils, StrUtils;\nfunction classify_integer(x: string): Integer;\nvar\n  n, i, a, t: Integer;begin\n  n := 0;\n  for i := 1 to Length(x) do\n    n := n + Ord(x[i]) - Ord('0');\n  while n > 9 do\n  begin\n    t := n;\n    a := 0;\n    while t > 0 do\n    begin\n      a := a + (t mod 10);\n      t := t div 10;\n    end;\n    n := a;\n  end;\n  classify_integer := n;\nend;", "buggy_code": "{$ASSERTIONS ON}\nuses\n  SysUtils, StrUtils;\nfunction classify_integer(x: string): Integer;\nvar\n  n, i, a, t: Integer;begin\n  n := 0;\n  for i := 1 to Length(x) do\n    n := n + x[i];\n  while n > 9 do\n  begin\n    t := n;\n    a := 0;\n    while t > 0 do\n    begin\n      a := a + (t mod 10);\n      t := t div 10;\n    end;\n    n := t;\n  end;\n  classify_integer := n;\nend;", "bug_with_line_numbers": "   1 | {$ASSERTIONS ON}\n   2 | uses\n   3 |   SysUtils, StrUtils;\n   4 | function classify_integer(x: string): Integer;\n   5 | var\n   6 |   n, i, a, t: Integer;begin\n   7 |   n := 0;\n   8 |   for i := 1 to Length(x) do\n   9 |     n := n + x[i];\n  10 |   while n > 9 do\n  11 |   begin\n  12 |     t := n;\n  13 |     a := 0;\n  14 |     while t > 0 do\n  15 |     begin\n  16 |       a := a + (t mod 10);\n  17 |       t := t div 10;\n  18 |     end;\n  19 |     n := t;\n  20 |   end;\n  21 |   classify_integer := n;\n  22 | end;", "fragment_lines": [9, 19], "fragment_content": ["n := n + x[i];", "n := t;"], "test": "procedure check;\nbegin\n  Assert(classify_integer('24') = 6);\n  Assert(classify_integer('39') = 3);\n  Assert(classify_integer('123456789') = 9);\n  Assert(classify_integer('123456789012345678901234567890') = 9);\n  Assert(classify_integer('12345') = 6);\n  Assert(classify_integer('999999999') = 9);\nend;\n\nbegin\n  check;\nend.", "instruction": "Observe the following faulty Pascal code\n```pascal\n{$ASSERTIONS ON}\nuses\n  SysUtils, StrUtils;\nfunction classify_integer(x: string): Integer;\nvar\n  n, i, a, t: Integer;begin\n  n := 0;\n  for i := 1 to Length(x) do\n    n := n + x[i];\n  while n > 9 do\n  begin\n    t := n;\n    a := 0;\n    while t > 0 do\n    begin\n      a := a + (t mod 10);\n      t := t div 10;\n    end;\n    n := t;\n  end;\n  classify_integer := n;\nend;\n```\nKnown, the bug code specifically exists in the following snippet:\n['n := n + x[i];', 'n := t;']\nFix bugs in the given code snippet. The complete , fixed code must be placed between ```pascal```. Do not generate any test, main,example usage or check code!\n"}
{"question_id": "Pascal/52", "category": "Multiple", "subtype": "double_bug", "level": "medium", "example": "Examples:\n    >>> apocalypseYear(6, [3, 2, 4, 5, 9, 18])\n    36", "docstring": "Given a sequence of n events, each occurring with a periodicity of a_i years,\nthe problem is to find the year Yn when the nth event occurs, under the\ncondition that the countdown for event i+1 can only commence in the year\nimmediately following the occurrence of event i.", "canonical_solution": "{$ASSERTIONS ON}\nfunction apocalypseYear(n: Int64; signs: array of Int64): Int64;var\n  i, period, nextOccurrence, year: Int64;\nbegin\n  year := 0;\n  for i := 0 to n-1  do\n  begin\n    period := signs[i];\n    nextOccurrence := (year div period + 1) * period;\n    year := nextOccurrence;\n  end;\n  apocalypseYear := year;\nend;", "buggy_code": "{$ASSERTIONS ON}\nfunction apocalypseYear(n: Int64; signs: array of Int64): Int64;var\n  i, period, nextOccurrence, year: Int64;\nbegin\n  year := 0;\n  for i := 0 to n:\n  begin\n    period := signs[i];\n    nextOccurrence := (year div period + 1) * (period - 1);\n    year := nextOccurrence;\n  end;\n  apocalypseYear := year;\nend;", "bug_with_line_numbers": "   1 | {$ASSERTIONS ON}\n   2 | function apocalypseYear(n: Int64; signs: array of Int64): Int64;var\n   3 |   i, period, nextOccurrence, year: Int64;\n   4 | begin\n   5 |   year := 0;\n   6 |   for i := 0 to n:\n   7 |   begin\n   8 |     period := signs[i];\n   9 |     nextOccurrence := (year div period + 1) * (period - 1);\n  10 |     year := nextOccurrence;\n  11 |   end;\n  12 |   apocalypseYear := year;\n  13 | end;", "fragment_lines": [6, 9], "fragment_content": ["for i := 0 to n:", "nextOccurrence := (year div period + 1) * (period - 1);"], "test": "procedure check;\nbegin\n  Assert(apocalypseYear(6, [3, 2, 4, 5, 9, 18]) = 36);\n  Assert(apocalypseYear(5, [1, 2, 3, 4, 5]) = 5);\n  Assert(apocalypseYear(5, [1, 1, 1, 1, 1]) = 5);\n  Assert(apocalypseYear(6, [50, 30, 711, 200, 503, 1006]) = 2012);\n  Assert(apocalypseYear(2, [1, 2]) = 2);\n  Assert(apocalypseYear(3, [3, 1, 2]) = 6);\n  Assert(apocalypseYear(3, [2, 3, 4]) = 4);\n  Assert(apocalypseYear(4, [1, 2, 3, 4]) = 4);\n  Assert(apocalypseYear(4, [5, 7, 11, 13]) = 13);\n  Assert(apocalypseYear(5, [2, 2, 2, 2, 2]) = 10);\n  Assert(apocalypseYear(3, [6, 10, 15]) = 15);\n  Assert(apocalypseYear(3, [4, 6, 14]) = 14);\n  Assert(apocalypseYear(4, [50, 30, 711, 200]) = 800);\n  Assert(apocalypseYear(6, [1, 1, 1, 1, 1, 1]) = 6);\n  Assert(apocalypseYear(2, [1000000, 999999]) = 1999998);\nend;\n\nbegin\n  check;\nend.", "instruction": "Observe the following faulty Pascal code\n```pascal\n{$ASSERTIONS ON}\nfunction apocalypseYear(n: Int64; signs: array of Int64): Int64;var\n  i, period, nextOccurrence, year: Int64;\nbegin\n  year := 0;\n  for i := 0 to n:\n  begin\n    period := signs[i];\n    nextOccurrence := (year div period + 1) * (period - 1);\n    year := nextOccurrence;\n  end;\n  apocalypseYear := year;\nend;\n```\nKnown, the bug code specifically exists in the following snippet:\n['for i := 0 to n:', 'nextOccurrence := (year div period + 1) * (period - 1);']\nFix bugs in the given code snippet. The complete , fixed code must be placed between ```pascal```. Do not generate any test, main,example usage or check code!\n"}
{"question_id": "Pascal/53", "category": "Multiple", "subtype": "double_bug", "level": "hard", "example": "example:\n    >>> expectedCuts(3, 3, 4)\n    3", "docstring": "Given a rectangle paper of size n x m placed on a plane Cartesian coordinate system with its bottom-left corner at (0,0) and top-right corner at (n,m), \ncalculate the expected number of operations to cut the paper so that the remaining area is less than k. \nIn each operation, a randomly chosen line parallel to the axes passes through points with Int64 coordinates and cuts the paper, \ndiscarding the bottom or right part of the paper along this line. The answer should be modulo 10^9+7.", "canonical_solution": "{$ASSERTIONS ON}\nfunction expectedCuts(n, m: Int64; k: Int64): Int64;const\n  MD = 1000000007;\nvar\n  vv: array[1..200001] of Int64; \n  i, j: Int64;\n  ans: Int64;\n\nbegin\n  vv[1] := 1;\n  for i := 2 to High(vv) do\n    vv[i] := (Int64(vv[i - MD mod i]) * (MD div i + 1)) mod MD;\n\n  if k > Int64(n) * m then\n  begin\n    expectedCuts := 0;\n    Exit;\n  end;\n\n  ans := 1;\n  for i := Int64((k + m - 1) div m) to n - 1 do\n    ans := (ans + vv[i + Int64((k + Int64(i) - 1) div Int64(i)) - 1]) mod MD;\n  for j := Int64((k + n - 1) div n) to m - 1 do\n    ans := (ans + vv[Int64((k + Int64(j) - 1) div Int64(j)) + j - 1]) mod MD;\n\n  expectedCuts := ans;\nend;", "buggy_code": "{$ASSERTIONS ON}\nfunction expectedCuts(n, m: Int64; k: Int64): Int64;const\n  MD = 1000000007;\nvar\n  vv: array[1..200001] of Int64; \n  i, j: Int64;\n  ans: Int64;\n\nbegin\n  vv[1] := 1;\n  for i := 2 to High(vv) do\n    vv[i] := (Int64(vv[i - MD mod i]) * (MD div i + 1)) mod MD;\n\n  if k > Int64(n) * m then\n  begin\n    expectedCuts := 0;\n    Exit;\n  end;\n\n  ans := 1;\n  for i := Int64((k + m - 1) div m) to m - 1 do\n    ans := (ans + vv[i + Int64((k + Int64(i) - 1) div Int64(i)) - 1]) mod MD;\n  for j := Int64((k + n - 1) div n) to m - 1 do\n    ans := (ans + vv[Int64((k + Int64(j) - 1) div Int64(j)) + j - 1]) mod MD;\n\n  expectedCuts := ans\nend;", "bug_with_line_numbers": "   1 | function expectedCuts(n, m: Int64; k: Int64): Int64;const\n   2 |   MD = 1000000007;\n   3 | var\n   4 |   vv: array[1..200001] of Int64; \n   5 |   i, j: Int64;\n   6 |   ans: Int64;\n   7 | begin\n   8 |   vv[1] := 1;\n   9 |   for i := 2 to High(vv) do\n  10 |     vv[i] := (Int64(vv[i - MD mod i]) * (MD div i + 1)) mod MD;\n  11 |   if k > Int64(n) * m then\n  12 |   begin\n  13 |     expectedCuts := 0;\n  14 |     Exit;\n  15 |   end;\n  16 |   ans := 1;\n  17 |   for i := Int64((k + m - 1) div m) to m - 1 do\n  18 |     ans := (ans + vv[i + Int64((k + Int64(i) - 1) div Int64(i)) - 1]) mod MD;\n  19 |   for j := Int64((k + n - 1) div n) to m - 1 do\n  20 |     ans := (ans + vv[Int64((k + Int64(j) - 1) div Int64(j)) + j - 1]) mod MD;\n  21 |   expectedCuts := ans\n  22 | end;", "fragment_lines": [17, 21], "fragment_content": ["for i := Int64((k + m - 1) div m) to m - 1 do", "expectedCuts := ans"], "test": "procedure check;\nbegin\n  Assert(expectedCuts(2, 4, 10) = 0);\n  Assert(expectedCuts(2, 4, 8) = 1);\n  Assert(expectedCuts(2, 4, 2) = 833333342);\n  Assert(expectedCuts(2, 4, 6) = 250000003);\n  Assert(expectedCuts(3, 3, 4) = 666666673);\n  Assert(expectedCuts(5, 5, 12) = 666666673);\n  Assert(expectedCuts(6, 7, 20) = 722222229);\n  Assert(expectedCuts(8, 8, 30) = 72727275);\n  Assert(expectedCuts(10, 10, 50) = 714285721);\n  Assert(expectedCuts(1, 10, 5) = 945634929);\n  Assert(expectedCuts(10, 1, 5) = 945634929);\nend;\n\nbegin\n  check;\nend.", "instruction": "Observe the following faulty Pascal code\n```pascal\n{$ASSERTIONS ON}\nfunction expectedCuts(n, m: Int64; k: Int64): Int64;const\n  MD = 1000000007;\nvar\n  vv: array[1..200001] of Int64; \n  i, j: Int64;\n  ans: Int64;\n\nbegin\n  vv[1] := 1;\n  for i := 2 to High(vv) do\n    vv[i] := (Int64(vv[i - MD mod i]) * (MD div i + 1)) mod MD;\n\n  if k > Int64(n) * m then\n  begin\n    expectedCuts := 0;\n    Exit;\n  end;\n\n  ans := 1;\n  for i := Int64((k + m - 1) div m) to m - 1 do\n    ans := (ans + vv[i + Int64((k + Int64(i) - 1) div Int64(i)) - 1]) mod MD;\n  for j := Int64((k + n - 1) div n) to m - 1 do\n    ans := (ans + vv[Int64((k + Int64(j) - 1) div Int64(j)) + j - 1]) mod MD;\n\n  expectedCuts := ans\nend;\n```\nKnown, the bug code specifically exists in the following snippet:\n['for i := Int64((k + m - 1) div m) to m - 1 do', 'expectedCuts := ans']\nFix bugs in the given code snippet. The complete , fixed code must be placed between ```pascal```. Do not generate any test, main,example usage or check code!\n"}
{"question_id": "Pascal/54", "category": "Multiple", "subtype": "double_bug", "level": "medium", "example": "Examples:\n    >>> countPowerNumbers(99, 1)\n    99", "docstring": "Given two positive integers n and k, find the number of positive integers x,\nwhere 1 <= x <= n, that can be expressed as x = a^b with a and b being positive\nintegers and b >= k. Different legal representations of the same number are counted\nonly once.", "canonical_solution": "function countPowerNumbers(n, k: integer): integer;var\n  count, x, i, m: integer;\n  t: int64;\n  mp: array of boolean;\nbegin\n  count := 0;\n  x := 0;\n  SetLength(mp, n + 1);\n  i := 2;\n  while i * i * i <= n do\n  begin\n    t := i * i;\n    m := 2;\n    while t <= n div i do\n    begin\n      t := t * i;\n      Inc(m);\n      if (m < k) or (mp[t]) then\n        continue;\n\n      if trunc(sqrt(t)) * trunc(sqrt(t)) = t then\n        Inc(x);\n\n      mp[t] := true;\n      Inc(count);\n    end;\n    i := i + 1;\n  end;\n\n  if k = 1 then\n  begin\n    count := n;\n  end\n  else if k >= 3 then\n  begin\n    count := count + 1;\n  end\n  else\n  begin\n    count := count + trunc(sqrt(n)) - x;\n  end;\n\n  countPowerNumbers := count;\nend;", "buggy_code": "function countPowerNumbers(n, k: integer): integer;var\n  count, x, i, m: integer;\n  t: int64;\n  mp: array of boolean;\nbegin\n  count := 0;\n  x := 0;\n  SetLength(mp, n + 1);\n  i := 2;\n  while i * i * i <= n do\n  begin\n    t := i ** 2 ;\n    m := 2;\n    while t <= n div i do\n    begin\n      t := t * i;\n      Inc(m);\n      if (m < k) or (mp[t]) then\n        continue;\n\n      if trunc(sqrt(t)) * trunc(sqrt(t)) == t then\n        Inc(x);\n\n      mp[t] := true;\n      Inc(count);\n    end;\n    i := i + 1;\n  end;\n\n  if k = 1 then\n  begin\n    count := n;\n  end\n  else if k >= 3 then\n  begin\n    count := count + 1;\n  end\n  else\n  begin\n    count := count + trunc(sqrt(n)) - x;\n  end;\n\n  countPowerNumbers := count;\nend;", "bug_with_line_numbers": "   1 | function countPowerNumbers(n, k: integer): integer;var\n   2 |   count, x, i, m: integer;\n   3 |   t: int64;\n   4 |   mp: array of boolean;\n   5 | begin\n   6 |   count := 0;\n   7 |   x := 0;\n   8 |   SetLength(mp, n + 1);\n   9 |   i := 2;\n  10 |   while i * i * i <= n do\n  11 |   begin\n  12 |     t := i ** 2 ;\n  13 |     m := 2;\n  14 |     while t <= n div i do\n  15 |     begin\n  16 |       t := t * i;\n  17 |       Inc(m);\n  18 |       if (m < k) or (mp[t]) then\n  19 |         continue;\n  20 |       if trunc(sqrt(t)) * trunc(sqrt(t)) == t then\n  21 |         Inc(x);\n  22 |       mp[t] := true;\n  23 |       Inc(count);\n  24 |     end;\n  25 |     i := i + 1;\n  26 |   end;\n  27 |   if k = 1 then\n  28 |   begin\n  29 |     count := n;\n  30 |   end\n  31 |   else if k >= 3 then\n  32 |   begin\n  33 |     count := count + 1;\n  34 |   end\n  35 |   else\n  36 |   begin\n  37 |     count := count + trunc(sqrt(n)) - x;\n  38 |   end;\n  39 |   countPowerNumbers := count;\n  40 | end;", "fragment_lines": [12, 20], "fragment_content": ["t := i ** 2 ;", "if trunc(sqrt(t)) * trunc(sqrt(t)) == t then"], "test": "procedure check;\nbegin\n  Assert(countPowerNumbers(99, 1) = 99);\n  Assert(countPowerNumbers(99, 3) = 7);\n  Assert(countPowerNumbers(99, 2) = 12);\n  Assert(countPowerNumbers(10, 1) = 10);\n  Assert(countPowerNumbers(10, 2) = 4);\n  Assert(countPowerNumbers(500, 1) = 500);\n  Assert(countPowerNumbers(500, 2) = 30);\n  Assert(countPowerNumbers(500, 3) = 13);\n  Assert(countPowerNumbers(1000, 1) = 1000);\n  Assert(countPowerNumbers(1000, 2) = 41);\n  Assert(countPowerNumbers(1000, 3) = 17);\n  Assert(countPowerNumbers(1000, 93) = 1);\n  Assert(countPowerNumbers(50, 2) = 10);\n  Assert(countPowerNumbers(50, 3) = 5);\n  Assert(countPowerNumbers(2, 3) = 1);\nend;\n\nbegin\n  check;\nend.", "instruction": "Observe the following faulty Pascal code\n```pascal\nfunction countPowerNumbers(n, k: integer): integer;var\n  count, x, i, m: integer;\n  t: int64;\n  mp: array of boolean;\nbegin\n  count := 0;\n  x := 0;\n  SetLength(mp, n + 1);\n  i := 2;\n  while i * i * i <= n do\n  begin\n    t := i ** 2 ;\n    m := 2;\n    while t <= n div i do\n    begin\n      t := t * i;\n      Inc(m);\n      if (m < k) or (mp[t]) then\n        continue;\n\n      if trunc(sqrt(t)) * trunc(sqrt(t)) == t then\n        Inc(x);\n\n      mp[t] := true;\n      Inc(count);\n    end;\n    i := i + 1;\n  end;\n\n  if k = 1 then\n  begin\n    count := n;\n  end\n  else if k >= 3 then\n  begin\n    count := count + 1;\n  end\n  else\n  begin\n    count := count + trunc(sqrt(n)) - x;\n  end;\n\n  countPowerNumbers := count;\nend;\n```\nKnown, the bug code specifically exists in the following snippet:\n['t := i ** 2 ;', 'if trunc(sqrt(t)) * trunc(sqrt(t)) == t then']\nFix bugs in the given code snippet. The complete , fixed code must be placed between ```pascal```. Do not generate any test, main,example usage or check code!\n"}
{"question_id": "Pascal/55", "category": "Multiple", "subtype": "double_bug", "level": "medium", "example": "Examples:\n    >>> newModuloFactorial(3, 7)\n    6", "docstring": "This problem introduces a new modulo operation, denoted by \"⊕\". Calculation of x ⊕ y:\n- If x is not a multiple of y, the result is x mod y.\n- Otherwise, if x is a multiple of y, divide x by y until it's no longer a multiple, resulting in x'.\n  The result is then x' mod y.\nFor instance, 4⊕5=4, 20⊕5=4, and 100⊕5=4.\nGiven a prime number p and an integer n, compute the value of n! ⊕ p, where n! is the factorial of n.", "canonical_solution": "{$ASSERTIONS ON}\nfunction newModuloFactorial(n, p: QWord): QWord;var\n  i: QWord;\n  pj: array of QWord;\n  ans: QWord;\nbegin\n  SetLength(pj, p);\n  pj[0] := 1;\n  pj[1] := 1;\n  for i := 2 to p - 1 do\n    pj[i] := (i * pj[i - 1]) mod p;\n\n  ans := 1;\n  while n > 0 do\n  begin\n    ans := (ans * pj[n mod p]) mod p;\n    if (n div p) and 1 = 1 then\n      ans := p - ans;\n    n := n div p;\n  end;\n  newModuloFactorial := ans;\nend;", "buggy_code": "{$ASSERTIONS ON}\nfunction newModuloFactorial(n, p: QWord): QWord;var\n  i: QWord;\n  pj: array of QWord;\n  ans: QWord;\nbegin\n  SetLength(pj, p);\n  pj[0] := 1;\n  pj[1] := 1;\n  for i := 2 to p - 1 do\n    pj[i] := (i * pj[i - 1]) mod p;\n\n  ans := 1;\n  while n > 0 do\n  begin\n    ans := (ans * pj[n]) mod p;\n    if n and 1 = 1 then\n      ans := p - ans;\n    n := n div p;\n  end;\n  newModuloFactorial := ans;\nend;", "bug_with_line_numbers": "   1 | {$ASSERTIONS ON}\n   2 | function newModuloFactorial(n, p: QWord): QWord;var\n   3 |   i: QWord;\n   4 |   pj: array of QWord;\n   5 |   ans: QWord;\n   6 | begin\n   7 |   SetLength(pj, p);\n   8 |   pj[0] := 1;\n   9 |   pj[1] := 1;\n  10 |   for i := 2 to p - 1 do\n  11 |     pj[i] := (i * pj[i - 1]) mod p;\n  12 |   ans := 1;\n  13 |   while n > 0 do\n  14 |   begin\n  15 |     ans := (ans * pj[n]) mod p;\n  16 |     if n and 1 = 1 then\n  17 |       ans := p - ans;\n  18 |     n := n div p;\n  19 |   end;\n  20 |   newModuloFactorial := ans;\n  21 | end;", "fragment_lines": [15, 16], "fragment_content": ["ans := (ans * pj[n]) mod p;", "if n and 1 = 1 then"], "test": "procedure check;\nbegin\n  Assert(newModuloFactorial(3, 7) = 6);\n  Assert(newModuloFactorial(10, 3) = 1);\n  Assert(newModuloFactorial(11, 7) = 4);\n  Assert(newModuloFactorial(45, 7) = 1);\n  Assert(newModuloFactorial(14, 7) = 2);\n  Assert(newModuloFactorial(1919, 10007) = 3152);\n  Assert(newModuloFactorial(810, 10007) = 3679);\n  Assert(newModuloFactorial(3, 7) = 6);\n  Assert(newModuloFactorial(10, 3) = 1);\n  Assert(newModuloFactorial(1, 2) = 1);\n  Assert(newModuloFactorial(5, 11) = 10);\n  Assert(newModuloFactorial(6, 13) = 5);\n  Assert(newModuloFactorial(8, 17) = 13);\n  Assert(newModuloFactorial(15, 19) = 16);\n  Assert(newModuloFactorial(21, 23) = 1);\n  Assert(newModuloFactorial(30, 29) = 28);\n  Assert(newModuloFactorial(100, 101) = 100);\nend;\n\nbegin\n  check;\n  WriteLn('All tests passed successfully.');\nend.", "instruction": "Observe the following faulty Pascal code\n```pascal\n{$ASSERTIONS ON}\nfunction newModuloFactorial(n, p: QWord): QWord;var\n  i: QWord;\n  pj: array of QWord;\n  ans: QWord;\nbegin\n  SetLength(pj, p);\n  pj[0] := 1;\n  pj[1] := 1;\n  for i := 2 to p - 1 do\n    pj[i] := (i * pj[i - 1]) mod p;\n\n  ans := 1;\n  while n > 0 do\n  begin\n    ans := (ans * pj[n]) mod p;\n    if n and 1 = 1 then\n      ans := p - ans;\n    n := n div p;\n  end;\n  newModuloFactorial := ans;\nend;\n```\nKnown, the bug code specifically exists in the following snippet:\n['ans := (ans * pj[n]) mod p;', 'if n and 1 = 1 then']\nFix bugs in the given code snippet. The complete , fixed code must be placed between ```pascal```. Do not generate any test, main,example usage or check code!\n"}
{"question_id": "Pascal/56", "category": "Multiple", "subtype": "double_bug", "level": "hard", "example": "Examples:\n    >>> makeEqualAgain(3, [1, 2, 1])\n    1\n    >>> makeEqualAgain(5, [5, 5, 1, 5, 5])\n    1", "docstring": "You are given an array a of n integers. You can perform at most one operation where \nyou select three integers i, j, x (1 <= i <= j <= n) and replace all elements from \na[i] to a[j] with x, at a cost of (j - i + 1). Find the minimum cost to make all \nelements in the array equal.", "canonical_solution": "{$ASSERTIONS ON}\n\nuses\n  SysUtils;\nfunction makeEqualAgain(n: Integer; a: array of Integer): Integer;var\n  p, q, c, d, k: Integer;\nbegin\n  k := n;\n  p := 1;\n  q := 0;\n  for p := 1 to k - 1 do begin\n    if a[p] <> a[p - 1] then\n      Break;\n  end;\n  for q := k - 1 downto p - 1 do begin\n    if a[q] <> a[p - 1] then\n      Break;\n  end;\n  for d := k - 2 downto 0 do begin\n    if a[d] <> a[d + 1] then\n      Break;\n  end;\n  for c := 0 to d - 1 do begin\n    if a[c] <> a[c + 1] then\n      Break;\n  end;\n  if q - p + 1 < d - c + 1 then\n    makeEqualAgain := q - p + 1\n  else\n    makeEqualAgain := d - c + 1;\nend;", "buggy_code": "{$ASSERTIONS ON}\n\nuses\n  SysUtils;\nfunction makeEqualAgain(n: Integer; a: array of Integer): Integer;var\n  p, q, c, d, k: Integer;\nbegin\n  k := n;\n  p := 1;\n  q := 0;\n  for p := 1 to k - 1 do begin\n    if a[p] <> a[p - 1] then\n      Break;\n  end;\n  for q := k - 1 downto p - 1 do begin\n    if a[q] <> a[p - 1] then\n      Break;\n  end;\n  for d := k - 2 downto 0 do begin\n    if a[d] <> a[d + 1] then\n      Break;\n  end;\n  for c := 0 to d - 1 do begin\n    if a[c] <> a[c + 1] then\n      Break;\n  end;\n  if q - p  > d - c  then\n    makeEqualAgain := q - p\n  else\n    makeEqualAgain := d - c ;\nend;", "bug_with_line_numbers": "   1 | {$ASSERTIONS ON}\n   2 | uses\n   3 |   SysUtils;\n   4 | function makeEqualAgain(n: Integer; a: array of Integer): Integer;var\n   5 |   p, q, c, d, k: Integer;\n   6 | begin\n   7 |   k := n;\n   8 |   p := 1;\n   9 |   q := 0;\n  10 |   for p := 1 to k - 1 do begin\n  11 |     if a[p] <> a[p - 1] then\n  12 |       Break;\n  13 |   end;\n  14 |   for q := k - 1 downto p - 1 do begin\n  15 |     if a[q] <> a[p - 1] then\n  16 |       Break;\n  17 |   end;\n  18 |   for d := k - 2 downto 0 do begin\n  19 |     if a[d] <> a[d + 1] then\n  20 |       Break;\n  21 |   end;\n  22 |   for c := 0 to d - 1 do begin\n  23 |     if a[c] <> a[c + 1] then\n  24 |       Break;\n  25 |   end;\n  26 |   if q - p  > d - c  then\n  27 |     makeEqualAgain := q - p\n  28 |   else\n  29 |     makeEqualAgain := d - c ;\n  30 | end;", "fragment_lines": [26, 27, 29], "fragment_content": ["if q - p  > d - c  then", "makeEqualAgain := q - p", "makeEqualAgain := d - c ;"], "test": "procedure check;\nvar\n  test1 :array[0..2] of Integer = (1, 2, 1);\n  test2 :array[0..4] of Integer= (5, 5, 1, 5, 5);\n  test3 :array[0..3] of Integer= (1, 1, 1, 1);\n  test4 :array[0..5] of Integer= (2, 2, 2, 3, 2, 2);\n  test5 :array[0..0] of Integer= (1);\n  test6 :array[0..1] of Integer= (1, 2);\n  test7 :array[0..3] of Integer= (1, 2, 2, 1);\n  test8 :array[0..6] of Integer= (4, 4, 4, 3, 3, 4, 4);\n  test9 :array[0..5] of Integer= (5, 4, 4, 4, 5, 5);\n  test10 :array[0..6] of Integer=(1, 2, 1, 2, 1, 2, 1);\n  a1 :array[0..5] of Integer= (1, 2, 3, 4, 5, 1);\n  a2 :array[0..6] of Integer= (1, 1, 1, 1, 1, 1, 1);\n  a3 :array[0..7] of Integer= (8, 8, 8, 1, 2, 8, 8, 8);\n  a4 :array[0..2] of Integer= (1, 2, 3);\n  a5 :array[0..6] of Integer= (4, 3, 2, 7, 1, 1, 3);\n  a6 :array[0..8] of Integer= (9, 9, 2, 9, 2, 5, 5, 5, 3);\nbegin\n  Assert(makeEqualAgain(6, a1) = 4);\n  Assert(makeEqualAgain(7, a2) = 0);\n  Assert(makeEqualAgain(8, a3) = 2);\n  Assert(makeEqualAgain(3, a4) = 2);\n  Assert(makeEqualAgain(7, a5) = 6);\n  Assert(makeEqualAgain(9, a6) = 7);\n\n  Assert(makeEqualAgain(3, test1) = 1);\n  Assert(makeEqualAgain(5, test2) = 1);\n  Assert(makeEqualAgain(4, test3) = 0);\n  Assert(makeEqualAgain(6, test4) = 1);\n  Assert(makeEqualAgain(1, test5) = 0);\n  Assert(makeEqualAgain(2, test6) = 1);\n  Assert(makeEqualAgain(4, test7) = 2);\n  Assert(makeEqualAgain(7, test8) = 2);\n  Assert(makeEqualAgain(6, test9) = 3);\n  Assert(makeEqualAgain(7, test10) = 5);\nend;\n\nbegin\n  check;\nend.", "instruction": "Observe the following faulty Pascal code\n```pascal\n{$ASSERTIONS ON}\n\nuses\n  SysUtils;\nfunction makeEqualAgain(n: Integer; a: array of Integer): Integer;var\n  p, q, c, d, k: Integer;\nbegin\n  k := n;\n  p := 1;\n  q := 0;\n  for p := 1 to k - 1 do begin\n    if a[p] <> a[p - 1] then\n      Break;\n  end;\n  for q := k - 1 downto p - 1 do begin\n    if a[q] <> a[p - 1] then\n      Break;\n  end;\n  for d := k - 2 downto 0 do begin\n    if a[d] <> a[d + 1] then\n      Break;\n  end;\n  for c := 0 to d - 1 do begin\n    if a[c] <> a[c + 1] then\n      Break;\n  end;\n  if q - p  > d - c  then\n    makeEqualAgain := q - p\n  else\n    makeEqualAgain := d - c ;\nend;\n```\nKnown, the bug code specifically exists in the following snippet:\n['if q - p  > d - c  then', 'makeEqualAgain := q - p', 'makeEqualAgain := d - c ;']\nFix bugs in the given code snippet. The complete , fixed code must be placed between ```pascal```. Do not generate any test, main,example usage or check code!\n"}
{"question_id": "Pascal/57", "category": "Multiple", "subtype": "double_bug", "level": "medium", "example": "Examples:\n    - minRoundsToSameChar('aab') -> 1", "docstring": "Function: minRoundsToSameChar\n  Given a string consisting of lowercase English letters, this function\n  calculates the minimum number of rounds needed to modify the string so\n  that all of its characters are the same. In each round, you can change\n  one character to another character.", "canonical_solution": "{$ASSERTIONS ON}\n\nuses\n  SysUtils;\nfunction minRoundsToSameChar(s: AnsiString): Integer;var\n  charCount: array[0..25] of Integer;\n  i, maxCount: Integer;\nbegin\n  // Initialize character counts\n  for i := 0 to 25 do\n    charCount[i] := 0;\n\n  // Count the occurrences of each character\n  for i := 1 to Length(s) do\n    Inc(charCount[Ord(s[i]) - Ord('a')]);\n\n  // Find the number of different characters with non-zero counts\n  maxCount := 0;\n  for i := 0 to 25 do\n    if charCount[i] > 0 then\n      Inc(maxCount);\n\n  // The minimum number of rounds required is the count of different\n  // characters minus one, because one character does not need to be changed\n  minRoundsToSameChar := maxCount - 1;\nend;", "buggy_code": "{$ASSERTIONS ON}\n\nuses\n  SysUtils;\nfunction minRoundsToSameChar(s: AnsiString): Integer;var\n  charCount: array[0..25] of Integer;\n  i, maxCount: Integer;\nbegin\n  // Initialize character counts  for i := 0 to 25 do\n    charCount[i] := 0;\n\n  // Count the occurrences of each character\n  for i := 1 to Length(s) do\n    Inc(charCount[Ord(s[i]) - Ord('a')]);\n\n  // Find the number of different characters with non-zero counts\n  maxCount := 0;\n  for i = 0 to 25 do\n    if charCount[i] > 0 then\n      Inc(maxCount);\n\n  // The minimum number of rounds required is the count of different\n  // characters minus one, because one character does not need to be changed\n  minRoundsToSameChar := maxCount - 1;\nend;", "bug_with_line_numbers": "   1 | {$ASSERTIONS ON}\n   2 | uses\n   3 |   SysUtils;\n   4 | function minRoundsToSameChar(s: AnsiString): Integer;var\n   5 |   charCount: array[0..25] of Integer;\n   6 |   i, maxCount: Integer;\n   7 | begin\n   8 |   // Initialize character counts  for i := 0 to 25 do\n   9 |     charCount[i] := 0;\n  10 |   // Count the occurrences of each character\n  11 |   for i := 1 to Length(s) do\n  12 |     Inc(charCount[Ord(s[i]) - Ord('a')]);\n  13 |   // Find the number of different characters with non-zero counts\n  14 |   maxCount := 0;\n  15 |   for i = 0 to 25 do\n  16 |     if charCount[i] > 0 then\n  17 |       Inc(maxCount);\n  18 |   // The minimum number of rounds required is the count of different\n  19 |   // characters minus one, because one character does not need to be changed\n  20 |   minRoundsToSameChar := maxCount - 1;\n  21 | end;", "fragment_lines": [8, 15], "fragment_content": ["// Initialize character counts  for i := 0 to 25 do", "for i = 0 to 25 do"], "test": "procedure check;\nbegin\n  Assert(minRoundsToSameChar('aab') = 1);\n  Assert(minRoundsToSameChar('abc') = 2);\n  Assert(minRoundsToSameChar('aaa') = 0);\n  Assert(minRoundsToSameChar('abab') = 1);\n  Assert(minRoundsToSameChar('zzzzz') = 0);\nend;\n\nbegin\n  check;\nend.", "instruction": "Observe the following faulty Pascal code\n```pascal\n{$ASSERTIONS ON}\n\nuses\n  SysUtils;\nfunction minRoundsToSameChar(s: AnsiString): Integer;var\n  charCount: array[0..25] of Integer;\n  i, maxCount: Integer;\nbegin\n  // Initialize character counts  for i := 0 to 25 do\n    charCount[i] := 0;\n\n  // Count the occurrences of each character\n  for i := 1 to Length(s) do\n    Inc(charCount[Ord(s[i]) - Ord('a')]);\n\n  // Find the number of different characters with non-zero counts\n  maxCount := 0;\n  for i = 0 to 25 do\n    if charCount[i] > 0 then\n      Inc(maxCount);\n\n  // The minimum number of rounds required is the count of different\n  // characters minus one, because one character does not need to be changed\n  minRoundsToSameChar := maxCount - 1;\nend;\n```\nKnown, the bug code specifically exists in the following snippet:\n['// Initialize character counts  for i := 0 to 25 do', 'for i = 0 to 25 do']\nFix bugs in the given code snippet. The complete , fixed code must be placed between ```pascal```. Do not generate any test, main,example usage or check code!\n"}
{"question_id": "Pascal/58", "category": "Multiple", "subtype": "double_bug", "level": "medium", "example": "Example:\n    >>> maxModeSum(3, [1, 2, 3])\n    Should return 17\n    An example sequence that reaches this maximum value is (3,2,3,1,2,2).", "docstring": "Given n positive integers representing the count of each number from 1 to n, \nfind the maximum sum of the mode for all prefixes of a sequence constructed from these numbers. \nThe mode is the largest number among the most frequent elements in a sequence.", "canonical_solution": "{$ASSERTIONS ON}\nfunction maxModeSum(n: int64; const counts: array of int64): int64;var\n  f: array[0..99999] of int64;\n  mx, i: int64;\n  ans : int64;\nbegin\n  ans := 0;\n  mx := 0;\n  for i := 0 to n do f[i] := 0;\n\n  for i := n downto 1 do\n  begin\n    while mx < counts[i - 1] do\n    begin\n      mx := mx + 1;\n      f[mx] := f[mx - 1] + i;\n    end;\n    ans := ans + f[counts[i - 1]];\n  end;\n  maxModeSum := ans;\nend;", "buggy_code": "{$ASSERTIONS ON}\nfunction maxModeSum(n: int64; const counts: array of int64): int64;var\n  f: array[0..99999] of int64;\n  mx, i: int64;\n  ans : int64;\nbegin\n  ans := 0;\n  mx := 0;\n  for i := 0 to n do f[i] := 0;\n\n  for i := n downto 1 do\n  begin\n    while mx < counts[i] do\n    begin\n      mx := mx + 1;\n      f[mx] := f[mx - 1] + i;\n    end;\n    ans := ans + f[counts[i]];\n  end;\n  maxModeSum := ans;\nend;", "bug_with_line_numbers": "   1 | function maxModeSum(n: int64; const counts: array of int64): int64;var\n   2 |   f: array[0..99999] of int64;\n   3 |   mx, i: int64;\n   4 |   ans : int64;\n   5 | begin\n   6 |   ans := 0;\n   7 |   mx := 0;\n   8 |   for i := 0 to n do f[i] := 0;\n   9 |   for i := n downto 1 do\n  10 |   begin\n  11 |     while mx < counts[i] do\n  12 |     begin\n  13 |       mx := mx + 1;\n  14 |       f[mx] := f[mx - 1] + i;\n  15 |     end;\n  16 |     ans := ans + f[counts[i]];\n  17 |   end;\n  18 |   maxModeSum := ans;\n  19 | end;", "fragment_lines": [11, 16], "fragment_content": ["while mx < counts[i] do", "ans := ans + f[counts[i]];"], "test": "procedure check;\nbegin\n  Assert(maxModeSum(3, [1, 3, 2]) = 17);\n  Assert(maxModeSum(4, [4, 1, 2, 3]) = 37);\n  Assert(maxModeSum(2, [1, 1]) = 4);\n  Assert(maxModeSum(5, [1, 2, 3, 4, 5]) = 75);\n  Assert(maxModeSum(1, [100000]) = 100000);\n  Assert(maxModeSum(5, [5, 3, 2, 4, 1]) = 62);\n  Assert(maxModeSum(3, [100000, 100000, 100000]) = 900000);\n  Assert(maxModeSum(3, [2, 2, 5]) = 27);\n  Assert(maxModeSum(4, [4, 4, 4, 4]) = 64);\n  Assert(maxModeSum(6, [1, 2, 3, 4, 5, 6]) = 126);\n  Assert(maxModeSum(3, [3, 1, 2]) = 16);\nend;\n\n(* Main *)\nbegin\n  check;\nend.", "instruction": "Observe the following faulty Pascal code\n```pascal\n{$ASSERTIONS ON}\nfunction maxModeSum(n: int64; const counts: array of int64): int64;var\n  f: array[0..99999] of int64;\n  mx, i: int64;\n  ans : int64;\nbegin\n  ans := 0;\n  mx := 0;\n  for i := 0 to n do f[i] := 0;\n\n  for i := n downto 1 do\n  begin\n    while mx < counts[i] do\n    begin\n      mx := mx + 1;\n      f[mx] := f[mx - 1] + i;\n    end;\n    ans := ans + f[counts[i]];\n  end;\n  maxModeSum := ans;\nend;\n```\nKnown, the bug code specifically exists in the following snippet:\n['while mx < counts[i] do', 'ans := ans + f[counts[i]];']\nFix bugs in the given code snippet. The complete , fixed code must be placed between ```pascal```. Do not generate any test, main,example usage or check code!\n"}
{"question_id": "Pascal/59", "category": "Multiple", "subtype": "triple_bug", "level": "hard", "example": "Examples:\n        >>> countPermutations(2, 1, [1, 2])\n    2", "docstring": "Given a permutation q of n elements and an integer k, find the number of permutations p of n elements such that f(p) = q, where f(p) is the lexicographically smallest permutation that can be obtained by dividing p into exactly k non-empty contiguous segments and sorting each segment(that is, choose $ k-1 $ breakpoints $ 1\\le x_1 < x_2 < \\cdots < x_{k-1} < n $, and divide it into $ [1, x_1], (x_1, x_2], \\cdots, (x_{k-1}, n] $). The result should be modulo 998244353.", "canonical_solution": "{$ASSERTIONS ON}\nuses\n  SysUtils;\nfunction countPermutations(n, k: int64; qq: array of int64): int64;var\n  P, i, j, m, ans, c, kk: int64;\n  q, jc, f: array[0..504] of int64;\n  dp: array[0..504, 0..504] of int64;\nbegin\n  P := 998244353;\n  ans := 0;\n  for i := 0 to n+2 do\n  begin\n    q[i] := 0;\n    jc[i] := 0;\n    f[i] := 0;\n    for j := 0 to n+2 do\n      dp[i][j] := 0;\n  end;\n\n  for i := 1 to n do\n    q[i] := qq[i - 1];\n  dp[0][0] := 1;\n  f[0] := 1;\n  jc[0] := 1;\n  for i := 1 to n do\n    jc[i] := (jc[i - 1] * i) mod P;\n  for i := 1 to n do\n  begin\n    f[i] := jc[i];\n    for j := 1 to i - 1 do\n      f[i] := (f[i] + P - (f[j] * jc[i - j]) mod P) mod P;\n  end;\n  for i := 1 to n do\n  begin\n    for j := 0 to i - 1 do\n      for kk := 1 to n do\n        dp[i][kk] := (dp[i][kk] + (dp[j][kk - 1] * f[i - j]) mod P) mod P;\n  end;\n  m := 0;\n  for i := 1 to n do\n    if q[i] > q[i + 1] then\n    begin\n      m := i;\n      break;\n    end;\n  if m = n then\n  begin\n    for i := k to n do\n    begin\n      ans := (ans + dp[n][i]) mod P;\n    end\n  end\n  else\n  begin\n    for i := m + 1 to n do\n    begin\n      if ((i xor (m + 1) <> 0) and ((q[i - 1] > q[i]) or (q[i] < q[m]))) then\n        break;\n      c := k + i - n - 1;\n      if c >= 0 then\n        ans := (ans + (dp[m][c] * jc[i - m - 1]) mod P) mod P;\n    end;\n  end;\n  countPermutations := ans;\nend;", "buggy_code": "{$ASSERTIONS ON}\nuses\n  SysUtils;\nfunction countPermutations(n, k: int64; qq: array of int64): int64;var\n  P, i, j, m, ans, c, kk: int64;\n  q, jc, f: array[0..504] of int64;\n  dp: array[0..504, 0..504] of int64;\nbegin\n  P := 998244353;\n  ans := 0;\n  for i := 0 to n+2 do\n  begin\n    q[i] := 0;\n    jc[i] := 0;\n    f[i] := 0;\n    for j := 0 to n+2 do\n      dp[i][j] := 0;\n  end;\n\n  for i := 1 to n do\n    q[i] := qq[i - 1];\n  dp[0][0] := 1;\n  f[0] := 1;\n  jc[0] := 1;\n  for i := 1 to n do\n    jc[i] := (jc[i - 1] * i) mod P;\n  for i := 1 to n do\n  begin\n    f[i] := jc[i];\n    for j := 1 to i  do\n      f[i] := (f[i] + P - (f[j] * jc[i - j]) mod P) mod P;\n  end;\n  for i := 1 to n do\n  begin\n    for j := 0 to i - 1 do\n      for kk := 1 to n do\n        dp[i][kk] := (dp[i][kk] + (dp[j][kk] * f[i - j]) mod P) mod P;\n  end;\n  m := 0;\n  for i := 1 to n do\n    if q[i] > q[i + 1] then\n    begin\n      m := i + 1;\n      break;\n    end;\n  if m = n then\n  begin\n    for i := k to n do\n    begin\n      ans := (ans + dp[n][i]) mod P;\n    end\n  end\n  else\n  begin\n    for i := m + 1 to n do\n    begin\n      if ((i xor (m + 1) <> 0) and ((q[i - 1] > q[i]) or (q[i] < q[m]))) then\n        break;\n      c := k + i - n - 1;\n      if c >= 0 then\n        ans := (ans + (dp[m][c] * jc[i - m - 1]) mod P) mod P;\n    end;\n  end;\n  countPermutations := ans;\nend;", "bug_with_line_numbers": "   1 | {$ASSERTIONS ON}\n   2 | uses\n   3 |   SysUtils;\n   4 | function countPermutations(n, k: int64; qq: array of int64): int64;var\n   5 |   P, i, j, m, ans, c, kk: int64;\n   6 |   q, jc, f: array[0..504] of int64;\n   7 |   dp: array[0..504, 0..504] of int64;\n   8 | begin\n   9 |   P := 998244353;\n  10 |   ans := 0;\n  11 |   for i := 0 to n+2 do\n  12 |   begin\n  13 |     q[i] := 0;\n  14 |     jc[i] := 0;\n  15 |     f[i] := 0;\n  16 |     for j := 0 to n+2 do\n  17 |       dp[i][j] := 0;\n  18 |   end;\n  19 |   for i := 1 to n do\n  20 |     q[i] := qq[i - 1];\n  21 |   dp[0][0] := 1;\n  22 |   f[0] := 1;\n  23 |   jc[0] := 1;\n  24 |   for i := 1 to n do\n  25 |     jc[i] := (jc[i - 1] * i) mod P;\n  26 |   for i := 1 to n do\n  27 |   begin\n  28 |     f[i] := jc[i];\n  29 |     for j := 1 to i  do\n  30 |       f[i] := (f[i] + P - (f[j] * jc[i - j]) mod P) mod P;\n  31 |   end;\n  32 |   for i := 1 to n do\n  33 |   begin\n  34 |     for j := 0 to i - 1 do\n  35 |       for kk := 1 to n do\n  36 |         dp[i][kk] := (dp[i][kk] + (dp[j][kk] * f[i - j]) mod P) mod P;\n  37 |   end;\n  38 |   m := 0;\n  39 |   for i := 1 to n do\n  40 |     if q[i] > q[i + 1] then\n  41 |     begin\n  42 |       m := i + 1;\n  43 |       break;\n  44 |     end;\n  45 |   if m = n then\n  46 |   begin\n  47 |     for i := k to n do\n  48 |     begin\n  49 |       ans := (ans + dp[n][i]) mod P;\n  50 |     end\n  51 |   end\n  52 |   else\n  53 |   begin\n  54 |     for i := m + 1 to n do\n  55 |     begin\n  56 |       if ((i xor (m + 1) <> 0) and ((q[i - 1] > q[i]) or (q[i] < q[m]))) then\n  57 |         break;\n  58 |       c := k + i - n - 1;\n  59 |       if c >= 0 then\n  60 |         ans := (ans + (dp[m][c] * jc[i - m - 1]) mod P) mod P;\n  61 |     end;\n  62 |   end;\n  63 |   countPermutations := ans;\n  64 | end;", "fragment_lines": [29, 36, 42], "fragment_content": ["for j := 1 to i  do", "dp[i][kk] := (dp[i][kk] + (dp[j][kk] * f[i - j]) mod P) mod P;", "m := i + 1;"], "test": "procedure testCountPermutations;\nvar\n  q1: array[0..1] of int64 = (1, 2);\n  q2:array[0..2] of int64= (3, 1, 2);\n  q3:array[0..5] of int64= (1, 2, 3, 6, 5, 4);\n  q4:array[0..5] of int64= (1, 2, 3, 4, 5, 6);\n  q5:array[0..5] of int64= (1, 2, 5, 3, 4, 5);\n  q6:array[0..8] of int64= (1, 2, 3, 4, 5, 6, 7, 8, 9);\n  q7:array[0..8] of int64= (1, 2, 3, 4, 5, 6, 7, 9, 8);\nbegin\n  Assert(countPermutations(2, 1, q1) = 2);\n  Assert(countPermutations(3, 3, q2) = 1);\n  Assert(countPermutations(6, 3, q3) = 13);\n  Assert(countPermutations(6, 1, q4) = 720); \n  Assert(countPermutations(6, 3, q5) = 0); \n  Assert(countPermutations(9, 9, q6) = 1); \n  Assert(countPermutations(9, 2, q7) = 29093);\nend;\n\nbegin\n  testCountPermutations;\nend.", "instruction": "Observe the following faulty Pascal code\n```pascal\n{$ASSERTIONS ON}\nuses\n  SysUtils;\nfunction countPermutations(n, k: int64; qq: array of int64): int64;var\n  P, i, j, m, ans, c, kk: int64;\n  q, jc, f: array[0..504] of int64;\n  dp: array[0..504, 0..504] of int64;\nbegin\n  P := 998244353;\n  ans := 0;\n  for i := 0 to n+2 do\n  begin\n    q[i] := 0;\n    jc[i] := 0;\n    f[i] := 0;\n    for j := 0 to n+2 do\n      dp[i][j] := 0;\n  end;\n\n  for i := 1 to n do\n    q[i] := qq[i - 1];\n  dp[0][0] := 1;\n  f[0] := 1;\n  jc[0] := 1;\n  for i := 1 to n do\n    jc[i] := (jc[i - 1] * i) mod P;\n  for i := 1 to n do\n  begin\n    f[i] := jc[i];\n    for j := 1 to i  do\n      f[i] := (f[i] + P - (f[j] * jc[i - j]) mod P) mod P;\n  end;\n  for i := 1 to n do\n  begin\n    for j := 0 to i - 1 do\n      for kk := 1 to n do\n        dp[i][kk] := (dp[i][kk] + (dp[j][kk] * f[i - j]) mod P) mod P;\n  end;\n  m := 0;\n  for i := 1 to n do\n    if q[i] > q[i + 1] then\n    begin\n      m := i + 1;\n      break;\n    end;\n  if m = n then\n  begin\n    for i := k to n do\n    begin\n      ans := (ans + dp[n][i]) mod P;\n    end\n  end\n  else\n  begin\n    for i := m + 1 to n do\n    begin\n      if ((i xor (m + 1) <> 0) and ((q[i - 1] > q[i]) or (q[i] < q[m]))) then\n        break;\n      c := k + i - n - 1;\n      if c >= 0 then\n        ans := (ans + (dp[m][c] * jc[i - m - 1]) mod P) mod P;\n    end;\n  end;\n  countPermutations := ans;\nend;\n```\nKnown, the bug code specifically exists in the following snippet:\n['for j := 1 to i  do', 'dp[i][kk] := (dp[i][kk] + (dp[j][kk] * f[i - j]) mod P) mod P;', 'm := i + 1;']\nFix bugs in the given code snippet. The complete , fixed code must be placed between ```pascal```. Do not generate any test, main,example usage or check code!\n"}
{"question_id": "Pascal/60", "category": "Multiple", "subtype": "triple_bug", "level": "hard", "example": "Examples:\n       >>> minOperations(5, [1, 2, 3, 2, 1])\n       2", "docstring": "Given a 1 by n pixel image where each pixel has a color represented by an integer,\n   you can pick a color and change all connected pixels of the same color to the chosen color.\n   Two pixels are connected if they are adjacent and have the same color.\n   Find the minimum number of operations required to make all pixels the same color.\n\n   Note: For each color, there are at most 20 pixels of that color.", "canonical_solution": "{$ASSERTIONS ON}\nfunction minOperations(n: Integer; pixels: array of Integer): Integer;var\n  pre, u: array of Integer;\n  f: array of array of int64;\n  i, j, len, l: Integer;\nbegin\n  SetLength(pre, n + 1);\n  SetLength(u, n + 1);\n  SetLength(f, n + 1, n + 1);\n\n  for i := 1 to n do\n  begin\n    pre[i] := 0;\n    u[i] := 0;\n  end;\n\n  for i := 1 to n do\n  begin\n    pre[i] := u[pixels[i - 1]];\n    u[pixels[i - 1]] := i;\n  end;\n\n  for i := 1 to n do\n    for j := 1 to n do\n      if i <> j then f[i, j] := 10000000\n      else f[i, j] := 0;\n  for len := 2 to n do\n    for i := 1 to n - len + 1 do\n    begin\n      j := i + len - 1;\n      f[i, j] := f[i, j - 1] + 1;\n      l := pre[j];\n      while l >= i do\n      begin\n        if f[i, j] < f[i, l] + f[l + 1, j] then\n          f[i, j] := f[i, j]\n        else\n          f[i, j] := f[i, l] + f[l + 1, j];\n        l := pre[l];\n      end;\n    end;\n\n  minOperations := f[1, n];\nend;", "buggy_code": "{$ASSERTIONS ON}\nfunction minOperations(n: Integer; pixels: array of Integer): Integer;var\n  pre, u: array of Integer;\n  f: array of array of int64;\n  i, j, len, l: Integer;\nbegin\n  SetLength(pre, n + 1);\n  SetLength(u, n + 1);\n  SetLength(f, n + 1, n + 1);\n\n  for i := 1 to n do\n  begin\n    pre[i] := 0;\n    u[i] := 0;\n  end;\n\n  for i := 1 to n do\n  begin\n    pre[i] := u[pixels[i - 1]];\n    u[pixels[i - 1]] := i;\n  end;\n\n  for i := 1 to n do\n    for j := 1 to n do\n      if i != j then f[i, j] := 10000000\n      else f[i, j] := 0;\n  for len := 2 to n do\n    for i := 1 to n - len + 1 do\n    begin\n      j := i + len - 1;\n      f[i, j] := f[i, j - 1] + 1;\n      l := pre[j];\n      while l > i do\n      begin\n        if f[i, j] < f[i, l] + f[l + 1, j] then\n          f[i, j] := f[i, j]\n        else\n          f[i, j] := f[i, l] + f[l + 1, j];\n        l := pre[l];\n      end;\n    end\n\n  minOperations := f[1, n];\nend;", "bug_with_line_numbers": "   1 | {$ASSERTIONS ON}\n   2 | function minOperations(n: Integer; pixels: array of Integer): Integer;var\n   3 |   pre, u: array of Integer;\n   4 |   f: array of array of int64;\n   5 |   i, j, len, l: Integer;\n   6 | begin\n   7 |   SetLength(pre, n + 1);\n   8 |   SetLength(u, n + 1);\n   9 |   SetLength(f, n + 1, n + 1);\n  10 |   for i := 1 to n do\n  11 |   begin\n  12 |     pre[i] := 0;\n  13 |     u[i] := 0;\n  14 |   end;\n  15 |   for i := 1 to n do\n  16 |   begin\n  17 |     pre[i] := u[pixels[i - 1]];\n  18 |     u[pixels[i - 1]] := i;\n  19 |   end;\n  20 |   for i := 1 to n do\n  21 |     for j := 1 to n do\n  22 |       if i != j then f[i, j] := 10000000\n  23 |       else f[i, j] := 0;\n  24 |   for len := 2 to n do\n  25 |     for i := 1 to n - len + 1 do\n  26 |     begin\n  27 |       j := i + len - 1;\n  28 |       f[i, j] := f[i, j - 1] + 1;\n  29 |       l := pre[j];\n  30 |       while l > i do\n  31 |       begin\n  32 |         if f[i, j] < f[i, l] + f[l + 1, j] then\n  33 |           f[i, j] := f[i, j]\n  34 |         else\n  35 |           f[i, j] := f[i, l] + f[l + 1, j];\n  36 |         l := pre[l];\n  37 |       end;\n  38 |     end\n  39 |   minOperations := f[1, n];\n  40 | end;", "fragment_lines": [22, 30, 38], "fragment_content": ["if i != j then f[i, j] := 10000000", "while l > i do", "end"], "test": "procedure check;\nbegin\n  Assert(minOperations(5, [1, 2, 3, 2, 1]) = 2);\n  Assert(minOperations(4, [1, 1, 2, 2]) = 1);\n  Assert(minOperations(5, [1, 2, 1, 4, 2]) = 3);\n  Assert(minOperations(5, [5, 5, 5, 5, 5]) = 0);\n  Assert(minOperations(6, [1, 1, 1, 2, 2, 2]) = 1);\n  Assert(minOperations(7, [1, 3, 3, 3, 2, 2, 2]) = 2);\n  Assert(minOperations(8, [4, 4, 4, 4, 3, 3, 3, 3]) = 1);\n  Assert(minOperations(9, [1, 2, 3, 4, 5, 6, 7, 8, 9]) = 8);\n  Assert(minOperations(10, [1, 2, 1, 2, 1, 2, 1, 2, 1, 2]) = 5);\n  Assert(minOperations(3, [3, 3, 3]) = 0);\n  Assert(minOperations(4, [2, 1, 1, 2]) = 1);\nend;\n\nbegin\n  check;\nend.", "instruction": "Observe the following faulty Pascal code\n```pascal\n{$ASSERTIONS ON}\nfunction minOperations(n: Integer; pixels: array of Integer): Integer;var\n  pre, u: array of Integer;\n  f: array of array of int64;\n  i, j, len, l: Integer;\nbegin\n  SetLength(pre, n + 1);\n  SetLength(u, n + 1);\n  SetLength(f, n + 1, n + 1);\n\n  for i := 1 to n do\n  begin\n    pre[i] := 0;\n    u[i] := 0;\n  end;\n\n  for i := 1 to n do\n  begin\n    pre[i] := u[pixels[i - 1]];\n    u[pixels[i - 1]] := i;\n  end;\n\n  for i := 1 to n do\n    for j := 1 to n do\n      if i != j then f[i, j] := 10000000\n      else f[i, j] := 0;\n  for len := 2 to n do\n    for i := 1 to n - len + 1 do\n    begin\n      j := i + len - 1;\n      f[i, j] := f[i, j - 1] + 1;\n      l := pre[j];\n      while l > i do\n      begin\n        if f[i, j] < f[i, l] + f[l + 1, j] then\n          f[i, j] := f[i, j]\n        else\n          f[i, j] := f[i, l] + f[l + 1, j];\n        l := pre[l];\n      end;\n    end\n\n  minOperations := f[1, n];\nend;\n```\nKnown, the bug code specifically exists in the following snippet:\n['if i != j then f[i, j] := 10000000', 'while l > i do', 'end']\nFix bugs in the given code snippet. The complete , fixed code must be placed between ```pascal```. Do not generate any test, main,example usage or check code!\n"}
{"question_id": "Pascal/61", "category": "Special", "subtype": "Misused := and =", "level": "medium", "example": "\nExamples:\n    >>> calculate_triangle_area(3, 5, 4)\n    6.00", "docstring": "Calculates the area of a triangle given the lengths of its three sides.\n\nParameters:\n- a (real): Length of side 'a'.\n- b (real): Length of side 'b'.\n- c (real): Length of side 'c'.\n\nReturns:\n- real: If the sides can form a triangle, returns the calculated area rounded to 2 decimal places.\n         Otherwise, returns -1 indicating that the sides do not form a triangle.", "canonical_solution": "{$ASSERTIONS ON}\n\nuses \n  Math, SysUtils;\n(*\nCalculates the area of a triangle given the lengths of its three sides.\n\nParameters:\n- a (real): Length of side 'a'.\n- b (real): Length of side 'b'.\n- c (real): Length of side 'c'.\n\nReturns:\n- real: If the sides can form a triangle, returns the calculated area rounded to 2 decimal places.\n         Otherwise, returns -1 indicating that the sides do not form a triangle.\n\nExamples:\n    >>> calculate_triangle_area(3, 5, 4)\n    6.00\n*)\nfunction calculate_triangle_area(a, b, c: real): real;\nvar\n  s: real;\n\nbegin\n  if (a + b > c) and (a + c > b) and (b + c > a) then\n  begin\n    s := (a + b + c) / 2;\n    calculate_triangle_area := sqrt(s * (s - a) * (s - b) * (s - c));\n  end\n  else\n    calculate_triangle_area := -1; (* Not a triangle *)\nend;", "buggy_code": "{$ASSERTIONS ON}\n\nuses \n  Math, SysUtils;\nfunction calculate_triangle_area(a, b, c: real): real;\nvar\n  s: real;\n\nbegin\n  if (a + b > c) and (a + c > b) and (b + c > a) then\n  begin\n    s = (a + b + c) / 2;\n    calculate_triangle_area = sqrt(s * (s - a) * (s - b) * (s - c));\n  end\n  else\n    calculate_triangle_area = -1; (* Not a triangle *)\nend;", "bug_with_line_numbers": "   1 | {$ASSERTIONS ON}\n   2 | uses \n   3 |   Math, SysUtils;\n   4 |  function calculate_triangle_area(a, b, c: real): real;\n   5 | var\n   6 |   s: real;\n   7 | begin\n   8 |   if (a + b > c) and (a + c > b) and (b + c > a) then\n   9 |   begin\n  10 |     s = (a + b + c) / 2;\n  11 |     calculate_triangle_area = sqrt(s * (s - a) * (s - b) * (s - c));\n  12 |   end\n  13 |   else\n  14 |     calculate_triangle_area = -1; (* Not a triangle *)\n  15 | end;", "fragment_lines": [10, 11, 14], "fragment_content": ["s = (a + b + c) / 2;", "calculate_triangle_area = sqrt(s * (s - a) * (s - b) * (s - c));", "calculate_triangle_area = -1; (* Not a triangle *)"], "test": "procedure testCalculateTriangleArea;\nvar\n  area: real;\nbegin\n  (* Triangle with sides 3, 5, 4 should return area 6 *)\n  area := calculate_triangle_area(3, 5, 4);\n  Assert(abs(area - 6) < 1e-6);\n\n  (* Not a triangle with sides 1, 1, 4 should return -1 *)\n  area := calculate_triangle_area(1, 1, 4);\n  Assert(area = -1);\n\n  (* Triangle with sides 7, 24, 25 should return area 84 *)\n  area := calculate_triangle_area(7, 24, 25);\n  Assert(abs(area - 84) < 1e-6);\n\n  (* Triangle with sides 10.5, 6.2, 7.3 should return a calculated area *)\n  area := calculate_triangle_area(10.5, 6.2, 7.3);\n  (* For precision issues, we test if the calculated area is close enough to the expected value *)\n  Assert(abs(area - 22.15) < 1e-2);\nend;\n\n(* Main *)\nbegin\n  testCalculateTriangleArea;\nend.", "instruction": "Observe the following faulty Pascal code\n```pascal\n{$ASSERTIONS ON}\n\nuses \n  Math, SysUtils;\nfunction calculate_triangle_area(a, b, c: real): real;\nvar\n  s: real;\n\nbegin\n  if (a + b > c) and (a + c > b) and (b + c > a) then\n  begin\n    s = (a + b + c) / 2;\n    calculate_triangle_area = sqrt(s * (s - a) * (s - b) * (s - c));\n  end\n  else\n    calculate_triangle_area = -1; (* Not a triangle *)\nend;\n```\nKnown, the bug code specifically exists in the following snippet:\n['s = (a + b + c) / 2;', 'calculate_triangle_area = sqrt(s * (s - a) * (s - b) * (s - c));', 'calculate_triangle_area = -1; (* Not a triangle *)']\nFix bugs in the given code snippet. The complete , fixed code must be placed between ```pascal```. Do not generate any test, main,example usage or check code!\n"}
{"question_id": "Pascal/62", "category": "Special", "subtype": "Misused := and =", "level": "easy", "example": "    Examples:\n    - find_integers(7, 11): -1\n", "docstring": "Given integers c and d, with the conditions a + b = c and a * b = d, determine a\npossible value for integer a (where a <= b). If multiple pairs (a, b) satisfy\nthe conditions, choose the one with the smallest value of a. If there are no such\npairs, return -1.\n\n    Parameters:\n    - c (integer): The sum of a and b.\n    - d (integer): The product of a and b.\n\n    Returns:\n    An integer representing a possible value of a, or -1 if no valid pairs are found.\n", "canonical_solution": "{$ASSERTIONS ON}\n(*\nGiven integers c and d, with the conditions a + b = c and a * b = d, determine a\npossible value for integer a (where a <= b). If multiple pairs (a, b) satisfy\nthe conditions, choose the one with the smallest value of a. If there are no such\npairs, return -1.\n\n    Parameters:\n    - c (integer): The sum of a and b.\n    - d (integer): The product of a and b.\n\n    Returns:\n    An integer representing a possible value of a, or -1 if no valid pairs are found.\n\n    Examples:\n    - find_integers(7, 11): -1\n*)\nfunction find_integers(c, d: integer): integer;\n\nvar\n  i: integer;\nbegin\n    for i := 0 to c div 2 do\n    begin\n        if (i * (c - i) = d) then\n        begin\n            find_integers := i;\n            Exit; // Exit the loop and function on the first match.\n        end;\n    end;\n    find_integers := -1; // Return -1 if no valid pairs (a, b) are found.\nend;", "buggy_code": "{$ASSERTIONS ON}\n(*\nGiven integers c and d, with the conditions a + b = c and a * b = d, determine a\npossible value for integer a (where a <= b). If multiple pairs (a, b) satisfy\nthe conditions, choose the one with the smallest value of a. If there are no such\npairs, return -1.\n\n    Parameters:\n    - c (integer): The sum of a and b.\n    - d (integer): The product of a and b.\n\n    Returns:\n    An integer representing a possible value of a, or -1 if no valid pairs are found.\n\n    Examples:\n    - find_integers(7, 11): -1\n*)\nfunction find_integers(c, d: integer): integer;\n\nvar\n  i: integer;\nbegin\n    for i = 0 to c div 2 do\n    begin\n        if (i * (c - i) = d) then\n        begin\n            find_integers = i;\n            Exit; // Exit the loop and function on the first match.\n        end;\n    end;\n    find_integers = -1; // Return -1 if no valid pairs (a, b) are found.\nend;", "bug_with_line_numbers": "   1 | {$ASSERTIONS ON}\n   2 | (*\n   3 | Given integers c and d, with the conditions a + b = c and a * b = d, determine a\n   4 | possible value for integer a (where a <= b). If multiple pairs (a, b) satisfy\n   5 | the conditions, choose the one with the smallest value of a. If there are no such\n   6 | pairs, return -1.\n   7 |     Parameters:\n   8 |     - c (integer): The sum of a and b.\n   9 |     - d (integer): The product of a and b.\n  10 |     Returns:\n  11 |     An integer representing a possible value of a, or -1 if no valid pairs are found.\n  12 |     Examples:\n  13 |     - find_integers(7, 11): -1\n  14 | *)\n  15 | function find_integers(c, d: integer): integer;\n  16 | var\n  17 |   i: integer;\n  18 | begin\n  19 |     for i = 0 to c div 2 do\n  20 |     begin\n  21 |         if (i * (c - i) = d) then\n  22 |         begin\n  23 |             find_integers = i;\n  24 |             Exit; \n  25 |         end;\n  26 |     end;\n  27 |     find_integers = -1; \n  28 | end;", "fragment_lines": [19, 23, 27], "fragment_content": ["for i = 0 to c div 2 do", "find_integers = i;", "find_integers = -1;"], "test": "procedure testFindIntegers;\nbegin\n    Assert(find_integers(5, 6) = 2);\n    Assert(find_integers(6, 9) = 3);\n    Assert(find_integers(7, 12) = 3);\n    Assert(find_integers(7, 11) = -1);\n    Assert(find_integers(9, 8) = 1);\n    Assert(find_integers(10, 25) = 5);\n    Assert(find_integers(10000, 8765) = -1);\nend;\n\nbegin\n    testFindIntegers;\nend.", "instruction": "Observe the following faulty Pascal code\n```pascal\n{$ASSERTIONS ON}\n(*\nGiven integers c and d, with the conditions a + b = c and a * b = d, determine a\npossible value for integer a (where a <= b). If multiple pairs (a, b) satisfy\nthe conditions, choose the one with the smallest value of a. If there are no such\npairs, return -1.\n\n    Parameters:\n    - c (integer): The sum of a and b.\n    - d (integer): The product of a and b.\n\n    Returns:\n    An integer representing a possible value of a, or -1 if no valid pairs are found.\n\n    Examples:\n    - find_integers(7, 11): -1\n*)\nfunction find_integers(c, d: integer): integer;\n\nvar\n  i: integer;\nbegin\n    for i = 0 to c div 2 do\n    begin\n        if (i * (c - i) = d) then\n        begin\n            find_integers = i;\n            Exit; // Exit the loop and function on the first match.\n        end;\n    end;\n    find_integers = -1; // Return -1 if no valid pairs (a, b) are found.\nend;\n```\nKnown, the bug code specifically exists in the following snippet:\n['for i = 0 to c div 2 do', 'find_integers = i;', 'find_integers = -1;']\nFix bugs in the given code snippet. The complete , fixed code must be placed between ```pascal```. Do not generate any test, main,example usage or check code!\n"}
{"question_id": "Pascal/63", "category": "Special", "subtype": "Misused := and =", "level": "easy", "example": "\n evenSumOrOddProduct(2, 3) returns 6", "docstring": "Given two integers a and b, return the sum if the sum is even, or return the product of a and b if the sum is odd.\nExample usage:\n  evenSumOrOddProduct(2, 3) returns 6", "canonical_solution": "{$ASSERTIONS ON}\n(**\nGiven two integers a and b, return the sum if the sum is even, or return the product of a and b if the sum is odd.\nExample usage:\n  evenSumOrOddProduct(2, 3) returns 6\n*)\nfunction evenSumOrOddProduct(a, b: Integer): Integer;\n\nvar\n  sum: Integer;\nbegin\n  sum := a + b;\n  if sum mod 2 = 0 then\n    evenSumOrOddProduct := sum\n  else\n    evenSumOrOddProduct := a * b;\nend;", "buggy_code": "{$ASSERTIONS ON}\n(**\nGiven two integers a and b, return the sum if the sum is even, or return the product of a and b if the sum is odd.\nExample usage:\n  evenSumOrOddProduct(2, 3) returns 6\n*)\nfunction evenSumOrOddProduct(a, b: Integer): Integer;\n\nvar\n  sum: Integer;\nbegin\n  sum = a + b;\n  if sum mod 2 = 0 then\n    evenSumOrOddProduct = sum\n  else\n    evenSumOrOddProduct = a * b;\nend;", "bug_with_line_numbers": "   1 | {$ASSERTIONS ON}\n   2 | (**\n   3 | Given two integers a and b, return the sum if the sum is even, or return the product of a and b if the sum is odd.\n   4 | Example usage:\n   5 |   evenSumOrOddProduct(2, 3) returns 6\n   6 | *)\n   7 | function evenSumOrOddProduct(a, b: Integer): Integer;\n   8 | var\n   9 |   sum: Integer;\n  10 | begin\n  11 |   sum = a + b;\n  12 |   if sum mod 2 = 0 then\n  13 |     evenSumOrOddProduct = sum\n  14 |   else\n  15 |     evenSumOrOddProduct = a * b;\n  16 | end;", "fragment_lines": [11, 13, 15], "fragment_content": ["sum = a + b;", "evenSumOrOddProduct = sum", "evenSumOrOddProduct = a * b;"], "test": "procedure testEvenSumOrOddProduct;\nbegin\n  Assert(evenSumOrOddProduct(2, 3) = 6);\n  Assert(evenSumOrOddProduct(5, 5) = 10);\n  Assert(evenSumOrOddProduct(1, 1) = 2);\n  Assert(evenSumOrOddProduct(0, 0) = 0);\n  Assert(evenSumOrOddProduct(-1, -1) = -2);\n  Assert(evenSumOrOddProduct(100, 200) = 300);\n  Assert(evenSumOrOddProduct(3, 4) = 12);\n  Assert(evenSumOrOddProduct(-5, 5) = 0);\n  Assert(evenSumOrOddProduct(7, 8) = 56);\n  Assert(evenSumOrOddProduct(9, 10) = 90);\n  Assert(evenSumOrOddProduct(11, 14) = 154);\nend;\n\nbegin\n  testEvenSumOrOddProduct;\nend.", "instruction": "Observe the following faulty Pascal code\n```pascal\n{$ASSERTIONS ON}\n(**\nGiven two integers a and b, return the sum if the sum is even, or return the product of a and b if the sum is odd.\nExample usage:\n  evenSumOrOddProduct(2, 3) returns 6\n*)\nfunction evenSumOrOddProduct(a, b: Integer): Integer;\n\nvar\n  sum: Integer;\nbegin\n  sum = a + b;\n  if sum mod 2 = 0 then\n    evenSumOrOddProduct = sum\n  else\n    evenSumOrOddProduct = a * b;\nend;\n```\nKnown, the bug code specifically exists in the following snippet:\n['sum = a + b;', 'evenSumOrOddProduct = sum', 'evenSumOrOddProduct = a * b;']\nFix bugs in the given code snippet. The complete , fixed code must be placed between ```pascal```. Do not generate any test, main,example usage or check code!\n"}
{"question_id": "Pascal/64", "category": "Special", "subtype": "Misused begin/end", "level": "medium", "example": "\n        - For 0 <= x < 10: y = cos(x + 3.0)\n        - For 10 <= x < 20: y = (cos(x + 7.5))^2\n        - For 20 <= x < 30: y = (cos(x + 4.0))^4\n        >>> calculate_function_value(40)\n        'Not define'", "docstring": "Calculates the value of the function for a given input.\n      Parameters:\n        - x (integer): Input value for the function.\n      Returns:\n        - A string with either the calculated function value rounded to 5 decimal places,\n          or a notice that the input is not in the defined domain ('Not define').\n       \n      Function Definitions:\n        - For 0 <= x < 10: y = cos(x + 3.0)\n        - For 10 <= x < 20: y = (cos(x + 7.5))^2\n        - For 20 <= x < 30: y = (cos(x + 4.0))^4", "canonical_solution": "{$ASSERTIONS ON}\n\nuses\n  Math, SysUtils;\n(*\n    Calculates the value of the function for a given input.\n      Parameters:\n        - x (integer): Input value for the function.\n      Returns:\n        - A string with either the calculated function value rounded to 5 decimal places,\n          or a notice that the input is not in the defined domain (\"Not define\").\n       \n      Function Definitions:\n        - For 0 <= x < 10: y = cos(x + 3.0)\n        - For 10 <= x < 20: y = (cos(x + 7.5))^2\n        - For 20 <= x < 30: y = (cos(x + 4.0))^4\n        >>> calculate_function_value(40)\n        'Not define'\n*)\nfunction calculate_function_value(x: Integer): string;\n\nvar\n  calculated_value: Double;\nbegin\n  if (0 <= x) and (x < 10) then\n  begin\n    calculated_value := cos(x + 3.0);\n    calculate_function_value := FormatFloat('0.00000', calculated_value);\n  end\n  else if (10 <= x) and (x < 20) then\n  begin\n    calculated_value := Power(cos(x + 7.5), 2.0);\n    calculate_function_value := FormatFloat('0.00000', calculated_value);\n  end\n  else if (20 <= x) and (x < 30) then\n  begin\n    calculated_value := Power(cos(x + 4.0), 4.0);\n    calculate_function_value := FormatFloat('0.00000', calculated_value);\n  end\n  else\n  begin\n    calculate_function_value := 'Not define';\n  end;\nend;", "buggy_code": "{$ASSERTIONS ON}\n\nuses\n  Math, SysUtils;\n\nfunction calculate_function_value(x: Integer): string;\nvar\n  calculated_value: Double;\nbegin\n  if (0 <= x) and (x < 10) then\n  begin\n    calculated_value := cos(x + 3.0);\n    calculate_function_value := FormatFloat('0.00000', calculated_value);\n  end\n  else if (10 <= x) and (x < 20) then\n  begin\n    calculated_value := Power(cos(x + 7.5), 2.0);\n    calculate_function_value := FormatFloat('0.00000', calculated_value);\n  end\n  else if (20 <= x) and (x < 30) then\n    calculated_value := Power(cos(x + 4.0), 4.0);\n    calculate_function_value := FormatFloat('0.00000', calculated_value);\n  else\n  begin\n    calculate_function_value := 'Not define';\n  end;\nend;", "bug_with_line_numbers": "   1 | {$ASSERTIONS ON}\n   2 | uses\n   3 |   Math, SysUtils;\n   4 | function calculate_function_value(x: Integer): string;\n   5 | var\n   6 |   calculated_value: Double;\n   7 | begin\n   8 |   if (0 <= x) and (x < 10) then\n   9 |   begin\n  10 |     calculated_value := cos(x + 3.0);\n  11 |     calculate_function_value := FormatFloat('0.00000', calculated_value);\n  12 |   end\n  13 |   else if (10 <= x) and (x < 20) then\n  14 |   begin\n  15 |     calculated_value := Power(cos(x + 7.5), 2.0);\n  16 |     calculate_function_value := FormatFloat('0.00000', calculated_value);\n  17 |   end\n  18 |   else if (20 <= x) and (x < 30) then\n  19 |     calculated_value := Power(cos(x + 4.0), 4.0);\n  20 |     calculate_function_value := FormatFloat('0.00000', calculated_value);\n  21 |   else\n  22 |   begin\n  23 |     calculate_function_value := 'Not define';\n  24 |   end;\n  25 | end;", "fragment_lines": [-1], "fragment_content": ["missing critical code snippet"], "test": "procedure testCalculateFunctionValue;\nvar\n  result: string;\nbegin\n  result := calculate_function_value(40);\n  Assert(result = 'Not define');\n  // WriteLn(calculate_function_value(5))\n\n  // Additional test cases based on provided function definitions\n  Assert(calculate_function_value(5) = '-0.14550');\n  Assert(calculate_function_value(15) = '0.76266');\n  Assert(calculate_function_value(25) = '0.31314');\n  Assert(calculate_function_value(-1) = 'Not define');\nend;\n\nbegin\n  testCalculateFunctionValue;\nend.", "instruction": "Observe the following faulty Pascal code\n```pascal\n{$ASSERTIONS ON}\n\nuses\n  Math, SysUtils;\n\nfunction calculate_function_value(x: Integer): string;\nvar\n  calculated_value: Double;\nbegin\n  if (0 <= x) and (x < 10) then\n  begin\n    calculated_value := cos(x + 3.0);\n    calculate_function_value := FormatFloat('0.00000', calculated_value);\n  end\n  else if (10 <= x) and (x < 20) then\n  begin\n    calculated_value := Power(cos(x + 7.5), 2.0);\n    calculate_function_value := FormatFloat('0.00000', calculated_value);\n  end\n  else if (20 <= x) and (x < 30) then\n    calculated_value := Power(cos(x + 4.0), 4.0);\n    calculate_function_value := FormatFloat('0.00000', calculated_value);\n  else\n  begin\n    calculate_function_value := 'Not define';\n  end;\nend;\n```\nKnown, the bug code specifically exists in the following snippet:\n['missing critical code snippet']\nFix bugs in the given code snippet. The complete , fixed code must be placed between ```pascal```. Do not generate any test, main,example usage or check code!\n"}
{"question_id": "Pascal/65", "category": "Special", "subtype": "Misused begin/end", "level": "easy", "example": "\nExamples:\n- process_request(1) returns 1\n- process_request(2) returns 2\n- process_request(3) returns 6\n", "docstring": "Calculates the factorial of a given number N modulo 10007.\n\nParameters:\n- N (integer): An integer representing the input value (N <= 10000).\n\nReturns:\n- integer: The factorial of N modulo 10007.\n", "canonical_solution": "{$ASSERTIONS ON}\n{\n  Calculates the factorial of a given number N modulo 10007.\n  \n  Parameters:\n  - N (integer): An integer representing the input value (N <= 10000).\n  \n  Returns:\n  - integer: The factorial of N modulo 10007.\n  \n  Examples:\n  - process_request(1) returns 1\n  - process_request(2) returns 2\n  - process_request(3) returns 6\n}\nfunction process_request(n: integer): integer;\n\nconst\n  MODULO = 10007;\nvar\n  a: array[0..10000] of integer;\n  i: integer;\nbegin\n  // Initialize the first two factorials\n  a[0] := 1;\n  a[1] := 1;\n  // Calculate factorials up to 10000 modulo 10007\n  for i := 2 to 10000 do\n  begin\n    a[i] := (a[i-1] * i) mod MODULO;\n  end;\n  \n  // Return the requested factorial modulo\n  process_request := a[n];\nend;", "buggy_code": "{$ASSERTIONS ON}\nfunction process_request(n: integer): integer;\nconst\n  MODULO = 10007;\nvar\n  a: array[0..10000] of integer;\n  i: integer;\nbegin\n  a[0] := 1;\n  a[1] := 1;\n  for i := 2 to 10000 do\n  begin\n    a[i] := (a[i-1] * i) mod MODULO;\n  end;\n  process_request := a[n];", "bug_with_line_numbers": "   1 | {$ASSERTIONS ON}\n   2 | function process_request(n: integer): integer;\n   3 | const\n   4 |   MODULO = 10007;\n   5 | var\n   6 |   a: array[0..10000] of integer;\n   7 |   i: integer;\n   8 | begin\n   9 |   a[0] := 1;\n  10 |   a[1] := 1;\n  11 |   for i := 2 to 10000 do\n  12 |   begin\n  13 |     a[i] := (a[i-1] * i) mod MODULO;\n  14 |   end;\n  15 |   begin\n  16 |     a[n] := a[n] * 2;\n  17 |   end;\n  18 |   process_request := a[n];", "fragment_lines": [-1], "fragment_content": ["missing critical code snippet"], "test": "procedure testProcessRequest;\nbegin\n  Assert(process_request(0) = 1, 'Test for N = 0 failed');\n  Assert(process_request(1) = 1, 'Test for N = 1 failed');\n  Assert(process_request(2) = 2, 'Test for N = 2 failed');\n  Assert(process_request(3) = 6, 'Test for N = 3 failed');\n  Assert(process_request(4) = 24, 'Test for N = 4 failed');\n  Assert(process_request(10) = 6266, 'Test for N = 10 failed');\n  Assert(process_request(10000) = 6991, 'Test for N = 10000 failed');\nend;\n\nbegin\n  (* Run the tests *)\n  testProcessRequest;\n  // WriteLn('All tests passed.');\nend.", "instruction": "Observe the following faulty Pascal code\n```pascal\n{$ASSERTIONS ON}\nfunction process_request(n: integer): integer;\nconst\n  MODULO = 10007;\nvar\n  a: array[0..10000] of integer;\n  i: integer;\nbegin\n  a[0] := 1;\n  a[1] := 1;\n  for i := 2 to 10000 do\n  begin\n    a[i] := (a[i-1] * i) mod MODULO;\n  end;\n  process_request := a[n];\n```\nKnown, the bug code specifically exists in the following snippet:\n['missing critical code snippet']\nFix bugs in the given code snippet. The complete , fixed code must be placed between ```pascal```. Do not generate any test, main,example usage or check code!\n"}
