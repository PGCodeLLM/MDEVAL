{"question_id": "F#/1", "category": "Multiple", "subtype": "double_bug", "level": "hard", "example": "sortByBinaryOnes([0, 1, 2, 3, 4, 5, 6, 7, 8])\n[0, 1, 2, 4, 8, 3, 5, 6, 7]\nsortByBinaryOnes([1024, 512, 256, 128, 64, 32, 16, 8, 4, 2, 1])\n[1, 2, 4, 8, 16, 32, 64, 128, 256, 512, 1024]", "docstring": "Sorts an array of integers based on the number of 1s in their binary representation. In case of a tie, sorts by their value.\n", "canonical_solution": "open System\n\nlet sortByBinaryOnes (arr: int list) =\n    \n\n    let countBinaryOnes (n:int) =\n        Convert.ToString(n, 2) |> Seq.filter (fun x -> x = '1') |> Seq.length\n\n    arr |> List.sortWith (fun x y -> \n        let onesX, onesY = countBinaryOnes x, countBinaryOnes y\n        if onesX = onesY then compare x y\n        else compare onesX onesY)", "buggy_code": "open System\n\nlet sortByBinaryOnes (arr: int list) =\n    \n\n    let countBinaryOnes (n:int) =\n        Convert.ToString(n, 2) |> Seq.filter (fun x -> x = 1) |> Seq.length\n\n    arr |> List.sortWith (fun x y -> \n        let onesX, onesY = countBinaryOnes x, countBinaryOnes y\n        if onesX = onesY then compare y x\n        else compare onesX onesY)", "bug_with_line_numbers": "   1 | open System\n   2 | let sortByBinaryOnes (arr: int list) =\n   3 |     let countBinaryOnes (n:int) =\n   4 |         Convert.ToString(n, 2) |> Seq.filter (fun x -> x = 1) |> Seq.length\n   5 |     arr |> List.sortWith (fun x y -> \n   6 |         let onesX, onesY = countBinaryOnes x, countBinaryOnes y\n   7 |         if onesX = onesY then compare y x\n   8 |         else compare onesX onesY)", "fragment_lines": [4, 7], "fragment_content": ["Convert.ToString(n, 2)", "if onesX = onesY then compare y x"], "test": "let check () =\n    if sortByBinaryOnes [0; 1; 2; 3; 4; 5; 6; 7; 8] <> [0; 1; 2; 4; 8; 3; 5; 6; 7] then\n        failwith \"Test Case 1 failed\"\n    if sortByBinaryOnes [1024; 512; 256; 128; 64; 32; 16; 8; 4; 2; 1] <> [1; 2; 4; 8; 16; 32; 64; 128; 256; 512; 1024] then\n        failwith \"Test Case 2 failed\"\n    if sortByBinaryOnes [10; 100; 1000; 10000] <> [10; 100; 10000; 1000] then\n        failwith \"Test Case 3 failed\"\n    if sortByBinaryOnes [3; 7; 15; 31; 63] <> [3; 7; 15; 31; 63] then\n        failwith \"Test Case 4 failed\"\n    if sortByBinaryOnes [5; 9; 17; 33; 65] <> [5;9;17; 33; 65;] then\n        failwith \"Test Case 5 failed\"\n\ncheck ()"}
{"question_id": "F#/2", "category": "Logic", "subtype": "condition_error", "level": "easy", "example": "countGoodTriplets([3, 0, 1, 1, 9, 7], 7, 2, 3)\n4\ncountGoodTriplets([1, 1, 2, 2, 3], 0, 0, 1)\n0", "docstring": "Counts the number of good triplets in the array `arr`.\n    A good triplet (arr[i], arr[j], arr[k]) satisfies certain conditions based on the absolute differences and indices.\n", "canonical_solution": "open System\n\nlet countGoodTriplets (arr: int list) (a: int) (b: int) (c: int) =\n    \n\n    let isGoodTriplet i j k =\n        abs (arr.[i] - arr.[j]) <= a &&\n        abs (arr.[j] - arr.[k]) <= b &&\n        abs (arr.[i] - arr.[k]) <= c\n\n    let rec countTriplets i j k count =\n        match i, j, k with\n        | _, _, _ when i >= List.length arr - 2 -> count\n        | _, _, _ when j >= List.length arr - 1 -> countTriplets (i + 1) (i + 2) (i + 3) count\n        | _, _, _ when k >= List.length arr -> countTriplets i (j + 1) (j + 2) count\n        | _, _, _ ->\n            let newCount = if isGoodTriplet i j k then count + 1 else count\n            countTriplets i j (k + 1) newCount\n\n    countTriplets 0 1 2 0", "buggy_code": "open System\n\nlet countGoodTriplets (arr: int list) (a: int) (b: int) (c: int) =\n    \n\n    let isGoodTriplet i j k =\n        abs (arr.[i] - arr.[j]) <= a &&\n        abs (arr.[j] - arr.[k]) <= b &&\n        abs (arr.[i] - arr.[k]) <= c\n\n    let rec countTriplets i j k count =\n        match i, j, k with\n        | _, _, _ when i >= List.length arr - 5 -> count\n        | _, _, _ when j >= List.length arr - 1 -> countTriplets (i + 1) (i + 2) (i + 3) count\n        | _, _, _ when k >= List.length arr -> countTriplets i (j + 1) (j + 2) count\n        | _, _, _ ->\n            let newCount = if isGoodTriplet i j k then count + 1 else count\n            countTriplets i j (k + 1) newCount\n\n    countTriplets 0 1 2 0", "bug_with_line_numbers": "   1 | open System\n   2 | let countGoodTriplets (arr: int list) (a: int) (b: int) (c: int) =\n   3 |     let isGoodTriplet i j k =\n   4 |         abs (arr.[i] - arr.[j]) <= a &&\n   5 |         abs (arr.[j] - arr.[k]) <= b &&\n   6 |         abs (arr.[i] - arr.[k]) <= c\n   7 |     let rec countTriplets i j k count =\n   8 |         match i, j, k with\n   9 |         | _, _, _ when i >= List.length arr - 5 -> count\n  10 |         | _, _, _ when j >= List.length arr - 1 -> countTriplets (i + 1) (i + 2) (i + 3) count\n  11 |         | _, _, _ when k >= List.length arr -> countTriplets i (j + 1) (j + 2) count\n  12 |         | _, _, _ ->\n  13 |             let newCount = if isGoodTriplet i j k then count + 1 else count\n  14 |             countTriplets i j (k + 1) newCount\n  15 |     countTriplets 0 1 2 0", "fragment_lines": [9], "fragment_content": [""], "test": "let check () =\n    if countGoodTriplets [3; 0; 1; 1; 9; 7] 7 2 3 <> 4 then\n        failwith \"Test Case 1 failed\"\n    if countGoodTriplets [1; 1; 2; 2; 3] 0 0 1 <> 0 then\n        failwith \"Test Case 2 failed\"\n    if countGoodTriplets [1; 2; 3; 4; 5] 1 1 1 <> 0 then\n        failwith \"Test Case 3 failed\"\n\ncheck ()"}
{"question_id": "F#/3", "category": "Reference", "subtype": "illegal_keyword", "level": "hard", "example": "countGoodTriplets([3, 0, 1, 1, 9, 7], 7, 2, 3)\n4\ncountGoodTriplets([1, 1, 2, 2, 3], 0, 0, 1)\n0", "docstring": "Counts the number of good triplets in the array `arr`.\n    A good triplet (arr[i], arr[j], arr[k]) satisfies certain conditions based on the absolute differences and indices.\n", "canonical_solution": "open System\n\nlet countGoodTriplets (arr: int list) (a: int) (b: int) (c: int) =\n    \n\n    let isGoodTriplet i j k =\n        abs (arr.[i] - arr.[j]) <= a &&\n        abs (arr.[j] - arr.[k]) <= b &&\n        abs (arr.[i] - arr.[k]) <= c\n\n    let rec countTriplets i j k count =\n        match i, j, k with\n        | _, _, _ when i >= List.length arr - 2 -> count\n        | _, _, _ when j >= List.length arr - 1 -> countTriplets (i + 1) (i + 2) (i + 3) count\n        | _, _, _ when k >= List.length arr -> countTriplets i (j + 1) (j + 2) count\n        | _, _, _ ->\n            let newCount = if isGoodTriplet i j k then count + 1 else count\n            countTriplets i j (k + 1) newCount\n\n    countTriplets 0 1 2 0", "buggy_code": "open System\n\nlet countGoodTriplets (arr: int list) (a: int) (b: int) (c: int) =\n    \n\n    let isGoodTriplet i j k =\n        abs (arr.[i] - arr.[j]) <= a &&\n        abs (arr.[j] - arr.[k]) <= b &&\n        abs (arr.[i] - arr.[k]) <= c\n\n    let rec countTriplets i j k count =\n        match i, j, k with\n        | _, _, _ when i >= List.length arr - 2 -> count\n        | _, _, _ when j >= List.length arr - 1 -> countTriplets (i + 1) (i + 2) (i + 3) count\n        | _, _, _ when k >= List.length arr -> countTriplets i (j + 1) (j + 2) count\n        | _, _, _ ->\n            let member = if isGoodTriplet i j k then count + 1 else count\n            countTriplets i j (k + 1) member\n\n    countTriplets 0 1 2 0", "bug_with_line_numbers": "   1 | open System\n   2 | let countGoodTriplets (arr: int list) (a: int) (b: int) (c: int) =\n   3 |     let isGoodTriplet i j k =\n   4 |         abs (arr.[i] - arr.[j]) <= a &&\n   5 |         abs (arr.[j] - arr.[k]) <= b &&\n   6 |         abs (arr.[i] - arr.[k]) <= c\n   7 |     let rec countTriplets i j k count =\n   8 |         match i, j, k with\n   9 |         | _, _, _ when i >= List.length arr - 2 -> count\n  10 |         | _, _, _ when j >= List.length arr - 1 -> countTriplets (i + 1) (i + 2) (i + 3) count\n  11 |         | _, _, _ when k >= List.length arr -> countTriplets i (j + 1) (j + 2) count\n  12 |         | _, _, _ ->\n  13 |             let member = if isGoodTriplet i j k then count + 1 else count\n  14 |             countTriplets i j (k + 1) member\n  15 |     countTriplets 0 1 2 0", "fragment_lines": [13, 14], "fragment_content": ["let member = if isGoodTriplet i j k then count + 1 else count", "countTriplets i j (k + 1) member"], "test": "let check () =\n    if countGoodTriplets [3; 0; 1; 1; 9; 7] 7 2 3 <> 4 then\n        failwith \"Test Case 1 failed\"\n    if countGoodTriplets [1; 1; 2; 2; 3] 0 0 1 <> 0 then\n        failwith \"Test Case 2 failed\"\n    if countGoodTriplets [1; 2; 3; 4; 5] 1 1 1 <> 0 then\n        failwith \"Test Case 3 failed\"\n\ncheck ()"}
{"question_id": "F#/4", "category": "Multiple", "subtype": "double_bug", "level": "easy", "example": "hasThreeConsecutiveOdds([2, 6, 4, 1])\nFalse\nhasThreeConsecutiveOdds([1, 2, 34, 3, 4, 5, 7, 23, 12])\nTrue", "docstring": "Checks if there are any three consecutive odd numbers in the array `arr`.\n", "canonical_solution": "open System\n\nlet hasThreeConsecutiveOdds (arr: int list) =\n    \n\n    let rec checkConsecutive idx =\n        if idx > List.length arr - 3 then\n            false\n        elif arr.[idx] % 2 <> 0 && arr.[idx + 1] % 2 <> 0 && arr.[idx + 2] % 2 <> 0 then\n            true\n        else\n            checkConsecutive (idx + 1)\n\n    checkConsecutive 0", "buggy_code": "open System\n\nlet hasThreeConsecutiveOdds (arr: int list) =\n    \n\n    let rec checkConsecutive idx =\n        if idx >= List.length arr - 3 then\n            false\n        elif arr.[idx] % 2 <> 0 && arr.[idx] % 2 <> 0 && arr.[idx + 2] % 2 <> 0 then\n            true\n        else\n            checkConsecutive (idx + 1)\n\n    checkConsecutive 0", "bug_with_line_numbers": "   1 | open System\n   2 | let hasThreeConsecutiveOdds (arr: int list) =\n   3 |     let rec checkConsecutive idx =\n   4 |         if idx >= List.length arr - 3 then\n   5 |             false\n   6 |         elif arr.[idx] % 2 <> 0 && arr.[idx] % 2 <> 0 && arr.[idx + 2] % 2 <> 0 then\n   7 |             true\n   8 |         else\n   9 |             checkConsecutive (idx + 1)\n  10 |     checkConsecutive 0", "fragment_lines": [4, 6], "fragment_content": ["if idx >= List.length arr - 3 then", "elif arr.[idx] % 2 <> 0 && arr.[idx] % 2 <> 0 && arr.[idx + 2] % 2 <> 0 then"], "test": "let check () =\n    if hasThreeConsecutiveOdds [2; 6; 4; 1] <> false then\n        failwith \"Test Case 1 failed\"\n    if hasThreeConsecutiveOdds [1; 2; 34; 3; 4; 5; 7; 23; 12] <> true then\n        failwith \"Test Case 2 failed\"\n    if hasThreeConsecutiveOdds [1; 3; 5; 7; 9] <> true then\n        failwith \"Test Case 3 failed\"\n    if hasThreeConsecutiveOdds [2; 4; 6; 8; 10] <> false then\n        failwith \"Test Case 4 failed\"\n    if hasThreeConsecutiveOdds [1; 1; 2; 3; 5] <> false then\n        failwith \"Test Case 5 failed\"\n\ncheck ()"}
{"question_id": "F#/5", "category": "Syntax", "subtype": "misused ==and=", "level": "medium", "example": "hasThreeConsecutiveOdds([2, 6, 4, 1])\nFalse\nhasThreeConsecutiveOdds([1, 2, 34, 3, 4, 5, 7, 23, 12])\nTrue", "docstring": "Checks if there are any three consecutive odd numbers in the array `arr`.\n", "canonical_solution": "open System\n\nlet hasThreeConsecutiveOdds (arr: int list) =\n    \n\n    let rec checkConsecutive idx =\n        if idx > List.length arr - 3 then\n            false\n        elif arr.[idx] % 2 <> 0 && arr.[idx + 1] % 2 <> 0 && arr.[idx + 2] % 2 <> 0 then\n            true\n        else\n            checkConsecutive (idx + 1)\n\n    checkConsecutive 0", "buggy_code": "open System\n\nlet hasThreeConsecutiveOdds (arr: int list) =\n    \n\n    let rec checkConsecutive idx =\n        if idx > List.length arr - 3 then\n            false\n        elif arr.[idx] % 2 != 0 && arr.[idx + 1] % 2 != 0 && arr.[idx + 2] % 2 != 0 then\n            true\n        else\n            checkConsecutive (idx + 1)\n\n    checkConsecutive 0", "bug_with_line_numbers": "   1 | open System\n   2 | let hasThreeConsecutiveOdds (arr: int list) =\n   3 |     let rec checkConsecutive idx =\n   4 |         if idx > List.length arr - 3 then\n   5 |             false\n   6 |         elif arr.[idx] % 2 != 0 && arr.[idx + 1] % 2 != 0 && arr.[idx + 2] % 2 != 0 then\n   7 |             true\n   8 |         else\n   9 |             checkConsecutive (idx + 1)\n  10 |     checkConsecutive 0", "fragment_lines": [6], "fragment_content": ["elif arr.[idx] % 2 != 0 && arr.[idx + 1] % 2 != 0 && arr.[idx + 2] % 2 != 0 then"], "test": "let check () =\n    if hasThreeConsecutiveOdds [2; 6; 4; 1] <> false then\n        failwith \"Test Case 1 failed\"\n    if hasThreeConsecutiveOdds [1; 2; 34; 3; 4; 5; 7; 23; 12] <> true then\n        failwith \"Test Case 2 failed\"\n    if hasThreeConsecutiveOdds [1; 3; 5; 7; 9] <> true then\n        failwith \"Test Case 3 failed\"\n    if hasThreeConsecutiveOdds [2; 4; 6; 8; 10] <> false then\n        failwith \"Test Case 4 failed\"\n    if hasThreeConsecutiveOdds [1; 1; 2; 3; 5] <> false then\n        failwith \"Test Case 5 failed\"\n\ncheck ()"}
{"question_id": "F#/6", "category": "Syntax", "subtype": "unclosed_parentheses", "level": "easy", "example": "hasThreeConsecutiveOdds([2, 6, 4, 1])\nFalse\nhasThreeConsecutiveOdds([1, 2, 34, 3, 4, 5, 7, 23, 12])\nTrue", "docstring": "Checks if there are any three consecutive odd numbers in the array `arr`.\n", "canonical_solution": "open System\n\nlet hasThreeConsecutiveOdds (arr: int list) =\n    \n\n    let rec checkConsecutive idx =\n        if idx > List.length arr - 3 then\n            false\n        elif arr.[idx] % 2 <> 0 && arr.[idx + 1] % 2 <> 0 && arr.[idx + 2] % 2 <> 0 then\n            true\n        else\n            checkConsecutive (idx + 1)\n\n    checkConsecutive 0", "buggy_code": "open System\n\nlet hasThreeConsecutiveOdds (arr: int list) =\n    \n\n    let rec checkConsecutive idx =\n        if idx > List.length arr - 3 then\n            false\n        elif arr.[idx] % 2 <> 0 && arr.[idx + 1] % 2 <> 0 && arr.[idx + 2] % 2 <> 0 then\n            true\n        else\n            checkConsecutive idx + 1\n\n    checkConsecutive 0", "bug_with_line_numbers": "   1 | open System\n   2 | let hasThreeConsecutiveOdds (arr: int list) =\n   3 |     let rec checkConsecutive idx =\n   4 |         if idx > List.length arr - 3 then\n   5 |             false\n   6 |         elif arr.[idx] % 2 <> 0 && arr.[idx + 1] % 2 <> 0 && arr.[idx + 2] % 2 <> 0 then\n   7 |             true\n   8 |         else\n   9 |             checkConsecutive idx + 1\n  10 |     checkConsecutive 0", "fragment_lines": [9], "fragment_content": ["checkConsecutive idx + 1"], "test": "let check () =\n    if hasThreeConsecutiveOdds [2; 6; 4; 1] <> false then\n        failwith \"Test Case 1 failed\"\n    if hasThreeConsecutiveOdds [1; 2; 34; 3; 4; 5; 7; 23; 12] <> true then\n        failwith \"Test Case 2 failed\"\n    if hasThreeConsecutiveOdds [1; 3; 5; 7; 9] <> true then\n        failwith \"Test Case 3 failed\"\n    if hasThreeConsecutiveOdds [2; 4; 6; 8; 10] <> false then\n        failwith \"Test Case 4 failed\"\n    if hasThreeConsecutiveOdds [1; 1; 2; 3; 5] <> false then\n        failwith \"Test Case 5 failed\"\n\ncheck ()"}
{"question_id": "F#/7", "category": "Logic", "subtype": "algorithm_error", "level": "hard", "example": "calculateSwimmingTime(9, 30, 10, 45)\n(1, 15)\ncalculateSwimmingTime(23, 15, 1, 30)\n(2, 15)\ncalculateSwimmingTime(5, 0, 5, 30)\n(0, 30)", "docstring": "Calculates the total time spent swimming by a fish, given the start and end times.\n    Time is provided in a 24-hour format.\n\n    Parameters:\n    startHour (int): The hour when the fish started swimming (0-23).\n    startMinute (int): The minute when the fish started swimming (0-59).\n    endHour (int): The hour when the fish stopped swimming (0-23).\n    endMinute (int): The minute when the fish stopped swimming (0-59).\n\n    Returns:\n    Tuple of (int, int): Total hours and minutes spent swimming.\n\n", "canonical_solution": "open System\n\nlet calculateSwimmingTime (startHour: int) (startMinute: int) (endHour: int) (endMinute: int) =\n\n\n    let start = new TimeSpan(startHour, startMinute, 0)\n    let end_ = new TimeSpan(endHour, endMinute, 0)\n    let duration = if end_ < start then end_.Add(new TimeSpan(24, 0, 0)) - start else end_ - start\n    (duration.Hours, duration.Minutes)", "buggy_code": "open System\n\nlet calculateSwimmingTime (startHour: int) (startMinute: int) (endHour: int) (endMinute: int) =\n\n\n    let start = new TimeSpan(startHour, startMinute, 0)\n    let end_ = new TimeSpan(endHour, endMinute, 0)\n    let duration =  end_ - start\n    (duration.Hours, duration.Minutes)", "bug_with_line_numbers": "   1 | open System\n   2 | let calculateSwimmingTime (startHour: int) (startMinute: int) (endHour: int) (endMinute: int) =\n   3 |     let start = new TimeSpan(startHour, startMinute, 0)\n   4 |     let end_ = new TimeSpan(endHour, endMinute, 0)\n   5 |     let duration =  end_ - start\n   6 |     (duration.Hours, duration.Minutes)", "fragment_lines": [5], "fragment_content": ["let duration =  end_ - start"], "test": "let check () =\n    if calculateSwimmingTime 9 30 10 45 <> (1, 15) then\n        failwith \"Test Case 1 failed\"\n    if calculateSwimmingTime 23 15 1 30 <> (2, 15) then\n        failwith \"Test Case 2 failed\"\n    if calculateSwimmingTime 5 0 5 30 <> (0, 30) then\n        failwith \"Test Case 3 failed\"\n    if calculateSwimmingTime 11 20 13 45 <> (2, 25) then\n        failwith \"Test Case 4 failed\"\n    if calculateSwimmingTime 16 50 16 50 <> (0, 0) then\n        failwith \"Test Case 5 failed\"\n    if calculateSwimmingTime 0 0 23 59 <> (23, 59) then\n        failwith \"Test Case 6 failed\"\n    if calculateSwimmingTime 22 15 3 10 <> (4, 55) then\n        failwith \"Test Case 7 failed\"\n\ncheck ()"}
{"question_id": "F#/8", "category": "Reference", "subtype": "function_error", "level": "easy", "example": "calculateSwimmingTime(9, 30, 10, 45)\n(1, 15)\ncalculateSwimmingTime(23, 15, 1, 30)\n(2, 15)\ncalculateSwimmingTime(5, 0, 5, 30)\n(0, 30)", "docstring": "Calculates the total time spent swimming by a fish, given the start and end times.\n    Time is provided in a 24-hour format.\n\n    Parameters:\n    startHour (int): The hour when the fish started swimming (0-23).\n    startMinute (int): The minute when the fish started swimming (0-59).\n    endHour (int): The hour when the fish stopped swimming (0-23).\n    endMinute (int): The minute when the fish stopped swimming (0-59).\n\n    Returns:\n    Tuple of (int, int): Total hours and minutes spent swimming.\n\n", "canonical_solution": "open System\n\nlet calculateSwimmingTime (startHour: int) (startMinute: int) (endHour: int) (endMinute: int) =\n\n\n    let start = new TimeSpan(startHour, startMinute, 0)\n    let end_ = new TimeSpan(endHour, endMinute, 0)\n    let duration = if end_ < start then end_.Add(new TimeSpan(24, 0, 0)) - start else end_ - start\n    (duration.Hours, duration.Minutes)", "buggy_code": "open System\n\nlet calculateSwimmingTime (startHour: int) (startMinute: int) (endHour: int) (endMinute: int) =\n\n\n    let start = new TimeSpan(startHour, startMinute, 0)\n    let end_ = new TimeSpan(endMinute, endHour, 0)\n    let duration = if end_ < start then end_.Add(new TimeSpan(24, 0, 0)) - start else end_ - start\n    (duration.Hours, duration.Minutes)", "bug_with_line_numbers": "   1 | open System\n   2 | let calculateSwimmingTime (startHour: int) (startMinute: int) (endHour: int) (endMinute: int) =\n   3 |     let start = new TimeSpan(startHour, startMinute, 0)\n   4 |     let end_ = new TimeSpan(endMinute, endHour, 0)\n   5 |     let duration = if end_ < start then end_.Add(new TimeSpan(24, 0, 0)) - start else end_ - start\n   6 |     (duration.Hours, duration.Minutes)", "fragment_lines": [4], "fragment_content": ["let end_ = new TimeSpan(endMinute, endHour, 0)"], "test": "let check () =\n    if calculateSwimmingTime 9 30 10 45 <> (1, 15) then\n        failwith \"Test Case 1 failed\"\n    if calculateSwimmingTime 23 15 1 30 <> (2, 15) then\n        failwith \"Test Case 2 failed\"\n    if calculateSwimmingTime 5 0 5 30 <> (0, 30) then\n        failwith \"Test Case 3 failed\"\n    if calculateSwimmingTime 11 20 13 45 <> (2, 25) then\n        failwith \"Test Case 4 failed\"\n    if calculateSwimmingTime 16 50 16 50 <> (0, 0) then\n        failwith \"Test Case 5 failed\"\n    if calculateSwimmingTime 0 0 23 59 <> (23, 59) then\n        failwith \"Test Case 6 failed\"\n    if calculateSwimmingTime 22 15 3 10 <> (4, 55) then\n        failwith \"Test Case 7 failed\"\n\ncheck ()"}
{"question_id": "F#/9", "category": "Logic", "subtype": "variable_error", "level": "medium", "example": "calculateSwimmingTime(9, 30, 10, 45)\n(1, 15)\ncalculateSwimmingTime(23, 15, 1, 30)\n(2, 15)\ncalculateSwimmingTime(5, 0, 5, 30)\n(0, 30)", "docstring": "Calculates the total time spent swimming by a fish, given the start and end times.\n    Time is provided in a 24-hour format.\n\n    Parameters:\n    startHour (int): The hour when the fish started swimming (0-23).\n    startMinute (int): The minute when the fish started swimming (0-59).\n    endHour (int): The hour when the fish stopped swimming (0-23).\n    endMinute (int): The minute when the fish stopped swimming (0-59).\n\n    Returns:\n    Tuple of (int, int): Total hours and minutes spent swimming.\n\n", "canonical_solution": "open System\n\nlet calculateSwimmingTime (startHour: int) (startMinute: int) (endHour: int) (endMinute: int) =\n\n\n    let start = new TimeSpan(startHour, startMinute, 0)\n    let end_ = new TimeSpan(endHour, endMinute, 0)\n    let duration = if end_ < start then end_.Add(new TimeSpan(24, 0, 0)) - start else end_ - start\n    (duration.Hours, duration.Minutes)", "buggy_code": "open System\n\nlet calculateSwimmingTime (startHour: int) (startMinute: int) (endHour: int) (endMinute: int) =\n\n\n    let start = new TimeSpan(startHour, startMinute, 0)\n    let end_ = new TimeSpan(endHour, endMinute, 0)\n    let duration = if end_ < start then end_.Add(new TimeSpan(12, 0, 0)) - start else end_ - start\n    (duration.Hours, duration.Minutes)", "bug_with_line_numbers": "   1 | open System\n   2 | let calculateSwimmingTime (startHour: int) (startMinute: int) (endHour: int) (endMinute: int) =\n   3 |     let start = new TimeSpan(startHour, startMinute, 0)\n   4 |     let end_ = new TimeSpan(endHour, endMinute, 0)\n   5 |     let duration = if end_ < start then end_.Add(new TimeSpan(12, 0, 0)) - start else end_ - start\n   6 |     (duration.Hours, duration.Minutes)", "fragment_lines": [5], "fragment_content": ["let duration = if end_ < start then end_.Add(new TimeSpan(12, 0, 0)) - start else end_ - start"], "test": "let check () =\n    if calculateSwimmingTime 9 30 10 45 <> (1, 15) then\n        failwith \"Test Case 1 failed\"\n    if calculateSwimmingTime 23 15 1 30 <> (2, 15) then\n        failwith \"Test Case 2 failed\"\n    if calculateSwimmingTime 5 0 5 30 <> (0, 30) then\n        failwith \"Test Case 3 failed\"\n    if calculateSwimmingTime 11 20 13 45 <> (2, 25) then\n        failwith \"Test Case 4 failed\"\n    if calculateSwimmingTime 16 50 16 50 <> (0, 0) then\n        failwith \"Test Case 5 failed\"\n    if calculateSwimmingTime 0 0 23 59 <> (23, 59) then\n        failwith \"Test Case 6 failed\"\n    if calculateSwimmingTime 22 15 3 10 <> (4, 55) then\n        failwith \"Test Case 7 failed\"\n\ncheck ()"}
{"question_id": "F#/10", "category": "Logic", "subtype": "operation_error", "level": "hard", "example": "reorderNumbers [1, 3, 5] \"ABC\"\n\"1 3 5\"\nreorderNumbers [6, 2, 4] \"BCA\"\n\"4 6 2\"", "docstring": "Reorder a list of three numbers (A, B, and C) according to a specified order.\n    Each of the numbers A, B, and C are distinct and follow the rule A < B < C.\n    The order is given as a string of three characters 'A', 'B', and 'C' representing the desired order.\n\n", "canonical_solution": "open System\n\nlet reorderNumbers (nums: int list) (order: string) =\n\n\n    let sortedNums = List.sort nums\n    let mapping = Map.ofList [('A', sortedNums.[0]); ('B', sortedNums.[1]); ('C', sortedNums.[2])]\n    String.Join(\" \", order |> Seq.map (fun c -> mapping.[c].ToString()))", "buggy_code": "open System\n\nlet reorderNumbers (nums: int list) (order: string) =\n\n\n    let sortedNums = List.sortDescending nums\n    let mapping = Map.ofList [('A', sortedNums.[0]); ('B', sortedNums.[1]); ('C', sortedNums.[2])]\n    String.Join(\" \", order |> Seq.map (fun c -> mapping.[c].ToString()))", "bug_with_line_numbers": "   1 | open System\n   2 | let reorderNumbers (nums: int list) (order: string) =\n   3 |     let sortedNums = List.sortDescending nums\n   4 |     let mapping = Map.ofList [('A', sortedNums.[0]); ('B', sortedNums.[1]); ('C', sortedNums.[2])]\n   5 |     String.Join(\" \", order |> Seq.map (fun c -> mapping.[c].ToString()))", "fragment_lines": [3], "fragment_content": ["let sortedNums = List.sortDescending nums"], "test": "let check () =\n    if reorderNumbers [1; 3; 5] \"ABC\" <> \"1 3 5\" then\n        failwith \"Test Case 1 failed\"\n    if reorderNumbers [6; 2; 4] \"BCA\" <> \"4 6 2\" then\n        failwith \"Test Case 2 failed\"\n    if reorderNumbers [8; 10; 9] \"CAB\" <> \"10 8 9\" then\n        failwith \"Test Case 3 failed\"\n    if reorderNumbers [15; 20; 17] \"ACB\" <> \"15 20 17\" then\n        failwith \"Test Case 4 failed\"\n    if reorderNumbers [21; 19; 23] \"BAC\" <> \"21 19 23\" then\n        failwith \"Test Case 5 failed\"\n\ncheck ()\n\n"}
{"question_id": "F#/11", "category": "Multiple", "subtype": "quadruple_bug", "level": "hard", "example": "reorderNumbers [1, 3, 5] \"ABC\"\n\"1 3 5\"\nreorderNumbers [6, 2, 4] \"BCA\"\n\"4 6 2\"", "docstring": "Reorder a list of three numbers (A, B, and C) according to a specified order.\n    Each of the numbers A, B, and C are distinct and follow the rule A < B < C.\n    The order is given as a string of three characters 'A', 'B', and 'C' representing the desired order.\n\n", "canonical_solution": "open System\n\nlet reorderNumbers (nums: int list) (order: string) =\n\n\n    let sortedNums = List.sort nums\n    let mapping = Map.ofList [('A', sortedNums.[0]); ('B', sortedNums.[1]); ('C', sortedNums.[2])]\n    String.Join(\" \", order |> Seq.map (fun c -> mapping.[c].ToString()))", "buggy_code": "open System\n\nlet reorderNumbers (nums: int list) (order: string) =\n\n\n    let sortedNums = List.sortDescending nums\n    let mapping = Map.ofList [('A', sortedNums); ('B', sortedNums.[1]); (C, sortedNums.[2])]\n    String.Join(\" \", order |> Seq.map (fun c -> mapping.[c].String()))", "bug_with_line_numbers": "   1 | open System\n   2 | let reorderNumbers (nums: int list) (order: string) =\n   3 |     let sortedNums = List.sortDescending nums\n   4 |     let mapping = Map.ofList [('A', sortedNums); ('B', sortedNums.[1]); (C, sortedNums.[2])]\n   5 |     String.Join(\" \", order |> Seq.map (fun c -> mapping.[c].String()))", "fragment_lines": [3, 4, 5], "fragment_content": ["let sortedNums = List.sortDescending nums", "let mapping = Map.ofList [('A', sortedNums); ('B', sortedNums.[1]); (C, sortedNums.[2])]", "String.Join(\" \", order"], "test": "let check () =\n    if reorderNumbers [1; 3; 5] \"ABC\" <> \"1 3 5\" then\n        failwith \"Test Case 1 failed\"\n    if reorderNumbers [6; 2; 4] \"BCA\" <> \"4 6 2\" then\n        failwith \"Test Case 2 failed\"\n    if reorderNumbers [8; 10; 9] \"CAB\" <> \"10 8 9\" then\n        failwith \"Test Case 3 failed\"\n    if reorderNumbers [15; 20; 17] \"ACB\" <> \"15 20 17\" then\n        failwith \"Test Case 4 failed\"\n    if reorderNumbers [21; 19; 23] \"BAC\" <> \"21 19 23\" then\n        failwith \"Test Case 5 failed\"\n\ncheck ()\n\n"}
{"question_id": "F#/12", "category": "Syntax", "subtype": "misused ==and=", "level": "easy", "example": "sortByBinaryOnes([0, 1, 2, 3, 4, 5, 6, 7, 8])\n[0, 1, 2, 4, 8, 3, 5, 6, 7]\nsortByBinaryOnes([1024, 512, 256, 128, 64, 32, 16, 8, 4, 2, 1])\n[1, 2, 4, 8, 16, 32, 64, 128, 256, 512, 1024]", "docstring": "Sorts an array of integers based on the number of 1s in their binary representation. In case of a tie, sorts by their value.\n", "canonical_solution": "open System\n\nlet sortByBinaryOnes (arr: int list) =\n    \n\n    let countBinaryOnes (n:int) =\n        Convert.ToString(n, 2) |> Seq.filter (fun x -> x = '1') |> Seq.length\n\n    arr |> List.sortWith (fun x y -> \n        let onesX, onesY = countBinaryOnes x, countBinaryOnes y\n        if onesX = onesY then compare x y\n        else compare onesX onesY)", "buggy_code": "open System\n\nlet sortByBinaryOnes (arr: int list) =\n    \n\n    let countBinaryOnes (n:int) =\n        Convert.ToString(n, 2) |> Seq.filter (fun x -> x = '1') |> Seq.length\n\n    arr |> List.sortWith (fun x y -> \n        let onesX, onesY = countBinaryOnes x, countBinaryOnes y\n        if onesX == onesY then compare x y\n        else compare onesX onesY)", "bug_with_line_numbers": "   1 | open System\n   2 | let sortByBinaryOnes (arr: int list) =\n   3 |     let countBinaryOnes (n:int) =\n   4 |         Convert.ToString(n, 2) |> Seq.filter (fun x -> x = '1') |> Seq.length\n   5 |     arr |> List.sortWith (fun x y -> \n   6 |         let onesX, onesY = countBinaryOnes x, countBinaryOnes y\n   7 |         if onesX == onesY then compare x y\n   8 |         else compare onesX onesY)", "fragment_lines": [7], "fragment_content": ["if onesX == onesY then compare x y"], "test": "let check () =\n    if sortByBinaryOnes [0; 1; 2; 3; 4; 5; 6; 7; 8] <> [0; 1; 2; 4; 8; 3; 5; 6; 7] then\n        failwith \"Test Case 1 failed\"\n    if sortByBinaryOnes [1024; 512; 256; 128; 64; 32; 16; 8; 4; 2; 1] <> [1; 2; 4; 8; 16; 32; 64; 128; 256; 512; 1024] then\n        failwith \"Test Case 2 failed\"\n    if sortByBinaryOnes [10; 100; 1000; 10000] <> [10; 100; 10000; 1000] then\n        failwith \"Test Case 3 failed\"\n    if sortByBinaryOnes [3; 7; 15; 31; 63] <> [3; 7; 15; 31; 63] then\n        failwith \"Test Case 4 failed\"\n    if sortByBinaryOnes [5; 9; 17; 33; 65] <> [5;9;17; 33; 65;] then\n        failwith \"Test Case 5 failed\"\n\ncheck ()"}
{"question_id": "F#/13", "category": "Syntax", "subtype": "unclosed_string", "level": "easy", "example": "reorderNumbers [1, 3, 5] \"ABC\"\n\"1 3 5\"\nreorderNumbers [6, 2, 4] \"BCA\"\n\"4 6 2\"", "docstring": "Reorder a list of three numbers (A, B, and C) according to a specified order.\n    Each of the numbers A, B, and C are distinct and follow the rule A < B < C.\n    The order is given as a string of three characters 'A', 'B', and 'C' representing the desired order.\n\n", "canonical_solution": "open System\n\nlet reorderNumbers (nums: int list) (order: string) =\n\n\n    let sortedNums = List.sort nums\n    let mapping = Map.ofList [('A', sortedNums.[0]); ('B', sortedNums.[1]); ('C', sortedNums.[2])]\n    String.Join(\" \", order |> Seq.map (fun c -> mapping.[c].ToString()))", "buggy_code": "open System\n\nlet reorderNumbers (nums: int list) (order: string) =\n\n\n    let sortedNums = List.sort nums\n    let mapping = Map.ofList [('A, sortedNums.[0]); (B', sortedNums.[1]); ('C', sortedNums.[2])]\n    String.Join(\" \", order |> Seq.map (fun c -> mapping.[c].ToString()))", "bug_with_line_numbers": "   1 | open System\n   2 | let reorderNumbers (nums: int list) (order: string) =\n   3 |     let sortedNums = List.sort nums\n   4 |     let mapping = Map.ofList [('A, sortedNums.[0]); (B', sortedNums.[1]); ('C', sortedNums.[2])]\n   5 |     String.Join(\" \", order |> Seq.map (fun c -> mapping.[c].ToString()))", "fragment_lines": [4], "fragment_content": ["let mapping = Map.ofList [('A, sortedNums.[0]); (B', sortedNums.[1]); ('C', sortedNums.[2])]"], "test": "let check () =\n    if reorderNumbers [1; 3; 5] \"ABC\" <> \"1 3 5\" then\n        failwith \"Test Case 1 failed\"\n    if reorderNumbers [6; 2; 4] \"BCA\" <> \"4 6 2\" then\n        failwith \"Test Case 2 failed\"\n    if reorderNumbers [8; 10; 9] \"CAB\" <> \"10 8 9\" then\n        failwith \"Test Case 3 failed\"\n    if reorderNumbers [15; 20; 17] \"ACB\" <> \"15 20 17\" then\n        failwith \"Test Case 4 failed\"\n    if reorderNumbers [21; 19; 23] \"BAC\" <> \"21 19 23\" then\n        failwith \"Test Case 5 failed\"\n\ncheck ()\n\n"}
{"question_id": "F#/14", "category": "Logic", "subtype": "algorithm_error", "level": "medium", "example": "mostUnhappyDay [5; 6; 7; 5; 5; 0; 0] [3; 2; 2; 3; 4; 4; 6]\n3\nmostUnhappyDay [4; 4; 4; 4; 4; 0; 0] [3; 3; 3; 3; 3; 0; 0]\n0", "docstring": "Determines the day of the week on which Jinjin is most unhappy. Jinjin becomes unhappy if her total daily hours (school plus extra classes) exceed 8 hours. \n    The function takes two lists of integers representing the hours spent in school and in extra classes for each day of the week, respectively. \n    It returns the day of the week (1 for Monday, 2 for Tuesday, etc.) on which she is most unhappy. If she is not unhappy any day, it returns 0. \n    If there are multiple days with the same level of unhappiness, it returns the earliest day.\n\n", "canonical_solution": "open System\n\nlet mostUnhappyDay (schoolHours: int list) (extraHours: int list) : int =\n\n\n    let totalHours = List.map2 (+) schoolHours extraHours\n    let daysUnhappy = List.map (fun h -> if h > 8 then h - 8 else 0) totalHours\n    let maxUnhappy = List.max daysUnhappy\n\n    if maxUnhappy = 0 then 0\n    else \n        let index = List.findIndex (fun h -> h = maxUnhappy) daysUnhappy\n        index + 1", "buggy_code": "open System\n\nlet mostUnhappyDay (schoolHours: int list) (extraHours: int list) : int =\n\n\n    let totalHours = List.map2 (+) schoolHours extraHours\n    let daysUnhappy = List.map (fun h -> if h > 8 then h - 19 else 0) totalHours\n    let maxUnhappy = List.max daysUnhappy\n\n    if maxUnhappy = 0 then 0\n    else \n        let index = List.findIndex (fun h -> h = maxUnhappy) daysUnhappy\n        index + 1", "bug_with_line_numbers": "   1 | open System\n   2 | let mostUnhappyDay (schoolHours: int list) (extraHours: int list) : int =\n   3 |     let totalHours = List.map2 (+) schoolHours extraHours\n   4 |     let daysUnhappy = List.map (fun h -> if h > 8 then h - 19 else 0) totalHours\n   5 |     let maxUnhappy = List.max daysUnhappy\n   6 |     if maxUnhappy = 0 then 0\n   7 |     else \n   8 |         let index = List.findIndex (fun h -> h = maxUnhappy) daysUnhappy\n   9 |         index + 1", "fragment_lines": [4], "fragment_content": ["let daysUnhappy = List.map (fun h -> if h > 8 then h - 19 else 0) totalHours"], "test": "let check () =\n    if mostUnhappyDay [5; 6; 7; 5; 5; 0; 0] [3; 2; 2; 3; 4; 4; 6] <> 3 then\n        failwith \"Test Case 1 failed\"\n    if mostUnhappyDay [4; 4; 4; 4; 4; 0; 0] [3; 3; 3; 3; 3; 0; 0] <> 0 then\n        failwith \"Test Case 2 failed\"\n    if mostUnhappyDay [1; 2; 3; 4; 5; 6; 7] [7; 6; 5; 4; 3; 2; 1] <> 0 then\n        failwith \"Test Case 3 failed\"\n    if mostUnhappyDay [2; 3; 4; 5; 6; 7; 1] [3; 2; 1; 1; 2; 2; 5] <> 6 then\n        failwith \"Test Case 4 failed\"\n    if mostUnhappyDay [3; 3; 3; 3; 3; 3; 3] [1; 1; 1; 1; 1; 1; 1] <> 0 then\n        failwith \"Test Case 5 failed\"\n    if mostUnhappyDay [0; 0; 0; 0; 0; 0; 9] [0; 0; 0; 0; 0; 0; 0] <> 7 then\n        failwith \"Test Case 6 failed\"\n    if mostUnhappyDay [5; 5; 5; 5; 5; 5; 5] [4; 4; 4; 4; 4; 4; 4] <> 1 then\n        failwith \"Test Case 7 failed\"\n\ncheck ()"}
{"question_id": "F#/15", "category": "Reference", "subtype": "function_error", "level": "medium", "example": "mostUnhappyDay [5; 6; 7; 5; 5; 0; 0] [3; 2; 2; 3; 4; 4; 6]\n3\nmostUnhappyDay [4; 4; 4; 4; 4; 0; 0] [3; 3; 3; 3; 3; 0; 0]\n0", "docstring": "Determines the day of the week on which Jinjin is most unhappy. Jinjin becomes unhappy if her total daily hours (school plus extra classes) exceed 8 hours. \n    The function takes two lists of integers representing the hours spent in school and in extra classes for each day of the week, respectively. \n    It returns the day of the week (1 for Monday, 2 for Tuesday, etc.) on which she is most unhappy. If she is not unhappy any day, it returns 0. \n    If there are multiple days with the same level of unhappiness, it returns the earliest day.\n\n", "canonical_solution": "open System\n\nlet mostUnhappyDay (schoolHours: int list) (extraHours: int list) : int =\n\n\n    let totalHours = List.map2 (+) schoolHours extraHours\n    let daysUnhappy = List.map (fun h -> if h > 8 then h - 8 else 0) totalHours\n    let maxUnhappy = List.max daysUnhappy\n\n    if maxUnhappy = 0 then 0\n    else \n        let index = List.findIndex (fun h -> h = maxUnhappy) daysUnhappy\n        index + 1", "buggy_code": "open System\n\nlet mostUnhappyDay (schoolHours: int list) (extraHours: int list) : int =\n\n\n    let totalHours = List.map (+) schoolHours extraHours\n    let daysUnhappy = List.map (fun h -> if h > 8 then h - 8 else 0) totalHours\n    let maxUnhappy = List.max daysUnhappy\n\n    if maxUnhappy = 0 then 0\n    else \n        let index = List.findIndex (fun h -> h = maxUnhappy) daysUnhappy\n        index + 1", "bug_with_line_numbers": "   1 | open System\n   2 | let mostUnhappyDay (schoolHours: int list) (extraHours: int list) : int =\n   3 |     let totalHours = List.map (+) schoolHours extraHours\n   4 |     let daysUnhappy = List.map (fun h -> if h > 8 then h - 8 else 0) totalHours\n   5 |     let maxUnhappy = List.max daysUnhappy\n   6 |     if maxUnhappy = 0 then 0\n   7 |     else \n   8 |         let index = List.findIndex (fun h -> h = maxUnhappy) daysUnhappy\n   9 |         index + 1", "fragment_lines": [3], "fragment_content": ["let totalHours = List.map (+) schoolHours extraHours"], "test": "let check () =\n    if mostUnhappyDay [5; 6; 7; 5; 5; 0; 0] [3; 2; 2; 3; 4; 4; 6] <> 3 then\n        failwith \"Test Case 1 failed\"\n    if mostUnhappyDay [4; 4; 4; 4; 4; 0; 0] [3; 3; 3; 3; 3; 0; 0] <> 0 then\n        failwith \"Test Case 2 failed\"\n    if mostUnhappyDay [1; 2; 3; 4; 5; 6; 7] [7; 6; 5; 4; 3; 2; 1] <> 0 then\n        failwith \"Test Case 3 failed\"\n    if mostUnhappyDay [2; 3; 4; 5; 6; 7; 1] [3; 2; 1; 1; 2; 2; 5] <> 6 then\n        failwith \"Test Case 4 failed\"\n    if mostUnhappyDay [3; 3; 3; 3; 3; 3; 3] [1; 1; 1; 1; 1; 1; 1] <> 0 then\n        failwith \"Test Case 5 failed\"\n    if mostUnhappyDay [0; 0; 0; 0; 0; 0; 9] [0; 0; 0; 0; 0; 0; 0] <> 7 then\n        failwith \"Test Case 6 failed\"\n    if mostUnhappyDay [5; 5; 5; 5; 5; 5; 5] [4; 4; 4; 4; 4; 4; 4] <> 1 then\n        failwith \"Test Case 7 failed\"\n\ncheck ()"}
{"question_id": "F#/16", "category": "Logic", "subtype": "variable_error", "level": "hard", "example": "mostUnhappyDay [5; 6; 7; 5; 5; 0; 0] [3; 2; 2; 3; 4; 4; 6]\n3\nmostUnhappyDay [4; 4; 4; 4; 4; 0; 0] [3; 3; 3; 3; 3; 0; 0]\n0", "docstring": "Determines the day of the week on which Jinjin is most unhappy. Jinjin becomes unhappy if her total daily hours (school plus extra classes) exceed 8 hours. \n    The function takes two lists of integers representing the hours spent in school and in extra classes for each day of the week, respectively. \n    It returns the day of the week (1 for Monday, 2 for Tuesday, etc.) on which she is most unhappy. If she is not unhappy any day, it returns 0. \n    If there are multiple days with the same level of unhappiness, it returns the earliest day.\n\n", "canonical_solution": "open System\n\nlet mostUnhappyDay (schoolHours: int list) (extraHours: int list) : int =\n\n\n    let totalHours = List.map2 (+) schoolHours extraHours\n    let daysUnhappy = List.map (fun h -> if h > 8 then h - 8 else 0) totalHours\n    let maxUnhappy = List.max daysUnhappy\n\n    if maxUnhappy = 0 then 0\n    else \n        let index = List.findIndex (fun h -> h = maxUnhappy) daysUnhappy\n        index + 1", "buggy_code": "open System\n\nlet mostUnhappyDay (schoolHours: int list) (extraHours: int list) : int =\n\n\n    let totalHours = List.map2 (+) schoolHours extraHours\n    let daysUnhappy = List.map (fun h -> if h > 8 then h - 8 else 0) totalHours\n    let maxUnhappy = List.max daysUnhappy\n\n    if maxUnhappy = 0 then 0\n    else \n        let index = List.findIndex (fun h -> h = maxUnhappy) daysUnhappy\n        index", "bug_with_line_numbers": "   1 | open System\n   2 | let mostUnhappyDay (schoolHours: int list) (extraHours: int list) : int =\n   3 |     let totalHours = List.map2 (+) schoolHours extraHours\n   4 |     let daysUnhappy = List.map (fun h -> if h > 8 then h - 8 else 0) totalHours\n   5 |     let maxUnhappy = List.max daysUnhappy\n   6 |     if maxUnhappy = 0 then 0\n   7 |     else \n   8 |         let index = List.findIndex (fun h -> h = maxUnhappy) daysUnhappy\n   9 |         index", "fragment_lines": [9], "fragment_content": ["index"], "test": "let check () =\n    if mostUnhappyDay [5; 6; 7; 5; 5; 0; 0] [3; 2; 2; 3; 4; 4; 6] <> 3 then\n        failwith \"Test Case 1 failed\"\n    if mostUnhappyDay [4; 4; 4; 4; 4; 0; 0] [3; 3; 3; 3; 3; 0; 0] <> 0 then\n        failwith \"Test Case 2 failed\"\n    if mostUnhappyDay [1; 2; 3; 4; 5; 6; 7] [7; 6; 5; 4; 3; 2; 1] <> 0 then\n        failwith \"Test Case 3 failed\"\n    if mostUnhappyDay [2; 3; 4; 5; 6; 7; 1] [3; 2; 1; 1; 2; 2; 5] <> 6 then\n        failwith \"Test Case 4 failed\"\n    if mostUnhappyDay [3; 3; 3; 3; 3; 3; 3] [1; 1; 1; 1; 1; 1; 1] <> 0 then\n        failwith \"Test Case 5 failed\"\n    if mostUnhappyDay [0; 0; 0; 0; 0; 0; 9] [0; 0; 0; 0; 0; 0; 0] <> 7 then\n        failwith \"Test Case 6 failed\"\n    if mostUnhappyDay [5; 5; 5; 5; 5; 5; 5] [4; 4; 4; 4; 4; 4; 4] <> 1 then\n        failwith \"Test Case 7 failed\"\n\ncheck ()"}
{"question_id": "F#/17", "category": "Logic", "subtype": "condition_error", "level": "medium", "example": "findLargerPrimeFactor 15\n5\nfindLargerPrimeFactor 35\n7", "docstring": "Finds the larger of the two prime factors of a given positive integer 'n',\n    where 'n' is the product of exactly two distinct prime numbers.\n    Note: The function assumes that 'n' is always a product of two distinct primes.\n\n", "canonical_solution": "open System\n\nlet findLargerPrimeFactor (n: int) =\n\n\n    let rec findFactor i =\n        if i * i > n then\n            n\n        elif n % i = 0 then\n            max i (n / i)\n        else\n            findFactor (i + 1)\n\n    findFactor 2", "buggy_code": "open System\n\nlet findLargerPrimeFactor (n: int) =\n\n\n    let rec findFactor i =\n        if i * i <> n then\n            n\n        elif n % i = 0 then\n            max i (n / i)\n        else\n            findFactor (i + 1)\n\n    findFactor 2", "bug_with_line_numbers": "   1 | open System\n   2 | let findLargerPrimeFactor (n: int) =\n   3 |     let rec findFactor i =\n   4 |         if i * i <> n then\n   5 |             n\n   6 |         elif n % i = 0 then\n   7 |             max i (n / i)\n   8 |         else\n   9 |             findFactor (i + 1)\n  10 |     findFactor 2", "fragment_lines": [4], "fragment_content": ["if i * i <> n then"], "test": "let check () =\n    if findLargerPrimeFactor 15 <> 5 then\n        failwith \"Test Case 1 failed\"\n    if findLargerPrimeFactor 35 <> 7 then\n        failwith \"Test Case 2 failed\"\n    if findLargerPrimeFactor 77 <> 11 then\n        failwith \"Test Case 3 failed\"\n    if findLargerPrimeFactor 143 <> 13 then\n        failwith \"Test Case 4 failed\"\n    if findLargerPrimeFactor 221 <> 17 then\n        failwith \"Test Case 5 failed\"\n    if findLargerPrimeFactor 323 <> 19 then\n        failwith \"Test Case 6 failed\"\n    if findLargerPrimeFactor 437 <> 23 then\n        failwith \"Test Case 7 failed\"\n\ncheck ()"}
{"question_id": "F#/18", "category": "Logic", "subtype": "algorithm_error", "level": "hard", "example": "findLargerPrimeFactor 15\n5\nfindLargerPrimeFactor 35\n7", "docstring": "Finds the larger of the two prime factors of a given positive integer 'n',\n    where 'n' is the product of exactly two distinct prime numbers.\n    Note: The function assumes that 'n' is always a product of two distinct primes.\n\n", "canonical_solution": "open System\n\nlet findLargerPrimeFactor (n: int) =\n\n\n    let rec findFactor i =\n        if i * i > n then\n            n\n        elif n % i = 0 then\n            max i (n / i)\n        else\n            findFactor (i + 1)\n\n    findFactor 2", "buggy_code": "open System\n\nlet findLargerPrimeFactor (n: int) =\n\n\n    let rec findFactor i =\n        if i * i > n then\n            n\n        elif n % i = 0 then\n            i\n        else\n            findFactor (i + 1)\n\n    findFactor 2", "bug_with_line_numbers": "   1 | open System\n   2 | let findLargerPrimeFactor (n: int) =\n   3 |     let rec findFactor i =\n   4 |         if i * i > n then\n   5 |             n\n   6 |         elif n % i = 0 then\n   7 |             i\n   8 |         else\n   9 |             findFactor (i + 1)\n  10 |     findFactor 2", "fragment_lines": [7], "fragment_content": ["i"], "test": "let check () =\n    if findLargerPrimeFactor 15 <> 5 then\n        failwith \"Test Case 1 failed\"\n    if findLargerPrimeFactor 35 <> 7 then\n        failwith \"Test Case 2 failed\"\n    if findLargerPrimeFactor 77 <> 11 then\n        failwith \"Test Case 3 failed\"\n    if findLargerPrimeFactor 143 <> 13 then\n        failwith \"Test Case 4 failed\"\n    if findLargerPrimeFactor 221 <> 17 then\n        failwith \"Test Case 5 failed\"\n    if findLargerPrimeFactor 323 <> 19 then\n        failwith \"Test Case 6 failed\"\n    if findLargerPrimeFactor 437 <> 23 then\n        failwith \"Test Case 7 failed\"\n\ncheck ()"}
{"question_id": "F#/19", "category": "Multiple", "subtype": "double_bug", "level": "medium", "example": "findLargerPrimeFactor 15\n5\nfindLargerPrimeFactor 35\n7", "docstring": "Finds the larger of the two prime factors of a given positive integer 'n',\n    where 'n' is the product of exactly two distinct prime numbers.\n    Note: The function assumes that 'n' is always a product of two distinct primes.\n\n", "canonical_solution": "open System\n\nlet findLargerPrimeFactor (n: int) =\n\n\n    let rec findFactor i =\n        if i * i > n then\n            n\n        elif n % i = 0 then\n            max i (n / i)\n        else\n            findFactor (i + 1)\n\n    findFactor 2", "buggy_code": "open System\n\nlet findLargerPrimeFactor (n: int) =\n\n\n    let rec findFactor i =\n        if i * i > n then\n            i\n        elif n % i = 0 then\n            min i (n / i)\n        else\n            findFactor (i + 1)\n\n    findFactor 2", "bug_with_line_numbers": "   1 | open System\n   2 | let findLargerPrimeFactor (n: int) =\n   3 |     let rec findFactor i =\n   4 |         if i * i > n then\n   5 |             i\n   6 |         elif n % i = 0 then\n   7 |             min i (n / i)\n   8 |         else\n   9 |             findFactor (i + 1)\n  10 |     findFactor 2", "fragment_lines": [5, 7], "fragment_content": ["i", "min i (n / i)"], "test": "let check () =\n    if findLargerPrimeFactor 15 <> 5 then\n        failwith \"Test Case 1 failed\"\n    if findLargerPrimeFactor 35 <> 7 then\n        failwith \"Test Case 2 failed\"\n    if findLargerPrimeFactor 77 <> 11 then\n        failwith \"Test Case 3 failed\"\n    if findLargerPrimeFactor 143 <> 13 then\n        failwith \"Test Case 4 failed\"\n    if findLargerPrimeFactor 221 <> 17 then\n        failwith \"Test Case 5 failed\"\n    if findLargerPrimeFactor 323 <> 19 then\n        failwith \"Test Case 6 failed\"\n    if findLargerPrimeFactor 437 <> 23 then\n        failwith \"Test Case 7 failed\"\n\ncheck ()"}
{"question_id": "F#/20", "category": "Logic", "subtype": "condition_error", "level": "medium", "example": "longestConsecutiveSequence([10, 1, 2, 3, 4, 6, 7])\n4\nlongestConsecutiveSequence([4, 2, 1, 6, 5])\n3", "docstring": "This function finds the length of the longest consecutive sequence of natural numbers in a given list of integers.\n      It assumes the list may not be sorted and can contain duplicates.\n\n", "canonical_solution": "open System\nlet longestConsecutiveSequence (numbers: int list) =\n  \n\n        let numbersSet = Set.ofList numbers\n        numbersSet |> Seq.fold (fun maxLen n ->\n            if Set.contains (n - 1) numbersSet then\n                maxLen\n            else\n                let mutable len = 1\n                while Set.contains (n + len) numbersSet do\n                    len <- len + 1\n                max maxLen len) 0", "buggy_code": "open System\nlet longestConsecutiveSequence (numbers: int list) =\n  \n\n        let numbersSet = Set.ofList numbers\n        numbersSet |> Seq.fold (fun maxLen n ->\n            if Set.contains n numbersSet then\n                maxLen\n            else\n                let mutable len = 1\n                while Set.contains (n + len) numbersSet do\n                    len <- len + 1\n                max maxLen len) 0", "bug_with_line_numbers": "   1 | open System\n   2 | let longestConsecutiveSequence (numbers: int list) =\n   3 |         let numbersSet = Set.ofList numbers\n   4 |         numbersSet |> Seq.fold (fun maxLen n ->\n   5 |             if Set.contains n numbersSet then\n   6 |                 maxLen\n   7 |             else\n   8 |                 let mutable len = 1\n   9 |                 while Set.contains (n + len) numbersSet do\n  10 |                     len <- len + 1\n  11 |                 max maxLen len) 0", "fragment_lines": [5], "fragment_content": ["if Set.contains n numbersSet then"], "test": "let check () =\n    if longestConsecutiveSequence [5; 4; 3; 2; 1; 6; 10; 11] <> 6 then\n        failwith \"Test Case 1 failed\"\n    if longestConsecutiveSequence [8; 9; 1; 2; 3; 7; 6; 10] <> 5 then\n        failwith \"Test Case 2 failed\"\n    if longestConsecutiveSequence [15; 5; 1; 2; 12; 3; 10; 4] <> 5 then\n        failwith \"Test Case 3 failed\"\n    if longestConsecutiveSequence [1; 2; 3; 4; 5; 9; 10; 11; 12] <> 5 then\n        failwith \"Test Case 4 failed\"\n    if longestConsecutiveSequence [1; 3; 5; 7; 9; 2; 4; 6; 8; 10] <> 10 then\n        failwith \"Test Case 5 failed\"\n    if longestConsecutiveSequence [1] <> 1 then\n        failwith \"Test Case 6 failed\"\n    if longestConsecutiveSequence [100; 101; 102; 103; 105; 106; 107] <> 4 then\n        failwith \"Test Case 7 failed\"\n\ncheck ()"}
{"question_id": "F#/21", "category": "Multiple", "subtype": "double_bug", "level": "medium", "example": "longestConsecutiveSequence([10, 1, 2, 3, 4, 6, 7])\n4\nlongestConsecutiveSequence([4, 2, 1, 6, 5])\n3", "docstring": "This function finds the length of the longest consecutive sequence of natural numbers in a given list of integers.\n      It assumes the list may not be sorted and can contain duplicates.\n\n", "canonical_solution": "open System\nlet longestConsecutiveSequence (numbers: int list) =\n  \n\n        let numbersSet = Set.ofList numbers\n        numbersSet |> Seq.fold (fun maxLen n ->\n            if Set.contains (n - 1) numbersSet then\n                maxLen\n            else\n                let mutable len = 1\n                while Set.contains (n + len) numbersSet do\n                    len <- len + 1\n                max maxLen len) 0", "buggy_code": "open System\nlet longestConsecutiveSequence (numbers: int list) =\n  \n\n        let numbersSet = Set.ofList numbers\n        numbersSet |> Seq.fold (fun maxLen n ->\n            if Set.contains (n - 1) numbersSet then\n                maxLen\n            else\n                let mutable len = 1\n                while Set.contains n numbersSet do\n                    len <- len - 1\n                max maxLen len) 0", "bug_with_line_numbers": "   1 | open System\n   2 | let longestConsecutiveSequence (numbers: int list) =\n   3 |         let numbersSet = Set.ofList numbers\n   4 |         numbersSet |> Seq.fold (fun maxLen n ->\n   5 |             if Set.contains (n - 1) numbersSet then\n   6 |                 maxLen\n   7 |             else\n   8 |                 let mutable len = 1\n   9 |                 while Set.contains n numbersSet do\n  10 |                     len <- len - 1\n  11 |                 max maxLen len) 0", "fragment_lines": [9, 10], "fragment_content": ["while Set.contains n numbersSet do", "len <- len - 1"], "test": "let check () =\n    if longestConsecutiveSequence [5; 4; 3; 2; 1; 6; 10; 11] <> 6 then\n        failwith \"Test Case 1 failed\"\n    if longestConsecutiveSequence [8; 9; 1; 2; 3; 7; 6; 10] <> 5 then\n        failwith \"Test Case 2 failed\"\n    if longestConsecutiveSequence [15; 5; 1; 2; 12; 3; 10; 4] <> 5 then\n        failwith \"Test Case 3 failed\"\n    if longestConsecutiveSequence [1; 2; 3; 4; 5; 9; 10; 11; 12] <> 5 then\n        failwith \"Test Case 4 failed\"\n    if longestConsecutiveSequence [1; 3; 5; 7; 9; 2; 4; 6; 8; 10] <> 10 then\n        failwith \"Test Case 5 failed\"\n    if longestConsecutiveSequence [1] <> 1 then\n        failwith \"Test Case 6 failed\"\n    if longestConsecutiveSequence [100; 101; 102; 103; 105; 106; 107] <> 4 then\n        failwith \"Test Case 7 failed\"\n\ncheck ()"}
{"question_id": "F#/22", "category": "Logic", "subtype": "variable_error", "level": "medium", "example": "longestConsecutiveSequence([10, 1, 2, 3, 4, 6, 7])\n4\nlongestConsecutiveSequence([4, 2, 1, 6, 5])\n3", "docstring": "This function finds the length of the longest consecutive sequence of natural numbers in a given list of integers.\n      It assumes the list may not be sorted and can contain duplicates.\n\n", "canonical_solution": "open System\nlet longestConsecutiveSequence (numbers: int list) =\n  \n\n        let numbersSet = Set.ofList numbers\n        numbersSet |> Seq.fold (fun maxLen n ->\n            if Set.contains (n - 1) numbersSet then\n                maxLen\n            else\n                let mutable len = 1\n                while Set.contains (n + len) numbersSet do\n                    len <- len + 1\n                max maxLen len) 0", "buggy_code": "open System\nlet longestConsecutiveSequence (numbers: int list) =\n  \n\n        let numbersSet = Set.ofList numbers\n        numbersSet |> Seq.fold (fun maxLen n ->\n            if Set.contains (n - 1) numbersSet then\n                maxLen\n            else\n                let len = 1\n                while Set.contains (n + len) numbersSet do\n                    len <- len + 1\n                max maxLen len) 0", "bug_with_line_numbers": "   1 | open System\n   2 | let longestConsecutiveSequence (numbers: int list) =\n   3 |         let numbersSet = Set.ofList numbers\n   4 |         numbersSet |> Seq.fold (fun maxLen n ->\n   5 |             if Set.contains (n - 1) numbersSet then\n   6 |                 maxLen\n   7 |             else\n   8 |                 let len = 1\n   9 |                 while Set.contains (n + len) numbersSet do\n  10 |                     len <- len + 1\n  11 |                 max maxLen len) 0", "fragment_lines": [8], "fragment_content": ["let len = 1"], "test": "let check () =\n    if longestConsecutiveSequence [5; 4; 3; 2; 1; 6; 10; 11] <> 6 then\n        failwith \"Test Case 1 failed\"\n    if longestConsecutiveSequence [8; 9; 1; 2; 3; 7; 6; 10] <> 5 then\n        failwith \"Test Case 2 failed\"\n    if longestConsecutiveSequence [15; 5; 1; 2; 12; 3; 10; 4] <> 5 then\n        failwith \"Test Case 3 failed\"\n    if longestConsecutiveSequence [1; 2; 3; 4; 5; 9; 10; 11; 12] <> 5 then\n        failwith \"Test Case 4 failed\"\n    if longestConsecutiveSequence [1; 3; 5; 7; 9; 2; 4; 6; 8; 10] <> 10 then\n        failwith \"Test Case 5 failed\"\n    if longestConsecutiveSequence [1] <> 1 then\n        failwith \"Test Case 6 failed\"\n    if longestConsecutiveSequence [100; 101; 102; 103; 105; 106; 107] <> 4 then\n        failwith \"Test Case 7 failed\"\n\ncheck ()"}
{"question_id": "F#/23", "category": "Logic", "subtype": "operation_error", "level": "easy", "example": "sortByBinaryOnes([0, 1, 2, 3, 4, 5, 6, 7, 8])\n[0, 1, 2, 4, 8, 3, 5, 6, 7]\nsortByBinaryOnes([1024, 512, 256, 128, 64, 32, 16, 8, 4, 2, 1])\n[1, 2, 4, 8, 16, 32, 64, 128, 256, 512, 1024]", "docstring": "Sorts an array of integers based on the number of 1s in their binary representation. In case of a tie, sorts by their value.\n", "canonical_solution": "open System\n\nlet sortByBinaryOnes (arr: int list) =\n    \n\n    let countBinaryOnes (n:int) =\n        Convert.ToString(n, 2) |> Seq.filter (fun x -> x = '1') |> Seq.length\n\n    arr |> List.sortWith (fun x y -> \n        let onesX, onesY = countBinaryOnes x, countBinaryOnes y\n        if onesX = onesY then compare x y\n        else compare onesX onesY)", "buggy_code": "open System\n\nlet sortByBinaryOnes (arr: int list) =\n    \n\n    let countBinaryOnes (n:int) =\n        Convert.ToString(n, 2) >> Seq.filter (fun x -> x = \"1\") >> Seq.length\n\n    arr |> List.sortWith (fun x y -> \n        let onesX, onesY = countBinaryOnes x, countBinaryOnes y\n        if onesX = onesY then compare x y\n        else compare onesX onesY)", "bug_with_line_numbers": "   1 | open System\n   2 | let sortByBinaryOnes (arr: int list) =\n   3 |     let countBinaryOnes (n:int) =\n   4 |         Convert.ToString(n, 2) >> Seq.filter (fun x -> x = \"1\") >> Seq.length\n   5 |     arr |> List.sortWith (fun x y -> \n   6 |         let onesX, onesY = countBinaryOnes x, countBinaryOnes y\n   7 |         if onesX = onesY then compare x y\n   8 |         else compare onesX onesY)", "fragment_lines": [4], "fragment_content": ["Convert.ToString(n, 2) >> Seq.filter (fun x -> x = \"1\") >> Seq.length"], "test": "let check () =\n    if sortByBinaryOnes [0; 1; 2; 3; 4; 5; 6; 7; 8] <> [0; 1; 2; 4; 8; 3; 5; 6; 7] then\n        failwith \"Test Case 1 failed\"\n    if sortByBinaryOnes [1024; 512; 256; 128; 64; 32; 16; 8; 4; 2; 1] <> [1; 2; 4; 8; 16; 32; 64; 128; 256; 512; 1024] then\n        failwith \"Test Case 2 failed\"\n    if sortByBinaryOnes [10; 100; 1000; 10000] <> [10; 100; 10000; 1000] then\n        failwith \"Test Case 3 failed\"\n    if sortByBinaryOnes [3; 7; 15; 31; 63] <> [3; 7; 15; 31; 63] then\n        failwith \"Test Case 4 failed\"\n    if sortByBinaryOnes [5; 9; 17; 33; 65] <> [5;9;17; 33; 65;] then\n        failwith \"Test Case 5 failed\"\n\ncheck ()"}
{"question_id": "F#/24", "category": "Logic", "subtype": "algorithm_error", "level": "hard", "example": "reverseDigits(123)\n321\nreverseDigits(-380)\n-83\nreverseDigits(0)\n0\nreverseDigits(100)\n1", "docstring": "Reverse the digits of an integer.\n", "canonical_solution": "open System\nlet reverseDigits (n: int) =\n\n\n    let reversedStr =\n        string n\n        |> Seq.rev\n        |> Seq.toArray\n        |> System.String\n    let reversedInt =\n        if reversedStr.EndsWith('-') then\n            -(int (reversedStr.Substring(0, reversedStr.Length - 1)))\n        else\n            int reversedStr\n    reversedInt", "buggy_code": "open System\nlet reverseDigits (n: int) =\n\n\n    let reversedStr =\n        string n\n        |> Seq.rev\n        |> Seq.toArray\n        |> System.String\n    let reversedInt =\n        if reversedStr.StartsWith('-') then\n            (int (reversedStr.Substring(0, reversedStr.Length - 1)))\n        else\n            int reversedStr\n    reversedInt", "bug_with_line_numbers": "   1 | open System\n   2 | let reverseDigits (n: int) =\n   3 |     let reversedStr =\n   4 |         string n\n   5 |         |> Seq.rev\n   6 |         |> Seq.toArray\n   7 |         |> System.String\n   8 |     let reversedInt =\n   9 |         if reversedStr.StartsWith('-') then\n  10 |             (int (reversedStr.Substring(0, reversedStr.Length - 1)))\n  11 |         else\n  12 |             int reversedStr\n  13 |     reversedInt", "fragment_lines": [9, 10], "fragment_content": ["if reversedStr.StartsWith('-') then", "(int (reversedStr.Substring(0, reversedStr.Length - 1)))"], "test": "let check () =\n    if reverseDigits 123 <> 321 then\n        failwith \"Test Case 1 failed\"\n    if reverseDigits -380 <> -83 then\n        failwith \"Test Case 2 failed\"\n    if reverseDigits 0 <> 0 then\n        failwith \"Test Case 3 failed\"\n    if reverseDigits 100 <> 1 then\n        failwith \"Test Case 4 failed\"\n    if reverseDigits -100 <> -1 then\n        failwith \"Test Case 5 failed\"\n    if reverseDigits 123456789 <> 987654321 then\n        failwith \"Test Case 6 failed\"\n    if reverseDigits -987654321 <> -123456789 then\n        failwith \"Test Case 7 failed\"\n\ncheck ()"}
{"question_id": "F#/25", "category": "Reference", "subtype": "function_error", "level": "medium", "example": "reverseDigits(123)\n321\nreverseDigits(-380)\n-83\nreverseDigits(0)\n0\nreverseDigits(100)\n1", "docstring": "Reverse the digits of an integer.\n", "canonical_solution": "open System\nlet reverseDigits (n: int) =\n\n\n    let reversedStr =\n        string n\n        |> Seq.rev\n        |> Seq.toArray\n        |> System.String\n    let reversedInt =\n        if reversedStr.EndsWith('-') then\n            -(int (reversedStr.Substring(0, reversedStr.Length - 1)))\n        else\n            int reversedStr\n    reversedInt", "buggy_code": "open System\nlet reverseDigits (n: int) =\n\n\n    let reversedStr =\n        string n\n        |> Seq.rev\n        |> Seq.toArray\n        |> System.String\n    let reversedInt =\n        if reversedStr.EndsWith('-') then\n            -(int (reversedStr.Substring(0, reversedStr.Length - 1)))\n        else\n            int reversedStr\n    reversedStr", "bug_with_line_numbers": "   1 | open System\n   2 | let reverseDigits (n: int) =\n   3 |     let reversedStr =\n   4 |         string n\n   5 |         |> Seq.rev\n   6 |         |> Seq.toArray\n   7 |         |> System.String\n   8 |     let reversedInt =\n   9 |         if reversedStr.EndsWith('-') then\n  10 |             -(int (reversedStr.Substring(0, reversedStr.Length - 1)))\n  11 |         else\n  12 |             int reversedStr\n  13 |     reversedStr", "fragment_lines": [13], "fragment_content": ["reversedStr"], "test": "let check () =\n    if reverseDigits 123 <> 321 then\n        failwith \"Test Case 1 failed\"\n    if reverseDigits -380 <> -83 then\n        failwith \"Test Case 2 failed\"\n    if reverseDigits 0 <> 0 then\n        failwith \"Test Case 3 failed\"\n    if reverseDigits 100 <> 1 then\n        failwith \"Test Case 4 failed\"\n    if reverseDigits -100 <> -1 then\n        failwith \"Test Case 5 failed\"\n    if reverseDigits 123456789 <> 987654321 then\n        failwith \"Test Case 6 failed\"\n    if reverseDigits -987654321 <> -123456789 then\n        failwith \"Test Case 7 failed\"\n\ncheck ()"}
{"question_id": "F#/26", "category": "Logic", "subtype": "variable_error", "level": "medium", "example": "reverseDigits(123)\n321\nreverseDigits(-380)\n-83\nreverseDigits(0)\n0\nreverseDigits(100)\n1", "docstring": "Reverse the digits of an integer.\n", "canonical_solution": "open System\nlet reverseDigits (n: int) =\n\n\n    let reversedStr =\n        string n\n        |> Seq.rev\n        |> Seq.toArray\n        |> System.String\n    let reversedInt =\n        if reversedStr.EndsWith('-') then\n            -(int (reversedStr.Substring(0, reversedStr.Length - 1)))\n        else\n            int reversedStr\n    reversedInt", "buggy_code": "open System\nlet reverseDigits (n: int) =\n\n\n    let reversedStr =\n        string n\n        |> Seq.rev\n        |> Seq.toArray\n        |> System.String\n    let reversedInt =\n        if reversedStr.EndsWith('-') then\n            -(reversedStr.Substring(0, reversedStr.Length - 1))\n        else\n            int reversedStr\n    reversedInt", "bug_with_line_numbers": "   1 | open System\n   2 | let reverseDigits (n: int) =\n   3 |     let reversedStr =\n   4 |         string n\n   5 |         |> Seq.rev\n   6 |         |> Seq.toArray\n   7 |         |> System.String\n   8 |     let reversedInt =\n   9 |         if reversedStr.EndsWith('-') then\n  10 |             -(reversedStr.Substring(0, reversedStr.Length - 1))\n  11 |         else\n  12 |             int reversedStr\n  13 |     reversedInt", "fragment_lines": [10], "fragment_content": ["-(reversedStr.Substring(0, reversedStr.Length - 1))"], "test": "let check () =\n    if reverseDigits 123 <> 321 then\n        failwith \"Test Case 1 failed\"\n    if reverseDigits -380 <> -83 then\n        failwith \"Test Case 2 failed\"\n    if reverseDigits 0 <> 0 then\n        failwith \"Test Case 3 failed\"\n    if reverseDigits 100 <> 1 then\n        failwith \"Test Case 4 failed\"\n    if reverseDigits -100 <> -1 then\n        failwith \"Test Case 5 failed\"\n    if reverseDigits 123456789 <> 987654321 then\n        failwith \"Test Case 6 failed\"\n    if reverseDigits -987654321 <> -123456789 then\n        failwith \"Test Case 7 failed\"\n\ncheck ()"}
{"question_id": "F#/27", "category": "Reference", "subtype": "function_error", "level": "easy", "example": "calculateAvailableData 10 3 [4; 6; 2]\n28\ncalculateAvailableData 15 2 [10; 12]\n23\ncalculateAvailableData 12 4 [3; 6; 9; 4]\n38", "docstring": "Calculates the available mobile data for the next month based on a monthly data quota, the number of months used, and the data used each month.\n    \n    Arguments:\n    monthlyQuota - the monthly data quota in MB.\n    monthsUsed - the number of months the data plan has been used.\n    dataUsedPerMonth - a list of integers representing the data used each month in MB.\n\n    Returns:\n    An integer representing the available data for the next month in MB.\n\n", "canonical_solution": "open System\n\nlet calculateAvailableData (monthlyQuota: int) (monthsUsed: int) (dataUsedPerMonth: int list) =\n\n\n    let totalQuota = monthlyQuota * (monthsUsed + 1)\n    let totalUsed = List.sum dataUsedPerMonth\n    totalQuota - totalUsed", "buggy_code": "open System\n\nlet calculateAvailableData (monthlyQuota: int) (monthsUsed: int) (dataUsedPerMonth: int list) =\n\n\n    let totalQuota = monthlyQuota * (monthsUsed + 1)\n    let totalUsed = list.sum dataUsedPerMonth\n    totalQuota - totalUsed", "bug_with_line_numbers": "   1 | open System\n   2 | let calculateAvailableData (monthlyQuota: int) (monthsUsed: int) (dataUsedPerMonth: int list) =\n   3 |     let totalQuota = monthlyQuota * (monthsUsed + 1)\n   4 |     let totalUsed = list.sum dataUsedPerMonth\n   5 |     totalQuota - totalUsed", "fragment_lines": [4], "fragment_content": ["let totalUsed = list.sum dataUsedPerMonth"], "test": "let check () =\n    if calculateAvailableData 10 3 [4; 6; 2] <> 28 then\n        failwith \"Test Case 1 failed\"\n    if calculateAvailableData 15 2 [10; 12] <> 23 then\n        failwith \"Test Case 2 failed\"\n    if calculateAvailableData 12 4 [3; 6; 9; 4] <> 38 then\n        failwith \"Test Case 3 failed\"\n    if calculateAvailableData 10 2 [5; 5; 5] <> 15 then\n        failwith \"Test Case 4 failed\"\n    if calculateAvailableData 20 1 [15] <> 25 then\n        failwith \"Test Case 5 failed\"\n    if calculateAvailableData 8 3 [2; 4; 3] <> 23 then\n        failwith \"Test Case 6 failed\"\n    if calculateAvailableData 5 0 [] <> 5 then\n        failwith \"Test Case 7 failed\"\n\ncheck ()"}
{"question_id": "F#/28", "category": "Logic", "subtype": "operation_error", "level": "hard", "example": "calculateAvailableData 10 3 [4; 6; 2]\n28\ncalculateAvailableData 15 2 [10; 12]\n23\ncalculateAvailableData 12 4 [3; 6; 9; 4]\n38", "docstring": "Calculates the available mobile data for the next month based on a monthly data quota, the number of months used, and the data used each month.\n    \n    Arguments:\n    monthlyQuota - the monthly data quota in MB.\n    monthsUsed - the number of months the data plan has been used.\n    dataUsedPerMonth - a list of integers representing the data used each month in MB.\n\n    Returns:\n    An integer representing the available data for the next month in MB.\n\n", "canonical_solution": "open System\n\nlet calculateAvailableData (monthlyQuota: int) (monthsUsed: int) (dataUsedPerMonth: int list) =\n\n\n    let totalQuota = monthlyQuota * (monthsUsed + 1)\n    let totalUsed = List.sum dataUsedPerMonth\n    totalQuota - totalUsed", "buggy_code": "open System\n\nlet calculateAvailableData (monthlyQuota: int) (monthsUsed: int) (dataUsedPerMonth: int list) =\n\n\n    let totalQuota = monthlyQuota * monthsUsed + 1\n    let totalUsed = List.sum dataUsedPerMonth\n    totalQuota - totalUsed", "bug_with_line_numbers": "   1 | open System\n   2 | let calculateAvailableData (monthlyQuota: int) (monthsUsed: int) (dataUsedPerMonth: int list) =\n   3 |     let totalQuota = monthlyQuota * monthsUsed + 1\n   4 |     let totalUsed = List.sum dataUsedPerMonth\n   5 |     totalQuota - totalUsed", "fragment_lines": [3], "fragment_content": ["let totalQuota = monthlyQuota * monthsUsed + 1"], "test": "let check () =\n    if calculateAvailableData 10 3 [4; 6; 2] <> 28 then\n        failwith \"Test Case 1 failed\"\n    if calculateAvailableData 15 2 [10; 12] <> 23 then\n        failwith \"Test Case 2 failed\"\n    if calculateAvailableData 12 4 [3; 6; 9; 4] <> 38 then\n        failwith \"Test Case 3 failed\"\n    if calculateAvailableData 10 2 [5; 5; 5] <> 15 then\n        failwith \"Test Case 4 failed\"\n    if calculateAvailableData 20 1 [15] <> 25 then\n        failwith \"Test Case 5 failed\"\n    if calculateAvailableData 8 3 [2; 4; 3] <> 23 then\n        failwith \"Test Case 6 failed\"\n    if calculateAvailableData 5 0 [] <> 5 then\n        failwith \"Test Case 7 failed\"\n\ncheck ()"}
{"question_id": "F#/29", "category": "Multiple", "subtype": "triple_bug", "level": "hard", "example": "calculateAvailableData 10 3 [4; 6; 2]\n28\ncalculateAvailableData 15 2 [10; 12]\n23\ncalculateAvailableData 12 4 [3; 6; 9; 4]\n38", "docstring": "Calculates the available mobile data for the next month based on a monthly data quota, the number of months used, and the data used each month.\n    \n    Arguments:\n    monthlyQuota - the monthly data quota in MB.\n    monthsUsed - the number of months the data plan has been used.\n    dataUsedPerMonth - a list of integers representing the data used each month in MB.\n\n    Returns:\n    An integer representing the available data for the next month in MB.\n\n", "canonical_solution": "open System\n\nlet calculateAvailableData (monthlyQuota: int) (monthsUsed: int) (dataUsedPerMonth: int list) =\n\n\n    let totalQuota = monthlyQuota * (monthsUsed + 1)\n    let totalUsed = List.sum dataUsedPerMonth\n    totalQuota - totalUsed", "buggy_code": "open System\n\nlet calculateAvailableData (monthlyQuota: int) (monthsUsed: int) (dataUsedPerMonth: int list) =\n\n\n    let totalQuota = monthlyQuota * (monthsUsed) + 1\n    let totalUsed = List.sum monthlyQuota\n    totalUsed - totalQuota", "bug_with_line_numbers": "   1 | open System\n   2 | let calculateAvailableData (monthlyQuota: int) (monthsUsed: int) (dataUsedPerMonth: int list) =\n   3 |     let totalQuota = monthlyQuota * (monthsUsed) + 1\n   4 |     let totalUsed = List.sum monthlyQuota\n   5 |     totalUsed - totalQuota", "fragment_lines": [3, 4, 5], "fragment_content": ["let totalQuota = monthlyQuota * (monthsUsed) + 1", "let totalUsed = List.sum monthlyQuota", "totalUsed - totalQuota"], "test": "let check () =\n    if calculateAvailableData 10 3 [4; 6; 2] <> 28 then\n        failwith \"Test Case 1 failed\"\n    if calculateAvailableData 15 2 [10; 12] <> 23 then\n        failwith \"Test Case 2 failed\"\n    if calculateAvailableData 12 4 [3; 6; 9; 4] <> 38 then\n        failwith \"Test Case 3 failed\"\n    if calculateAvailableData 10 2 [5; 5; 5] <> 15 then\n        failwith \"Test Case 4 failed\"\n    if calculateAvailableData 20 1 [15] <> 25 then\n        failwith \"Test Case 5 failed\"\n    if calculateAvailableData 8 3 [2; 4; 3] <> 23 then\n        failwith \"Test Case 6 failed\"\n    if calculateAvailableData 5 0 [] <> 5 then\n        failwith \"Test Case 7 failed\"\n\ncheck ()"}
{"question_id": "F#/30", "category": "Logic", "subtype": "condition_error", "level": "medium", "example": "canMatchFit(3, 3, 4, [2, 5, 6])\n[\"DA\", \"DA\", \"NE\"]", "docstring": "Determines if each match from a list of match lengths can fit inside a w x h rectangular box.\n    A match fits if its length is less than or equal to the diagonal of the box.\n\n    Args:\n    n: The number of matches.\n    w: The width of the box.\n    h: The height of the box.\n    matches: A list of integers representing the lengths of the matches.\n\n    Returns:\n    A list of strings, each either \"DA\" (if the match fits) or \"NE\" (if the match does not fit).\n\n", "canonical_solution": "open System\n\nlet canMatchFit (n: int) (w: int) (h: int) (matches: int list) =\n\n\n    let diagonal = Math.Sqrt(float(w * w + h * h))\n    matches |> List.map (fun matchLength ->\n        if float(matchLength) <= diagonal then \"DA\" else \"NE\"\n    )", "buggy_code": "open System\n\nlet canMatchFit (n: int) (w: int) (h: int) (matches: int list) =\n\n\n    let diagonal = Math.Sqrt(float(w * w + h * h))\n    matches |> List.map (fun matchLength ->\n        if float(matchLength) < diagonal then \"DA\" else \"NE\"\n    )", "bug_with_line_numbers": "   1 | open System\n   2 | let canMatchFit (n: int) (w: int) (h: int) (matches: int list) =\n   3 |     let diagonal = Math.Sqrt(float(w * w + h * h))\n   4 |     matches |> List.map (fun matchLength ->\n   5 |         if float(matchLength) < diagonal then \"DA\" else \"NE\"\n   6 |     )", "fragment_lines": [5], "fragment_content": ["if float(matchLength) < diagonal then \"DA\" else \"NE\""], "test": "let check () =\n    let test1 = canMatchFit 3 3 4 [2; 5; 6]\n    let expected1 = [\"DA\"; \"DA\"; \"NE\"]\n    if test1 <> expected1 then\n        failwith \"Test Case 1 failed\"\n\n    let test2 = canMatchFit 2 5 5 [7; 3]\n    let expected2 = [\"DA\"; \"DA\"]\n    if test2 <> expected2 then\n        failwith \"Test Case 2 failed\"\n\n    let test3 = canMatchFit 4 10 10 [5; 12; 8; 15]\n    let expected3 = [\"DA\"; \"DA\"; \"DA\"; \"NE\"]\n    if test3 <> expected3 then\n        failwith \"Test Case 3 failed\"\n\n    let test4 = canMatchFit 3 6 8 [10; 6; 7]\n    let expected4 = [\"DA\"; \"DA\"; \"DA\"]\n    if test4 <> expected4 then\n        failwith \"Test Case 4 failed\"\n\n    printfn \"All tests passed!\"\n\ncheck ()"}
{"question_id": "F#/31", "category": "Multiple", "subtype": "double_bug", "level": "hard", "example": "canMatchFit(3, 3, 4, [2, 5, 6])\n[\"DA\", \"DA\", \"NE\"]", "docstring": "Determines if each match from a list of match lengths can fit inside a w x h rectangular box.\n    A match fits if its length is less than or equal to the diagonal of the box.\n\n    Args:\n    n: The number of matches.\n    w: The width of the box.\n    h: The height of the box.\n    matches: A list of integers representing the lengths of the matches.\n\n    Returns:\n    A list of strings, each either \"DA\" (if the match fits) or \"NE\" (if the match does not fit).\n\n", "canonical_solution": "open System\n\nlet canMatchFit (n: int) (w: int) (h: int) (matches: int list) =\n\n\n    let diagonal = Math.Sqrt(float(w * w + h * h))\n    matches |> List.map (fun matchLength ->\n        if float(matchLength) <= diagonal then \"DA\" else \"NE\"\n    )", "buggy_code": "open System\n\nlet canMatchFit (n: int) (w: int) (h: int) (matches: int list) =\n\n\n    let diagonal = Math.Sqrt(float(w * w + h * h))\n    matches |> List.map2 (fun matchLength ->\n        if float(matchLength) <= diagonal then DA else NE\n    )", "bug_with_line_numbers": "   1 | open System\n   2 | let canMatchFit (n: int) (w: int) (h: int) (matches: int list) =\n   3 |     let diagonal = Math.Sqrt(float(w * w + h * h))\n   4 |     matches |> List.map2 (fun matchLength ->\n   5 |         if float(matchLength) <= diagonal then DA else NE\n   6 |     )", "fragment_lines": [4, 5], "fragment_content": ["matches", "if float(matchLength) <= diagonal then DA else NE"], "test": "let check () =\n    let test1 = canMatchFit 3 3 4 [2; 5; 6]\n    let expected1 = [\"DA\"; \"DA\"; \"NE\"]\n    if test1 <> expected1 then\n        failwith \"Test Case 1 failed\"\n\n    let test2 = canMatchFit 2 5 5 [7; 3]\n    let expected2 = [\"DA\"; \"DA\"]\n    if test2 <> expected2 then\n        failwith \"Test Case 2 failed\"\n\n    let test3 = canMatchFit 4 10 10 [5; 12; 8; 15]\n    let expected3 = [\"DA\"; \"DA\"; \"DA\"; \"NE\"]\n    if test3 <> expected3 then\n        failwith \"Test Case 3 failed\"\n\n    let test4 = canMatchFit 3 6 8 [10; 6; 7]\n    let expected4 = [\"DA\"; \"DA\"; \"DA\"]\n    if test4 <> expected4 then\n        failwith \"Test Case 4 failed\"\n\n    printfn \"All tests passed!\"\n\ncheck ()"}
{"question_id": "F#/32", "category": "Logic", "subtype": "type_error", "level": "medium", "example": "canMatchFit(3, 3, 4, [2, 5, 6])\n[\"DA\", \"DA\", \"NE\"]", "docstring": "Determines if each match from a list of match lengths can fit inside a w x h rectangular box.\n    A match fits if its length is less than or equal to the diagonal of the box.\n\n    Args:\n    n: The number of matches.\n    w: The width of the box.\n    h: The height of the box.\n    matches: A list of integers representing the lengths of the matches.\n\n    Returns:\n    A list of strings, each either \"DA\" (if the match fits) or \"NE\" (if the match does not fit).\n\n", "canonical_solution": "open System\n\nlet canMatchFit (n: int) (w: int) (h: int) (matches: int list) =\n\n\n    let diagonal = Math.Sqrt(float(w * w + h * h))\n    matches |> List.map (fun matchLength ->\n        if float(matchLength) <= diagonal then \"DA\" else \"NE\"\n    )", "buggy_code": "open System\n\nlet canMatchFit (n: int) (w: int) (h: int) (matches: int list) =\n\n\n    let diagonal = Math.Sqrt(w * w + h * h)\n    matches |> List.map (fun matchLength ->\n        if float(matchLength) <= diagonal then \"DA\" else \"NE\"\n    )", "bug_with_line_numbers": "   1 | open System\n   2 | let canMatchFit (n: int) (w: int) (h: int) (matches: int list) =\n   3 |     let diagonal = Math.Sqrt(w * w + h * h)\n   4 |     matches |> List.map (fun matchLength ->\n   5 |         if float(matchLength) <= diagonal then \"DA\" else \"NE\"\n   6 |     )", "fragment_lines": [3], "fragment_content": ["let diagonal = Math.Sqrt(w * w + h * h)"], "test": "let check () =\n    let test1 = canMatchFit 3 3 4 [2; 5; 6]\n    let expected1 = [\"DA\"; \"DA\"; \"NE\"]\n    if test1 <> expected1 then\n        failwith \"Test Case 1 failed\"\n\n    let test2 = canMatchFit 2 5 5 [7; 3]\n    let expected2 = [\"DA\"; \"DA\"]\n    if test2 <> expected2 then\n        failwith \"Test Case 2 failed\"\n\n    let test3 = canMatchFit 4 10 10 [5; 12; 8; 15]\n    let expected3 = [\"DA\"; \"DA\"; \"DA\"; \"NE\"]\n    if test3 <> expected3 then\n        failwith \"Test Case 3 failed\"\n\n    let test4 = canMatchFit 3 6 8 [10; 6; 7]\n    let expected4 = [\"DA\"; \"DA\"; \"DA\"]\n    if test4 <> expected4 then\n        failwith \"Test Case 4 failed\"\n\n    printfn \"All tests passed!\"\n\ncheck ()"}
{"question_id": "F#/33", "category": "Logic", "subtype": "condition_error", "level": "medium", "example": "findFourthVertex [(5, 5); (5, 7); (7, 5)]\n(7, 7)\nfindFourthVertex [(10, 20);(30, 10); (10, 10)]\n(30, 20)", "docstring": "Given the coordinates of three vertices of a rectangle, this function computes \n    the coordinates of the fourth vertex. The rectangle is assumed to have sides \n    parallel to the coordinate axes.\n    \n", "canonical_solution": "open System\n\nlet findFourthVertex (coordinates: (int * int) list) : int * int =\n\n\n    let (xList, yList) = List.unzip coordinates\n    let findFourthCoordinate (coordList: int list) =\n        match List.distinct coordList with\n        | [a; b] -> if List.filter ((=) a) coordList |> List.length = 1 then a else b\n        | _ -> failwith \"Invalid input\"\n\n    let fourthX = findFourthCoordinate xList\n    let fourthY = findFourthCoordinate yList\n    (fourthX, fourthY)", "buggy_code": "open System\n\nlet findFourthVertex (coordinates: (int * int) list) : int * int =\n\n\n    let (xList, yList) = List.unzip coordinates\n    let findFourthCoordinate (coordList: int list) =\n        match List.distinct coordList with\n        | [a; b] -> if List.filter ((=) a) coordList |> List.length = 0 then a else b\n        | _ -> failwith \"Invalid input\"\n\n    let fourthX = findFourthCoordinate xList\n    let fourthY = findFourthCoordinate yList\n    (fourthX, fourthY)", "bug_with_line_numbers": "   1 | open System\n   2 | let findFourthVertex (coordinates: (int * int) list) : int * int =\n   3 |     let (xList, yList) = List.unzip coordinates\n   4 |     let findFourthCoordinate (coordList: int list) =\n   5 |         match List.distinct coordList with\n   6 |         | [a; b] -> if List.filter ((=) a) coordList |> List.length = 0 then a else b\n   7 |         | _ -> failwith \"Invalid input\"\n   8 |     let fourthX = findFourthCoordinate xList\n   9 |     let fourthY = findFourthCoordinate yList\n  10 |     (fourthX, fourthY)", "fragment_lines": [6], "fragment_content": [""], "test": "let check () =\n    if findFourthVertex [(5, 5); (5, 7); (7, 5)] <> (7, 7) then\n        failwith \"Test Case 1 failed\"\n    if findFourthVertex [(10, 20); (30, 10); (10, 10)] <> (30, 20) then\n        failwith \"Test Case 2 failed\"\n    if findFourthVertex [(2, 2); (2, 4); (4, 2)] <> (4, 4) then\n        failwith \"Test Case 3 failed\"\n    if findFourthVertex [(3, 3); (6, 3); (3, 6)] <> (6, 6) then\n        failwith \"Test Case 4 failed\"\n    if findFourthVertex [(8, 10); (5, 10); (5, 7)] <> (8, 7) then\n        failwith \"Test Case 5 failed\"\n    if findFourthVertex [(12, 15); (9, 12); (12, 12)] <> (9, 15) then\n        failwith \"Test Case 6 failed\"\n\ncheck ()"}
{"question_id": "F#/34", "category": "Logic", "subtype": "algorithm_error", "level": "medium", "example": "findLuckyNumbers([[3, 7, 8], [9, 11, 13], [15, 16, 17]])\n[15]\nfindLuckyNumbers([[1, 10, 4, 2], [9, 3, 8, 7], [15, 16, 17, 12]])\n[12]", "docstring": "Finds all lucky numbers in an m x n matrix. A lucky number is the smallest in its row and the largest in its column.\n", "canonical_solution": "open System\n\nlet findLuckyNumbers (matrix: int list list) =\n    \n\n    let rowMins = matrix |> List.map List.min\n    let colMaxs = \n        [for colIdx in 0 .. (List.head matrix |> List.length) - 1 do\n            yield matrix |> List.map (fun row -> row.[colIdx]) |> List.max]\n\n    [for rowIdx in 0 .. matrix.Length - 1 do\n        for colIdx in 0 .. (matrix.[rowIdx] |> List.length) - 1 do\n            let value = matrix.[rowIdx].[colIdx]\n            if value = rowMins.[rowIdx] && value = colMaxs.[colIdx] then\n                yield value]", "buggy_code": "open System\n\nlet findLuckyNumbers (matrix: int list list) =\n    \n\n    let rowMins = matrix |> List.map List.min\n    let colMaxs = \n        [for colIdx in 0 .. (List.head matrix |> List.length) - 1 do\n            yield matrix |> List.map List.max]\n\n    [for rowIdx in 0 .. matrix.Length - 1 do\n        for colIdx in 0 .. (matrix.[rowIdx] |> List.length) - 1 do\n            let value = matrix.[rowIdx].[colIdx]\n            if value = rowMins.[rowIdx] && value = colMaxs.[colIdx] then\n                yield value]", "bug_with_line_numbers": "   1 | open System\n   2 | let findLuckyNumbers (matrix: int list list) =\n   3 |     let rowMins = matrix |> List.map List.min\n   4 |     let colMaxs = \n   5 |         [for colIdx in 0 .. (List.head matrix |> List.length) - 1 do\n   6 |             yield matrix |> List.map List.max]\n   7 |     [for rowIdx in 0 .. matrix.Length - 1 do\n   8 |         for colIdx in 0 .. (matrix.[rowIdx] |> List.length) - 1 do\n   9 |             let value = matrix.[rowIdx].[colIdx]\n  10 |             if value = rowMins.[rowIdx] && value = colMaxs.[colIdx] then\n  11 |                 yield value]", "fragment_lines": [6], "fragment_content": ["yield matrix"], "test": "let check () =\n    if findLuckyNumbers [[3; 7; 8]; [9; 11; 13]; [15; 16; 17]] <> [15] then\n        failwith \"Test Case 1 failed\"\n    if findLuckyNumbers [[1; 10; 4; 2]; [9; 3; 8; 7]; [15; 16; 17; 12]] <> [12] then\n        failwith \"Test Case 2 failed\"\n    if findLuckyNumbers [[1; 2; 3]; [4; 5; 6]; [7; 8; 9]] <> [7] then\n        failwith \"Test Case 3 failed\"\n    if findLuckyNumbers [[7; 8]; [1; 6]] <> [7] then\n        failwith \"Test Case 4 failed\"\n    if findLuckyNumbers [[11; 17; 4; 3]; [9; 5; 8; 7]; [15; 2; 16; 12]] <> [] then\n        failwith \"Test Case 5 failed\"\n\ncheck ()"}
{"question_id": "F#/35", "category": "Multiple", "subtype": "double_bug", "level": "hard", "example": "findFourthVertex [(5, 5); (5, 7); (7, 5)]\n(7, 7)\nfindFourthVertex [(10, 20);(30, 10); (10, 10)]\n(30, 20)", "docstring": "Given the coordinates of three vertices of a rectangle, this function computes \n    the coordinates of the fourth vertex. The rectangle is assumed to have sides \n    parallel to the coordinate axes.\n    \n", "canonical_solution": "open System\n\nlet findFourthVertex (coordinates: (int * int) list) : int * int =\n\n\n    let (xList, yList) = List.unzip coordinates\n    let findFourthCoordinate (coordList: int list) =\n        match List.distinct coordList with\n        | [a; b] -> if List.filter ((=) a) coordList |> List.length = 1 then a else b\n        | _ -> failwith \"Invalid input\"\n\n    let fourthX = findFourthCoordinate xList\n    let fourthY = findFourthCoordinate yList\n    (fourthX, fourthY)", "buggy_code": "open System\n\nlet findFourthVertex (coordinates: (int * int) list) : int * int =\n\n\n    let (xList, yList) = List.unzip coordinates\n    let findFourthCoordinate (coordList: int list) =\n        match List.distinct coordList with\n        | [a; b] -> if List.filter ((=) a) coordList |> List.length = 0 then b else a\n        | _ -> failwith \"Invalid input\"\n\n    let fourthX = findFourthCoordinate coordinates.[0..1]\n    let fourthY = findFourthCoordinate yList\n    (fourthX, fourthY)", "bug_with_line_numbers": "   1 | open System\n   2 | let findFourthVertex (coordinates: (int * int) list) : int * int =\n   3 |     let (xList, yList) = List.unzip coordinates\n   4 |     let findFourthCoordinate (coordList: int list) =\n   5 |         match List.distinct coordList with\n   6 |         | [a; b] -> if List.filter ((=) a) coordList |> List.length = 0 then b else a\n   7 |         | _ -> failwith \"Invalid input\"\n   8 |     let fourthX = findFourthCoordinate coordinates.[0..1]\n   9 |     let fourthY = findFourthCoordinate yList\n  10 |     (fourthX, fourthY)", "fragment_lines": [6, 8], "fragment_content": ["", "let fourthX = findFourthCoordinate coordinates.[0..1]"], "test": "let check () =\n    if findFourthVertex [(5, 5); (5, 7); (7, 5)] <> (7, 7) then\n        failwith \"Test Case 1 failed\"\n    if findFourthVertex [(10, 20); (30, 10); (10, 10)] <> (30, 20) then\n        failwith \"Test Case 2 failed\"\n    if findFourthVertex [(2, 2); (2, 4); (4, 2)] <> (4, 4) then\n        failwith \"Test Case 3 failed\"\n    if findFourthVertex [(3, 3); (6, 3); (3, 6)] <> (6, 6) then\n        failwith \"Test Case 4 failed\"\n    if findFourthVertex [(8, 10); (5, 10); (5, 7)] <> (8, 7) then\n        failwith \"Test Case 5 failed\"\n    if findFourthVertex [(12, 15); (9, 12); (12, 12)] <> (9, 15) then\n        failwith \"Test Case 6 failed\"\n\ncheck ()"}
{"question_id": "F#/36", "category": "Syntax", "subtype": "misused ==and=", "level": "medium", "example": "findFourthVertex [(5, 5); (5, 7); (7, 5)]\n(7, 7)\nfindFourthVertex [(10, 20);(30, 10); (10, 10)]\n(30, 20)", "docstring": "Given the coordinates of three vertices of a rectangle, this function computes \n    the coordinates of the fourth vertex. The rectangle is assumed to have sides \n    parallel to the coordinate axes.\n    \n", "canonical_solution": "open System\n\nlet findFourthVertex (coordinates: (int * int) list) : int * int =\n\n\n    let (xList, yList) = List.unzip coordinates\n    let findFourthCoordinate (coordList: int list) =\n        match List.distinct coordList with\n        | [a; b] -> if List.filter ((=) a) coordList |> List.length = 1 then a else b\n        | _ -> failwith \"Invalid input\"\n\n    let fourthX = findFourthCoordinate xList\n    let fourthY = findFourthCoordinate yList\n    (fourthX, fourthY)", "buggy_code": "open System\n\nlet findFourthVertex (coordinates: (int * int) list) : int * int =\n\n\n    let (xList, yList) = List.unzip coordinates\n    let findFourthCoordinate (coordList: int list) =\n        match List.distinct coordList with\n        | [a; b] -> if List.filter (== a) coordList |> List.length == 1 then a else b\n        | _ -> failwith \"Invalid input\"\n\n    let fourthX = findFourthCoordinate xList\n    let fourthY = findFourthCoordinate yList\n    (fourthX, fourthY)", "bug_with_line_numbers": "   1 | open System\n   2 | let findFourthVertex (coordinates: (int * int) list) : int * int =\n   3 |     let (xList, yList) = List.unzip coordinates\n   4 |     let findFourthCoordinate (coordList: int list) =\n   5 |         match List.distinct coordList with\n   6 |         | [a; b] -> if List.filter (== a) coordList |> List.length == 1 then a else b\n   7 |         | _ -> failwith \"Invalid input\"\n   8 |     let fourthX = findFourthCoordinate xList\n   9 |     let fourthY = findFourthCoordinate yList\n  10 |     (fourthX, fourthY)", "fragment_lines": [6], "fragment_content": [""], "test": "let check () =\n    if findFourthVertex [(5, 5); (5, 7); (7, 5)] <> (7, 7) then\n        failwith \"Test Case 1 failed\"\n    if findFourthVertex [(10, 20); (30, 10); (10, 10)] <> (30, 20) then\n        failwith \"Test Case 2 failed\"\n    if findFourthVertex [(2, 2); (2, 4); (4, 2)] <> (4, 4) then\n        failwith \"Test Case 3 failed\"\n    if findFourthVertex [(3, 3); (6, 3); (3, 6)] <> (6, 6) then\n        failwith \"Test Case 4 failed\"\n    if findFourthVertex [(8, 10); (5, 10); (5, 7)] <> (8, 7) then\n        failwith \"Test Case 5 failed\"\n    if findFourthVertex [(12, 15); (9, 12); (12, 12)] <> (9, 15) then\n        failwith \"Test Case 6 failed\"\n\ncheck ()"}
{"question_id": "F#/37", "category": "Logic", "subtype": "algorithm_error", "level": "hard", "example": "calculateFinalScore [9; 5; 6; 8; 9]\n7.67\ncalculateFinalScore [10; 10; 10; 10; 10]\n10.00\ncalculateFinalScore [0; 0; 0; 0; 0]\n0.00", "docstring": "This function calculates the final score of a contestant by removing the highest and lowest scores\n    from a list of scores, and then calculating the average of the remaining scores.\n\n", "canonical_solution": "open System\nlet calculateFinalScore (scores: int list) =\n\n\n    let sortedScores = List.sort scores\n    let trimmedScores = sortedScores |> List.skip 1 |> List.rev |> List.skip 1 |> List.rev\n    let sum = List.sum trimmedScores\n    let count = List.length trimmedScores\n    let average = float sum / float count\n    System.Math.Round(average, 2)", "buggy_code": "open System\nlet calculateFinalScore (scores: int list) =\n\n\n    let sortedScores = List.sort scores\n    let trimmedScores = sortedScores |> List.skip 1 |> List.skip 1\n    let sum = List.sum trimmedScores\n    let count = List.length trimmedScores\n    let average = float sum / float count\n    System.Math.Round(average, 2)", "bug_with_line_numbers": "   1 | open System\n   2 | let calculateFinalScore (scores: int list) =\n   3 |     let sortedScores = List.sort scores\n   4 |     let trimmedScores = sortedScores |> List.skip 1 |> List.skip 1\n   5 |     let sum = List.sum trimmedScores\n   6 |     let count = List.length trimmedScores\n   7 |     let average = float sum / float count\n   8 |     System.Math.Round(average, 2)", "fragment_lines": [4], "fragment_content": ["let trimmedScores = sortedScores"], "test": "let check () =\n    if calculateFinalScore [9; 5; 6; 8; 9] <> 7.67 then\n        failwith \"Test Case 1 failed\"\n    if calculateFinalScore [10; 10; 10; 10; 10] <> 10.00 then\n        failwith \"Test Case 2 failed\"\n    if calculateFinalScore [0; 0; 0; 0; 0] <> 0.00 then\n        failwith \"Test Case 3 failed\"\n    if calculateFinalScore [5; 6; 7; 8; 9] <> 7.00 then\n        failwith \"Test Case 4 failed\"\n    if calculateFinalScore [1; 2; 3; 4; 5] <> 3.00 then\n        failwith \"Test Case 5 failed\"\n\ncheck ()"}
{"question_id": "F#/38", "category": "Multiple", "subtype": "double_bug", "level": "easy", "example": "calculateFinalScore [9; 5; 6; 8; 9]\n7.67\ncalculateFinalScore [10; 10; 10; 10; 10]\n10.00\ncalculateFinalScore [0; 0; 0; 0; 0]\n0.00", "docstring": "This function calculates the final score of a contestant by removing the highest and lowest scores\n    from a list of scores, and then calculating the average of the remaining scores.\n\n", "canonical_solution": "open System\nlet calculateFinalScore (scores: int list) =\n\n\n    let sortedScores = List.sort scores\n    let trimmedScores = sortedScores |> List.skip 1 |> List.rev |> List.skip 1 |> List.rev\n    let sum = List.sum trimmedScores\n    let count = List.length trimmedScores\n    let average = float sum / float count\n    System.Math.Round(average, 2)", "buggy_code": "open System\nlet calculateFinalScore (scores: int list) =\n\n\n    let sortedScores = List.sort scores\n    let trimmedScores = sortedScores |> List.skip 1 |> List.rev |> List.skip 1 |> List.rev\n    let sum = List.add trimmedScores\n    let count = List.length trimmedScores\n    let average = sum / count\n    System.Math.Round(average, 2)", "bug_with_line_numbers": "   1 | open System\n   2 | let calculateFinalScore (scores: int list) =\n   3 |     let sortedScores = List.sort scores\n   4 |     let trimmedScores = sortedScores |> List.skip 1 |> List.rev |> List.skip 1 |> List.rev\n   5 |     let sum = List.add trimmedScores\n   6 |     let count = List.length trimmedScores\n   7 |     let average = sum / count\n   8 |     System.Math.Round(average, 2)", "fragment_lines": [5, 7], "fragment_content": ["let sum = List.add trimmedScores", "let average = sum / count"], "test": "let check () =\n    if calculateFinalScore [9; 5; 6; 8; 9] <> 7.67 then\n        failwith \"Test Case 1 failed\"\n    if calculateFinalScore [10; 10; 10; 10; 10] <> 10.00 then\n        failwith \"Test Case 2 failed\"\n    if calculateFinalScore [0; 0; 0; 0; 0] <> 0.00 then\n        failwith \"Test Case 3 failed\"\n    if calculateFinalScore [5; 6; 7; 8; 9] <> 7.00 then\n        failwith \"Test Case 4 failed\"\n    if calculateFinalScore [1; 2; 3; 4; 5] <> 3.00 then\n        failwith \"Test Case 5 failed\"\n\ncheck ()"}
{"question_id": "F#/39", "category": "Multiple", "subtype": "triple_bug", "level": "hard", "example": "calculateFinalScore [9; 5; 6; 8; 9]\n7.67\ncalculateFinalScore [10; 10; 10; 10; 10]\n10.00\ncalculateFinalScore [0; 0; 0; 0; 0]\n0.00", "docstring": "This function calculates the final score of a contestant by removing the highest and lowest scores\n    from a list of scores, and then calculating the average of the remaining scores.\n\n", "canonical_solution": "open System\nlet calculateFinalScore (scores: int list) =\n\n\n    let sortedScores = List.sort scores\n    let trimmedScores = sortedScores |> List.skip 1 |> List.rev |> List.skip 1 |> List.rev\n    let sum = List.sum trimmedScores\n    let count = List.length trimmedScores\n    let average = float sum / float count\n    System.Math.Round(average, 2)", "buggy_code": "open System\nlet calculateFinalScore (scores: int list) =\n\n\n    let sortedScores = List.sortDescending scores\n    let trimmedScores = sortedScores |> List.skip 1 |> List.rev |> List.skip 1 |> List.rev\n    let sum = List.sum trimmedScores\n    let count = List.length trimmedScores\n    let average = sum / count\n    (average, 2)", "bug_with_line_numbers": "   1 | open System\n   2 | let calculateFinalScore (scores: int list) =\n   3 |     let sortedScores = List.sortDescending scores\n   4 |     let trimmedScores = sortedScores |> List.skip 1 |> List.rev |> List.skip 1 |> List.rev\n   5 |     let sum = List.sum trimmedScores\n   6 |     let count = List.length trimmedScores\n   7 |     let average = sum / count\n   8 |     (average, 2)", "fragment_lines": [3, 7, 8], "fragment_content": ["let sortedScores = List.sortDescending scores", "let average = sum / count", "(average, 2)"], "test": "let check () =\n    if calculateFinalScore [9; 5; 6; 8; 9] <> 7.67 then\n        failwith \"Test Case 1 failed\"\n    if calculateFinalScore [10; 10; 10; 10; 10] <> 10.00 then\n        failwith \"Test Case 2 failed\"\n    if calculateFinalScore [0; 0; 0; 0; 0] <> 0.00 then\n        failwith \"Test Case 3 failed\"\n    if calculateFinalScore [5; 6; 7; 8; 9] <> 7.00 then\n        failwith \"Test Case 4 failed\"\n    if calculateFinalScore [1; 2; 3; 4; 5] <> 3.00 then\n        failwith \"Test Case 5 failed\"\n\ncheck ()"}
{"question_id": "F#/40", "category": "Multiple", "subtype": "double_bug", "level": "hard", "example": "finalPosition \"ENWS\" 5 results in (1, 0)\n(Moves: E -> N -> W -> S -> E)", "docstring": "Calculates the final position of a robot after executing a given command string for a specified duration.\n        The command string consists of characters 'E', 'S', 'W', 'N', representing movements east, south, west, and north, respectively.\n        The robot repeats the command string from the beginning if it reaches the end before the time is up.\n\n", "canonical_solution": "open System\n\nlet finalPosition (commands: string) (time: int) : (int * int) =\n    \n\n    let move (x, y) (command: char) =\n        match command with\n        | 'E' -> (x + 1, y)\n        | 'S' -> (x, y - 1)\n        | 'W' -> (x - 1, y)\n        | 'N' -> (x, y + 1)\n        | _ -> (x, y)\n\n    let rec moveRobot (x, y) (commands: string) (time: int) =\n        if time <= 0 then (x, y)\n        else\n            let newCommands = if commands.Length > 1 then commands.[1..] + commands.[0].ToString() else commands\n            moveRobot (move (x, y) commands.[0]) newCommands (time - 1)\n\n    moveRobot (0, 0) commands time", "buggy_code": "open System\n\nlet finalPosition (commands: string) (time: int) : (int * int) =\n    \n\n    let move (x, y) (command: char) =\n        match command with\n        | 'E' -> (x + 1, y)\n        | 'S' -> (x, y - 1)\n        | 'W' -> (x - 1, y)\n        | 'N' -> (x, y + 1)\n        | _ -> (x, y)\n\n    let rec moveRobot (x, y) (commands: string) (time: int) =\n        if time < 0 then (x, y)\n        else\n            let newCommands = if commands.Length > 1 then commands.[1..] + commands.[0].ToString() else commands\n            moveRobot (move (x, y) commands.[0]) newCommands (time - 1)\n\n    moveRobot 0 commands time", "bug_with_line_numbers": "   1 | open System\n   2 | let finalPosition (commands: string) (time: int) : (int * int) =\n   3 |     let move (x, y) (command: char) =\n   4 |         match command with\n   5 |         | 'E' -> (x + 1, y)\n   6 |         | 'S' -> (x, y - 1)\n   7 |         | 'W' -> (x - 1, y)\n   8 |         | 'N' -> (x, y + 1)\n   9 |         | _ -> (x, y)\n  10 |     let rec moveRobot (x, y) (commands: string) (time: int) =\n  11 |         if time < 0 then (x, y)\n  12 |         else\n  13 |             let newCommands = if commands.Length > 1 then commands.[1..] + commands.[0].ToString() else commands\n  14 |             moveRobot (move (x, y) commands.[0]) newCommands (time - 1)\n  15 |     moveRobot 0 commands time", "fragment_lines": [11, 15], "fragment_content": ["if time < 0 then (x, y)", "moveRobot 0 commands time"], "test": "let check () =\n    if finalPosition \"ENWS\" 5 <> (1, 0) then\n        failwith \"Test Case 1 failed\"\n    if finalPosition \"NNSS\" 3 <> (0, 1) then\n        failwith \"Test Case 2 failed\"\n    if finalPosition \"SWNE\" 4 <> (0, 0) then\n        failwith \"Test Case 3 failed\"\n    if finalPosition \"EESSWWNN\" 8 <> (0, 0) then\n        failwith \"Test Case 4 failed\"\n    if finalPosition \"W\" 10 <> (-10, 0) then\n        failwith \"Test Case 5 failed\"\n    if finalPosition \"NESW\" 2 <> (1, 1) then\n        failwith \"Test Case 6 failed\"\n    if finalPosition \"SSSEEE\" 6 <> (3, -3) then\n        failwith \"Test Case 7 failed\"\n\ncheck ()"}
{"question_id": "F#/41", "category": "Logic", "subtype": "operation_error", "level": "easy", "example": "finalPosition \"ENWS\" 5 results in (1, 0)\n(Moves: E -> N -> W -> S -> E)", "docstring": "Calculates the final position of a robot after executing a given command string for a specified duration.\n        The command string consists of characters 'E', 'S', 'W', 'N', representing movements east, south, west, and north, respectively.\n        The robot repeats the command string from the beginning if it reaches the end before the time is up.\n\n", "canonical_solution": "open System\n\nlet finalPosition (commands: string) (time: int) : (int * int) =\n    \n\n    let move (x, y) (command: char) =\n        match command with\n        | 'E' -> (x + 1, y)\n        | 'S' -> (x, y - 1)\n        | 'W' -> (x - 1, y)\n        | 'N' -> (x, y + 1)\n        | _ -> (x, y)\n\n    let rec moveRobot (x, y) (commands: string) (time: int) =\n        if time <= 0 then (x, y)\n        else\n            let newCommands = if commands.Length > 1 then commands.[1..] + commands.[0].ToString() else commands\n            moveRobot (move (x, y) commands.[0]) newCommands (time - 1)\n\n    moveRobot (0, 0) commands time", "buggy_code": "open System\n\nlet finalPosition (commands: string) (time: int) : (int * int) =\n    \n\n    let move (x, y) (command: char) =\n        match command with\n        | 'E' -> (x + 1, y)\n        | 'S' -> (x, y - 1)\n        | 'W' -> (x - 1, y)\n        | 'N' -> (x, y + 1)\n        | _ -> (x, y)\n\n    let rec moveRobot (x, y) (commands: string) (time: int) =\n        if time <= 0 then (x, y)\n        else\n            let newCommands = if commands.Length > 1 then commands.[1..] + commands.[0].ToString() else commands\n            moveRobot (move (x, y) commands.[0]) newCommands (time)\n\n    moveRobot (0, 0) commands time", "bug_with_line_numbers": "   1 | open System\n   2 | let finalPosition (commands: string) (time: int) : (int * int) =\n   3 |     let move (x, y) (command: char) =\n   4 |         match command with\n   5 |         | 'E' -> (x + 1, y)\n   6 |         | 'S' -> (x, y - 1)\n   7 |         | 'W' -> (x - 1, y)\n   8 |         | 'N' -> (x, y + 1)\n   9 |         | _ -> (x, y)\n  10 |     let rec moveRobot (x, y) (commands: string) (time: int) =\n  11 |         if time <= 0 then (x, y)\n  12 |         else\n  13 |             let newCommands = if commands.Length > 1 then commands.[1..] + commands.[0].ToString() else commands\n  14 |             moveRobot (move (x, y) commands.[0]) newCommands (time)\n  15 |     moveRobot (0, 0) commands time", "fragment_lines": [14], "fragment_content": ["moveRobot (move (x, y) commands.[0]) newCommands (time)"], "test": "let check () =\n    if finalPosition \"ENWS\" 5 <> (1, 0) then\n        failwith \"Test Case 1 failed\"\n    if finalPosition \"NNSS\" 3 <> (0, 1) then\n        failwith \"Test Case 2 failed\"\n    if finalPosition \"SWNE\" 4 <> (0, 0) then\n        failwith \"Test Case 3 failed\"\n    if finalPosition \"EESSWWNN\" 8 <> (0, 0) then\n        failwith \"Test Case 4 failed\"\n    if finalPosition \"W\" 10 <> (-10, 0) then\n        failwith \"Test Case 5 failed\"\n    if finalPosition \"NESW\" 2 <> (1, 1) then\n        failwith \"Test Case 6 failed\"\n    if finalPosition \"SSSEEE\" 6 <> (3, -3) then\n        failwith \"Test Case 7 failed\"\n\ncheck ()"}
{"question_id": "F#/42", "category": "Logic", "subtype": "type_error", "level": "medium", "example": "finalPosition \"ENWS\" 5 results in (1, 0)\n(Moves: E -> N -> W -> S -> E)", "docstring": "Calculates the final position of a robot after executing a given command string for a specified duration.\n        The command string consists of characters 'E', 'S', 'W', 'N', representing movements east, south, west, and north, respectively.\n        The robot repeats the command string from the beginning if it reaches the end before the time is up.\n\n", "canonical_solution": "open System\n\nlet finalPosition (commands: string) (time: int) : (int * int) =\n    \n\n    let move (x, y) (command: char) =\n        match command with\n        | 'E' -> (x + 1, y)\n        | 'S' -> (x, y - 1)\n        | 'W' -> (x - 1, y)\n        | 'N' -> (x, y + 1)\n        | _ -> (x, y)\n\n    let rec moveRobot (x, y) (commands: string) (time: int) =\n        if time <= 0 then (x, y)\n        else\n            let newCommands = if commands.Length > 1 then commands.[1..] + commands.[0].ToString() else commands\n            moveRobot (move (x, y) commands.[0]) newCommands (time - 1)\n\n    moveRobot (0, 0) commands time", "buggy_code": "open System\n\nlet finalPosition (commands: string) (time: int) : (int * int) =\n    \n\n    let move (x, y) (command: char) =\n        match command with\n        | 'E' -> (x + 1, y)\n        | 'S' -> (x, y - 1)\n        | 'W' -> (x - 1, y)\n        | 'N' -> (x, y + 1)\n        | _ -> (x, y)\n\n    let rec moveRobot (x, y) (commands: string) (time: int) =\n        if time <= 0 then (x, y)\n        else\n            let newCommands = if commands.Length > 1 then commands.[1..] + commands.[0] else commands\n            moveRobot (move (x, y) commands.[0]) newCommands (time - 1)\n\n    moveRobot (0, 0) commands time", "bug_with_line_numbers": "   1 | open System\n   2 | let finalPosition (commands: string) (time: int) : (int * int) =\n   3 |     let move (x, y) (command: char) =\n   4 |         match command with\n   5 |         | 'E' -> (x + 1, y)\n   6 |         | 'S' -> (x, y - 1)\n   7 |         | 'W' -> (x - 1, y)\n   8 |         | 'N' -> (x, y + 1)\n   9 |         | _ -> (x, y)\n  10 |     let rec moveRobot (x, y) (commands: string) (time: int) =\n  11 |         if time <= 0 then (x, y)\n  12 |         else\n  13 |             let newCommands = if commands.Length > 1 then commands.[1..] + commands.[0] else commands\n  14 |             moveRobot (move (x, y) commands.[0]) newCommands (time - 1)\n  15 |     moveRobot (0, 0) commands time", "fragment_lines": [13], "fragment_content": ["let newCommands = if commands.Length > 1 then commands.[1..] + commands.[0] else commands"], "test": "let check () =\n    if finalPosition \"ENWS\" 5 <> (1, 0) then\n        failwith \"Test Case 1 failed\"\n    if finalPosition \"NNSS\" 3 <> (0, 1) then\n        failwith \"Test Case 2 failed\"\n    if finalPosition \"SWNE\" 4 <> (0, 0) then\n        failwith \"Test Case 3 failed\"\n    if finalPosition \"EESSWWNN\" 8 <> (0, 0) then\n        failwith \"Test Case 4 failed\"\n    if finalPosition \"W\" 10 <> (-10, 0) then\n        failwith \"Test Case 5 failed\"\n    if finalPosition \"NESW\" 2 <> (1, 1) then\n        failwith \"Test Case 6 failed\"\n    if finalPosition \"SSSEEE\" 6 <> (3, -3) then\n        failwith \"Test Case 7 failed\"\n\ncheck ()"}
{"question_id": "F#/43", "category": "Logic", "subtype": "algorithm_error", "level": "hard", "example": "maxGroupedKnapsackValue 50 [(10, 60, 1), (20, 100, 1), (30, 120, 2)]\n220", "docstring": "Calculates the maximum total value of items that can be put into a knapsack of a given total weight,\n    considering that items are grouped and within each group, items are mutually exclusive.\n\n    Args:\n    totalWeight: An integer representing the total weight capacity of the knapsack.\n    items: A list of tuples, each representing an item. Each tuple contains three integers:\n           - The weight of the item.\n           - The value of the item.\n           - The group number to which the item belongs.\n\n    Returns:\n    An integer representing the maximum total value that can be achieved within the given constraints.\n\n", "canonical_solution": "open System\n\n// Function to calculate the maximum value with group constraints\nlet maxGroupedKnapsackValue (totalWeight: int) (items: (int * int * int) list) =\n\n\n    let groups = items |> List.map (fun (_, _, g) -> g) |> Set.ofList\n    let dp = Array.init (totalWeight + 1) (fun _ -> Array.zeroCreate (Set.count groups + 1))\n\n    for i in 1 .. totalWeight do\n        for j in groups do\n            dp.[i].[j] <- dp.[i - 1].[j]\n            for weight, value, group in items do\n                if group = j && weight <= i then\n                    dp.[i].[j] <- max dp.[i].[j] (dp.[i - weight].[j - 1] + value)\n\n    Seq.fold max 0 (dp.[totalWeight])", "buggy_code": "open System\n\n// Function to calculate the maximum value with group constraints\nlet maxGroupedKnapsackValue (totalWeight: int) (items: (int * int * int) list) =\n\n\n    let groups = items |> List.map (fun (_, _, g) -> g) |> Set.ofList\n    let dp = Array.init (totalWeight + 1) (fun _ -> Array.zeroCreate (Set.count groups + 1))\n\n    for i in 1 .. totalWeight do\n        for j in groups do\n            dp.[i].[j] <- dp.[i - 1].[j]\n            for weight, value, group in items do\n                if group = j && weight <= i then\n                    dp.[i].[j] <- min dp.[i].[j] (dp.[i - weight].[j - 2] + value)\n\n    Seq.fold max 0 (dp.[totalWeight])", "bug_with_line_numbers": "   1 | open System\n   2 | // Function to calculate the maximum value with group constraints\n   3 | let maxGroupedKnapsackValue (totalWeight: int) (items: (int * int * int) list) =\n   4 |     let groups = items |> List.map (fun (_, _, g) -> g) |> Set.ofList\n   5 |     let dp = Array.init (totalWeight + 1) (fun _ -> Array.zeroCreate (Set.count groups + 1))\n   6 |     for i in 1 .. totalWeight do\n   7 |         for j in groups do\n   8 |             dp.[i].[j] <- dp.[i - 1].[j]\n   9 |             for weight, value, group in items do\n  10 |                 if group = j && weight <= i then\n  11 |                     dp.[i].[j] <- min dp.[i].[j] (dp.[i - weight].[j - 2] + value)\n  12 |     Seq.fold max 0 (dp.[totalWeight])", "fragment_lines": [11], "fragment_content": ["dp.[i].[j] <- min dp.[i].[j] (dp.[i - weight].[j - 2] + value)"], "test": "let check () =\n    let test1 = maxGroupedKnapsackValue 50 [(10, 10, 1); (20, 20, 1); (30, 35, 2)]\n    if test1 <> 55 then\n        failwithf \"Test Case 1 failed: Expected 55, got %d\" test1\n\n    let test2 = maxGroupedKnapsackValue 50 [(10, 60, 1); (20, 100, 1); (30, 120, 2)]\n    if test2 <> 220 then\n        failwithf \"Test Case 2 failed: Expected 220, got %d\" test2\n\n    let test3 = maxGroupedKnapsackValue 50 [(10, 60, 1); (20, 100, 2); (30, 120, 2)]\n    if test3 <> 180 then\n        failwithf \"Test Case 3 failed: Expected 180, got %d\" test3\n\n    let test4 = maxGroupedKnapsackValue 50 [(10, 40, 1); (15, 60, 1); (25, 90, 2); (35, 120, 3)]\n    if test4 <> 150 then\n        failwithf \"Test Case 4 failed: Expected 150, got %d\" test4\n\n    let test5 = maxGroupedKnapsackValue 30 [(5, 10, 1); (10, 20, 1); (15, 30, 2)]\n    if test5 <> 50 then\n        failwithf \"Test Case 5 failed: Expected 50, got %d\" test5\n\ncheck ()"}
{"question_id": "F#/44", "category": "Reference", "subtype": "faulty_indexing", "level": "hard", "example": "maxGroupedKnapsackValue 50 [(10, 60, 1), (20, 100, 1), (30, 120, 2)]\n220", "docstring": "Calculates the maximum total value of items that can be put into a knapsack of a given total weight,\n    considering that items are grouped and within each group, items are mutually exclusive.\n\n    Args:\n    totalWeight: An integer representing the total weight capacity of the knapsack.\n    items: A list of tuples, each representing an item. Each tuple contains three integers:\n           - The weight of the item.\n           - The value of the item.\n           - The group number to which the item belongs.\n\n    Returns:\n    An integer representing the maximum total value that can be achieved within the given constraints.\n\n", "canonical_solution": "open System\n\n// Function to calculate the maximum value with group constraints\nlet maxGroupedKnapsackValue (totalWeight: int) (items: (int * int * int) list) =\n\n\n    let groups = items |> List.map (fun (_, _, g) -> g) |> Set.ofList\n    let dp = Array.init (totalWeight + 1) (fun _ -> Array.zeroCreate (Set.count groups + 1))\n\n    for i in 1 .. totalWeight do\n        for j in groups do\n            dp.[i].[j] <- dp.[i - 1].[j]\n            for weight, value, group in items do\n                if group = j && weight <= i then\n                    dp.[i].[j] <- max dp.[i].[j] (dp.[i - weight].[j - 1] + value)\n\n    Seq.fold max 0 (dp.[totalWeight])", "buggy_code": "open System\n\n// Function to calculate the maximum value with group constraints\nlet maxGroupedKnapsackValue (totalWeight: int) (items: (int * int * int) list) =\n\n\n    let groups = items |> List.map (fun (_, _, g) -> g) |> Set.ofList\n    let dp = Array.init (totalWeight + 1) (fun _ -> Array.zeroCreate (Set.count groups + 1))\n\n    for i in 0 .. totalWeight do\n        for j in groups do\n            dp.[i].[j] <- dp.[i - 1].[j]\n            for weight, value, group in items do\n                if group = j && weight <= i then\n                    dp.[i].[j] <- max dp.[i].[j] (dp.[i - weight].[j - 1] + value)\n\n    Seq.fold max 0 (dp.[totalWeight])", "bug_with_line_numbers": "   1 | open System\n   2 | // Function to calculate the maximum value with group constraints\n   3 | let maxGroupedKnapsackValue (totalWeight: int) (items: (int * int * int) list) =\n   4 |     let groups = items |> List.map (fun (_, _, g) -> g) |> Set.ofList\n   5 |     let dp = Array.init (totalWeight + 1) (fun _ -> Array.zeroCreate (Set.count groups + 1))\n   6 |     for i in 0 .. totalWeight do\n   7 |         for j in groups do\n   8 |             dp.[i].[j] <- dp.[i - 1].[j]\n   9 |             for weight, value, group in items do\n  10 |                 if group = j && weight <= i then\n  11 |                     dp.[i].[j] <- max dp.[i].[j] (dp.[i - weight].[j - 1] + value)\n  12 |     Seq.fold max 0 (dp.[totalWeight])", "fragment_lines": [6], "fragment_content": ["for i in 0 .. totalWeight do"], "test": "let check () =\n    let test1 = maxGroupedKnapsackValue 50 [(10, 10, 1); (20, 20, 1); (30, 35, 2)]\n    if test1 <> 55 then\n        failwithf \"Test Case 1 failed: Expected 55, got %d\" test1\n\n    let test2 = maxGroupedKnapsackValue 50 [(10, 60, 1); (20, 100, 1); (30, 120, 2)]\n    if test2 <> 220 then\n        failwithf \"Test Case 2 failed: Expected 220, got %d\" test2\n\n    let test3 = maxGroupedKnapsackValue 50 [(10, 60, 1); (20, 100, 2); (30, 120, 2)]\n    if test3 <> 180 then\n        failwithf \"Test Case 3 failed: Expected 180, got %d\" test3\n\n    let test4 = maxGroupedKnapsackValue 50 [(10, 40, 1); (15, 60, 1); (25, 90, 2); (35, 120, 3)]\n    if test4 <> 150 then\n        failwithf \"Test Case 4 failed: Expected 150, got %d\" test4\n\n    let test5 = maxGroupedKnapsackValue 30 [(5, 10, 1); (10, 20, 1); (15, 30, 2)]\n    if test5 <> 50 then\n        failwithf \"Test Case 5 failed: Expected 50, got %d\" test5\n\ncheck ()"}
{"question_id": "F#/45", "category": "Reference", "subtype": "faulty_indexing", "level": "easy", "example": "findLuckyNumbers([[3, 7, 8], [9, 11, 13], [15, 16, 17]])\n[15]\nfindLuckyNumbers([[1, 10, 4, 2], [9, 3, 8, 7], [15, 16, 17, 12]])\n[12]", "docstring": "Finds all lucky numbers in an m x n matrix. A lucky number is the smallest in its row and the largest in its column.\n", "canonical_solution": "open System\n\nlet findLuckyNumbers (matrix: int list list) =\n    \n\n    let rowMins = matrix |> List.map List.min\n    let colMaxs = \n        [for colIdx in 0 .. (List.head matrix |> List.length) - 1 do\n            yield matrix |> List.map (fun row -> row.[colIdx]) |> List.max]\n\n    [for rowIdx in 0 .. matrix.Length - 1 do\n        for colIdx in 0 .. (matrix.[rowIdx] |> List.length) - 1 do\n            let value = matrix.[rowIdx].[colIdx]\n            if value = rowMins.[rowIdx] && value = colMaxs.[colIdx] then\n                yield value]", "buggy_code": "open System\n\nlet findLuckyNumbers (matrix: int list list) =\n    \n\n    let rowMins = matrix |> List.map List.min\n    let colMaxs = \n        [for colIdx in 0 .. (List.head matrix |> List.length) do\n            yield matrix |> List.map (fun row -> row.[colIdx]) |> List.max]\n\n    [for rowIdx in 0 .. matrix.Length - 1 do\n        for colIdx in 0 .. (matrix.[rowIdx] |> List.length) - 1 do\n            let value = matrix.[rowIdx].[colIdx]\n            if value = rowMins.[rowIdx] && value = colMaxs.[colIdx] then\n                yield value]", "bug_with_line_numbers": "   1 | open System\n   2 | let findLuckyNumbers (matrix: int list list) =\n   3 |     let rowMins = matrix |> List.map List.min\n   4 |     let colMaxs = \n   5 |         [for colIdx in 0 .. (List.head matrix |> List.length) do\n   6 |             yield matrix |> List.map (fun row -> row.[colIdx]) |> List.max]\n   7 |     [for rowIdx in 0 .. matrix.Length - 1 do\n   8 |         for colIdx in 0 .. (matrix.[rowIdx] |> List.length) - 1 do\n   9 |             let value = matrix.[rowIdx].[colIdx]\n  10 |             if value = rowMins.[rowIdx] && value = colMaxs.[colIdx] then\n  11 |                 yield value]", "fragment_lines": [5], "fragment_content": ["[for colIdx in 0 .. (List.head matrix"], "test": "let check () =\n    if findLuckyNumbers [[3; 7; 8]; [9; 11; 13]; [15; 16; 17]] <> [15] then\n        failwith \"Test Case 1 failed\"\n    if findLuckyNumbers [[1; 10; 4; 2]; [9; 3; 8; 7]; [15; 16; 17; 12]] <> [12] then\n        failwith \"Test Case 2 failed\"\n    if findLuckyNumbers [[1; 2; 3]; [4; 5; 6]; [7; 8; 9]] <> [7] then\n        failwith \"Test Case 3 failed\"\n    if findLuckyNumbers [[7; 8]; [1; 6]] <> [7] then\n        failwith \"Test Case 4 failed\"\n    if findLuckyNumbers [[11; 17; 4; 3]; [9; 5; 8; 7]; [15; 2; 16; 12]] <> [] then\n        failwith \"Test Case 5 failed\"\n\ncheck ()"}
{"question_id": "F#/46", "category": "Reference", "subtype": "illegal_keyword", "level": "hard", "example": "maxGroupedKnapsackValue 50 [(10, 60, 1), (20, 100, 1), (30, 120, 2)]\n220", "docstring": "Calculates the maximum total value of items that can be put into a knapsack of a given total weight,\n    considering that items are grouped and within each group, items are mutually exclusive.\n\n    Args:\n    totalWeight: An integer representing the total weight capacity of the knapsack.\n    items: A list of tuples, each representing an item. Each tuple contains three integers:\n           - The weight of the item.\n           - The value of the item.\n           - The group number to which the item belongs.\n\n    Returns:\n    An integer representing the maximum total value that can be achieved within the given constraints.\n\n", "canonical_solution": "open System\n\n// Function to calculate the maximum value with group constraints\nlet maxGroupedKnapsackValue (totalWeight: int) (items: (int * int * int) list) =\n\n\n    let groups = items |> List.map (fun (_, _, g) -> g) |> Set.ofList\n    let dp = Array.init (totalWeight + 1) (fun _ -> Array.zeroCreate (Set.count groups + 1))\n\n    for i in 1 .. totalWeight do\n        for j in groups do\n            dp.[i].[j] <- dp.[i - 1].[j]\n            for weight, value, group in items do\n                if group = j && weight <= i then\n                    dp.[i].[j] <- max dp.[i].[j] (dp.[i - weight].[j - 1] + value)\n\n    Seq.fold max 0 (dp.[totalWeight])", "buggy_code": "open System\n\n// Function to calculate the maximum value with group constraints\nlet maxGroupedKnapsackValue (totalWeight: int) (items: (int * int * int) list) =\n\n\n    let groups = items |> List.map (fun (default, default, g) -> g) |> Set.ofList\n    let dp = Array.init (totalWeight + 1) (fun _ -> Array.zeroCreate (Set.count groups + 1))\n\n    for i in 1 .. totalWeight do\n        for j in groups do\n            dp.[i].[j] <- dp.[i - 1].[j]\n            for weight, value, group in items do\n                if group = j && weight <= i then\n                    dp.[i].[j] <- max dp.[i].[j] (dp.[i - weight].[j - 1] + value)\n\n    Seq.fold max 0 (dp.[totalWeight])", "bug_with_line_numbers": "   1 | open System\n   2 | // Function to calculate the maximum value with group constraints\n   3 | let maxGroupedKnapsackValue (totalWeight: int) (items: (int * int * int) list) =\n   4 |     let groups = items |> List.map (fun (default, default, g) -> g) |> Set.ofList\n   5 |     let dp = Array.init (totalWeight + 1) (fun _ -> Array.zeroCreate (Set.count groups + 1))\n   6 |     for i in 1 .. totalWeight do\n   7 |         for j in groups do\n   8 |             dp.[i].[j] <- dp.[i - 1].[j]\n   9 |             for weight, value, group in items do\n  10 |                 if group = j && weight <= i then\n  11 |                     dp.[i].[j] <- max dp.[i].[j] (dp.[i - weight].[j - 1] + value)\n  12 |     Seq.fold max 0 (dp.[totalWeight])", "fragment_lines": [4], "fragment_content": ["let groups = items"], "test": "let check () =\n    let test1 = maxGroupedKnapsackValue 50 [(10, 10, 1); (20, 20, 1); (30, 35, 2)]\n    if test1 <> 55 then\n        failwithf \"Test Case 1 failed: Expected 55, got %d\" test1\n\n    let test2 = maxGroupedKnapsackValue 50 [(10, 60, 1); (20, 100, 1); (30, 120, 2)]\n    if test2 <> 220 then\n        failwithf \"Test Case 2 failed: Expected 220, got %d\" test2\n\n    let test3 = maxGroupedKnapsackValue 50 [(10, 60, 1); (20, 100, 2); (30, 120, 2)]\n    if test3 <> 180 then\n        failwithf \"Test Case 3 failed: Expected 180, got %d\" test3\n\n    let test4 = maxGroupedKnapsackValue 50 [(10, 40, 1); (15, 60, 1); (25, 90, 2); (35, 120, 3)]\n    if test4 <> 150 then\n        failwithf \"Test Case 4 failed: Expected 150, got %d\" test4\n\n    let test5 = maxGroupedKnapsackValue 30 [(5, 10, 1); (10, 20, 1); (15, 30, 2)]\n    if test5 <> 50 then\n        failwithf \"Test Case 5 failed: Expected 50, got %d\" test5\n\ncheck ()"}
{"question_id": "F#/47", "category": "Logic", "subtype": "algorithm_error", "level": "medium", "example": "maxContests [(1, 4), (2, 5), (6, 8)]\n2", "docstring": "This function calculates the maximum number of contests one can participate in, given each contest's start and end times.\n    The contests are represented as a list of tuples, where each tuple contains two integers representing the start and end times of a contest.\n    The function returns the maximum number of contests that can be attended without overlapping.\n\n", "canonical_solution": "open System\n\nlet maxContests (contests: (int * int) list) =\n\n\n    let sortedContests = List.sortBy snd contests\n\n    let rec countMaxContests lastEnd remainingContests count =\n        match remainingContests with\n        | [] -> count\n        | (start, end_)::tail ->\n            if start >= lastEnd then\n                countMaxContests end_ tail (count + 1)\n            else\n                countMaxContests lastEnd tail count\n\n    countMaxContests Int32.MinValue sortedContests 0", "buggy_code": "open System\n\nlet maxContests (contests: (int * int) list) =\n\n\n    let sortedContests = List.sortBy snd contests\n\n    let rec countMaxContests lastEnd remainingContests count =\n        match remainingContests with\n        | [] -> count\n        | (start, end_)::tail ->\n            if start >= lastEnd then\n                countMaxContests end_ tail count\n            else\n                countMaxContests lastEnd tail count\n\n    countMaxContests Int32.MinValue sortedContests 0", "bug_with_line_numbers": "   1 | open System\n   2 | let maxContests (contests: (int * int) list) =\n   3 |     let sortedContests = List.sortBy snd contests\n   4 |     let rec countMaxContests lastEnd remainingContests count =\n   5 |         match remainingContests with\n   6 |         | [] -> count\n   7 |         | (start, end_)::tail ->\n   8 |             if start >= lastEnd then\n   9 |                 countMaxContests end_ tail count\n  10 |             else\n  11 |                 countMaxContests lastEnd tail count\n  12 |     countMaxContests Int32.MinValue sortedContests 0", "fragment_lines": [9], "fragment_content": ["countMaxContests end_ tail count"], "test": "let check () =\n    if maxContests [(1, 3); (2, 5); (4, 6)] <> 2 then\n        failwith \"Test Case 1 failed\"\n    if maxContests [(0, 2); (1, 3); (3, 5)] <> 2 then\n        failwith \"Test Case 2 failed\"\n    if maxContests [(5, 7); (1, 3); (2, 4)] <> 2 then\n        failwith \"Test Case 3 failed\"\n    if maxContests [(1, 4); (2, 5); (6, 8)] <> 2 then\n        failwith \"Test Case 4 failed\"\n    if maxContests [(0, 1); (1, 2); (2, 3)] <> 3 then\n        failwith \"Test Case 5 failed\"\n\ncheck ()"}
{"question_id": "F#/48", "category": "Reference", "subtype": "undefined_objects", "level": "easy", "example": "maxContests [(1, 4), (2, 5), (6, 8)]\n2", "docstring": "This function calculates the maximum number of contests one can participate in, given each contest's start and end times.\n    The contests are represented as a list of tuples, where each tuple contains two integers representing the start and end times of a contest.\n    The function returns the maximum number of contests that can be attended without overlapping.\n\n", "canonical_solution": "open System\n\nlet maxContests (contests: (int * int) list) =\n\n\n    let sortedContests = List.sortBy snd contests\n\n    let rec countMaxContests lastEnd remainingContests count =\n        match remainingContests with\n        | [] -> count\n        | (start, end_)::tail ->\n            if start >= lastEnd then\n                countMaxContests end_ tail (count + 1)\n            else\n                countMaxContests lastEnd tail count\n\n    countMaxContests Int32.MinValue sortedContests 0", "buggy_code": "open System\n\nlet maxContests (contests: (int * int) list) =\n\n\n    let sortedContests = List.sortBy snd contests\n\n    let rec countMaxContests lastEnd remainingContests count =\n        match remainingContests with\n        | [] -> count\n        | (start, end_)::tail ->\n            if start >= lastEnd then\n                countMaxContests end_tail (count + 1)\n            else\n                countMaxContests lastEnd tail count\n\n    countMaxContests Int32.MinValue sortedContests 0", "bug_with_line_numbers": "   1 | open System\n   2 | let maxContests (contests: (int * int) list) =\n   3 |     let sortedContests = List.sortBy snd contests\n   4 |     let rec countMaxContests lastEnd remainingContests count =\n   5 |         match remainingContests with\n   6 |         | [] -> count\n   7 |         | (start, end_)::tail ->\n   8 |             if start >= lastEnd then\n   9 |                 countMaxContests end_tail (count + 1)\n  10 |             else\n  11 |                 countMaxContests lastEnd tail count\n  12 |     countMaxContests Int32.MinValue sortedContests 0", "fragment_lines": [9], "fragment_content": ["countMaxContests end_tail (count + 1)"], "test": "let check () =\n    if maxContests [(1, 3); (2, 5); (4, 6)] <> 2 then\n        failwith \"Test Case 1 failed\"\n    if maxContests [(0, 2); (1, 3); (3, 5)] <> 2 then\n        failwith \"Test Case 2 failed\"\n    if maxContests [(5, 7); (1, 3); (2, 4)] <> 2 then\n        failwith \"Test Case 3 failed\"\n    if maxContests [(1, 4); (2, 5); (6, 8)] <> 2 then\n        failwith \"Test Case 4 failed\"\n    if maxContests [(0, 1); (1, 2); (2, 3)] <> 3 then\n        failwith \"Test Case 5 failed\"\n\ncheck ()"}
{"question_id": "F#/49", "category": "Logic", "subtype": "variable_error", "level": "hard", "example": "maxContests [(1, 4), (2, 5), (6, 8)]\n2", "docstring": "This function calculates the maximum number of contests one can participate in, given each contest's start and end times.\n    The contests are represented as a list of tuples, where each tuple contains two integers representing the start and end times of a contest.\n    The function returns the maximum number of contests that can be attended without overlapping.\n\n", "canonical_solution": "open System\n\nlet maxContests (contests: (int * int) list) =\n\n\n    let sortedContests = List.sortBy snd contests\n\n    let rec countMaxContests lastEnd remainingContests count =\n        match remainingContests with\n        | [] -> count\n        | (start, end_)::tail ->\n            if start >= lastEnd then\n                countMaxContests end_ tail (count + 1)\n            else\n                countMaxContests lastEnd tail count\n\n    countMaxContests Int32.MinValue sortedContests 0", "buggy_code": "open System\n\nlet maxContests (contests: (int * int) list) =\n\n\n    let sortedContests = List.sortByDescending snd contests\n\n    let rec countMaxContests lastEnd remainingContests count =\n        match remainingContests with\n        | [] -> count\n        | (start, end_)::tail ->\n            if start >= lastEnd then\n                countMaxContests end_ tail (count + 1)\n            else\n                countMaxContests lastEnd tail count\n\n    countMaxContests Int32.MinValue sortedContests 0", "bug_with_line_numbers": "   1 | open System\n   2 | let maxContests (contests: (int * int) list) =\n   3 |     let sortedContests = List.sortByDescending snd contests\n   4 |     let rec countMaxContests lastEnd remainingContests count =\n   5 |         match remainingContests with\n   6 |         | [] -> count\n   7 |         | (start, end_)::tail ->\n   8 |             if start >= lastEnd then\n   9 |                 countMaxContests end_ tail (count + 1)\n  10 |             else\n  11 |                 countMaxContests lastEnd tail count\n  12 |     countMaxContests Int32.MinValue sortedContests 0", "fragment_lines": [3], "fragment_content": ["let sortedContests = List.sortByDescending snd contests"], "test": "let check () =\n    if maxContests [(1, 3); (2, 5); (4, 6)] <> 2 then\n        failwith \"Test Case 1 failed\"\n    if maxContests [(0, 2); (1, 3); (3, 5)] <> 2 then\n        failwith \"Test Case 2 failed\"\n    if maxContests [(5, 7); (1, 3); (2, 4)] <> 2 then\n        failwith \"Test Case 3 failed\"\n    if maxContests [(1, 4); (2, 5); (6, 8)] <> 2 then\n        failwith \"Test Case 4 failed\"\n    if maxContests [(0, 1); (1, 2); (2, 3)] <> 3 then\n        failwith \"Test Case 5 failed\"\n\ncheck ()"}
{"question_id": "F#/50", "category": "Logic", "subtype": "algorithm_error", "level": "medium", "example": "countWordClasses [\"ABAC\"; \"BAAC\"; \"XYZ\"; \"ZYX\"; \"ABC\"]\n3\ncountWordClasses [\"AAAA\"; \"AAAB\"; \"BAAA\"]\n2", "docstring": "Counts the number of unique classes of words in a list where two words belong \n    to the same class if they consist of the same letters in any order.\n\n    Parameters:\n    words: A list of words consisting of uppercase letters.\n\n    Returns: \n    The number of unique word classes.\n\n", "canonical_solution": "open System\nopen System.Collections.Generic\n\nlet countWordClasses (words: string list) =\n\n\n    let getLetterFrequency word =\n        word \n        |> Seq.groupBy id\n        |> Seq.map (fun (ch, seq) -> ch, Seq.length seq)\n        |> Map.ofSeq\n\n    words\n    |> List.map getLetterFrequency\n    |> Set.ofList\n    |> Set.count", "buggy_code": "open System\nopen System.Collections.Generic\n\nlet countWordClasses (words: string list) =\n\n\n    let getLetterFrequency word =\n        word \n        |> Seq.distinct\n        |> Seq.map (fun (ch, seq) -> ch, Seq.length seq)\n        |> Map.ofSeq\n\n    words\n    |> List.map getLetterFrequency\n    |> Set.ofList\n    |> Set.count", "bug_with_line_numbers": "   1 | open System\n   2 | open System.Collections.Generic\n   3 | let countWordClasses (words: string list) =\n   4 |     let getLetterFrequency word =\n   5 |         word \n   6 |         |> Seq.distinct\n   7 |         |> Seq.map (fun (ch, seq) -> ch, Seq.length seq)\n   8 |         |> Map.ofSeq\n   9 |     words\n  10 |     |> List.map getLetterFrequency\n  11 |     |> Set.ofList\n  12 |     |> Set.count", "fragment_lines": [6], "fragment_content": [""], "test": "let check () =\n    if countWordClasses [\"ABAC\"; \"BAAC\"; \"XYZ\"; \"ZYX\"; \"ABC\"] <> 3 then\n        failwith \"Test Case 1 failed\"\n    if countWordClasses [\"AAAA\"; \"AAAB\"; \"BAAA\"] <> 2 then\n        failwith \"Test Case 2 failed\"\n    if countWordClasses [\"APPLE\"; \"PPALE\"; \"BYTE\"; \"BETY\"] <> 2 then\n        failwith \"Test Case 3 failed\"\n    if countWordClasses [] <> 0 then\n        failwith \"Test Case 4 failed\"\n    if countWordClasses [\"SINGLE\"] <> 1 then\n        failwith \"Test Case 5 failed\"\n\ncheck ()"}
{"question_id": "F#/51", "category": "Reference", "subtype": "function_error", "level": "medium", "example": "countWordClasses [\"ABAC\"; \"BAAC\"; \"XYZ\"; \"ZYX\"; \"ABC\"]\n3\ncountWordClasses [\"AAAA\"; \"AAAB\"; \"BAAA\"]\n2", "docstring": "Counts the number of unique classes of words in a list where two words belong \n    to the same class if they consist of the same letters in any order.\n\n    Parameters:\n    words: A list of words consisting of uppercase letters.\n\n    Returns: \n    The number of unique word classes.\n\n", "canonical_solution": "open System\nopen System.Collections.Generic\n\nlet countWordClasses (words: string list) =\n\n\n    let getLetterFrequency word =\n        word \n        |> Seq.groupBy id\n        |> Seq.map (fun (ch, seq) -> ch, Seq.length seq)\n        |> Map.ofSeq\n\n    words\n    |> List.map getLetterFrequency\n    |> Set.ofList\n    |> Set.count", "buggy_code": "open System\nopen System.Collections.Generic\n\nlet countWordClasses (words: string list) =\n\n\n    let getLetterFrequency word =\n        word \n        |> Seq.groupBy id\n        |> Seq.map (fun (ch, seq) -> ch, Seq.size seq)\n        |> Map.ofSeq\n\n    words\n    |> List.map getLetterFrequency\n    |> Set.ofList\n    |> Set.count", "bug_with_line_numbers": "   1 | open System\n   2 | open System.Collections.Generic\n   3 | let countWordClasses (words: string list) =\n   4 |     let getLetterFrequency word =\n   5 |         word \n   6 |         |> Seq.groupBy id\n   7 |         |> Seq.map (fun (ch, seq) -> ch, Seq.size seq)\n   8 |         |> Map.ofSeq\n   9 |     words\n  10 |     |> List.map getLetterFrequency\n  11 |     |> Set.ofList\n  12 |     |> Set.count", "fragment_lines": [7], "fragment_content": [""], "test": "let check () =\n    if countWordClasses [\"ABAC\"; \"BAAC\"; \"XYZ\"; \"ZYX\"; \"ABC\"] <> 3 then\n        failwith \"Test Case 1 failed\"\n    if countWordClasses [\"AAAA\"; \"AAAB\"; \"BAAA\"] <> 2 then\n        failwith \"Test Case 2 failed\"\n    if countWordClasses [\"APPLE\"; \"PPALE\"; \"BYTE\"; \"BETY\"] <> 2 then\n        failwith \"Test Case 3 failed\"\n    if countWordClasses [] <> 0 then\n        failwith \"Test Case 4 failed\"\n    if countWordClasses [\"SINGLE\"] <> 1 then\n        failwith \"Test Case 5 failed\"\n\ncheck ()"}
{"question_id": "F#/52", "category": "Logic", "subtype": "type_error", "level": "medium", "example": "countWordClasses [\"ABAC\"; \"BAAC\"; \"XYZ\"; \"ZYX\"; \"ABC\"]\n3\ncountWordClasses [\"AAAA\"; \"AAAB\"; \"BAAA\"]\n2", "docstring": "Counts the number of unique classes of words in a list where two words belong \n    to the same class if they consist of the same letters in any order.\n\n    Parameters:\n    words: A list of words consisting of uppercase letters.\n\n    Returns: \n    The number of unique word classes.\n\n", "canonical_solution": "open System\nopen System.Collections.Generic\n\nlet countWordClasses (words: string list) =\n\n\n    let getLetterFrequency word =\n        word \n        |> Seq.groupBy id\n        |> Seq.map (fun (ch, seq) -> ch, Seq.length seq)\n        |> Map.ofSeq\n\n    words\n    |> List.map getLetterFrequency\n    |> Set.ofList\n    |> Set.count", "buggy_code": "open System\nopen System.Collections.Generic\n\nlet countWordClasses (words: string list) =\n\n\n    let getLetterFrequency word =\n        word \n        |> Seq.groupBy id\n        |> Seq.map (fun (ch, seq) -> ch, Seq.length seq)\n        |> Map.ofSeq\n\n    words\n    |> List.map getLetterFrequency\n    |> Set.ofArray\n    |> Set.count", "bug_with_line_numbers": "   1 | open System\n   2 | open System.Collections.Generic\n   3 | let countWordClasses (words: string list) =\n   4 |     let getLetterFrequency word =\n   5 |         word \n   6 |         |> Seq.groupBy id\n   7 |         |> Seq.map (fun (ch, seq) -> ch, Seq.length seq)\n   8 |         |> Map.ofSeq\n   9 |     words\n  10 |     |> List.map getLetterFrequency\n  11 |     |> Set.ofArray\n  12 |     |> Set.count", "fragment_lines": [11], "fragment_content": [""], "test": "let check () =\n    if countWordClasses [\"ABAC\"; \"BAAC\"; \"XYZ\"; \"ZYX\"; \"ABC\"] <> 3 then\n        failwith \"Test Case 1 failed\"\n    if countWordClasses [\"AAAA\"; \"AAAB\"; \"BAAA\"] <> 2 then\n        failwith \"Test Case 2 failed\"\n    if countWordClasses [\"APPLE\"; \"PPALE\"; \"BYTE\"; \"BETY\"] <> 2 then\n        failwith \"Test Case 3 failed\"\n    if countWordClasses [] <> 0 then\n        failwith \"Test Case 4 failed\"\n    if countWordClasses [\"SINGLE\"] <> 1 then\n        failwith \"Test Case 5 failed\"\n\ncheck ()"}
{"question_id": "F#/53", "category": "Logic", "subtype": "algorithm_error", "level": "medium", "example": "maximumMinimumDistance [1; 2; 4; 8; 9] 3\n3\nmaximumMinimumDistance [1; 3; 5; 7; 9; 11] 4\n2", "docstring": "Determines the largest minimum distance between any two cows in a given set of stalls.\n\n    Parameters:\n    stalls - A list of integers representing the coordinates of the stalls.\n    cows - An integer representing the number of cows to be placed in the stalls.\n\n    The function finds the largest minimum distance that can be maintained between any two cows,\n    given the constraints of the stall positions.\n\n", "canonical_solution": "open System\n\nlet maximumMinimumDistance (stalls: int list) (cows: int) : int =\n\n\n    let sortedStalls = List.sort stalls\n\n    let canPlaceCows distance =\n        let rec helper placedCows lastStall remainingStalls =\n            match remainingStalls with\n            | [] -> placedCows >= cows\n            | stall::tail ->\n                if stall - lastStall >= distance then\n                    helper (placedCows + 1) stall tail\n                else\n                    helper placedCows lastStall tail\n\n        helper 1 (List.head sortedStalls) (List.tail sortedStalls)\n\n    let rec binarySearch low high =\n        if low > high then high\n        else\n            let mid = low + (high - low) / 2\n            if canPlaceCows mid then\n                binarySearch (mid + 1) high\n            else\n                binarySearch low (mid - 1)\n\n    binarySearch 0 (List.max sortedStalls)", "buggy_code": "open System\n\nlet maximumMinimumDistance (stalls: int list) (cows: int) : int =\n\n\n    let sortedStalls = List.sort stalls\n\n    let canPlaceCows distance =\n        let rec helper placedCows lastStall remainingStalls =\n            match remainingStalls with\n            | [] -> placedCows >= cows\n            | stall::tail ->\n                if stall - lastStall >= distance then\n                    helper placedCows stall tail\n                else\n                    helper placedCows lastStall tail\n\n        helper 1 (List.head sortedStalls) (List.tail sortedStalls)\n\n    let rec binarySearch low high =\n        if low > high then high\n        else\n            let mid = low + (high - low) / 2\n            if canPlaceCows mid then\n                binarySearch (mid + 1) high\n            else\n                binarySearch low (mid - 1)\n\n    binarySearch 0 (List.max sortedStalls)", "bug_with_line_numbers": "   1 | open System\n   2 | let maximumMinimumDistance (stalls: int list) (cows: int) : int =\n   3 |     let sortedStalls = List.sort stalls\n   4 |     let canPlaceCows distance =\n   5 |         let rec helper placedCows lastStall remainingStalls =\n   6 |             match remainingStalls with\n   7 |             | [] -> placedCows >= cows\n   8 |             | stall::tail ->\n   9 |                 if stall - lastStall >= distance then\n  10 |                     helper placedCows stall tail\n  11 |                 else\n  12 |                     helper placedCows lastStall tail\n  13 |         helper 1 (List.head sortedStalls) (List.tail sortedStalls)\n  14 |     let rec binarySearch low high =\n  15 |         if low > high then high\n  16 |         else\n  17 |             let mid = low + (high - low) / 2\n  18 |             if canPlaceCows mid then\n  19 |                 binarySearch (mid + 1) high\n  20 |             else\n  21 |                 binarySearch low (mid - 1)\n  22 |     binarySearch 0 (List.max sortedStalls)", "fragment_lines": [10], "fragment_content": ["helper placedCows stall tail"], "test": "let check () =\n    if maximumMinimumDistance [1; 2; 4; 8; 9] 3 <> 3 then\n        failwith \"Test Case 1 failed\"\n    if maximumMinimumDistance [1; 3; 5; 7; 9; 11] 4 <> 2 then\n        failwith \"Test Case 2 failed\"\n    if maximumMinimumDistance [1; 2; 3; 4; 5; 6; 7; 8; 9; 10] 5 <> 2 then\n        failwith \"Test Case 3 failed\"\n    if maximumMinimumDistance [10; 20; 30; 40; 50] 2 <> 40 then\n        failwith \"Test Case 4 failed\"\n    if maximumMinimumDistance [5; 15; 25; 35; 45; 55; 65; 75; 85; 95] 3 <> 40 then\n        failwith \"Test Case 5 failed\"\n\ncheck ()"}
{"question_id": "F#/54", "category": "Logic", "subtype": "condition_error", "level": "medium", "example": "maximumMinimumDistance [1; 2; 4; 8; 9] 3\n3\nmaximumMinimumDistance [1; 3; 5; 7; 9; 11] 4\n2", "docstring": "Determines the largest minimum distance between any two cows in a given set of stalls.\n\n    Parameters:\n    stalls - A list of integers representing the coordinates of the stalls.\n    cows - An integer representing the number of cows to be placed in the stalls.\n\n    The function finds the largest minimum distance that can be maintained between any two cows,\n    given the constraints of the stall positions.\n\n", "canonical_solution": "open System\n\nlet maximumMinimumDistance (stalls: int list) (cows: int) : int =\n\n\n    let sortedStalls = List.sort stalls\n\n    let canPlaceCows distance =\n        let rec helper placedCows lastStall remainingStalls =\n            match remainingStalls with\n            | [] -> placedCows >= cows\n            | stall::tail ->\n                if stall - lastStall >= distance then\n                    helper (placedCows + 1) stall tail\n                else\n                    helper placedCows lastStall tail\n\n        helper 1 (List.head sortedStalls) (List.tail sortedStalls)\n\n    let rec binarySearch low high =\n        if low > high then high\n        else\n            let mid = low + (high - low) / 2\n            if canPlaceCows mid then\n                binarySearch (mid + 1) high\n            else\n                binarySearch low (mid - 1)\n\n    binarySearch 0 (List.max sortedStalls)", "buggy_code": "open System\n\nlet maximumMinimumDistance (stalls: int list) (cows: int) : int =\n\n\n    let sortedStalls = List.sort stalls\n\n    let canPlaceCows distance =\n        let rec helper placedCows lastStall remainingStalls =\n            match remainingStalls with\n            | [] -> placedCows >= cows\n            | stall::tail ->\n                if stall - lastStall > distance then\n                    helper (placedCows + 1) stall tail\n                else\n                    helper placedCows lastStall tail\n\n        helper 1 (List.head sortedStalls) (List.tail sortedStalls)\n\n    let rec binarySearch low high =\n        if low > high then high\n        else\n            let mid = low + (high - low) / 2\n            if canPlaceCows mid then\n                binarySearch (mid + 1) high\n            else\n                binarySearch low (mid - 1)\n\n    binarySearch 0 (List.max sortedStalls)", "bug_with_line_numbers": "   1 | open System\n   2 | let maximumMinimumDistance (stalls: int list) (cows: int) : int =\n   3 |     let sortedStalls = List.sort stalls\n   4 |     let canPlaceCows distance =\n   5 |         let rec helper placedCows lastStall remainingStalls =\n   6 |             match remainingStalls with\n   7 |             | [] -> placedCows >= cows\n   8 |             | stall::tail ->\n   9 |                 if stall - lastStall > distance then\n  10 |                     helper (placedCows + 1) stall tail\n  11 |                 else\n  12 |                     helper placedCows lastStall tail\n  13 |         helper 1 (List.head sortedStalls) (List.tail sortedStalls)\n  14 |     let rec binarySearch low high =\n  15 |         if low > high then high\n  16 |         else\n  17 |             let mid = low + (high - low) / 2\n  18 |             if canPlaceCows mid then\n  19 |                 binarySearch (mid + 1) high\n  20 |             else\n  21 |                 binarySearch low (mid - 1)\n  22 |     binarySearch 0 (List.max sortedStalls)", "fragment_lines": [9], "fragment_content": ["if stall - lastStall > distance then"], "test": "let check () =\n    if maximumMinimumDistance [1; 2; 4; 8; 9] 3 <> 3 then\n        failwith \"Test Case 1 failed\"\n    if maximumMinimumDistance [1; 3; 5; 7; 9; 11] 4 <> 2 then\n        failwith \"Test Case 2 failed\"\n    if maximumMinimumDistance [1; 2; 3; 4; 5; 6; 7; 8; 9; 10] 5 <> 2 then\n        failwith \"Test Case 3 failed\"\n    if maximumMinimumDistance [10; 20; 30; 40; 50] 2 <> 40 then\n        failwith \"Test Case 4 failed\"\n    if maximumMinimumDistance [5; 15; 25; 35; 45; 55; 65; 75; 85; 95] 3 <> 40 then\n        failwith \"Test Case 5 failed\"\n\ncheck ()"}
{"question_id": "F#/55", "category": "Multiple", "subtype": "double_bug", "level": "medium", "example": "maximumMinimumDistance [1; 2; 4; 8; 9] 3\n3\nmaximumMinimumDistance [1; 3; 5; 7; 9; 11] 4\n2", "docstring": "Determines the largest minimum distance between any two cows in a given set of stalls.\n\n    Parameters:\n    stalls - A list of integers representing the coordinates of the stalls.\n    cows - An integer representing the number of cows to be placed in the stalls.\n\n    The function finds the largest minimum distance that can be maintained between any two cows,\n    given the constraints of the stall positions.\n\n", "canonical_solution": "open System\n\nlet maximumMinimumDistance (stalls: int list) (cows: int) : int =\n\n\n    let sortedStalls = List.sort stalls\n\n    let canPlaceCows distance =\n        let rec helper placedCows lastStall remainingStalls =\n            match remainingStalls with\n            | [] -> placedCows >= cows\n            | stall::tail ->\n                if stall - lastStall >= distance then\n                    helper (placedCows + 1) stall tail\n                else\n                    helper placedCows lastStall tail\n\n        helper 1 (List.head sortedStalls) (List.tail sortedStalls)\n\n    let rec binarySearch low high =\n        if low > high then high\n        else\n            let mid = low + (high - low) / 2\n            if canPlaceCows mid then\n                binarySearch (mid + 1) high\n            else\n                binarySearch low (mid - 1)\n\n    binarySearch 0 (List.max sortedStalls)", "buggy_code": "open System\n\nlet maximumMinimumDistance (stalls: int list) (cows: int) : int =\n\n\n    let sortedStalls = List.sort stalls\n\n    let canPlaceCows distance =\n        let rec helper placedCows lastStall remainingStalls =\n            match remainingStalls with\n            | [] -> placedCows >= cows\n            | stall::tail ->\n                if stall - lastStall < distance then\n                    helper (placedCows + 1) stall tail\n                else\n                    helper placedCows lastStall tail\n\n        helper 1 (List.tail sortedStalls) (List.head sortedStalls)\n\n    let rec binarySearch low high =\n        if low > high then high\n        else\n            let mid = low + (high - low) / 2\n            if canPlaceCows mid then\n                binarySearch (mid + 1) high\n            else\n                binarySearch low (mid - 1)\n\n    binarySearch 0 (List.max sortedStalls)", "bug_with_line_numbers": "   1 | open System\n   2 | let maximumMinimumDistance (stalls: int list) (cows: int) : int =\n   3 |     let sortedStalls = List.sort stalls\n   4 |     let canPlaceCows distance =\n   5 |         let rec helper placedCows lastStall remainingStalls =\n   6 |             match remainingStalls with\n   7 |             | [] -> placedCows >= cows\n   8 |             | stall::tail ->\n   9 |                 if stall - lastStall < distance then\n  10 |                     helper (placedCows + 1) stall tail\n  11 |                 else\n  12 |                     helper placedCows lastStall tail\n  13 |         helper 1 (List.tail sortedStalls) (List.head sortedStalls)\n  14 |     let rec binarySearch low high =\n  15 |         if low > high then high\n  16 |         else\n  17 |             let mid = low + (high - low) / 2\n  18 |             if canPlaceCows mid then\n  19 |                 binarySearch (mid + 1) high\n  20 |             else\n  21 |                 binarySearch low (mid - 1)\n  22 |     binarySearch 0 (List.max sortedStalls)", "fragment_lines": [9, 13], "fragment_content": ["if stall - lastStall < distance then", "helper 1 (List.tail sortedStalls) (List.head sortedStalls)"], "test": "let check () =\n    if maximumMinimumDistance [1; 2; 4; 8; 9] 3 <> 3 then\n        failwith \"Test Case 1 failed\"\n    if maximumMinimumDistance [1; 3; 5; 7; 9; 11] 4 <> 2 then\n        failwith \"Test Case 2 failed\"\n    if maximumMinimumDistance [1; 2; 3; 4; 5; 6; 7; 8; 9; 10] 5 <> 2 then\n        failwith \"Test Case 3 failed\"\n    if maximumMinimumDistance [10; 20; 30; 40; 50] 2 <> 40 then\n        failwith \"Test Case 4 failed\"\n    if maximumMinimumDistance [5; 15; 25; 35; 45; 55; 65; 75; 85; 95] 3 <> 40 then\n        failwith \"Test Case 5 failed\"\n\ncheck ()"}
{"question_id": "F#/56", "category": "Syntax", "subtype": "unclosed_parentheses", "level": "medium", "example": "findLuckyNumbers([[3, 7, 8], [9, 11, 13], [15, 16, 17]])\n[15]\nfindLuckyNumbers([[1, 10, 4, 2], [9, 3, 8, 7], [15, 16, 17, 12]])\n[12]", "docstring": "Finds all lucky numbers in an m x n matrix. A lucky number is the smallest in its row and the largest in its column.\n", "canonical_solution": "open System\n\nlet findLuckyNumbers (matrix: int list list) =\n    \n\n    let rowMins = matrix |> List.map List.min\n    let colMaxs = \n        [for colIdx in 0 .. (List.head matrix |> List.length) - 1 do\n            yield matrix |> List.map (fun row -> row.[colIdx]) |> List.max]\n\n    [for rowIdx in 0 .. matrix.Length - 1 do\n        for colIdx in 0 .. (matrix.[rowIdx] |> List.length) - 1 do\n            let value = matrix.[rowIdx].[colIdx]\n            if value = rowMins.[rowIdx] && value = colMaxs.[colIdx] then\n                yield value]", "buggy_code": "open System\n\nlet findLuckyNumbers (matrix: int list list) =\n    \n\n    let rowMins = matrix |> List.map List.min\n    let colMaxs = \n        [for colIdx in 0 .. (List.head matrix |> List.length) - 1 do\n            yield matrix |> List.map List.max\n\n    [for rowIdx in 0 .. matrix.Length - 1 do\n        for colIdx in 0 .. (matrix.[rowIdx] |> List.length) - 1 do\n            let value = matrix.[rowIdx].[colIdx]\n            if value = rowMins.[rowIdx] && value = colMaxs.[colIdx] then\n                yield value]", "bug_with_line_numbers": "   1 | open System\n   2 | let findLuckyNumbers (matrix: int list list) =\n   3 |     let rowMins = matrix |> List.map List.min\n   4 |     let colMaxs = \n   5 |         [for colIdx in 0 .. (List.head matrix |> List.length) - 1 do\n   6 |             yield matrix |> List.map List.max\n   7 |     [for rowIdx in 0 .. matrix.Length - 1 do\n   8 |         for colIdx in 0 .. (matrix.[rowIdx] |> List.length) - 1 do\n   9 |             let value = matrix.[rowIdx].[colIdx]\n  10 |             if value = rowMins.[rowIdx] && value = colMaxs.[colIdx] then\n  11 |                 yield value]", "fragment_lines": [6], "fragment_content": ["yield matrix"], "test": "let check () =\n    if findLuckyNumbers [[3; 7; 8]; [9; 11; 13]; [15; 16; 17]] <> [15] then\n        failwith \"Test Case 1 failed\"\n    if findLuckyNumbers [[1; 10; 4; 2]; [9; 3; 8; 7]; [15; 16; 17; 12]] <> [12] then\n        failwith \"Test Case 2 failed\"\n    if findLuckyNumbers [[1; 2; 3]; [4; 5; 6]; [7; 8; 9]] <> [7] then\n        failwith \"Test Case 3 failed\"\n    if findLuckyNumbers [[7; 8]; [1; 6]] <> [7] then\n        failwith \"Test Case 4 failed\"\n    if findLuckyNumbers [[11; 17; 4; 3]; [9; 5; 8; 7]; [15; 2; 16; 12]] <> [] then\n        failwith \"Test Case 5 failed\"\n\ncheck ()"}
{"question_id": "F#/57", "category": "Logic", "subtype": "algorithm_error", "level": "medium", "example": "createTargetArray([0, 1, 2, 3, 4], [0, 1, 2, 2, 1])\n[0, 4, 1, 3, 2]\ncreateTargetArray([1, 2, 3, 4, 0], [0, 1, 2, 3, 0])\n[0, 1, 2, 3, 4]", "docstring": "Creates a target array based on arrays `nums` and `index`. Elements from `nums` are inserted into the target array at positions specified by `index`.\n", "canonical_solution": "open System\n\nlet createTargetArray (nums: int list) (index: int list) =\n    \n\n    let rec insertAt idx x lst =\n        match idx, lst with\n        | _, [] -> [x]  //  x \n        | 0, _ -> x :: lst\n        | i, h :: t when i = List.length lst -> lst @ [x]  // \n        | _, h :: t -> h :: (insertAt (idx - 1) x t)\n\n    let target = List.fold2 (fun acc n i -> insertAt i n acc) [] nums index\n    target", "buggy_code": "open System\n\nlet createTargetArray (nums: int list) (index: int list) =\n    \n\n    let rec insertAt idx x lst =\n        match idx, lst with\n        | _, [] -> [x]  //  x \n        | 0, _ -> x :: lst\n        | i, h :: t when i = List.length lst -> [x] @ lst  // \n        | _, h :: t -> h :: (insertAt (idx - 1) x t)\n\n    let target = List.fold2 (fun acc n i -> insertAt i n acc) [] nums index\n    target", "bug_with_line_numbers": "   1 | open System\n   2 | let createTargetArray (nums: int list) (index: int list) =\n   3 |     let rec insertAt idx x lst =\n   4 |         match idx, lst with\n   5 |         | _, [] -> [x]  //  x \n   6 |         | 0, _ -> x :: lst\n   7 |         | i, h :: t when i = List.length lst -> [x] @ lst  // \n   8 |         | _, h :: t -> h :: (insertAt (idx - 1) x t)\n   9 |     let target = List.fold2 (fun acc n i -> insertAt i n acc) [] nums index\n  10 |     target", "fragment_lines": [7], "fragment_content": [""], "test": "let check () =\n    if createTargetArray [0; 1; 2; 3; 4] [0; 1; 2; 2; 1] <> [0; 4; 1; 3; 2] then\n        failwith \"Test Case 1 failed\"\n    if createTargetArray [1; 2; 3; 4; 0] [0; 1; 2; 3; 0] <> [0; 1; 2; 3; 4] then\n        failwith \"Test Case 2 failed\"\n    if createTargetArray [4; 3; 2; 1; 0] [0; 0; 0; 0; 0] <> [0; 1; 2; 3; 4] then\n        failwith \"Test Case 3 failed\"\n\ncheck ()"}
{"question_id": "F#/58", "category": "Multiple", "subtype": "double_bug", "level": "medium", "example": "createTargetArray([0, 1, 2, 3, 4], [0, 1, 2, 2, 1])\n[0, 4, 1, 3, 2]\ncreateTargetArray([1, 2, 3, 4, 0], [0, 1, 2, 3, 0])\n[0, 1, 2, 3, 4]", "docstring": "Creates a target array based on arrays `nums` and `index`. Elements from `nums` are inserted into the target array at positions specified by `index`.\n", "canonical_solution": "open System\n\nlet createTargetArray (nums: int list) (index: int list) =\n    \n\n    let rec insertAt idx x lst =\n        match idx, lst with\n        | _, [] -> [x]  //  x \n        | 0, _ -> x :: lst\n        | i, h :: t when i = List.length lst -> lst @ [x]  // \n        | _, h :: t -> h :: (insertAt (idx - 1) x t)\n\n    let target = List.fold2 (fun acc n i -> insertAt i n acc) [] nums index\n    target", "buggy_code": "open System\n\nlet createTargetArray (nums: int list index: int list) =\n    \n\n    let rec insertAt idx x lst =\n        match idx, lst with\n        | _, [] -> [x]  //  x \n        | 0, _ -> x :: lst\n        | i, h :: t when i = List.length lst -> lst @ [x]  // \n        | _, h :: t -> (insertAt (idx - 1) x t)\n\n    let target = List.fold2 (fun acc n i -> insertAt i n acc) [] nums index\n    target", "bug_with_line_numbers": "   1 | open System\n   2 | let createTargetArray (nums: int list index: int list) =\n   3 |     let rec insertAt idx x lst =\n   4 |         match idx, lst with\n   5 |         | _, [] -> [x]  //  x \n   6 |         | 0, _ -> x :: lst\n   7 |         | i, h :: t when i = List.length lst -> lst @ [x]  // \n   8 |         | _, h :: t -> (insertAt (idx - 1) x t)\n   9 |     let target = List.fold2 (fun acc n i -> insertAt i n acc) [] nums index\n  10 |     target", "fragment_lines": [2, 8], "fragment_content": ["let createTargetArray (nums: int list index: int list) =", ""], "test": "let check () =\n    if createTargetArray [0; 1; 2; 3; 4] [0; 1; 2; 2; 1] <> [0; 4; 1; 3; 2] then\n        failwith \"Test Case 1 failed\"\n    if createTargetArray [1; 2; 3; 4; 0] [0; 1; 2; 3; 0] <> [0; 1; 2; 3; 4] then\n        failwith \"Test Case 2 failed\"\n    if createTargetArray [4; 3; 2; 1; 0] [0; 0; 0; 0; 0] <> [0; 1; 2; 3; 4] then\n        failwith \"Test Case 3 failed\"\n\ncheck ()"}
{"question_id": "F#/59", "category": "Logic", "subtype": "type_error", "level": "medium", "example": "createTargetArray([0, 1, 2, 3, 4], [0, 1, 2, 2, 1])\n[0, 4, 1, 3, 2]\ncreateTargetArray([1, 2, 3, 4, 0], [0, 1, 2, 3, 0])\n[0, 1, 2, 3, 4]", "docstring": "Creates a target array based on arrays `nums` and `index`. Elements from `nums` are inserted into the target array at positions specified by `index`.\n", "canonical_solution": "open System\n\nlet createTargetArray (nums: int list) (index: int list) =\n    \n\n    let rec insertAt idx x lst =\n        match idx, lst with\n        | _, [] -> [x]  //  x \n        | 0, _ -> x :: lst\n        | i, h :: t when i = List.length lst -> lst @ [x]  // \n        | _, h :: t -> h :: (insertAt (idx - 1) x t)\n\n    let target = List.fold2 (fun acc n i -> insertAt i n acc) [] nums index\n    target", "buggy_code": "open System\n\nlet createTargetArray (nums: int list) (index: int list) =\n    \n\n    let rec insertAt idx x lst =\n        match idx, lst with\n        | _, [] -> x  //  x \n        | 0, _ -> x :: lst\n        | i, h :: t when i = List.length lst -> lst @ [x]  // \n        | _, h :: t -> h :: (insertAt (idx - 1) x t)\n\n    let target = List.fold2 (fun acc n i -> insertAt i n acc) [] nums index\n    target", "bug_with_line_numbers": "   1 | open System\n   2 | let createTargetArray (nums: int list) (index: int list) =\n   3 |     let rec insertAt idx x lst =\n   4 |         match idx, lst with\n   5 |         | _, [] -> x  //  x \n   6 |         | 0, _ -> x :: lst\n   7 |         | i, h :: t when i = List.length lst -> lst @ [x]  // \n   8 |         | _, h :: t -> h :: (insertAt (idx - 1) x t)\n   9 |     let target = List.fold2 (fun acc n i -> insertAt i n acc) [] nums index\n  10 |     target", "fragment_lines": [5], "fragment_content": [""], "test": "let check () =\n    if createTargetArray [0; 1; 2; 3; 4] [0; 1; 2; 2; 1] <> [0; 4; 1; 3; 2] then\n        failwith \"Test Case 1 failed\"\n    if createTargetArray [1; 2; 3; 4; 0] [0; 1; 2; 3; 0] <> [0; 1; 2; 3; 4] then\n        failwith \"Test Case 2 failed\"\n    if createTargetArray [4; 3; 2; 1; 0] [0; 0; 0; 0; 0] <> [0; 1; 2; 3; 4] then\n        failwith \"Test Case 3 failed\"\n\ncheck ()"}
{"question_id": "F#/60", "category": "Logic", "subtype": "algorithm_error", "level": "hard", "example": "countGoodTriplets([3, 0, 1, 1, 9, 7], 7, 2, 3)\n4\ncountGoodTriplets([1, 1, 2, 2, 3], 0, 0, 1)\n0", "docstring": "Counts the number of good triplets in the array `arr`.\n    A good triplet (arr[i], arr[j], arr[k]) satisfies certain conditions based on the absolute differences and indices.\n", "canonical_solution": "open System\n\nlet countGoodTriplets (arr: int list) (a: int) (b: int) (c: int) =\n    \n\n    let isGoodTriplet i j k =\n        abs (arr.[i] - arr.[j]) <= a &&\n        abs (arr.[j] - arr.[k]) <= b &&\n        abs (arr.[i] - arr.[k]) <= c\n\n    let rec countTriplets i j k count =\n        match i, j, k with\n        | _, _, _ when i >= List.length arr - 2 -> count\n        | _, _, _ when j >= List.length arr - 1 -> countTriplets (i + 1) (i + 2) (i + 3) count\n        | _, _, _ when k >= List.length arr -> countTriplets i (j + 1) (j + 2) count\n        | _, _, _ ->\n            let newCount = if isGoodTriplet i j k then count + 1 else count\n            countTriplets i j (k + 1) newCount\n\n    countTriplets 0 1 2 0", "buggy_code": "open System\n\nlet countGoodTriplets (arr: int list) (a: int) (b: int) (c: int) =\n    \n\n    let isGoodTriplet i j k =\n        abs (arr.[i] - arr.[j]) <= a &&\n        abs (arr.[j] - arr.[k]) <= b &&\n        abs (arr.[i] - arr.[k]) <= c\n\n    let rec countTriplets i j k count =\n        match i, j, k with\n        | _, _, _ when i >= List.length arr - 2 -> count\n        | _, _, _ when j >= List.length arr - 1 -> countTriplets (i + 1) (j) (k) count\n        | _, _, _ when k >= List.length arr -> countTriplets i (j + 1) (j + 2) count\n        | _, _, _ ->\n            let newCount = if isGoodTriplet i j k then count + 1 else count\n            countTriplets i j (k + 1) newCount\n\n    countTriplets 0 1 2 0", "bug_with_line_numbers": "   1 | open System\n   2 | let countGoodTriplets (arr: int list) (a: int) (b: int) (c: int) =\n   3 |     let isGoodTriplet i j k =\n   4 |         abs (arr.[i] - arr.[j]) <= a &&\n   5 |         abs (arr.[j] - arr.[k]) <= b &&\n   6 |         abs (arr.[i] - arr.[k]) <= c\n   7 |     let rec countTriplets i j k count =\n   8 |         match i, j, k with\n   9 |         | _, _, _ when i >= List.length arr - 2 -> count\n  10 |         | _, _, _ when j >= List.length arr - 1 -> countTriplets (i + 1) (j) (k) count\n  11 |         | _, _, _ when k >= List.length arr -> countTriplets i (j + 1) (j + 2) count\n  12 |         | _, _, _ ->\n  13 |             let newCount = if isGoodTriplet i j k then count + 1 else count\n  14 |             countTriplets i j (k + 1) newCount\n  15 |     countTriplets 0 1 2 0", "fragment_lines": [10], "fragment_content": [""], "test": "let check () =\n    if countGoodTriplets [3; 0; 1; 1; 9; 7] 7 2 3 <> 4 then\n        failwith \"Test Case 1 failed\"\n    if countGoodTriplets [1; 1; 2; 2; 3] 0 0 1 <> 0 then\n        failwith \"Test Case 2 failed\"\n    if countGoodTriplets [1; 2; 3; 4; 5] 1 1 1 <> 0 then\n        failwith \"Test Case 3 failed\"\n\ncheck ()"}
{"question_id": "F#/61", "category": "Special", "subtype": "Misused match", "level": "medium", "example": "    >>> countGoodTriplets([3, 0, 1, 1, 9, 7], 7, 2, 3)\n    4\n    >>> countGoodTriplets([1, 1, 2, 2, 3], 0, 0, 1)\n    0\n    ", "docstring": "\n    Counts the number of good triplets in the array `arr`.\n    A good triplet (arr[i], arr[j], arr[k]) satisfies certain conditions based on the absolute differences and indices.\n    ", "canonical_solution": "open System\n\nlet countGoodTriplets (arr: int list) (a: int) (b: int) (c: int) =\n    (*\n    Counts the number of good triplets in the array `arr`.\n    A good triplet (arr[i], arr[j], arr[k]) satisfies certain conditions based on the absolute differences and indices.\n    >>> countGoodTriplets([3, 0, 1, 1, 9, 7], 7, 2, 3)\n    4\n    >>> countGoodTriplets([1, 1, 2, 2, 3], 0, 0, 1)\n    0\n    *)\n\n    let isGoodTriplet i j k =\n        abs (arr.[i] - arr.[j]) <= a &&\n        abs (arr.[j] - arr.[k]) <= b &&\n        abs (arr.[i] - arr.[k]) <= c\n\n    let rec countTriplets i j k count =\n        match i, j, k with\n        | _, _, _ when i >= List.length arr - 2 -> count\n        | _, _, _ when j >= List.length arr - 1 -> countTriplets (i + 1) (i + 2) (i + 3) count\n        | _, _, _ when k >= List.length arr -> countTriplets i (j + 1) (j + 2) count\n        | _, _, _ ->\n            let newCount = if isGoodTriplet i j k then count + 1 else count\n            countTriplets i j (k + 1) newCount\n\n    countTriplets 0 1 2 0", "buggy_code": "open System\n\nlet countGoodTriplets (arr: int list) (a: int) (b: int) (c: int) =\n    (*\n    Counts the number of good triplets in the array `arr`.\n    A good triplet (arr[i], arr[j], arr[k]) satisfies certain conditions based on the absolute differences and indices.\n    >>> countGoodTriplets([3, 0, 1, 1, 9, 7], 7, 2, 3)\n    4\n    >>> countGoodTriplets([1, 1, 2, 2, 3], 0, 0, 1)\n    0\n    *)\n\n    let isGoodTriplet i j k =\n        abs (arr.[i] - arr.[j]) <= a &&\n        abs (arr.[j] - arr.[k]) <= b &&\n        abs (arr.[i] - arr.[k]) <= c\n\n    let rec countTriplets i j k count =\n        match i, j, k with\n        | _, _, _ when i >= List.length arr - 2 -> count\n        | _, _, _ when j >= List.length arr - 1 -> countTriplets (i + 1) (i + 2) (i + 3) count\n        | _, _, _ when k >= List.length arr -> countTriplets i (j + 1) (j + 2) count\n\n    countTriplets 0 1 2 0", "bug_with_line_numbers": "   1 | open System\n   2 | let countGoodTriplets (arr: int list) (a: int) (b: int) (c: int) =\n   3 |     (*\n   4 |     Counts the number of good triplets in the array `arr`.\n   5 |     A good triplet (arr[i], arr[j], arr[k]) satisfies certain conditions based on the absolute differences and indices.\n   6 |     >>> countGoodTriplets([3, 0, 1, 1, 9, 7], 7, 2, 3)\n   7 |     4\n   8 |     >>> countGoodTriplets([1, 1, 2, 2, 3], 0, 0, 1)\n   9 |     0\n  10 |     *)\n  11 |     let isGoodTriplet i j k =\n  12 |         abs (arr.[i] - arr.[j]) <= a &&\n  13 |         abs (arr.[j] - arr.[k]) <= b &&\n  14 |         abs (arr.[i] - arr.[k]) <= c\n  15 |     let rec countTriplets i j k count =\n  16 |         match i, j, k with\n  17 |         | _, _, _ when i >= List.length arr - 2 -> count\n  18 |         | _, _, _ when j >= List.length arr - 1 -> countTriplets (i + 1) (i + 2) (i + 3) count\n  19 |         | _, _, _ when k >= List.length arr -> countTriplets i (j + 1) (j + 2) count\n  20 |     countTriplets 0 1 2 0", "fragment_lines": [-1], "fragment_content": ["missing critical code snippet"], "test": "let test () =\n    if countGoodTriplets [3; 0; 1; 1; 9; 7] 7 2 3 <> 4 then\n        failwith \"Test Case 1 failed\"\n    if countGoodTriplets [1; 1; 2; 2; 3] 0 0 1 <> 0 then\n        failwith \"Test Case 2 failed\"\n    if countGoodTriplets [1; 2; 3; 4; 5] 1 1 1 <> 0 then\n        failwith \"Test Case 3 failed\"\n\ntest ()"}
{"question_id": "F#/62", "category": "Special", "subtype": "Misused match", "level": "easy", "example": "\n\n    Examples:\n    - calculateBessieScore 6\n      Returns: 8 (Sequence: 6 -> 3 -> 10 -> 5 -> 16 -> 8 -> 4 -> 2 -> 1)\n    - calculateBessieScore 1\n      Returns: 0 (Sequence: 1)", "docstring": "This function calculates the score of a game where the score increases with each transformation of the number N.\n    The rules are:\n    - If N is odd, multiply it by 3 and add 1.\n    - If N is even, divide it by 2.\n    The game ends when N becomes 1, and the score is the number of transformations made.", "canonical_solution": "open System\nlet rec calculateBessieScore (n: int) : int =\n(*\n    This function calculates the score of a game where the score increases with each transformation of the number N.\n    The rules are:\n    - If N is odd, multiply it by 3 and add 1.\n    - If N is even, divide it by 2.\n    The game ends when N becomes 1, and the score is the number of transformations made.\n\n    Examples:\n    - calculateBessieScore 6\n      Returns: 8 (Sequence: 6 -> 3 -> 10 -> 5 -> 16 -> 8 -> 4 -> 2 -> 1)\n    - calculateBessieScore 1\n      Returns: 0 (Sequence: 1)\n*)\n\n    match n with\n    | 1 -> 0\n    | _ when n % 2 = 0 -> 1 + calculateBessieScore (n / 2)\n    | _ -> 1 + calculateBessieScore (3 * n + 1)", "buggy_code": "open System\nlet rec calculateBessieScore (n: int) : int =\n(*\n    This function calculates the score of a game where the score increases with each transformation of the number N.\n    The rules are:\n    - If N is odd, multiply it by 3 and add 1.\n    - If N is even, divide it by 2.\n    The game ends when N becomes 1, and the score is the number of transformations made.\n\n    Examples:\n    - calculateBessieScore 6\n      Returns: 8 (Sequence: 6 -> 3 -> 10 -> 5 -> 16 -> 8 -> 4 -> 2 -> 1)\n    - calculateBessieScore 1\n      Returns: 0 (Sequence: 1)\n*)\n\n    match n with\n    | 1 -> 0\n    | _ when n % 2 = 0 -> 1 + calculateBessieScore (n / 2)", "bug_with_line_numbers": "   1 | open System\n   2 | let rec calculateBessieScore (n: int) : int =\n   3 | (*\n   4 |     This function calculates the score of a game where the score increases with each transformation of the number N.\n   5 |     The rules are:\n   6 |     - If N is odd, multiply it by 3 and add 1.\n   7 |     - If N is even, divide it by 2.\n   8 |     The game ends when N becomes 1, and the score is the number of transformations made.\n   9 |     Examples:\n  10 |     - calculateBessieScore 6\n  11 |       Returns: 8 (Sequence: 6 -> 3 -> 10 -> 5 -> 16 -> 8 -> 4 -> 2 -> 1)\n  12 |     - calculateBessieScore 1\n  13 |       Returns: 0 (Sequence: 1)\n  14 | *)\n  15 |     match n with\n  16 |     | 1 -> 0\n  17 |     | _ when n % 2 = 0 -> 1 + calculateBessieScore (n / 2)", "fragment_lines": [-1], "fragment_content": ["missing critical code snippet"], "test": "let test () =\n    if calculateBessieScore 6 <> 8 then\n        failwith \"Test Case 1 failed\"\n    if calculateBessieScore 1 <> 0 then\n        failwith \"Test Case 2 failed\"\n    if calculateBessieScore 7 <> 16 then\n        failwith \"Test Case 3 failed\"\n    if calculateBessieScore 15 <> 17 then\n        failwith \"Test Case 4 failed\"\n    if calculateBessieScore 22 <> 15 then\n        failwith \"Test Case 5 failed\"\n    if calculateBessieScore 2 <> 1 then\n        failwith \"Test Case 6 failed\"\n    if calculateBessieScore 10 <> 6 then\n        failwith \"Test Case 7 failed\"\n\ntest ()"}
{"question_id": "F#/63", "category": "Special", "subtype": "Misused match", "level": "easy", "example": "\n    Example:\n    >>> findFourthVertex [(5, 5); (5, 7); (7, 5)]\n    (7, 7)\n    \n    >>> findFourthVertex [(10, 20);(30, 10); (10, 10)]\n    (30, 20)\n", "docstring": "\n\n   Given the coordinates of three vertices of a rectangle, this function computes \n    the coordinates of the fourth vertex. The rectangle is assumed to have sides \n    parallel to the coordinate axes.\n", "canonical_solution": "open System\n\nlet findFourthVertex (coordinates: (int * int) list) : int * int =\n(*\n    Given the coordinates of three vertices of a rectangle, this function computes \n    the coordinates of the fourth vertex. The rectangle is assumed to have sides \n    parallel to the coordinate axes.\n    \n    Example:\n    >>> findFourthVertex [(5, 5); (5, 7); (7, 5)]\n    (7, 7)\n    \n    >>> findFourthVertex [(10, 20);(30, 10); (10, 10)]\n    (30, 20)\n*)\n\n    let (xList, yList) = List.unzip coordinates\n    let findFourthCoordinate (coordList: int list) =\n        match List.distinct coordList with\n        | [a; b] -> if List.filter ((=) a) coordList |> List.length = 1 then a else b\n        | _ -> failwith \"Invalid input\"\n\n    let fourthX = findFourthCoordinate xList\n    let fourthY = findFourthCoordinate yList\n    (fourthX, fourthY)", "buggy_code": "open System\n\nlet findFourthVertex (coordinates: (int * int) list) : int * int =\n    let (xList, yList) = List.unzip coordinates\n    let findFourthCoordinate (coordList: int list) =\n        match List.distinct coordList with\n        | [a; b] -> if List.filter ((=) a) coordList |> List.length = 1 then a else b\n\n    let fourthX = findFourthCoordinate xList\n    let fourthY = findFourthCoordinate yList\n    (fourthX, fourthY)", "bug_with_line_numbers": "   1 | open System\n   2 | let findFourthVertex (coordinates: (int * int) list) : int * int =\n   3 |     let (xList, yList) = List.unzip coordinates\n   4 |     let findFourthCoordinate (coordList: int list) =\n   5 |         match List.distinct coordList with\n   6 |         | [a; b] -> if List.filter ((=) a) coordList |> List.length = 1 then b else a\n   7 |     let fourthX = findFourthCoordinate xList\n   8 |     let fourthY = findFourthCoordinate yList\n   9 |     (fourthX, fourthY)", "fragment_lines": [-1], "fragment_content": ["missing critical code snippet"], "test": "let check () =\n    if findFourthVertex [(5, 5); (5, 7); (7, 5)] <> (7, 7) then\n        failwith \"Test Case 1 failed\"\n    if findFourthVertex [(10, 20); (30, 10); (10, 10)] <> (30, 20) then\n        failwith \"Test Case 2 failed\"\n    if findFourthVertex [(2, 2); (2, 4); (4, 2)] <> (4, 4) then\n        failwith \"Test Case 3 failed\"\n    if findFourthVertex [(3, 3); (6, 3); (3, 6)] <> (6, 6) then\n        failwith \"Test Case 4 failed\"\n    if findFourthVertex [(8, 10); (5, 10); (5, 7)] <> (8, 7) then\n        failwith \"Test Case 5 failed\"\n    if findFourthVertex [(12, 15); (9, 12); (12, 12)] <> (9, 15) then\n        failwith \"Test Case 6 failed\"\n\ncheck ()"}
{"question_id": "F#/64", "category": "Special", "subtype": "Misused match", "level": "medium", "example": "\n        Examples:\n        - finalPosition \"ENWS\" 5 results in (1, 0)\n          (Moves: E -> N -> W -> S -> E)\n    ", "docstring": "\n        Calculates the final position of a robot after executing a given command string for a specified duration.\n        The command string consists of characters 'E', 'S', 'W', 'N', representing movements east, south, west, and north, respectively.\n        The robot repeats the command string from the beginning if it reaches the end before the time is up.\n    ", "canonical_solution": "open System\n\nlet finalPosition (commands: string) (time: int) : (int * int) =\n    (*\n        Calculates the final position of a robot after executing a given command string for a specified duration.\n        The command string consists of characters 'E', 'S', 'W', 'N', representing movements east, south, west, and north, respectively.\n        The robot repeats the command string from the beginning if it reaches the end before the time is up.\n\n        Examples:\n        - finalPosition \"ENWS\" 5 results in (1, 0)\n          (Moves: E -> N -> W -> S -> E)\n    *)\n\n    let move (x, y) (command: char) =\n        match command with\n        | 'E' -> (x + 1, y)\n        | 'S' -> (x, y - 1)\n        | 'W' -> (x - 1, y)\n        | 'N' -> (x, y + 1)\n        | _ -> (x, y)\n\n    let rec moveRobot (x, y) (commands: string) (time: int) =\n        if time <= 0 then (x, y)\n        else\n            let newCommands = if commands.Length > 1 then commands.[1..] + commands.[0].ToString() else commands\n            moveRobot (move (x, y) commands.[0]) newCommands (time - 1)\n\n    moveRobot (0, 0) commands time", "buggy_code": "open System\n\nlet finalPosition (commands: string) (time: int) : (int * int) =\n    (*\n        Calculates the final position of a robot after executing a given command string for a specified duration.\n        The command string consists of characters 'E', 'S', 'W', 'N', representing movements east, south, west, and north, respectively.\n        The robot repeats the command string from the beginning if it reaches the end before the time is up.\n\n        Examples:\n        - finalPosition \"ENWS\" 5 results in (1, 0)\n          (Moves: E -> N -> W -> S -> E)\n    *)\n\n    let move (x, y) (command: char) =\n        match command with\n        | 'E' -> (x + 1, y)\n        | 'S' -> (x, y - 1)\n        | 'W' -> (x - 1, y)\n        | 'N' -> (x, y + 1)\n\n    let rec moveRobot (x, y) (commands: string) (time: int) =\n        if time <= 0 then (x, y)\n        else\n            let newCommands = if commands.Length > 1 then commands.[1..] + commands.[0].ToString() else commands\n            moveRobot (move (x, y) commands.[0]) newCommands (time - 1)\n\n    moveRobot (0, 0) commands time", "bug_with_line_numbers": "   1 | open System\n   2 | let finalPosition (commands: string) (time: int) : (int * int) =\n   3 |     (*\n   4 |         Calculates the final position of a robot after executing a given command string for a specified duration.\n   5 |         The command string consists of characters 'E', 'S', 'W', 'N', representing movements east, south, west, and north, respectively.\n   6 |         The robot repeats the command string from the beginning if it reaches the end before the time is up.\n   7 |         Examples:\n   8 |         - finalPosition \"ENWS\" 5 results in (1, 0)\n   9 |           (Moves: E -> N -> W -> S -> E)\n  10 |     *)\n  11 |     let move (x, y) (command: char) =\n  12 |         match command with\n  13 |         | 'E' -> (x + 1, y)\n  14 |         | 'S' -> (x, y - 1)\n  15 |         | 'W' -> (x - 1, y)\n  16 |         | 'N' -> (x, y + 1)\n  17 |     let rec moveRobot (x, y) (commands: string) (time: int) =\n  18 |         if time <= 0 then (x, y)\n  19 |         else\n  20 |             let newCommands = if commands.Length > 1 then commands.[1..] + commands.[0].ToString() else commands\n  21 |             moveRobot (move (x, y) commands.[0]) newCommands (time - 1)\n  22 |     moveRobot (0, 0) commands time", "fragment_lines": [-1], "fragment_content": ["missing critical code snippet"], "test": "let check () =\n    if finalPosition \"ENWS\" 5 <> (1, 0) then\n        failwith \"Test Case 1 failed\"\n    if finalPosition \"NNSS\" 3 <> (0, 1) then\n        failwith \"Test Case 2 failed\"\n    if finalPosition \"SWNE\" 4 <> (0, 0) then\n        failwith \"Test Case 3 failed\"\n    if finalPosition \"EESSWWNN\" 8 <> (0, 0) then\n        failwith \"Test Case 4 failed\"\n    if finalPosition \"W\" 10 <> (-10, 0) then\n        failwith \"Test Case 5 failed\"\n    if finalPosition \"NESW\" 2 <> (1, 1) then\n        failwith \"Test Case 6 failed\"\n    if finalPosition \"SSSEEE\" 6 <> (3, -3) then\n        failwith \"Test Case 7 failed\"\n\ncheck ()"}
{"question_id": "F#/65", "category": "Special", "subtype": "Misused match", "level": "medium", "example": "Write a F# function `let hanoiTowerSteps (n: int) =` to solve the following problem:\n\n    Calculates the number of steps required to solve a Hanoi Tower puzzle with 'n' disks. \n    According to the rules of the game, only one disk can be moved at a time, and a disk can only be placed on top of a larger one or on an empty rod.\n\n    Example:\n    >>> hanoiTowerSteps(1)\n    1\n    >>> hanoiTowerSteps(3)\n    7\n    >>> hanoiTowerSteps(4)\n    15\n", "docstring": "Write a F# function `let hanoiTowerSteps (n: int) =` to solve the following problem:\n\n    Calculates the number of steps required to solve a Hanoi Tower puzzle with 'n' disks. \n    According to the rules of the game, only one disk can be moved at a time, and a disk can only be placed on top of a larger one or on an empty rod.\n\n    Example:\n    >>> hanoiTowerSteps(1)\n    1\n    >>> hanoiTowerSteps(3)\n    7\n    >>> hanoiTowerSteps(4)\n    15\n", "canonical_solution": "open System\nlet hanoiTowerSteps (n: int) =\n(*\n    Calculates the number of steps required to solve a Hanoi Tower puzzle with 'n' disks. \n    According to the rules of the game, only one disk can be moved at a time, and a disk can only be placed on top of a larger one or on an empty rod.\n\n    Example:\n    >>> hanoiTowerSteps(1)\n    1\n    >>> hanoiTowerSteps(3)\n    7\n    >>> hanoiTowerSteps(4)\n    15\n*)\n\n    let rec solveHanoi n a b c =\n        match n with\n        | 0 -> 0\n        | _ -> solveHanoi (n - 1) a c b + 1 + solveHanoi (n - 1) b a c\n    solveHanoi n \"A\" \"B\" \"C\"", "buggy_code": "open System\nlet hanoiTowerSteps (n: int) =\n    let rec solveHanoi n a b c =\n        match n with\n        | 0 -> 0\n        | 1 -> solveHanoi (n - 1) a c b + 1 + solveHanoi (n - 1) b a c\n    solveHanoi n \"A\" \"B\" \"C\"", "bug_with_line_numbers": "   1 | open System\n   2 | let hanoiTowerSteps (n: int) =\n   3 |     let rec solveHanoi n a b c =\n   4 |         match n with\n   5 |         | 0 -> 0\n   6 |         | 1 -> solveHanoi (n - 1) a c b + 1 + solveHanoi (n - 1) b a c\n   7 |     solveHanoi n \"A\" \"B\" \"C\"", "fragment_lines": [6], "fragment_content": [""], "test": "let checkHanoi () =\n    if hanoiTowerSteps 1 <> 1 then\n        failwith \"Test Case 1 failed\"\n    if hanoiTowerSteps 3 <> 7 then\n        failwith \"Test Case 2 failed\"\n    if hanoiTowerSteps 4 <> 15 then\n        failwith \"Test Case 3 failed\"\n    if hanoiTowerSteps 5 <> 31 then\n        failwith \"Test Case 4 failed\"\n    if hanoiTowerSteps 6 <> 63 then\n        failwith \"Test Case 5 failed\"\n    if hanoiTowerSteps 10 <> 1023 then\n        failwith \"Test Case 6 failed\"\n    if hanoiTowerSteps 0 <> 0 then\n        failwith \"Test Case 7 failed\"\n\ncheckHanoi ()"}
