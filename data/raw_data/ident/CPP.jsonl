{"question_id": "CPP/1", "category": "Syntax", "subtype": "illegal_comment", "level": "easy", "example": "* Examples:\n * >>> process_request(1)\n * 1\n * >>> process_request(10)\n * 6266", "docstring": "* Calculates the factorial of N modulo 10007.\n * \n * Parameters:\n * - N (int): An integer representing the input value (N <= 10000).\n * \n * Returns:\n * int: The result after calculating the factorial of N and\n * taking the modulo 10007.\n *", "canonical_solution": "#include <cassert>\n#include <cmath>\n#include <cstdio>\n#include <cstring>\n\nint process_request(int n)\n\n{\n    int a[10010];\n    a[0] = 1;\n    a[1] = 1;\n    for (register int i = 2; i <= 10000; i++) {\n        a[i] = (a[i - 1] * i) % 10007;\n    }\n    return a[n];\n}", "buggy_code": "#include <cassert>\n#include <cmath>\n#include <cstdio>\n#include <cstring>\nint process_request(int n)\n{\n    int a[10010];\n    a[0] = 1;\n    a[1] = 1;\n    # find the factorial\n    for (register int i = 2; i <= 10000; i++) {\n        a[i] = (a[i - 1] * i) % 10007;\n    }\n    return a[n];\n}", "test": "int main()\n{\n    assert(process_request(0) == 1); // Added test for boundary condition\n    assert(process_request(1) == 1);\n    assert(process_request(2) == 2);\n    assert(process_request(3) == 6);\n    assert(process_request(4) == 24);\n    assert(process_request(10) == 6266); // 10! % 10007 = 3628800 % 10007 = 6266\n    assert(process_request(10000) == 6991); // Added a test for upper boundary condition\n    // printf(\"All tests passed.\\n\");\n    return 0;\n}", "instruction": " the following faulty CPP code snippet and error type list. \nYour task is to select the error type of the code based on the error list provided\n\nYou only need to answer error type. Do not write anything else in your response. \n\nFor example, if the code snippet is missing a semicolon, Your output should be 'missing_colons'.\n\nfaulty code:\n\n```\n#include <cassert>\n#include <cmath>\n#include <cstdio>\n#include <cstring>\nint process_request(int n)\n{\n    int a[10010];\n    a[0] = 1;\n    a[1] = 1;\n    # find the factorial\n    for (register int i = 2; i <= 10000; i++) {\n        a[i] = (a[i - 1] * i) % 10007;\n    }\n    return a[n];\n}\n```\nerror type list:\n\n['illegal_comment', 'illegal_separation', 'missing_colons', 'misused ==and=', 'unclosed_parentheses', 'unclosed_string', 'faulty_indexing', 'function_error', 'illegal_keyword', 'undefined_methods', 'undefined_objects', 'algorithm_error', 'condition_error', 'operation_error', 'type_error', 'variable_error', 'double_bug', 'triple_bug', 'quadruple_bug', 'Misused Macro Definition', 'missing_backtick', 'misused_let', 'misused templte', 'Delayed Execution', 'Misused match', 'Misused := and =', 'Unused Variable', 'Misused === and ==', 'Misused =>', 'Misused Spread Operator', 'Misused begin/end', 'Missing $', 'illegal_indentation', 'Missing mut', 'Misused var and val', 'The digital leader is 0', 'Duplicate keys', 'struct_error', 'json_content_error']\n"}
{"question_id": "CPP/2", "category": "Syntax", "subtype": "illegal_comment", "level": "easy", "example": "* Example Usage:\n * \n * create_id(\"fish\", \"cat\") returns \"ftiasch\"\n * create_id(\"icpc\", \"acm\") returns \"imccpac\"", "docstring": "* Generates a unique identifier by interweaving two words in a specified pattern.\n * @param word1 The first word to be used in the ID creation process.\n * @param word2 The second word to be used in the ID creation process.\n * @return A unique identifier formed by alternating characters from the second word,\n *         reversed, with characters from the first word.", "canonical_solution": "#include <iostream>\n#include <string>\n#include <cassert>\n\nstd::string create_id(const std::string& word1, const std::string& word2)\n\n{\n    std::string id;\n    int j = 0, k = word2.length() - 1;\n    for (int i = 0; i < word1.length() + word2.length(); ++i) {\n        if (i % 2 == 0) {\n            id += word1[j++];\n        } else {\n            id += word2[k--];\n        }\n    }\n    return id;\n}", "buggy_code": "#include <iostream>\n#include <string>\n#include <cassert>\nstd::string create_id(const std::string& word1, const std::string& word2)\n{\n    std::string id;\n    int j = 0, k = word2.length() - 1;\n    for (int i = 0; i < word1.length() + word2.length(); ++i) {\n        if (i % 2 == 0) {\n            id += word1[j++];\n        } else {\n            id += word2[k--];   ## Take character from word2 in reverse\n        }\n    }\n    return id;\n}", "test": "int main() {\n    std::string id; // To hold the results from create_id\n\n    id = create_id(\"fish\", \"cat\");\n    assert(id.compare(\"ftiasch\") == 0);\n\n    id = create_id(\"icpc\", \"acm\");\n    assert(id.compare(\"imccpac\") == 0);\n\n    id = create_id(\"oo\", \"w\");\n    assert(id.compare(\"owo\") == 0);\n\n    // Add more test samples\n    id = create_id(\"hello\", \"world\");\n    assert(id.compare(\"hdellrloow\") == 0);\n\n    id = create_id(\"abc\", \"def\");\n    assert(id.compare(\"afbecd\") == 0);\n\n    id = create_id(\"buaanb\", \"nbbuaa\");\n    assert(id.compare(\"bauaauabnbbn\") == 0);\n\n    id = create_id(\"xtuisgood\", \"ilovextu\");\n    assert(id.compare(\"xuttuxiesvgooloid\") == 0);\n\n    // std::cout << \"All tests passed!\" << std::endl;\n\n    return 0;\n}", "instruction": " the following faulty CPP code snippet and error type list. \nYour task is to select the error type of the code based on the error list provided\n\nYou only need to answer error type. Do not write anything else in your response. \n\nFor example, if the code snippet is missing a semicolon, Your output should be 'missing_colons'.\n\nfaulty code:\n\n```\n#include <iostream>\n#include <string>\n#include <cassert>\nstd::string create_id(const std::string& word1, const std::string& word2)\n{\n    std::string id;\n    int j = 0, k = word2.length() - 1;\n    for (int i = 0; i < word1.length() + word2.length(); ++i) {\n        if (i % 2 == 0) {\n            id += word1[j++];\n        } else {\n            id += word2[k--];   ## Take character from word2 in reverse\n        }\n    }\n    return id;\n}\n```\nerror type list:\n\n['illegal_comment', 'illegal_separation', 'missing_colons', 'misused ==and=', 'unclosed_parentheses', 'unclosed_string', 'faulty_indexing', 'function_error', 'illegal_keyword', 'undefined_methods', 'undefined_objects', 'algorithm_error', 'condition_error', 'operation_error', 'type_error', 'variable_error', 'double_bug', 'triple_bug', 'quadruple_bug', 'Misused Macro Definition', 'missing_backtick', 'misused_let', 'misused templte', 'Delayed Execution', 'Misused match', 'Misused := and =', 'Unused Variable', 'Misused === and ==', 'Misused =>', 'Misused Spread Operator', 'Misused begin/end', 'Missing $', 'illegal_indentation', 'Missing mut', 'Misused var and val', 'The digital leader is 0', 'Duplicate keys', 'struct_error', 'json_content_error']\n"}
{"question_id": "CPP/3", "category": "Syntax", "subtype": "illegal_separation", "level": "easy", "example": ">>> hamming_distance(1,2)\n\t2", "docstring": "Calculate the Hamming distance between two integers in binary representation.\n​    Parameters:\n- x (int): The first positive integer (x <= 1,000,000,000).\n- y (int): The second positive integer (y <= 1,000,000,000).\n​    Returns:\n​    int: The Hamming distance between x and y, i.e., the number of bits that need to be flipped\n​         to transform x into y in binary.", "canonical_solution": "#include <bits/stdc++.h>\n\nint hamming_distance(int x, int y)\n\n{\n    int distance = 0;\n    int xor_result = x ^ y;\n    while (xor_result) {\n        if (xor_result & 1) {\n            distance++;\n        }\n        xor_result >>= 1;\n    }\n    return distance;\n}", "buggy_code": "#include <bits/stdc++.h>\nint hamming_distance(int x, int y)\n{\n    int distance = 0;\n    int xor_result = x ^ y;\n    while (xor_result) {\n        if (xor_result & 1) {\n            distance++;\n        }\n    }\n    xor_result >>= 1;\n    \n    return distance;\n}", "test": "int main() {\n    assert(hamming_distance(1, 2) == 2); // 01 and 10 have 2 different bits\n    assert(hamming_distance(4, 7) == 2); // 100 and 111 have 2 different bits\n    assert(hamming_distance(25, 30) == 3); // Additional test: 11001 and 11110 have 3 different bits\n    assert(hamming_distance(0, 0) == 0); // Additional test: Same numbers have 0 different bits\n    assert(hamming_distance(0xFFFFFFF, 0x0000000) == 28); // Additional test: Max unsigned int and 0 have 32 different bits\n    return 0;\n}", "instruction": " the following faulty CPP code snippet and error type list. \nYour task is to select the error type of the code based on the error list provided\n\nYou only need to answer error type. Do not write anything else in your response. \n\nFor example, if the code snippet is missing a semicolon, Your output should be 'missing_colons'.\n\nfaulty code:\n\n```\n#include <bits/stdc++.h>\nint hamming_distance(int x, int y)\n{\n    int distance = 0;\n    int xor_result = x ^ y;\n    while (xor_result) {\n        if (xor_result & 1) {\n            distance++;\n        }\n    }\n    xor_result >>= 1;\n    \n    return distance;\n}\n```\nerror type list:\n\n['illegal_comment', 'illegal_separation', 'missing_colons', 'misused ==and=', 'unclosed_parentheses', 'unclosed_string', 'faulty_indexing', 'function_error', 'illegal_keyword', 'undefined_methods', 'undefined_objects', 'algorithm_error', 'condition_error', 'operation_error', 'type_error', 'variable_error', 'double_bug', 'triple_bug', 'quadruple_bug', 'Misused Macro Definition', 'missing_backtick', 'misused_let', 'misused templte', 'Delayed Execution', 'Misused match', 'Misused := and =', 'Unused Variable', 'Misused === and ==', 'Misused =>', 'Misused Spread Operator', 'Misused begin/end', 'Missing $', 'illegal_indentation', 'Missing mut', 'Misused var and val', 'The digital leader is 0', 'Duplicate keys', 'struct_error', 'json_content_error']\n"}
{"question_id": "CPP/4", "category": "Syntax", "subtype": "illegal_separation", "level": "easy", "example": "* Example:\n *    >>> Is_Square({9})\n *    true", "docstring": "* Determines if it is possible to assemble the wooden squares from n buckets\n * into a single larger square, where each bucket contains squares with a side length of 1.\n * \n * Input: vector of numbers\n * \n * @param squares Vector containing the count of squares in each bucket.\n * @return True if it is possible to form a larger square, False otherwise.", "canonical_solution": "#include <cassert>\n#include <cmath>\n#include <vector>\n\nbool Is_Square(std::vector<int> squares)\n\n{\n    long long sum = 0;\n    for (int square : squares) {\n        sum += square; \n    }\n    int root = static_cast<int>(std::sqrt(sum));\n    return root * root == sum;\n}", "buggy_code": "#include <cassert>\n#include <cmath>\n#include <vector>\nbool Is_Square(std::vector<int> squares)\n{\n    long long sum = 0;\n    for (int square : squares) {\n        sum += square; \n        int root = static_cast<int>(std::sqrt(sum));\n    }\n    return root * root == sum;\n}", "test": "int main() {\n    assert(Is_Square({9}) == true);\n    assert(Is_Square({14, 2}) == true);\n    assert(Is_Square({7, 7}) == false);\n    assert(Is_Square({1, 2, 3, 4, 5, 6, 7}) == false);\n    assert(Is_Square({1, 3, 5, 7, 9, 11}) == true);\n    assert(Is_Square({2, 2, 2, 2}) == false);\n\n    // Additional test cases\n    assert(Is_Square({4, 5, 6}) == false);\n    assert(Is_Square({16, 9, 4, 1}) == false);\n    assert(Is_Square({1, 1, 1, 1, 1}) == false);\n    assert(Is_Square({25, 25}) == false);\n    assert(Is_Square({10, 10, 5}) == true);\n\n    // All tests passed\n    return 0;\n}", "instruction": " the following faulty CPP code snippet and error type list. \nYour task is to select the error type of the code based on the error list provided\n\nYou only need to answer error type. Do not write anything else in your response. \n\nFor example, if the code snippet is missing a semicolon, Your output should be 'missing_colons'.\n\nfaulty code:\n\n```\n#include <cassert>\n#include <cmath>\n#include <vector>\nbool Is_Square(std::vector<int> squares)\n{\n    long long sum = 0;\n    for (int square : squares) {\n        sum += square; \n        int root = static_cast<int>(std::sqrt(sum));\n    }\n    return root * root == sum;\n}\n```\nerror type list:\n\n['illegal_comment', 'illegal_separation', 'missing_colons', 'misused ==and=', 'unclosed_parentheses', 'unclosed_string', 'faulty_indexing', 'function_error', 'illegal_keyword', 'undefined_methods', 'undefined_objects', 'algorithm_error', 'condition_error', 'operation_error', 'type_error', 'variable_error', 'double_bug', 'triple_bug', 'quadruple_bug', 'Misused Macro Definition', 'missing_backtick', 'misused_let', 'misused templte', 'Delayed Execution', 'Misused match', 'Misused := and =', 'Unused Variable', 'Misused === and ==', 'Misused =>', 'Misused Spread Operator', 'Misused begin/end', 'Missing $', 'illegal_indentation', 'Missing mut', 'Misused var and val', 'The digital leader is 0', 'Duplicate keys', 'struct_error', 'json_content_error']\n"}
{"question_id": "CPP/5", "category": "Syntax", "subtype": "missing_colons", "level": "easy", "example": ">>> Example call: \nint max, min;\nfind_max_min(1,2,3, &max, &min);\nassert(max == 3 && min == 1);", "docstring": "Find the maximum and minimum of three distinct integers.\nParameters:\na (int): The first integer.\nb (int): The second integer.\nc (int): The third integer.\n\nReturns:\nTuple[int, int]: A tuple is not a concept in C; instead, we will return by Reference.", "canonical_solution": "#include <cassert>\n#include <cstdio>\n\nvoid find_max_min(int a, int b, int c, int *max, int *min)\n\n{\n    if (a > b) {\n        if (a > c) {\n            *max = a;\n            *min = (b < c) ? b : c;\n        } else {\n            *max = c;\n            *min = b;\n        }\n    } else if (b > c) {\n        *max = b;\n        *min = (a < c) ? a : c;\n    } else {\n        *max = c;\n        *min = a;\n    }\n}", "buggy_code": "#include <cassert>\n#include <cstdio>\nvoid find_max_min(int a, int b, int c, int *max, int *min)\n{\n    if (a > b) {\n        if (a > c) {\n            *max = a;\n            *min = (b < c) ? b c;\n        } else {\n            *max = c;\n            *min = b;\n        }\n    } else if (b > c) {\n        *max = b;\n        *min = (a < c) ? a : c;\n    } else {\n        *max = c;\n        *min = a;\n    }\n}", "test": "int main() {\n    int max, min;\n\n    // Test with a set of values\n    find_max_min(1, 2, 3, &max, &min);\n    assert(max == 3 && min == 1);\n\n    // Additional tests\n    find_max_min(5, 3, 4, &max, &min);\n    assert(max == 5 && min == 3);\n\n    find_max_min(10, -2, 7, &max, &min);\n    assert(max == 10 && min == -2);\n\n    find_max_min(-1, -3, -2, &max, &min);\n    assert(max == -1 && min == -3);\n\n    return 0;\n}", "instruction": " the following faulty CPP code snippet and error type list. \nYour task is to select the error type of the code based on the error list provided\n\nYou only need to answer error type. Do not write anything else in your response. \n\nFor example, if the code snippet is missing a semicolon, Your output should be 'missing_colons'.\n\nfaulty code:\n\n```\n#include <cassert>\n#include <cstdio>\nvoid find_max_min(int a, int b, int c, int *max, int *min)\n{\n    if (a > b) {\n        if (a > c) {\n            *max = a;\n            *min = (b < c) ? b c;\n        } else {\n            *max = c;\n            *min = b;\n        }\n    } else if (b > c) {\n        *max = b;\n        *min = (a < c) ? a : c;\n    } else {\n        *max = c;\n        *min = a;\n    }\n}\n```\nerror type list:\n\n['illegal_comment', 'illegal_separation', 'missing_colons', 'misused ==and=', 'unclosed_parentheses', 'unclosed_string', 'faulty_indexing', 'function_error', 'illegal_keyword', 'undefined_methods', 'undefined_objects', 'algorithm_error', 'condition_error', 'operation_error', 'type_error', 'variable_error', 'double_bug', 'triple_bug', 'quadruple_bug', 'Misused Macro Definition', 'missing_backtick', 'misused_let', 'misused templte', 'Delayed Execution', 'Misused match', 'Misused := and =', 'Unused Variable', 'Misused === and ==', 'Misused =>', 'Misused Spread Operator', 'Misused begin/end', 'Missing $', 'illegal_indentation', 'Missing mut', 'Misused var and val', 'The digital leader is 0', 'Duplicate keys', 'struct_error', 'json_content_error']\n"}
{"question_id": "CPP/6", "category": "Syntax", "subtype": "missing_colons", "level": "easy", "example": ">>> Example call: \nint max, min;\nfind_max_min(1,2,3, &max, &min);\nassert(max == 3 && min == 1);", "docstring": "Find the maximum and minimum of three distinct integers.\nParameters:\na (int): The first integer.\nb (int): The second integer.\nc (int): The third integer.\n\nReturns:\nTuple[int, int]: A tuple is not a concept in C; instead, we will return by Reference.", "canonical_solution": "#include <cassert>\n#include <cstdio>\n\nvoid find_max_min(int a, int b, int c, int *max, int *min)\n\n{\n    if (a > b) {\n        if (a > c) {\n            *max = a;\n            *min = (b < c) ? b : c;\n        } else {\n            *max = c;\n            *min = b;\n        }\n    } else if (b > c) {\n        *max = b;\n        *min = (a < c) ? a : c;\n    } else {\n        *max = c;\n        *min = a;\n    }\n}", "buggy_code": "#include <cassert>\n#include <cstdio>\nvoid find_max_min(int a, int b, int c, int *max, int *min)\n{\n    if (a > b) {\n        if (a > c) {\n            *max = a;\n            *min = (b < c) ? b : c;\n        } else {\n            *max = c;\n            *min = b;\n        }\n    } else if (b > c) {\n        *max = b;\n        *min = (a < c) ? a c;\n    } else {\n        *max = c;\n        *min = a;\n    }\n}", "test": "int main() {\n    int max, min;\n\n    // Test with a set of values\n    find_max_min(1, 2, 3, &max, &min);\n    assert(max == 3 && min == 1);\n\n    // Additional tests\n    find_max_min(5, 3, 4, &max, &min);\n    assert(max == 5 && min == 3);\n\n    find_max_min(10, -2, 7, &max, &min);\n    assert(max == 10 && min == -2);\n\n    find_max_min(-1, -3, -2, &max, &min);\n    assert(max == -1 && min == -3);\n\n    return 0;\n}", "instruction": " the following faulty CPP code snippet and error type list. \nYour task is to select the error type of the code based on the error list provided\n\nYou only need to answer error type. Do not write anything else in your response. \n\nFor example, if the code snippet is missing a semicolon, Your output should be 'missing_colons'.\n\nfaulty code:\n\n```\n#include <cassert>\n#include <cstdio>\nvoid find_max_min(int a, int b, int c, int *max, int *min)\n{\n    if (a > b) {\n        if (a > c) {\n            *max = a;\n            *min = (b < c) ? b : c;\n        } else {\n            *max = c;\n            *min = b;\n        }\n    } else if (b > c) {\n        *max = b;\n        *min = (a < c) ? a c;\n    } else {\n        *max = c;\n        *min = a;\n    }\n}\n```\nerror type list:\n\n['illegal_comment', 'illegal_separation', 'missing_colons', 'misused ==and=', 'unclosed_parentheses', 'unclosed_string', 'faulty_indexing', 'function_error', 'illegal_keyword', 'undefined_methods', 'undefined_objects', 'algorithm_error', 'condition_error', 'operation_error', 'type_error', 'variable_error', 'double_bug', 'triple_bug', 'quadruple_bug', 'Misused Macro Definition', 'missing_backtick', 'misused_let', 'misused templte', 'Delayed Execution', 'Misused match', 'Misused := and =', 'Unused Variable', 'Misused === and ==', 'Misused =>', 'Misused Spread Operator', 'Misused begin/end', 'Missing $', 'illegal_indentation', 'Missing mut', 'Misused var and val', 'The digital leader is 0', 'Duplicate keys', 'struct_error', 'json_content_error']\n"}
{"question_id": "CPP/7", "category": "Syntax", "subtype": "misused ==and=", "level": "easy", "example": "* Usage:\n *   count_odd_numbers(5, 1, 4, 3, 2, 5) should return 3", "docstring": "* Count the number of odd integers in a given list of numbers.\n * Parameters:\n * - count (int): The number of integers to evaluate.\n * - ... (int): A sequence of integers.\n * Returns:\n *   int: The count of odd numbers in the input list.", "canonical_solution": "#include <assert.h>\n#include <stdarg.h>\n\n\nint count_odd_numbers(int count, ...)\n\n{\n    va_list args;\n    va_start(args, count);\n    int ans = 0;\n    for (int i = 0; i < count; i++) {\n        int num = va_arg(args, int);\n        if (num & 1) {\n            ans++;\n        }\n    }\n    va_end(args);\n    return ans;\n}", "buggy_code": "#include <assert.h>\n#include <stdarg.h>\nint count_odd_numbers(int count, ...)\n{\n    va_list args;\n    va_start(args, count);\n    int ans == 0;\n    for (int i = 0; i < count; i++) {\n        int num = va_arg(args, int);\n        if (num & 1) {\n            ans++;\n        }\n    }\n    va_end(args);\n    return ans;\n}", "test": "int main() {\n    assert(count_odd_numbers(5, 1, 4, 3, 2, 5) == 3);\n    assert(count_odd_numbers(4, 2, 2, 0, 0) == 0);\n    assert(count_odd_numbers(6, 7, 7, 8, 1, 9, 10) == 4); // Additional Test Sample\n    // Uncomment the following line to print a success message\n    // std::printf(\"All tests passed!\\n\");\n    return 0;\n}", "instruction": " the following faulty CPP code snippet and error type list. \nYour task is to select the error type of the code based on the error list provided\n\nYou only need to answer error type. Do not write anything else in your response. \n\nFor example, if the code snippet is missing a semicolon, Your output should be 'missing_colons'.\n\nfaulty code:\n\n```\n#include <assert.h>\n#include <stdarg.h>\nint count_odd_numbers(int count, ...)\n{\n    va_list args;\n    va_start(args, count);\n    int ans == 0;\n    for (int i = 0; i < count; i++) {\n        int num = va_arg(args, int);\n        if (num & 1) {\n            ans++;\n        }\n    }\n    va_end(args);\n    return ans;\n}\n```\nerror type list:\n\n['illegal_comment', 'illegal_separation', 'missing_colons', 'misused ==and=', 'unclosed_parentheses', 'unclosed_string', 'faulty_indexing', 'function_error', 'illegal_keyword', 'undefined_methods', 'undefined_objects', 'algorithm_error', 'condition_error', 'operation_error', 'type_error', 'variable_error', 'double_bug', 'triple_bug', 'quadruple_bug', 'Misused Macro Definition', 'missing_backtick', 'misused_let', 'misused templte', 'Delayed Execution', 'Misused match', 'Misused := and =', 'Unused Variable', 'Misused === and ==', 'Misused =>', 'Misused Spread Operator', 'Misused begin/end', 'Missing $', 'illegal_indentation', 'Missing mut', 'Misused var and val', 'The digital leader is 0', 'Duplicate keys', 'struct_error', 'json_content_error']\n"}
{"question_id": "CPP/8", "category": "Syntax", "subtype": "misused ==and=", "level": "easy", "example": "Examples:\n>>> count_acute_triangles(4, 1, 1, 1, 1)\n4", "docstring": "Count the number of acute-angled triangles that can be formed by selecting any 3 edges out of\na given set of edges.\n  \nArgs:\n- edges_count: The number of edges passed.\n- An arbitrary number of integer arguments representing the lengths of the edges.\n  \nReturns:\nint: The count of distinct acute-angled triangles that can be formed.", "canonical_solution": "#include <cassert>\n#include <cmath>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cstdarg>\n\nint count_acute_triangles(int edges_count, ...)\n\n{\n    va_list args;\n    va_start(args, edges_count);\n\n    int* edges = (int*) malloc(edges_count * sizeof(int));\n    for (int i = 0; i < edges_count; i++) {\n        edges[i] = va_arg(args, int);\n    }\n    va_end(args);\n\n    qsort(edges, edges_count, sizeof(int), (int (*)(const void *, const void *)) strcmp);\n\n\n    int sum = 0;\n    for (int i = 0; i < edges_count - 2; i++) {\n        for (int j = i + 1; j < edges_count - 1; j++) {\n            for (int k = j + 1; k < edges_count; k++) {\n                int x = edges[i], y = edges[j], z = edges[k];\n                if (x + y > z && x * x + y * y > z * z) {\n                    sum++;\n                }\n            }\n        }\n    }\n\n    free(edges);\n    return sum;\n}", "buggy_code": "#include <cassert>\n#include <cmath>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cstdarg>\nint count_acute_triangles(int edges_count, ...)\n{\n    va_list args;\n    va_start(args, edges_count);\n    int* edges = (int*) malloc(edges_count * sizeof(int));\n    for (int i = 0; i < edges_count; i++) {\n        edges[i] = va_arg(args, int);\n    }\n    va_end(args);\n    qsort(edges, edges_count, sizeof(int), (int (*)(const void *, const void *)) strcmp);\n    int sum = 0;\n    for (int i = 0; i < edges_count - 2; i++) {\n        for (int j == i + 1; j < edges_count - 1; j++) {\n            for (int k = j + 1; k < edges_count; k++) {\n                int x = edges[i], y = edges[j], z = edges[k];\n                if (x + y > z && x * x + y * y > z * z) {\n                    sum++;\n                }\n            }\n        }\n    }\n    free(edges);\n    return sum;\n}", "test": "int main() {\n    assert(count_acute_triangles(4, 1, 1, 1, 1) == 4);\n    assert(count_acute_triangles(3, 1, 2, 3) == 0);\n    // Additional tests to ensure correctness\n    assert(count_acute_triangles(5, 3, 4, 5, 7, 10) == 0);\n    assert(count_acute_triangles(6, 6, 8, 10, 5, 5, 5) == 4);\n    return 0;\n}", "instruction": " the following faulty CPP code snippet and error type list. \nYour task is to select the error type of the code based on the error list provided\n\nYou only need to answer error type. Do not write anything else in your response. \n\nFor example, if the code snippet is missing a semicolon, Your output should be 'missing_colons'.\n\nfaulty code:\n\n```\n#include <cassert>\n#include <cmath>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cstdarg>\nint count_acute_triangles(int edges_count, ...)\n{\n    va_list args;\n    va_start(args, edges_count);\n    int* edges = (int*) malloc(edges_count * sizeof(int));\n    for (int i = 0; i < edges_count; i++) {\n        edges[i] = va_arg(args, int);\n    }\n    va_end(args);\n    qsort(edges, edges_count, sizeof(int), (int (*)(const void *, const void *)) strcmp);\n    int sum = 0;\n    for (int i = 0; i < edges_count - 2; i++) {\n        for (int j == i + 1; j < edges_count - 1; j++) {\n            for (int k = j + 1; k < edges_count; k++) {\n                int x = edges[i], y = edges[j], z = edges[k];\n                if (x + y > z && x * x + y * y > z * z) {\n                    sum++;\n                }\n            }\n        }\n    }\n    free(edges);\n    return sum;\n}\n```\nerror type list:\n\n['illegal_comment', 'illegal_separation', 'missing_colons', 'misused ==and=', 'unclosed_parentheses', 'unclosed_string', 'faulty_indexing', 'function_error', 'illegal_keyword', 'undefined_methods', 'undefined_objects', 'algorithm_error', 'condition_error', 'operation_error', 'type_error', 'variable_error', 'double_bug', 'triple_bug', 'quadruple_bug', 'Misused Macro Definition', 'missing_backtick', 'misused_let', 'misused templte', 'Delayed Execution', 'Misused match', 'Misused := and =', 'Unused Variable', 'Misused === and ==', 'Misused =>', 'Misused Spread Operator', 'Misused begin/end', 'Missing $', 'illegal_indentation', 'Missing mut', 'Misused var and val', 'The digital leader is 0', 'Duplicate keys', 'struct_error', 'json_content_error']\n"}
{"question_id": "CPP/9", "category": "Syntax", "subtype": "unclosed_parentheses", "level": "easy", "example": "Example usage:\nassert(decode_numbers(\"0000\") == 4);", "docstring": "Decode a series of numbers to reveal the pattern and understand the actual values \neach digit represents.\n\nEquations provided for Reference:\n0000=4 8888=8 1234=1 5678=3 9012=2 1357=0 2468=4\n\nParameters:\n- data_str: A constant character array (C-style string) representing a series of numbers. Length does not exceed 100.\n\nReturns:\nint: The result of each data string corresponding to the right-hand side of the equation.", "canonical_solution": "#include <cassert>\n#include <cstring>\n#include <iostream>\n\nint decode_numbers(const char* data_str)\n\n{\n    int a[] = {1, 0, 0, 0, 1, 0, 1, 0, 2, 1};\n    int ans = 0;\n    for(int i = 0; i < std::strlen(data_str); i++) {\n        ans += a[data_str[i] - '0'];\n    }\n    return ans;\n}", "buggy_code": "#include <cassert>\n#include <cstring>\n#include <iostream>\nint decode_numbers(const char* data_str)\n{\n    int a[] = {1, 0, 0, 0, 1, 0, 1, 0, 2, 1};\n    int ans = 0;\n    for(int i = 0; i < std::strlen(data_str; i++) {\n        ans += a[data_str[i] - '0'];\n    }\n    return ans;\n}", "test": "int main() {\n    // Assert basic provided test cases\n    assert(decode_numbers(\"0000\") == 4);\n    assert(decode_numbers(\"8888\") == 8);\n    assert(decode_numbers(\"1234\") == 1);\n    assert(decode_numbers(\"5678\") == 3);\n    assert(decode_numbers(\"9012\") == 2);\n    assert(decode_numbers(\"1357\") == 0);\n    assert(decode_numbers(\"2468\") == 4);\n\n    // Assert additional test cases\n    assert(decode_numbers(\"9999\") == 4);\n    assert(decode_numbers(\"1111\") == 0);\n    assert(decode_numbers(\"2222\") == 0);\n    assert(decode_numbers(\"3333\") == 0);\n    assert(decode_numbers(\"4444\") == 4);\n    assert(decode_numbers(\"5555\") == 0);\n    assert(decode_numbers(\"6666\") == 4);\n    assert(decode_numbers(\"7777\") == 0);\n    assert(decode_numbers(\"0001\") == 3);\n    assert(decode_numbers(\"2301\") == 1);\n\n    // Indicate that all tests passed\n    // std::cout << \"All tests passed successfully!\" << std::endl;\n\n    return 0;\n}", "instruction": " the following faulty CPP code snippet and error type list. \nYour task is to select the error type of the code based on the error list provided\n\nYou only need to answer error type. Do not write anything else in your response. \n\nFor example, if the code snippet is missing a semicolon, Your output should be 'missing_colons'.\n\nfaulty code:\n\n```\n#include <cassert>\n#include <cstring>\n#include <iostream>\nint decode_numbers(const char* data_str)\n{\n    int a[] = {1, 0, 0, 0, 1, 0, 1, 0, 2, 1};\n    int ans = 0;\n    for(int i = 0; i < std::strlen(data_str; i++) {\n        ans += a[data_str[i] - '0'];\n    }\n    return ans;\n}\n```\nerror type list:\n\n['illegal_comment', 'illegal_separation', 'missing_colons', 'misused ==and=', 'unclosed_parentheses', 'unclosed_string', 'faulty_indexing', 'function_error', 'illegal_keyword', 'undefined_methods', 'undefined_objects', 'algorithm_error', 'condition_error', 'operation_error', 'type_error', 'variable_error', 'double_bug', 'triple_bug', 'quadruple_bug', 'Misused Macro Definition', 'missing_backtick', 'misused_let', 'misused templte', 'Delayed Execution', 'Misused match', 'Misused := and =', 'Unused Variable', 'Misused === and ==', 'Misused =>', 'Misused Spread Operator', 'Misused begin/end', 'Missing $', 'illegal_indentation', 'Missing mut', 'Misused var and val', 'The digital leader is 0', 'Duplicate keys', 'struct_error', 'json_content_error']\n"}
{"question_id": "CPP/10", "category": "Syntax", "subtype": "unclosed_parentheses", "level": "easy", "example": "* Examples:\n *   >>> isPalindrome(\"racecar\")\n *   true\n *   >>> isPalindrome(\"hello\")\n *   false", "docstring": "* Determine if a given string is a palindrome. A palindrome is a word, phrase,\n * number, or other sequence of characters that reads the same forward and\n * backward (ignoring spaces, punctuation, and capitalization).", "canonical_solution": "#include <cassert>\n#include <cctype> \n#include <cstring>\n\nbool isPalindrome(const char* str)\n\n{\n    int start = 0;\n    int end = strlen(str) - 1;\n    \n    while (start < end) {\n        while (!isalnum(str[start]) && start < end) start++;\n        while (!isalnum(str[end]) && start < end) end--;\n        if (tolower(str[start]) != tolower(str[end]))\n            return false;\n        start++;\n        end--;\n    }\n    return true;\n}", "buggy_code": "#include <cassert>\n#include <cctype> \n#include <cstring>\nbool isPalindrome(const char* str)\n{\n    int start = 0;\n    int end = strlen(str) - 1;\n    \n    while (start < end) {\n        while (!isalnum(str[start]) && start < end) start++;\n        while (!isalnum(str[end]) && start < end) end--;\n        if (tolower(str[start]) != tolower(str[end]))\n            return false;\n        start++;\n        end--;\n    \n    return true;\n}", "test": "int main()\n{\n    assert(isPalindrome(\"A man a plan a canal Panama\") == true);\n    assert(isPalindrome(\"No lemon, no melon\") == true);\n    assert(isPalindrome(\"Was it a car or a cat I saw\") == true);\n    assert(isPalindrome(\"Madam, in Eden, I'm Adam\") == true);\n    assert(isPalindrome(\"Never odd or even\") == true);\n    assert(isPalindrome(\"Eva, can I see bees in a cave\") == true);\n    assert(isPalindrome(\"hello\") == false);\n    assert(isPalindrome(\"GitHub\") == false);\n    assert(isPalindrome(\"programming\") == false);\n    \n    return 0;\n}", "instruction": " the following faulty CPP code snippet and error type list. \nYour task is to select the error type of the code based on the error list provided\n\nYou only need to answer error type. Do not write anything else in your response. \n\nFor example, if the code snippet is missing a semicolon, Your output should be 'missing_colons'.\n\nfaulty code:\n\n```\n#include <cassert>\n#include <cctype> \n#include <cstring>\nbool isPalindrome(const char* str)\n{\n    int start = 0;\n    int end = strlen(str) - 1;\n    \n    while (start < end) {\n        while (!isalnum(str[start]) && start < end) start++;\n        while (!isalnum(str[end]) && start < end) end--;\n        if (tolower(str[start]) != tolower(str[end]))\n            return false;\n        start++;\n        end--;\n    \n    return true;\n}\n```\nerror type list:\n\n['illegal_comment', 'illegal_separation', 'missing_colons', 'misused ==and=', 'unclosed_parentheses', 'unclosed_string', 'faulty_indexing', 'function_error', 'illegal_keyword', 'undefined_methods', 'undefined_objects', 'algorithm_error', 'condition_error', 'operation_error', 'type_error', 'variable_error', 'double_bug', 'triple_bug', 'quadruple_bug', 'Misused Macro Definition', 'missing_backtick', 'misused_let', 'misused templte', 'Delayed Execution', 'Misused match', 'Misused := and =', 'Unused Variable', 'Misused === and ==', 'Misused =>', 'Misused Spread Operator', 'Misused begin/end', 'Missing $', 'illegal_indentation', 'Missing mut', 'Misused var and val', 'The digital leader is 0', 'Duplicate keys', 'struct_error', 'json_content_error']\n"}
{"question_id": "CPP/11", "category": "Syntax", "subtype": "unclosed_string", "level": "easy", "example": ">>> shift_characters(\"NS BFW, JAJSYX TK NRUTWYFSHJ FWJ YMJ WJXZQY TK YWNANFQ HFZXJX\")\n\"IN WAR, EVENTS OF IMPORTANCE ARE THE RESULT OF TRIVIAL CAUSES\"", "docstring": "Shifts all characters by 5 positions in alphabetical order. Only letters are replaced,\nand all letters are in uppercase.\n\nParameters:\ntext (std::string&): The input text to be processed, modified in place.\n\nReturns:\nstd::string&: The transformed text with characters shifted by 5 positions.", "canonical_solution": "#include <bits/stdc++.h>\n\nstd::string& shift_characters(std::string& text)\n\n{\n    size_t len = text.length();\n    for (size_t i = 0; i < len; ++i) {\n        if ('A' <= text[i] && text[i] <= 'E') {\n            text[i] = text[i] + 'V' - 'A';\n        } else if ('F' <= text[i] && text[i] <= 'Z') {\n            text[i] = text[i] + 'A' - 'F';\n        }\n    }\n    return text;\n}", "buggy_code": "#include <bits/stdc++.h>\nstd::string& shift_characters(std::string& text)\n{\n    size_t len = text.length();\n    for (size_t i = 0; i < len; ++i) {\n        if ('A' <= text[i] && text[i] <= 'E) {\n            text[i] = text[i] + 'V' - 'A';\n        } else if ('F' <= text[i] && text[i] <= 'Z') {\n            text[i] = text[i] + 'A' - 'F';\n        }\n    }\n    return text;\n}", "test": "int main()\n{\n    std::string test1 = \"NS BFW, JAJSYX TK NRUTWYFSHJ FWJ YMJ WJXZQY TK YWNANFQ HFZXJX\";\n    std::string test2 = \"N BTZQI WFYMJW GJ KNWXY NS F QNYYQJ NGJWNFS ANQQFLJ YMFS XJHTSI NS WTRJ\";\n    std::string test3 = \"IFSLJW PSTBX KZQQ BJQQ YMFY HFJXFW NX RTWJ IFSLJWTZX YMFS MJ\";\n\n    assert(shift_characters(test1) == \"IN WAR, EVENTS OF IMPORTANCE ARE THE RESULT OF TRIVIAL CAUSES\");\n    assert(shift_characters(test2) == \"I WOULD RATHER BE FIRST IN A LITTLE IBERIAN VILLAGE THAN SECOND IN ROME\");\n    assert(shift_characters(test3) == \"DANGER KNOWS FULL WELL THAT CAESAR IS MORE DANGEROUS THAN HE\");\n    return 0;\n}", "instruction": " the following faulty CPP code snippet and error type list. \nYour task is to select the error type of the code based on the error list provided\n\nYou only need to answer error type. Do not write anything else in your response. \n\nFor example, if the code snippet is missing a semicolon, Your output should be 'missing_colons'.\n\nfaulty code:\n\n```\n#include <bits/stdc++.h>\nstd::string& shift_characters(std::string& text)\n{\n    size_t len = text.length();\n    for (size_t i = 0; i < len; ++i) {\n        if ('A' <= text[i] && text[i] <= 'E) {\n            text[i] = text[i] + 'V' - 'A';\n        } else if ('F' <= text[i] && text[i] <= 'Z') {\n            text[i] = text[i] + 'A' - 'F';\n        }\n    }\n    return text;\n}\n```\nerror type list:\n\n['illegal_comment', 'illegal_separation', 'missing_colons', 'misused ==and=', 'unclosed_parentheses', 'unclosed_string', 'faulty_indexing', 'function_error', 'illegal_keyword', 'undefined_methods', 'undefined_objects', 'algorithm_error', 'condition_error', 'operation_error', 'type_error', 'variable_error', 'double_bug', 'triple_bug', 'quadruple_bug', 'Misused Macro Definition', 'missing_backtick', 'misused_let', 'misused templte', 'Delayed Execution', 'Misused match', 'Misused := and =', 'Unused Variable', 'Misused === and ==', 'Misused =>', 'Misused Spread Operator', 'Misused begin/end', 'Missing $', 'illegal_indentation', 'Missing mut', 'Misused var and val', 'The digital leader is 0', 'Duplicate keys', 'struct_error', 'json_content_error']\n"}
{"question_id": "CPP/12", "category": "Syntax", "subtype": "unclosed_string", "level": "easy", "example": "* Examples:\n * >>> minRoundsToSameChar(\"aab\")\n * 1\n * >>> minRoundsToSameChar(\"abc\")\n * 2\n * >>> minRoundsToSameChar(\"aaa\")\n * 0", "docstring": "* Given a string consisting of lowercase English letters, in each round you can change\n * one of the characters to another character. The question is: what is the minimum\n * number of rounds needed to make the string composed of the same character?\n *", "canonical_solution": "#include <cassert>\n#include <cstring>\n#include <iostream>\n\nint minRoundsToSameChar(const char* s)\n\n{\n    int charCount[26] = {0};\n    for (int i = 0; i < 26; i++) {\n        charCount[i] = 0;\n    }\n    while (*s) {\n        charCount[*s - 'a']++;\n        s++;\n    }\n    int maxCount = 0;\n    for (int i = 0; i < 26; i++) {\n        if (charCount[i] != 0 ) {\n            maxCount ++;\n        }\n    }\n\n    return maxCount - 1;\n}", "buggy_code": "#include <cassert>\n#include <cstring>\n#include <iostream>\nint minRoundsToSameChar(const char* s)\n{\n    int charCount[26] = {0};\n    for (int i = 0; i < 26; i++) {\n        charCount[i] = 0;\n    }\n    while (*s) {\n        charCount[*s - 'a]++;\n        s++;\n    }\n    int maxCount = 0;\n    for (int i = 0; i < 26; i++) {\n        if (charCount[i] != 0 ) {\n            maxCount ++;\n        }\n    }\n    return maxCount - 1;\n}", "test": "int main() {\n    assert(minRoundsToSameChar(\"aab\") == 1);\n    assert(minRoundsToSameChar(\"abc\") == 2);\n    assert(minRoundsToSameChar(\"aaa\") == 0);\n    assert(minRoundsToSameChar(\"abab\") == 1);\n    assert(minRoundsToSameChar(\"zzzzz\") == 0);\n\n    return 0;\n}", "instruction": " the following faulty CPP code snippet and error type list. \nYour task is to select the error type of the code based on the error list provided\n\nYou only need to answer error type. Do not write anything else in your response. \n\nFor example, if the code snippet is missing a semicolon, Your output should be 'missing_colons'.\n\nfaulty code:\n\n```\n#include <cassert>\n#include <cstring>\n#include <iostream>\nint minRoundsToSameChar(const char* s)\n{\n    int charCount[26] = {0};\n    for (int i = 0; i < 26; i++) {\n        charCount[i] = 0;\n    }\n    while (*s) {\n        charCount[*s - 'a]++;\n        s++;\n    }\n    int maxCount = 0;\n    for (int i = 0; i < 26; i++) {\n        if (charCount[i] != 0 ) {\n            maxCount ++;\n        }\n    }\n    return maxCount - 1;\n}\n```\nerror type list:\n\n['illegal_comment', 'illegal_separation', 'missing_colons', 'misused ==and=', 'unclosed_parentheses', 'unclosed_string', 'faulty_indexing', 'function_error', 'illegal_keyword', 'undefined_methods', 'undefined_objects', 'algorithm_error', 'condition_error', 'operation_error', 'type_error', 'variable_error', 'double_bug', 'triple_bug', 'quadruple_bug', 'Misused Macro Definition', 'missing_backtick', 'misused_let', 'misused templte', 'Delayed Execution', 'Misused match', 'Misused := and =', 'Unused Variable', 'Misused === and ==', 'Misused =>', 'Misused Spread Operator', 'Misused begin/end', 'Missing $', 'illegal_indentation', 'Missing mut', 'Misused var and val', 'The digital leader is 0', 'Duplicate keys', 'struct_error', 'json_content_error']\n"}
{"question_id": "CPP/13", "category": "Reference", "subtype": "faulty_indexing", "level": "easy", "example": "* Examples:\n * count_coloring_methods(1,1) returns 1\n * count_coloring_methods(2,2) returns 2", "docstring": "* Counts the number of different coloring methods for n squares with m colors,\n * considering the requirement that adjacent squares and the first/last squares\n * must have different colors.\n * \n * @param n The number of squares.\n * @param m The number of colors.\n * @return The count of different coloring methods satisfying the specified conditions.\n *         The result is modulo 1000003.\n *", "canonical_solution": "#include <cassert>\n#include <iostream>\n\nint count_coloring_methods(int n, int m)\n\n{\n    int f[1111];\n    if (n == 1) return m;\n    if (n == 2) return static_cast<long long>(m) * (m - 1) % 1000003;\n    f[1] = m;\n    f[2] = static_cast<long long>(m) * (m - 1) % 1000003;\n    f[3] = static_cast<long long>(f[2]) * (m - 2) % 1000003;\n    for(int i = 4; i <= n; ++i) {\n        f[i] = (static_cast<long long>(f[i - 1]) * (m - 2) % 1000003 +\n                static_cast<long long>(f[i - 2]) * (m - 1) % 1000003) % 1000003;\n    }\n    return f[n];\n}", "buggy_code": "#include <cassert>\n#include <iostream>\nint count_coloring_methods(int n, int m)\n{\n    int f[1111];\n    if (n == 1) return m;\n    if (n == 2) return static_cast<long long>(m) * (m - 1) % 1000003;\n    f[1] = m;\n    f[2] = static_cast<long long>(m) * (m - 1) % 1000003;\n    f[3] = static_cast<long long>(f[2]) * (m - 2) % 1000003;\n    for(int i = 4; i <= n; ++i) {\n        f[i-1] = (static_cast<long long>(f[i - 1]) * (m - 2) % 1000003 +\n                static_cast<long long>(f[i - 2]) * (m - 1) % 1000003) % 1000003;\n    }\n    return f[n];\n}", "test": "int main() {\n    assert(count_coloring_methods(1, 1) == 1);\n    assert(count_coloring_methods(2, 2) == 2);\n    assert(count_coloring_methods(3, 3) == 6);\n    assert(count_coloring_methods(4, 2) == 2);\n    assert(count_coloring_methods(1000, 10) == 566585); // We don't have the expected result for this case\n\n    // Additional test cases\n    assert(count_coloring_methods(2, 3) == 6);\n    assert(count_coloring_methods(1000, 1000) == 67911);\n    assert(count_coloring_methods(999, 66) == 501817);\n    assert(count_coloring_methods(5, 3) == 30); // Example of an expected output\n\n    // std::cout << \"All tests passed!\\n\";\n    return 0;\n}", "instruction": " the following faulty CPP code snippet and error type list. \nYour task is to select the error type of the code based on the error list provided\n\nYou only need to answer error type. Do not write anything else in your response. \n\nFor example, if the code snippet is missing a semicolon, Your output should be 'missing_colons'.\n\nfaulty code:\n\n```\n#include <cassert>\n#include <iostream>\nint count_coloring_methods(int n, int m)\n{\n    int f[1111];\n    if (n == 1) return m;\n    if (n == 2) return static_cast<long long>(m) * (m - 1) % 1000003;\n    f[1] = m;\n    f[2] = static_cast<long long>(m) * (m - 1) % 1000003;\n    f[3] = static_cast<long long>(f[2]) * (m - 2) % 1000003;\n    for(int i = 4; i <= n; ++i) {\n        f[i-1] = (static_cast<long long>(f[i - 1]) * (m - 2) % 1000003 +\n                static_cast<long long>(f[i - 2]) * (m - 1) % 1000003) % 1000003;\n    }\n    return f[n];\n}\n```\nerror type list:\n\n['illegal_comment', 'illegal_separation', 'missing_colons', 'misused ==and=', 'unclosed_parentheses', 'unclosed_string', 'faulty_indexing', 'function_error', 'illegal_keyword', 'undefined_methods', 'undefined_objects', 'algorithm_error', 'condition_error', 'operation_error', 'type_error', 'variable_error', 'double_bug', 'triple_bug', 'quadruple_bug', 'Misused Macro Definition', 'missing_backtick', 'misused_let', 'misused templte', 'Delayed Execution', 'Misused match', 'Misused := and =', 'Unused Variable', 'Misused === and ==', 'Misused =>', 'Misused Spread Operator', 'Misused begin/end', 'Missing $', 'illegal_indentation', 'Missing mut', 'Misused var and val', 'The digital leader is 0', 'Duplicate keys', 'struct_error', 'json_content_error']\n"}
{"question_id": "CPP/14", "category": "Reference", "subtype": "faulty_indexing", "level": "easy", "example": "* Examples:\n *    >>> makeEqualAgain(3, (int[]){1, 2, 1})\n *    1\n *    >>> makeEqualAgain(5, (int[]){5, 5, 1, 5, 5})\n *    1", "docstring": "* You are given an array a of n integers. You can perform at most one operation where you\n * select three integers i, j, x (1 <= i <= j <= n) and replace all elements from a[i] to a[j] with x,\n * at a cost of (j - i + 1). Find the minimum cost to make all elements in the array equal.\n *", "canonical_solution": "#include <cstdio>\n#include <cassert>\n\nint makeEqualAgain(int n, int a[])\n\n{\n    int j = 0, p = 1, q = 0, c, d;\n    int k = n;\n    for (p = 1; p < k; p++) {\n        if (a[p] != a[p - 1])\n            break;\n    }\n    for (q = k - 1; q > p; q--) {\n        if (a[q] != a[p - 1])\n            break;\n    }\n    for (d = k - 2; d >= 0; d--) {\n        if (a[d] != a[d + 1])\n            break;\n    }\n    for (c = 0; c < d; c++) {\n        if (a[c] != a[c + 1])\n            break;\n    }\n    if (q - p + 1 < d - c + 1)\n        return q - p + 1;\n    else\n        return d - c + 1;\n}", "buggy_code": "#include <cstdio>\n#include <cassert>\nint makeEqualAgain(int n, int a[])\n{\n    int j = 0, p = 1, q = 0, c, d;\n    int k = n;\n    for (p = 1; p < k; p++) {\n        if (a[p] != a[p - 1])\n            break;\n    }\n    for (q = k - 1; q > p; q--) {\n        if (a[q-1] != a[p - 1])\n            break;\n    }\n    for (d = k - 2; d >= 0; d--) {\n        if (a[d] != a[d + 1])\n            break;\n    }\n    for (c = 0; c < d; c++) {\n        if (a[c] != a[c + 1])\n            break;\n    }\n    if (q - p + 1 < d - c + 1)\n        return q - p + 1;\n    else\n        return d - c + 1;\n}", "test": "int main() {\n    int a1[] = {1,2,3,4,5,1};\n    int a2[] = {1,1,1,1,1,1,1};\n    int a3[] = {8,8,8,1,2,8,8,8};\n    int a4[] = {1,2,3};\n    int a5[] = {4,3,2,7,1,1,3};\n    int a6[] = {9,9,2,9,2,5,5,5,3};\n    \n    assert(makeEqualAgain(6, a1) == 4);\n    assert(makeEqualAgain(7, a2) == 0);\n    assert(makeEqualAgain(8, a3) == 2);\n    assert(makeEqualAgain(3, a4) == 2);\n    assert(makeEqualAgain(7, a5) == 6);\n    assert(makeEqualAgain(9, a6) == 7);\n\n    int a7[] = {1, 2, 1};\n    int a8[] = {5, 5, 1, 5, 5};\n    int a9[] = {1, 1, 1, 1};\n    int a10[] = {2, 2, 2, 3, 2, 2};\n    int a11[] = {1};\n    int a12[] = {1, 2};\n    int a13[] = {1, 2, 2, 1};\n    int a14[] = {4, 4, 4, 3, 3, 4, 4};\n    int a15[] = {5, 4, 4, 4, 5, 5};\n    int a16[] = {1, 2, 1, 2, 1, 2, 1};\n    // Additional provided tests\n    assert(makeEqualAgain(3, a7) == 1);\n    assert(makeEqualAgain(5, a8) == 1);\n    assert(makeEqualAgain(4, a9) == 0);\n    assert(makeEqualAgain(6, a10) == 1);\n    assert(makeEqualAgain(1, a11) == 0);\n    assert(makeEqualAgain(2, a12) == 1);\n    assert(makeEqualAgain(4, a13) == 2);\n    assert(makeEqualAgain(7, a14) == 2);\n    assert(makeEqualAgain(6, a15) == 3);\n    assert(makeEqualAgain(7, a16) == 5);\n    \n    return 0;\n}", "instruction": " the following faulty CPP code snippet and error type list. \nYour task is to select the error type of the code based on the error list provided\n\nYou only need to answer error type. Do not write anything else in your response. \n\nFor example, if the code snippet is missing a semicolon, Your output should be 'missing_colons'.\n\nfaulty code:\n\n```\n#include <cstdio>\n#include <cassert>\nint makeEqualAgain(int n, int a[])\n{\n    int j = 0, p = 1, q = 0, c, d;\n    int k = n;\n    for (p = 1; p < k; p++) {\n        if (a[p] != a[p - 1])\n            break;\n    }\n    for (q = k - 1; q > p; q--) {\n        if (a[q-1] != a[p - 1])\n            break;\n    }\n    for (d = k - 2; d >= 0; d--) {\n        if (a[d] != a[d + 1])\n            break;\n    }\n    for (c = 0; c < d; c++) {\n        if (a[c] != a[c + 1])\n            break;\n    }\n    if (q - p + 1 < d - c + 1)\n        return q - p + 1;\n    else\n        return d - c + 1;\n}\n```\nerror type list:\n\n['illegal_comment', 'illegal_separation', 'missing_colons', 'misused ==and=', 'unclosed_parentheses', 'unclosed_string', 'faulty_indexing', 'function_error', 'illegal_keyword', 'undefined_methods', 'undefined_objects', 'algorithm_error', 'condition_error', 'operation_error', 'type_error', 'variable_error', 'double_bug', 'triple_bug', 'quadruple_bug', 'Misused Macro Definition', 'missing_backtick', 'misused_let', 'misused templte', 'Delayed Execution', 'Misused match', 'Misused := and =', 'Unused Variable', 'Misused === and ==', 'Misused =>', 'Misused Spread Operator', 'Misused begin/end', 'Missing $', 'illegal_indentation', 'Missing mut', 'Misused var and val', 'The digital leader is 0', 'Duplicate keys', 'struct_error', 'json_content_error']\n"}
{"question_id": "CPP/15", "category": "Reference", "subtype": "function_error", "level": "easy", "example": "* Examples:\n *   count_valid_coin_toss_sequences(1) returns 2\n *   count_valid_coin_toss_sequences(2) returns 3", "docstring": "* Count the number of valid coin toss sequences with no consecutive heads in n tosses.\n *\n * Parameters:\n * - n (int): The number of coin tosses.\n *\n * Returns:\n * - unsigned long long: The count of valid sequences.\n *", "canonical_solution": "#include <cassert>\n#include <cmath>\n#include <cstdio>\n#include <cstring>\n\nunsigned long long count_valid_coin_toss_sequences(int n)\n\n{\n    unsigned long long a[41][2];\n    a[1][0] = a[1][1] = 1;\n\n    for(int i = 2; i <= n; i++){\n        a[i][0] = a[i - 1][1] + a[i - 1][0];\n        a[i][1] = a[i - 1][0];\n    }\n\n    return a[n][0] + a[n][1];\n}", "buggy_code": "#include <cassert>\n#include <cmath>\n#include <cstdio>\n#include <cstring>\nunsigned long long count_valid_coin_toss_sequences(int *n)\n{\n    unsigned long long a[41][2];\n    a[1][0] = a[1][1] = 1;\n    for(int i = 2; i <= n; i++){\n        a[i][0] = a[i - 1][1] + a[i - 1][0];\n        a[i][1] = a[i - 1][0];\n    }\n    return a[n][0] + a[n][1];\n}", "test": "int main() {\n    assert(count_valid_coin_toss_sequences(1) == 2);\n    assert(count_valid_coin_toss_sequences(2) == 3);\n    assert(count_valid_coin_toss_sequences(3) == 5);\n    assert(count_valid_coin_toss_sequences(4) == 8); // Additional test\n    assert(count_valid_coin_toss_sequences(5) == 13); // Additional test\n    // Feel free to add more tests here\n    assert(count_valid_coin_toss_sequences(40) == 267914296ULL); // Additional test\n    assert(count_valid_coin_toss_sequences(39) == 165580141ULL);\n    assert(count_valid_coin_toss_sequences(38) == 102334155ULL);\n    // printf(\"All tests passed!\\n\");\n    return 0;\n}", "instruction": " the following faulty CPP code snippet and error type list. \nYour task is to select the error type of the code based on the error list provided\n\nYou only need to answer error type. Do not write anything else in your response. \n\nFor example, if the code snippet is missing a semicolon, Your output should be 'missing_colons'.\n\nfaulty code:\n\n```\n#include <cassert>\n#include <cmath>\n#include <cstdio>\n#include <cstring>\nunsigned long long count_valid_coin_toss_sequences(int *n)\n{\n    unsigned long long a[41][2];\n    a[1][0] = a[1][1] = 1;\n    for(int i = 2; i <= n; i++){\n        a[i][0] = a[i - 1][1] + a[i - 1][0];\n        a[i][1] = a[i - 1][0];\n    }\n    return a[n][0] + a[n][1];\n}\n```\nerror type list:\n\n['illegal_comment', 'illegal_separation', 'missing_colons', 'misused ==and=', 'unclosed_parentheses', 'unclosed_string', 'faulty_indexing', 'function_error', 'illegal_keyword', 'undefined_methods', 'undefined_objects', 'algorithm_error', 'condition_error', 'operation_error', 'type_error', 'variable_error', 'double_bug', 'triple_bug', 'quadruple_bug', 'Misused Macro Definition', 'missing_backtick', 'misused_let', 'misused templte', 'Delayed Execution', 'Misused match', 'Misused := and =', 'Unused Variable', 'Misused === and ==', 'Misused =>', 'Misused Spread Operator', 'Misused begin/end', 'Missing $', 'illegal_indentation', 'Missing mut', 'Misused var and val', 'The digital leader is 0', 'Duplicate keys', 'struct_error', 'json_content_error']\n"}
{"question_id": "CPP/16", "category": "Reference", "subtype": "function_error", "level": "easy", "example": "* Example:\n * >>> maxModeSum(3, {1, 2, 3})\n * 17\n * A sequence that reaches its maximum value is (3,2,3,1,2,2).", "docstring": "* Given n positive integers representing the count of each number from 1 to n,\n * find the maximum sum of the mode (most frequent element) for all prefixes of\n * a sequence constructed from these numbers. The mode is the largest number among\n * the most frequent elements in a sequence.\n *", "canonical_solution": "#include <cassert>\n#include <cstdio>\n\nlong long maxModeSum(int n, const int* counts)\n\n{\n    long long ans = 0;\n    int mx = 0;\n    long long f[100000];\n    for (int i = 0; i <= n; ++i) f[i] = 0;\n\n    for (int i = n; i > 0; --i) {\n        while (mx < counts[i - 1]) {\n            mx++;\n            f[mx] = f[mx - 1] + i;\n        }\n        ans += f[counts[i - 1]];\n    }\n    return ans;\n}", "buggy_code": "#include <cassert>\n#include <cstdio>\nlong long maxModeSum(int n, const int counts)\n{\n    long long ans = 0;\n    int mx = 0;\n    long long f[100000];\n    for (int i = 0; i <= n; ++i) f[i] = 0;\n    for (int i = n; i > 0; --i) {\n        while (mx < counts[i - 1]) {\n            mx++;\n            f[mx] = f[mx - 1] + i;\n        }\n        ans += f[counts[i - 1]];\n    }\n    return ans;\n}", "test": "int main() {\n    int a1[] = {1, 3, 2};\n    int a2[] = {4, 1, 2, 3};\n    int a3[] = {1, 1};\n    int a4[] = {1, 2, 3, 4, 5};\n    int a5[] = {100000};\n    int a6[] = {5, 3, 2, 4, 1};\n    int a7[] = {100000, 100000, 100000};\n    int a8[] = {2, 2, 5};\n    int a9[] = {4, 4, 4, 4};\n    int a10[] = {1, 2, 3, 4, 5, 6};\n    int a11[] = {3, 1, 2};\n\n    assert(maxModeSum(3, a1) == 17);\n    assert(maxModeSum(4, a2) == 37);\n    assert(maxModeSum(2, a3) == 4);\n    assert(maxModeSum(5, a4) == 75);\n    assert(maxModeSum(1, a5) == 100000);\n    assert(maxModeSum(5, a6) == 62);\n    assert(maxModeSum(3, a7) == 900000);\n    assert(maxModeSum(3, a8) == 27);\n    assert(maxModeSum(4, a9) == 64);\n    assert(maxModeSum(6, a10) == 126);\n    assert(maxModeSum(3, a11) == 16);\n    return 0;\n}", "instruction": " the following faulty CPP code snippet and error type list. \nYour task is to select the error type of the code based on the error list provided\n\nYou only need to answer error type. Do not write anything else in your response. \n\nFor example, if the code snippet is missing a semicolon, Your output should be 'missing_colons'.\n\nfaulty code:\n\n```\n#include <cassert>\n#include <cstdio>\nlong long maxModeSum(int n, const int counts)\n{\n    long long ans = 0;\n    int mx = 0;\n    long long f[100000];\n    for (int i = 0; i <= n; ++i) f[i] = 0;\n    for (int i = n; i > 0; --i) {\n        while (mx < counts[i - 1]) {\n            mx++;\n            f[mx] = f[mx - 1] + i;\n        }\n        ans += f[counts[i - 1]];\n    }\n    return ans;\n}\n```\nerror type list:\n\n['illegal_comment', 'illegal_separation', 'missing_colons', 'misused ==and=', 'unclosed_parentheses', 'unclosed_string', 'faulty_indexing', 'function_error', 'illegal_keyword', 'undefined_methods', 'undefined_objects', 'algorithm_error', 'condition_error', 'operation_error', 'type_error', 'variable_error', 'double_bug', 'triple_bug', 'quadruple_bug', 'Misused Macro Definition', 'missing_backtick', 'misused_let', 'misused templte', 'Delayed Execution', 'Misused match', 'Misused := and =', 'Unused Variable', 'Misused === and ==', 'Misused =>', 'Misused Spread Operator', 'Misused begin/end', 'Missing $', 'illegal_indentation', 'Missing mut', 'Misused var and val', 'The digital leader is 0', 'Duplicate keys', 'struct_error', 'json_content_error']\n"}
{"question_id": "CPP/17", "category": "Reference", "subtype": "illegal_keyword", "level": "easy", "example": "* Examples:\n *   >>> find_longest_consecutive_ones_length(7)\n *   3", "docstring": "* Find the length of the longest consecutive sequence of 1s in the binary \n * representation of a non-negative integer.\n *\n * Parameters:\n * - n (unsigned long long): A non-negative integer (0 ≤ n ≤ 2^64 - 1).\n *\n * Returns:\n * - int: The length of the longest consecutive sequence of 1s in the binary \n *        representation of the given integer.\n *", "canonical_solution": "#include <cassert>\n#include <cmath>\n#include <cstdio>\n#include <cstring>\n\nint find_longest_consecutive_ones_length(unsigned long long n)\n\n{\n    int max_length = 0;\n    int current_length = 0;\n    while (n) {\n        if (n & 1) {\n            current_length++;\n        } else {\n            if (current_length > max_length) {\n                max_length = current_length;\n            }\n            current_length = 0;\n        }\n        n >>= 1;\n    }\n    if (current_length > max_length) {\n        max_length = current_length;\n    }\n    return max_length;\n}", "buggy_code": "#include <cassert>\n#include <cmath>\n#include <cstdio>\n#include <cstring>\nint find_longest_consecutive_ones_length(unsigned long long n)\n{\n    int max_length = 0;\n    int return = 0;\n    while (n) {\n        if (n & 1) {\n            current_length++;\n        } else {\n            if (current_length > max_length) {\n                max_length = current_length;\n            }\n            current_length = 0;\n        }\n        n >>= 1;\n    }\n    if (current_length > max_length) {\n        max_length = current_length;\n    }\n    return max_length;\n}", "test": "int main()\n{\n    assert(find_longest_consecutive_ones_length(7) == 3);\n    assert(find_longest_consecutive_ones_length(13) == 2);\n    assert(find_longest_consecutive_ones_length(12345) == 3); // New test sample\n    assert(find_longest_consecutive_ones_length(0b11011101111) == 4); // New test sample using binary literal for clarity\n    assert(find_longest_consecutive_ones_length(0xFFFFFFFF) == 32); // New test sample: all ones for a 32-bit number\n    assert(find_longest_consecutive_ones_length(0) == 0); // New test sample: no ones in a zero\n\n    // printf(\"All tests passed!\\n\"); // In C++, you might use std::cout, but it is commented out as per the original code.\n    return 0;\n}", "instruction": " the following faulty CPP code snippet and error type list. \nYour task is to select the error type of the code based on the error list provided\n\nYou only need to answer error type. Do not write anything else in your response. \n\nFor example, if the code snippet is missing a semicolon, Your output should be 'missing_colons'.\n\nfaulty code:\n\n```\n#include <cassert>\n#include <cmath>\n#include <cstdio>\n#include <cstring>\nint find_longest_consecutive_ones_length(unsigned long long n)\n{\n    int max_length = 0;\n    int return = 0;\n    while (n) {\n        if (n & 1) {\n            current_length++;\n        } else {\n            if (current_length > max_length) {\n                max_length = current_length;\n            }\n            current_length = 0;\n        }\n        n >>= 1;\n    }\n    if (current_length > max_length) {\n        max_length = current_length;\n    }\n    return max_length;\n}\n```\nerror type list:\n\n['illegal_comment', 'illegal_separation', 'missing_colons', 'misused ==and=', 'unclosed_parentheses', 'unclosed_string', 'faulty_indexing', 'function_error', 'illegal_keyword', 'undefined_methods', 'undefined_objects', 'algorithm_error', 'condition_error', 'operation_error', 'type_error', 'variable_error', 'double_bug', 'triple_bug', 'quadruple_bug', 'Misused Macro Definition', 'missing_backtick', 'misused_let', 'misused templte', 'Delayed Execution', 'Misused match', 'Misused := and =', 'Unused Variable', 'Misused === and ==', 'Misused =>', 'Misused Spread Operator', 'Misused begin/end', 'Missing $', 'illegal_indentation', 'Missing mut', 'Misused var and val', 'The digital leader is 0', 'Duplicate keys', 'struct_error', 'json_content_error']\n"}
{"question_id": "CPP/18", "category": "Reference", "subtype": "illegal_keyword", "level": "easy", "example": "For example:\n    >>> countBalancedSubsequences(2, 2, 2)\n    2", "docstring": "Given three integers n, m, and k, find the number of sequences consisting of n '(' and m ')',\nsuch that the longest balanced subsequence is of length 2 * k. The result should be calculated modulo 1,000,000,007 (10^9 + 7).", "canonical_solution": "#include <cassert>\n\nlong long countBalancedSubsequences(long long n, long long m, long long k)\n\n{\n    const long long P = static_cast<long long>(1e9) + 7;\n    static long long C[4001][4001] = {0};\n\n    if (C[0][0] == 0) {\n        for (long long i = 0; i <= 4000; i++) C[i][0] = 1;\n        for (long long i = 1; i <= 4000; i++)\n            for (long long j = 1; j <= i; j++)\n                C[i][j] = (C[i - 1][j - 1] + C[i - 1][j]) % P;\n    }\n\n    if (k > n || k > m) return 0;\n    return (C[n + m][k] - C[n + m][k - 1] + P) % P;\n}", "buggy_code": "#include <cassert>\nlong long countBalancedSubsequences(long long n, long long m, long long k)\n{\n    const long long P = static_cast<long long>(1e9) + 7;\n    static long long const[4001][4001] = {0};\n    if (C[0][0] == 0) {\n        for (long long i = 0; i <= 4000; i++) C[i][0] = 1;\n        for (long long i = 1; i <= 4000; i++)\n            for (long long j = 1; j <= i; j++)\n                C[i][j] = (C[i - 1][j - 1] + C[i - 1][j]) % P;\n    }\n    if (k > n || k > m) return 0;\n    return (C[n + m][k] - C[n + m][k - 1] + P) % P;\n}", "test": "int main() {\n    assert(countBalancedSubsequences(2, 2, 2) == 2);\n    assert(countBalancedSubsequences(3, 2, 3) == 0);\n    assert(countBalancedSubsequences(3, 2, 1) == 4);\n    assert(countBalancedSubsequences(4, 3, 2) == 14);\n    assert(countBalancedSubsequences(5, 5, 2) == 35);\n    assert(countBalancedSubsequences(6, 1, 1) == 6);\n    assert(countBalancedSubsequences(1, 6, 1) == 6);\n    assert(countBalancedSubsequences(7, 2, 2) == 27);\n    assert(countBalancedSubsequences(8, 3, 3) == 110);\n    assert(countBalancedSubsequences(10, 10, 5) == 10659);\n    assert(countBalancedSubsequences(20, 20, 10) == 574221648);\n    assert(countBalancedSubsequences(2000, 2000, 1000) == 854104531);\n    assert(countBalancedSubsequences(2000, 1999, 1000) == 334874485);\n    assert(countBalancedSubsequences(2000, 2000, 1999) == 259428024);\n    return 0;\n}", "instruction": " the following faulty CPP code snippet and error type list. \nYour task is to select the error type of the code based on the error list provided\n\nYou only need to answer error type. Do not write anything else in your response. \n\nFor example, if the code snippet is missing a semicolon, Your output should be 'missing_colons'.\n\nfaulty code:\n\n```\n#include <cassert>\nlong long countBalancedSubsequences(long long n, long long m, long long k)\n{\n    const long long P = static_cast<long long>(1e9) + 7;\n    static long long const[4001][4001] = {0};\n    if (C[0][0] == 0) {\n        for (long long i = 0; i <= 4000; i++) C[i][0] = 1;\n        for (long long i = 1; i <= 4000; i++)\n            for (long long j = 1; j <= i; j++)\n                C[i][j] = (C[i - 1][j - 1] + C[i - 1][j]) % P;\n    }\n    if (k > n || k > m) return 0;\n    return (C[n + m][k] - C[n + m][k - 1] + P) % P;\n}\n```\nerror type list:\n\n['illegal_comment', 'illegal_separation', 'missing_colons', 'misused ==and=', 'unclosed_parentheses', 'unclosed_string', 'faulty_indexing', 'function_error', 'illegal_keyword', 'undefined_methods', 'undefined_objects', 'algorithm_error', 'condition_error', 'operation_error', 'type_error', 'variable_error', 'double_bug', 'triple_bug', 'quadruple_bug', 'Misused Macro Definition', 'missing_backtick', 'misused_let', 'misused templte', 'Delayed Execution', 'Misused match', 'Misused := and =', 'Unused Variable', 'Misused === and ==', 'Misused =>', 'Misused Spread Operator', 'Misused begin/end', 'Missing $', 'illegal_indentation', 'Missing mut', 'Misused var and val', 'The digital leader is 0', 'Duplicate keys', 'struct_error', 'json_content_error']\n"}
{"question_id": "CPP/19", "category": "Reference", "subtype": "undefined_methods", "level": "easy", "example": ">>> countPermutations(2, 1, [1, 2])\n    2", "docstring": "Given a permutation q of n elements and an integer k, find the number of permutations p of n elements such that f(p) = q, where f(p) is the lexicographically smallest permutation that can be obtained by dividing p into exactly k non-empty contiguous segments and sorting each segment (i.e., choose k-1 breakpoints 1 <= x_1 < x_2 < ... < x_{k-1} < n, and divide it into [1, x_1], (x_1, x_2], ..., (x_{k-1}, n]). The result should be modulo 998244353.", "canonical_solution": "#include <bits/stdc++.h>\n\nint countPermutations(int n, int k, int qq[])\n\n{\n    const int N = 505, P = 998244353;\n    int q[N], m, dp[N][N], jc[N], f[N], ans;\n    memset(q, 0, sizeof(q));\n    memset(dp, 0, sizeof(dp));\n    memset(jc, 0, sizeof(jc));\n    memset(f, 0, sizeof(f));\n    ans = 0;\n\n    for (int i = 1; i <= n; i++)\n        q[i] = qq[i - 1];\n    dp[0][0] = f[0] = 1;\n    for (int i = jc[0] = 1; i <= n; i++)\n        jc[i] = 1LL * jc[i - 1] * i % P;\n    for (int i = 1; i <= n; i++)\n    {\n        f[i] = jc[i];\n        for (int j = 1; j < i; j++)\n            f[i] = (f[i] + P - 1LL * f[j] * jc[i - j] % P) % P;\n    }\n    for (int i = 1; i <= n; i++)\n    {\n        for (int j = 0; j < i; j++)\n            for (int k = 1; k <= n; k++)\n                dp[i][k] = (dp[i][k] + dp[j][k - 1] * 1LL * f[i - j] % P) % P;\n    }\n    m = 0;\n    for (int i = 1; i <= n; i++)\n        if (q[i] > q[i + 1])\n        {\n            m = i;\n            break;\n        }\n    if (m == n)\n    {\n        for (int i = k; i <= n; i++)\n            ans = (ans + dp[n][i]) % P;\n    }\n    else\n    {\n        for (int i = m + 1; i <= n; i++)\n        {\n            if (i != m + 1 && (q[i - 1] > q[i] || q[i] < q[m]))\n                break;\n            int c = k + i - n - 1;\n            if (c >= 0)\n                ans = (ans + dp[m][c] * 1LL * jc[i - m - 1] % P) % P;\n        }\n    }\n    return ans;\n}", "buggy_code": "int countPermutations(int n, int k, int qq[])\n{\n    const int N = 505, P = 998244353;\n    int q[N], m, dp[N][N], jc[N], f[N], ans;\n    memset(q, 0, sizeof(q));\n    memset(dp, 0, sizeof(dp));\n    memset(jc, 0, sizeof(jc));\n    memset(f, 0, sizeof(f));\n    ans = 0;\n    for (int i = 1; i <= n; i++)\n        q[i] = qq[i - 1];\n    dp[0][0] = f[0] = 1;\n    for (int i = jc[0] = 1; i <= n; i++)\n        jc[i] = 1LL * jc[i - 1] * i % P;\n    for (int i = 1; i <= n; i++)\n    {\n        f[i] = jc[i];\n        for (int j = 1; j < i; j++)\n            f[i] = (f[i] + P - 1LL * f[j] * jc[i - j] % P) % P;\n    }\n    for (int i = 1; i <= n; i++)\n    {\n        for (int j = 0; j < i; j++)\n            for (int k = 1; k <= n; k++)\n                dp[i][k] = (dp[i][k] + dp[j][k - 1] * 1LL * f[i - j] % P) % P;\n    }\n    m = 0;\n    for (int i = 1; i <= n; i++)\n        if (q[i] > q[i + 1])\n        {\n            m = i;\n            break;\n        }\n    if (m == n)\n    {\n        for (int i = k; i <= n; i++)\n            ans = (ans + dp[n][i]) % P;\n    }\n    else\n    {\n        for (int i = m + 1; i <= n; i++)\n        {\n            if (i != m + 1 && (q[i - 1] > q[i] || q[i] < q[m]))\n                break;\n            int c = k + i - n - 1;\n            if (c >= 0)\n                ans = (ans + dp[m][c] * 1LL * jc[i - m - 1] % P) % P;\n        }\n    }\n    return ans;\n}", "test": "int main() {\n    int q1[] = {1, 2};\n    assert(countPermutations(2, 1, q1) == 2);\n\n    int q2[] = {3, 1, 2};\n    assert(countPermutations(3, 3, q2) == 1);\n\n    int q3[] = {1, 2, 3, 6, 5, 4};\n    assert(countPermutations(6, 3, q3) == 13);\n\n    int q4[] = {1, 2, 3, 4, 5, 6};\n    assert(countPermutations(6, 1, q4) == 720);\n\n    int q5[] = {1, 2, 5, 3, 4, 5};\n    assert(countPermutations(6, 3, q5) == 0);\n\n    int q6[] = {1, 2, 3, 4, 5, 6, 7, 8, 9};\n    assert(countPermutations(9, 9, q6) == 1);\n\n    int q7[] = {1, 2, 3, 4, 5, 6, 7, 9, 8};\n    assert(countPermutations(9, 2, q7) == 29093);\n    return 0;}", "instruction": " the following faulty CPP code snippet and error type list. \nYour task is to select the error type of the code based on the error list provided\n\nYou only need to answer error type. Do not write anything else in your response. \n\nFor example, if the code snippet is missing a semicolon, Your output should be 'missing_colons'.\n\nfaulty code:\n\n```\nint countPermutations(int n, int k, int qq[])\n{\n    const int N = 505, P = 998244353;\n    int q[N], m, dp[N][N], jc[N], f[N], ans;\n    memset(q, 0, sizeof(q));\n    memset(dp, 0, sizeof(dp));\n    memset(jc, 0, sizeof(jc));\n    memset(f, 0, sizeof(f));\n    ans = 0;\n    for (int i = 1; i <= n; i++)\n        q[i] = qq[i - 1];\n    dp[0][0] = f[0] = 1;\n    for (int i = jc[0] = 1; i <= n; i++)\n        jc[i] = 1LL * jc[i - 1] * i % P;\n    for (int i = 1; i <= n; i++)\n    {\n        f[i] = jc[i];\n        for (int j = 1; j < i; j++)\n            f[i] = (f[i] + P - 1LL * f[j] * jc[i - j] % P) % P;\n    }\n    for (int i = 1; i <= n; i++)\n    {\n        for (int j = 0; j < i; j++)\n            for (int k = 1; k <= n; k++)\n                dp[i][k] = (dp[i][k] + dp[j][k - 1] * 1LL * f[i - j] % P) % P;\n    }\n    m = 0;\n    for (int i = 1; i <= n; i++)\n        if (q[i] > q[i + 1])\n        {\n            m = i;\n            break;\n        }\n    if (m == n)\n    {\n        for (int i = k; i <= n; i++)\n            ans = (ans + dp[n][i]) % P;\n    }\n    else\n    {\n        for (int i = m + 1; i <= n; i++)\n        {\n            if (i != m + 1 && (q[i - 1] > q[i] || q[i] < q[m]))\n                break;\n            int c = k + i - n - 1;\n            if (c >= 0)\n                ans = (ans + dp[m][c] * 1LL * jc[i - m - 1] % P) % P;\n        }\n    }\n    return ans;\n}\n```\nerror type list:\n\n['illegal_comment', 'illegal_separation', 'missing_colons', 'misused ==and=', 'unclosed_parentheses', 'unclosed_string', 'faulty_indexing', 'function_error', 'illegal_keyword', 'undefined_methods', 'undefined_objects', 'algorithm_error', 'condition_error', 'operation_error', 'type_error', 'variable_error', 'double_bug', 'triple_bug', 'quadruple_bug', 'Misused Macro Definition', 'missing_backtick', 'misused_let', 'misused templte', 'Delayed Execution', 'Misused match', 'Misused := and =', 'Unused Variable', 'Misused === and ==', 'Misused =>', 'Misused Spread Operator', 'Misused begin/end', 'Missing $', 'illegal_indentation', 'Missing mut', 'Misused var and val', 'The digital leader is 0', 'Duplicate keys', 'struct_error', 'json_content_error']\n"}
{"question_id": "CPP/20", "category": "Reference", "subtype": "undefined_objects", "level": "easy", "example": ">>> countPermutations(2, 1, [1, 2])\n    2", "docstring": "Given a permutation q of n elements and an integer k, find the number of permutations p of n elements such that f(p) = q, where f(p) is the lexicographically smallest permutation that can be obtained by dividing p into exactly k non-empty contiguous segments and sorting each segment (i.e., choose k-1 breakpoints 1 <= x_1 < x_2 < ... < x_{k-1} < n, and divide it into [1, x_1], (x_1, x_2], ..., (x_{k-1}, n]). The result should be modulo 998244353.", "canonical_solution": "#include <bits/stdc++.h>\n\nint countPermutations(int n, int k, int qq[])\n\n{\n    const int N = 505, P = 998244353;\n    int q[N], m, dp[N][N], jc[N], f[N], ans;\n    memset(q, 0, sizeof(q));\n    memset(dp, 0, sizeof(dp));\n    memset(jc, 0, sizeof(jc));\n    memset(f, 0, sizeof(f));\n    ans = 0;\n\n    for (int i = 1; i <= n; i++)\n        q[i] = qq[i - 1];\n    dp[0][0] = f[0] = 1;\n    for (int i = jc[0] = 1; i <= n; i++)\n        jc[i] = 1LL * jc[i - 1] * i % P;\n    for (int i = 1; i <= n; i++)\n    {\n        f[i] = jc[i];\n        for (int j = 1; j < i; j++)\n            f[i] = (f[i] + P - 1LL * f[j] * jc[i - j] % P) % P;\n    }\n    for (int i = 1; i <= n; i++)\n    {\n        for (int j = 0; j < i; j++)\n            for (int k = 1; k <= n; k++)\n                dp[i][k] = (dp[i][k] + dp[j][k - 1] * 1LL * f[i - j] % P) % P;\n    }\n    m = 0;\n    for (int i = 1; i <= n; i++)\n        if (q[i] > q[i + 1])\n        {\n            m = i;\n            break;\n        }\n    if (m == n)\n    {\n        for (int i = k; i <= n; i++)\n            ans = (ans + dp[n][i]) % P;\n    }\n    else\n    {\n        for (int i = m + 1; i <= n; i++)\n        {\n            if (i != m + 1 && (q[i - 1] > q[i] || q[i] < q[m]))\n                break;\n            int c = k + i - n - 1;\n            if (c >= 0)\n                ans = (ans + dp[m][c] * 1LL * jc[i - m - 1] % P) % P;\n        }\n    }\n    return ans;\n}", "buggy_code": "#include <bits/stdc++.h>\nint countPermutations(int n, int k, int qq[])\n{\n    int q[N], m, dp[N][N], jc[N], f[N], ans;\n    memset(q, 0, sizeof(q));\n    memset(dp, 0, sizeof(dp));\n    memset(jc, 0, sizeof(jc));\n    memset(f, 0, sizeof(f));\n    ans = 0;\n    for (int i = 1; i <= n; i++)\n        q[i] = qq[i - 1];\n    dp[0][0] = f[0] = 1;\n    for (int i = jc[0] = 1; i <= n; i++)\n        jc[i] = 1LL * jc[i - 1] * i % P;\n    for (int i = 1; i <= n; i++)\n    {\n        f[i] = jc[i];\n        for (int j = 1; j < i; j++)\n            f[i] = (f[i] + P - 1LL * f[j] * jc[i - j] % P) % P;\n    }\n    for (int i = 1; i <= n; i++)\n    {\n        for (int j = 0; j < i; j++)\n            for (int k = 1; k <= n; k++)\n                dp[i][k] = (dp[i][k] + dp[j][k - 1] * 1LL * f[i - j] % P) % P;\n    }\n    m = 0;\n    for (int i = 1; i <= n; i++)\n        if (q[i] > q[i + 1])\n        {\n            m = i;\n            break;\n        }\n    if (m == n)\n    {\n        for (int i = k; i <= n; i++)\n            ans = (ans + dp[n][i]) % P;\n    }\n    else\n    {\n        for (int i = m + 1; i <= n; i++)\n        {\n            if (i != m + 1 && (q[i - 1] > q[i] || q[i] < q[m]))\n                break;\n            int c = k + i - n - 1;\n            if (c >= 0)\n                ans = (ans + dp[m][c] * 1LL * jc[i - m - 1] % P) % P;\n        }\n    }\n    return ans;\n}", "test": "int main() {\n    int q1[] = {1, 2};\n    assert(countPermutations(2, 1, q1) == 2);\n\n    int q2[] = {3, 1, 2};\n    assert(countPermutations(3, 3, q2) == 1);\n\n    int q3[] = {1, 2, 3, 6, 5, 4};\n    assert(countPermutations(6, 3, q3) == 13);\n\n    int q4[] = {1, 2, 3, 4, 5, 6};\n    assert(countPermutations(6, 1, q4) == 720);\n\n    int q5[] = {1, 2, 5, 3, 4, 5};\n    assert(countPermutations(6, 3, q5) == 0);\n\n    int q6[] = {1, 2, 3, 4, 5, 6, 7, 8, 9};\n    assert(countPermutations(9, 9, q6) == 1);\n\n    int q7[] = {1, 2, 3, 4, 5, 6, 7, 9, 8};\n    assert(countPermutations(9, 2, q7) == 29093);\n    return 0;}", "instruction": " the following faulty CPP code snippet and error type list. \nYour task is to select the error type of the code based on the error list provided\n\nYou only need to answer error type. Do not write anything else in your response. \n\nFor example, if the code snippet is missing a semicolon, Your output should be 'missing_colons'.\n\nfaulty code:\n\n```\n#include <bits/stdc++.h>\nint countPermutations(int n, int k, int qq[])\n{\n    int q[N], m, dp[N][N], jc[N], f[N], ans;\n    memset(q, 0, sizeof(q));\n    memset(dp, 0, sizeof(dp));\n    memset(jc, 0, sizeof(jc));\n    memset(f, 0, sizeof(f));\n    ans = 0;\n    for (int i = 1; i <= n; i++)\n        q[i] = qq[i - 1];\n    dp[0][0] = f[0] = 1;\n    for (int i = jc[0] = 1; i <= n; i++)\n        jc[i] = 1LL * jc[i - 1] * i % P;\n    for (int i = 1; i <= n; i++)\n    {\n        f[i] = jc[i];\n        for (int j = 1; j < i; j++)\n            f[i] = (f[i] + P - 1LL * f[j] * jc[i - j] % P) % P;\n    }\n    for (int i = 1; i <= n; i++)\n    {\n        for (int j = 0; j < i; j++)\n            for (int k = 1; k <= n; k++)\n                dp[i][k] = (dp[i][k] + dp[j][k - 1] * 1LL * f[i - j] % P) % P;\n    }\n    m = 0;\n    for (int i = 1; i <= n; i++)\n        if (q[i] > q[i + 1])\n        {\n            m = i;\n            break;\n        }\n    if (m == n)\n    {\n        for (int i = k; i <= n; i++)\n            ans = (ans + dp[n][i]) % P;\n    }\n    else\n    {\n        for (int i = m + 1; i <= n; i++)\n        {\n            if (i != m + 1 && (q[i - 1] > q[i] || q[i] < q[m]))\n                break;\n            int c = k + i - n - 1;\n            if (c >= 0)\n                ans = (ans + dp[m][c] * 1LL * jc[i - m - 1] % P) % P;\n        }\n    }\n    return ans;\n}\n```\nerror type list:\n\n['illegal_comment', 'illegal_separation', 'missing_colons', 'misused ==and=', 'unclosed_parentheses', 'unclosed_string', 'faulty_indexing', 'function_error', 'illegal_keyword', 'undefined_methods', 'undefined_objects', 'algorithm_error', 'condition_error', 'operation_error', 'type_error', 'variable_error', 'double_bug', 'triple_bug', 'quadruple_bug', 'Misused Macro Definition', 'missing_backtick', 'misused_let', 'misused templte', 'Delayed Execution', 'Misused match', 'Misused := and =', 'Unused Variable', 'Misused === and ==', 'Misused =>', 'Misused Spread Operator', 'Misused begin/end', 'Missing $', 'illegal_indentation', 'Missing mut', 'Misused var and val', 'The digital leader is 0', 'Duplicate keys', 'struct_error', 'json_content_error']\n"}
{"question_id": "CPP/21", "category": "Logic", "subtype": "algorithm_error", "level": "medium", "example": "* Examples:\n * >>> process_request(1)\n * 1\n * >>> process_request(10)\n * 6266", "docstring": "* Calculates the factorial of N modulo 10007.\n * \n * Parameters:\n * - N (int): An integer representing the input value (N <= 10000).\n * \n * Returns:\n * int: The result after calculating the factorial of N and\n * taking the modulo 10007.\n *", "canonical_solution": "#include <cassert>\n#include <cmath>\n#include <cstdio>\n#include <cstring>\n\nint process_request(int n)\n\n{\n    int a[10010];\n    a[0] = 1;\n    a[1] = 1;\n    for (register int i = 2; i <= 10000; i++) {\n        a[i] = (a[i - 1] * i) % 10007;\n    }\n    return a[n];\n}", "buggy_code": "#include <cassert>\n#include <cmath>\n#include <cstdio>\n#include <cstring>\nint process_request(int n)\n{\n    int a[10010];\n    a[0] = 1;\n    a[1] = 1;\n    for (register int i = 2; i <= 10000; i++) {\n        a[i] = (a[i-1] + i) % 10007;\n    }\n    return a[n];\n}", "test": "int main()\n{\n    assert(process_request(0) == 1); // Added test for boundary condition\n    assert(process_request(1) == 1);\n    assert(process_request(2) == 2);\n    assert(process_request(3) == 6);\n    assert(process_request(4) == 24);\n    assert(process_request(10) == 6266); // 10! % 10007 = 3628800 % 10007 = 6266\n    assert(process_request(10000) == 6991); // Added a test for upper boundary condition\n    // printf(\"All tests passed.\\n\");\n    return 0;\n}", "instruction": " the following faulty CPP code snippet and error type list. \nYour task is to select the error type of the code based on the error list provided\n\nYou only need to answer error type. Do not write anything else in your response. \n\nFor example, if the code snippet is missing a semicolon, Your output should be 'missing_colons'.\n\nfaulty code:\n\n```\n#include <cassert>\n#include <cmath>\n#include <cstdio>\n#include <cstring>\nint process_request(int n)\n{\n    int a[10010];\n    a[0] = 1;\n    a[1] = 1;\n    for (register int i = 2; i <= 10000; i++) {\n        a[i] = (a[i-1] + i) % 10007;\n    }\n    return a[n];\n}\n```\nerror type list:\n\n['illegal_comment', 'illegal_separation', 'missing_colons', 'misused ==and=', 'unclosed_parentheses', 'unclosed_string', 'faulty_indexing', 'function_error', 'illegal_keyword', 'undefined_methods', 'undefined_objects', 'algorithm_error', 'condition_error', 'operation_error', 'type_error', 'variable_error', 'double_bug', 'triple_bug', 'quadruple_bug', 'Misused Macro Definition', 'missing_backtick', 'misused_let', 'misused templte', 'Delayed Execution', 'Misused match', 'Misused := and =', 'Unused Variable', 'Misused === and ==', 'Misused =>', 'Misused Spread Operator', 'Misused begin/end', 'Missing $', 'illegal_indentation', 'Missing mut', 'Misused var and val', 'The digital leader is 0', 'Duplicate keys', 'struct_error', 'json_content_error']\n"}
{"question_id": "CPP/22", "category": "Logic", "subtype": "algorithm_error", "level": "easy", "example": ">>> hamming_distance(1,2)\n\t2", "docstring": "Calculate the Hamming distance between two integers in binary representation.\n​    Parameters:\n- x (int): The first positive integer (x <= 1,000,000,000).\n- y (int): The second positive integer (y <= 1,000,000,000).\n​    Returns:\n​    int: The Hamming distance between x and y, i.e., the number of bits that need to be flipped\n​         to transform x into y in binary.", "canonical_solution": "#include <bits/stdc++.h>\n\nint hamming_distance(int x, int y)\n\n{\n    int distance = 0;\n    int xor_result = x ^ y;\n    while (xor_result) {\n        if (xor_result & 1) {\n            distance++;\n        }\n        xor_result >>= 1;\n    }\n    return distance;\n}", "buggy_code": "#include <bits/stdc++.h>\nint hamming_distance(int x, int y)\n{\n    int distance = 1;\n    int xor_result = x ^ y;\n    while (xor_result) {\n        if (xor_result & 1) {\n            distance++;\n        }\n        xor_result >>= 1;\n    }\n    return distance;\n}", "test": "int main() {\n    assert(hamming_distance(1, 2) == 2); // 01 and 10 have 2 different bits\n    assert(hamming_distance(4, 7) == 2); // 100 and 111 have 2 different bits\n    assert(hamming_distance(25, 30) == 3); // Additional test: 11001 and 11110 have 3 different bits\n    assert(hamming_distance(0, 0) == 0); // Additional test: Same numbers have 0 different bits\n    assert(hamming_distance(0xFFFFFFF, 0x0000000) == 28); // Additional test: Max unsigned int and 0 have 32 different bits\n    return 0;\n}", "instruction": " the following faulty CPP code snippet and error type list. \nYour task is to select the error type of the code based on the error list provided\n\nYou only need to answer error type. Do not write anything else in your response. \n\nFor example, if the code snippet is missing a semicolon, Your output should be 'missing_colons'.\n\nfaulty code:\n\n```\n#include <bits/stdc++.h>\nint hamming_distance(int x, int y)\n{\n    int distance = 1;\n    int xor_result = x ^ y;\n    while (xor_result) {\n        if (xor_result & 1) {\n            distance++;\n        }\n        xor_result >>= 1;\n    }\n    return distance;\n}\n```\nerror type list:\n\n['illegal_comment', 'illegal_separation', 'missing_colons', 'misused ==and=', 'unclosed_parentheses', 'unclosed_string', 'faulty_indexing', 'function_error', 'illegal_keyword', 'undefined_methods', 'undefined_objects', 'algorithm_error', 'condition_error', 'operation_error', 'type_error', 'variable_error', 'double_bug', 'triple_bug', 'quadruple_bug', 'Misused Macro Definition', 'missing_backtick', 'misused_let', 'misused templte', 'Delayed Execution', 'Misused match', 'Misused := and =', 'Unused Variable', 'Misused === and ==', 'Misused =>', 'Misused Spread Operator', 'Misused begin/end', 'Missing $', 'illegal_indentation', 'Missing mut', 'Misused var and val', 'The digital leader is 0', 'Duplicate keys', 'struct_error', 'json_content_error']\n"}
{"question_id": "CPP/23", "category": "Logic", "subtype": "algorithm_error", "level": "easy", "example": "* Usage:\n *   count_odd_numbers(5, 1, 4, 3, 2, 5) should return 3", "docstring": "* Count the number of odd integers in a given list of numbers.\n * Parameters:\n * - count (int): The number of integers to evaluate.\n * - ... (int): A sequence of integers.\n * Returns:\n *   int: The count of odd numbers in the input list.", "canonical_solution": "#include <assert.h>\n#include <stdarg.h>\n\n\nint count_odd_numbers(int count, ...)\n\n{\n    va_list args;\n    va_start(args, count);\n    int ans = 0;\n    for (int i = 0; i < count; i++) {\n        int num = va_arg(args, int);\n        if (num & 1) {\n            ans++;\n        }\n    }\n    va_end(args);\n    return ans;\n}", "buggy_code": "#include <assert.h>\n#include <stdarg.h>\nint count_odd_numbers(int count, ...)\n{\n    va_list args;\n    va_start(args, count);\n    int ans = 0;\n    for (int i = 1; i < count; i++) {\n        int num = va_arg(args, int);\n        if (num & 1) {\n            ans++;\n        }\n    }\n    va_end(args);\n    return ans;\n}", "test": "int main() {\n    assert(count_odd_numbers(5, 1, 4, 3, 2, 5) == 3);\n    assert(count_odd_numbers(4, 2, 2, 0, 0) == 0);\n    assert(count_odd_numbers(6, 7, 7, 8, 1, 9, 10) == 4); // Additional Test Sample\n    // Uncomment the following line to print a success message\n    // std::printf(\"All tests passed!\\n\");\n    return 0;\n}", "instruction": " the following faulty CPP code snippet and error type list. \nYour task is to select the error type of the code based on the error list provided\n\nYou only need to answer error type. Do not write anything else in your response. \n\nFor example, if the code snippet is missing a semicolon, Your output should be 'missing_colons'.\n\nfaulty code:\n\n```\n#include <assert.h>\n#include <stdarg.h>\nint count_odd_numbers(int count, ...)\n{\n    va_list args;\n    va_start(args, count);\n    int ans = 0;\n    for (int i = 1; i < count; i++) {\n        int num = va_arg(args, int);\n        if (num & 1) {\n            ans++;\n        }\n    }\n    va_end(args);\n    return ans;\n}\n```\nerror type list:\n\n['illegal_comment', 'illegal_separation', 'missing_colons', 'misused ==and=', 'unclosed_parentheses', 'unclosed_string', 'faulty_indexing', 'function_error', 'illegal_keyword', 'undefined_methods', 'undefined_objects', 'algorithm_error', 'condition_error', 'operation_error', 'type_error', 'variable_error', 'double_bug', 'triple_bug', 'quadruple_bug', 'Misused Macro Definition', 'missing_backtick', 'misused_let', 'misused templte', 'Delayed Execution', 'Misused match', 'Misused := and =', 'Unused Variable', 'Misused === and ==', 'Misused =>', 'Misused Spread Operator', 'Misused begin/end', 'Missing $', 'illegal_indentation', 'Missing mut', 'Misused var and val', 'The digital leader is 0', 'Duplicate keys', 'struct_error', 'json_content_error']\n"}
{"question_id": "CPP/24", "category": "Logic", "subtype": "algorithm_error", "level": "easy", "example": "Example usage:\nassert(decode_numbers(\"0000\") == 4);", "docstring": "Decode a series of numbers to reveal the pattern and understand the actual values \neach digit represents.\n\nEquations provided for Reference:\n0000=4 8888=8 1234=1 5678=3 9012=2 1357=0 2468=4\n\nParameters:\n- data_str: A constant character array (C-style string) representing a series of numbers. Length does not exceed 100.\n\nReturns:\nint: The result of each data string corresponding to the right-hand side of the equation.", "canonical_solution": "#include <cassert>\n#include <cstring>\n#include <iostream>\n\nint decode_numbers(const char* data_str)\n\n{\n    int a[] = {1, 0, 0, 0, 1, 0, 1, 0, 2, 1};\n    int ans = 0;\n    for(int i = 0; i < std::strlen(data_str); i++) {\n        ans += a[data_str[i] - '0'];\n    }\n    return ans;\n}", "buggy_code": "#include <cassert>\n#include <cstring>\n#include <iostream>\nint decode_numbers(const char* data_str)\n{\n    int a[] = {1, 0, 0, 0, 1, 0, 1, 0, 2, 1};\n    int ans = 0;\n    for(int i = 1; i < std::strlen(data_str); i++) {\n        ans += a[data_str[i] - '0'];\n    }\n    return ans;\n}", "test": "int main() {\n    // Assert basic provided test cases\n    assert(decode_numbers(\"0000\") == 4);\n    assert(decode_numbers(\"8888\") == 8);\n    assert(decode_numbers(\"1234\") == 1);\n    assert(decode_numbers(\"5678\") == 3);\n    assert(decode_numbers(\"9012\") == 2);\n    assert(decode_numbers(\"1357\") == 0);\n    assert(decode_numbers(\"2468\") == 4);\n\n    // Assert additional test cases\n    assert(decode_numbers(\"9999\") == 4);\n    assert(decode_numbers(\"1111\") == 0);\n    assert(decode_numbers(\"2222\") == 0);\n    assert(decode_numbers(\"3333\") == 0);\n    assert(decode_numbers(\"4444\") == 4);\n    assert(decode_numbers(\"5555\") == 0);\n    assert(decode_numbers(\"6666\") == 4);\n    assert(decode_numbers(\"7777\") == 0);\n    assert(decode_numbers(\"0001\") == 3);\n    assert(decode_numbers(\"2301\") == 1);\n\n    // Indicate that all tests passed\n    // std::cout << \"All tests passed successfully!\" << std::endl;\n\n    return 0;\n}", "instruction": " the following faulty CPP code snippet and error type list. \nYour task is to select the error type of the code based on the error list provided\n\nYou only need to answer error type. Do not write anything else in your response. \n\nFor example, if the code snippet is missing a semicolon, Your output should be 'missing_colons'.\n\nfaulty code:\n\n```\n#include <cassert>\n#include <cstring>\n#include <iostream>\nint decode_numbers(const char* data_str)\n{\n    int a[] = {1, 0, 0, 0, 1, 0, 1, 0, 2, 1};\n    int ans = 0;\n    for(int i = 1; i < std::strlen(data_str); i++) {\n        ans += a[data_str[i] - '0'];\n    }\n    return ans;\n}\n```\nerror type list:\n\n['illegal_comment', 'illegal_separation', 'missing_colons', 'misused ==and=', 'unclosed_parentheses', 'unclosed_string', 'faulty_indexing', 'function_error', 'illegal_keyword', 'undefined_methods', 'undefined_objects', 'algorithm_error', 'condition_error', 'operation_error', 'type_error', 'variable_error', 'double_bug', 'triple_bug', 'quadruple_bug', 'Misused Macro Definition', 'missing_backtick', 'misused_let', 'misused templte', 'Delayed Execution', 'Misused match', 'Misused := and =', 'Unused Variable', 'Misused === and ==', 'Misused =>', 'Misused Spread Operator', 'Misused begin/end', 'Missing $', 'illegal_indentation', 'Missing mut', 'Misused var and val', 'The digital leader is 0', 'Duplicate keys', 'struct_error', 'json_content_error']\n"}
{"question_id": "CPP/25", "category": "Logic", "subtype": "algorithm_error", "level": "easy", "example": ">>> shift_characters(\"NS BFW, JAJSYX TK NRUTWYFSHJ FWJ YMJ WJXZQY TK YWNANFQ HFZXJX\")\n\"IN WAR, EVENTS OF IMPORTANCE ARE THE RESULT OF TRIVIAL CAUSES\"", "docstring": "Shifts all characters by 5 positions in alphabetical order. Only letters are replaced,\nand all letters are in uppercase.\n\nParameters:\ntext (std::string&): The input text to be processed, modified in place.\n\nReturns:\nstd::string&: The transformed text with characters shifted by 5 positions.", "canonical_solution": "#include <bits/stdc++.h>\n\nstd::string& shift_characters(std::string& text)\n\n{\n    size_t len = text.length();\n    for (size_t i = 0; i < len; ++i) {\n        if ('A' <= text[i] && text[i] <= 'E') {\n            text[i] = text[i] + 'V' - 'A';\n        } else if ('F' <= text[i] && text[i] <= 'Z') {\n            text[i] = text[i] + 'A' - 'F';\n        }\n    }\n    return text;\n}", "buggy_code": "#include <bits/stdc++.h>\nstd::string& shift_characters(std::string& text)\n{\n    size_t len = text.length();\n    for (size_t i = 0; i < len; ++i) {\n        if ('A' <= text[i] && text[i] <= 'E') {\n            text[i] = text[i] + 'V' - 'A';\n        } else if ('F' <= text[i] && text[i] <= 'Z') {\n            text[i] = text[i] + 'V' - 'A';\n        }\n    }\n    return text;\n}", "test": "int main()\n{\n    std::string test1 = \"NS BFW, JAJSYX TK NRUTWYFSHJ FWJ YMJ WJXZQY TK YWNANFQ HFZXJX\";\n    std::string test2 = \"N BTZQI WFYMJW GJ KNWXY NS F QNYYQJ NGJWNFS ANQQFLJ YMFS XJHTSI NS WTRJ\";\n    std::string test3 = \"IFSLJW PSTBX KZQQ BJQQ YMFY HFJXFW NX RTWJ IFSLJWTZX YMFS MJ\";\n\n    assert(shift_characters(test1) == \"IN WAR, EVENTS OF IMPORTANCE ARE THE RESULT OF TRIVIAL CAUSES\");\n    assert(shift_characters(test2) == \"I WOULD RATHER BE FIRST IN A LITTLE IBERIAN VILLAGE THAN SECOND IN ROME\");\n    assert(shift_characters(test3) == \"DANGER KNOWS FULL WELL THAT CAESAR IS MORE DANGEROUS THAN HE\");\n    return 0;\n}", "instruction": " the following faulty CPP code snippet and error type list. \nYour task is to select the error type of the code based on the error list provided\n\nYou only need to answer error type. Do not write anything else in your response. \n\nFor example, if the code snippet is missing a semicolon, Your output should be 'missing_colons'.\n\nfaulty code:\n\n```\n#include <bits/stdc++.h>\nstd::string& shift_characters(std::string& text)\n{\n    size_t len = text.length();\n    for (size_t i = 0; i < len; ++i) {\n        if ('A' <= text[i] && text[i] <= 'E') {\n            text[i] = text[i] + 'V' - 'A';\n        } else if ('F' <= text[i] && text[i] <= 'Z') {\n            text[i] = text[i] + 'V' - 'A';\n        }\n    }\n    return text;\n}\n```\nerror type list:\n\n['illegal_comment', 'illegal_separation', 'missing_colons', 'misused ==and=', 'unclosed_parentheses', 'unclosed_string', 'faulty_indexing', 'function_error', 'illegal_keyword', 'undefined_methods', 'undefined_objects', 'algorithm_error', 'condition_error', 'operation_error', 'type_error', 'variable_error', 'double_bug', 'triple_bug', 'quadruple_bug', 'Misused Macro Definition', 'missing_backtick', 'misused_let', 'misused templte', 'Delayed Execution', 'Misused match', 'Misused := and =', 'Unused Variable', 'Misused === and ==', 'Misused =>', 'Misused Spread Operator', 'Misused begin/end', 'Missing $', 'illegal_indentation', 'Missing mut', 'Misused var and val', 'The digital leader is 0', 'Duplicate keys', 'struct_error', 'json_content_error']\n"}
{"question_id": "CPP/26", "category": "Logic", "subtype": "condition_error", "level": "medium", "example": "* Examples:\n * count_coloring_methods(1,1) returns 1\n * count_coloring_methods(2,2) returns 2", "docstring": "* Counts the number of different coloring methods for n squares with m colors,\n * considering the requirement that adjacent squares and the first/last squares\n * must have different colors.\n * \n * @param n The number of squares.\n * @param m The number of colors.\n * @return The count of different coloring methods satisfying the specified conditions.\n *         The result is modulo 1000003.\n *", "canonical_solution": "#include <cassert>\n#include <iostream>\n\nint count_coloring_methods(int n, int m)\n\n{\n    int f[1111];\n    if (n == 1) return m;\n    if (n == 2) return static_cast<long long>(m) * (m - 1) % 1000003;\n    f[1] = m;\n    f[2] = static_cast<long long>(m) * (m - 1) % 1000003;\n    f[3] = static_cast<long long>(f[2]) * (m - 2) % 1000003;\n    for(int i = 4; i <= n; ++i) {\n        f[i] = (static_cast<long long>(f[i - 1]) * (m - 2) % 1000003 +\n                static_cast<long long>(f[i - 2]) * (m - 1) % 1000003) % 1000003;\n    }\n    return f[n];\n}", "buggy_code": "#include <cassert>\n#include <iostream>\nint count_coloring_methods(int n, int m)\n{\n    int f[1111];\n    if (n == 1) return m;\n    if (n == 2) return static_cast<long long>(m) * (m - 1) % 1000003;\n    f[1] = m;\n    f[2] = static_cast<long long>(m) * (m - 1) % 1000003;\n    f[3] = static_cast<long long>(f[2]) * (m - 2) % 1000003;\n    for(int i = 4; i < n; ++i) {\n        f[i] = (static_cast<long long>(f[i - 1]) * (m - 2) % 1000003 +\n                static_cast<long long>(f[i - 2]) * (m - 1) % 1000003) % 1000003;\n    }\n    return f[n];\n}", "test": "int main() {\n    assert(count_coloring_methods(1, 1) == 1);\n    assert(count_coloring_methods(2, 2) == 2);\n    assert(count_coloring_methods(3, 3) == 6);\n    assert(count_coloring_methods(4, 2) == 2);\n    assert(count_coloring_methods(1000, 10) == 566585); // We don't have the expected result for this case\n\n    // Additional test cases\n    assert(count_coloring_methods(2, 3) == 6);\n    assert(count_coloring_methods(1000, 1000) == 67911);\n    assert(count_coloring_methods(999, 66) == 501817);\n    assert(count_coloring_methods(5, 3) == 30); // Example of an expected output\n\n    // std::cout << \"All tests passed!\\n\";\n    return 0;\n}", "instruction": " the following faulty CPP code snippet and error type list. \nYour task is to select the error type of the code based on the error list provided\n\nYou only need to answer error type. Do not write anything else in your response. \n\nFor example, if the code snippet is missing a semicolon, Your output should be 'missing_colons'.\n\nfaulty code:\n\n```\n#include <cassert>\n#include <iostream>\nint count_coloring_methods(int n, int m)\n{\n    int f[1111];\n    if (n == 1) return m;\n    if (n == 2) return static_cast<long long>(m) * (m - 1) % 1000003;\n    f[1] = m;\n    f[2] = static_cast<long long>(m) * (m - 1) % 1000003;\n    f[3] = static_cast<long long>(f[2]) * (m - 2) % 1000003;\n    for(int i = 4; i < n; ++i) {\n        f[i] = (static_cast<long long>(f[i - 1]) * (m - 2) % 1000003 +\n                static_cast<long long>(f[i - 2]) * (m - 1) % 1000003) % 1000003;\n    }\n    return f[n];\n}\n```\nerror type list:\n\n['illegal_comment', 'illegal_separation', 'missing_colons', 'misused ==and=', 'unclosed_parentheses', 'unclosed_string', 'faulty_indexing', 'function_error', 'illegal_keyword', 'undefined_methods', 'undefined_objects', 'algorithm_error', 'condition_error', 'operation_error', 'type_error', 'variable_error', 'double_bug', 'triple_bug', 'quadruple_bug', 'Misused Macro Definition', 'missing_backtick', 'misused_let', 'misused templte', 'Delayed Execution', 'Misused match', 'Misused := and =', 'Unused Variable', 'Misused === and ==', 'Misused =>', 'Misused Spread Operator', 'Misused begin/end', 'Missing $', 'illegal_indentation', 'Missing mut', 'Misused var and val', 'The digital leader is 0', 'Duplicate keys', 'struct_error', 'json_content_error']\n"}
{"question_id": "CPP/27", "category": "Logic", "subtype": "condition_error", "level": "medium", "example": "* Examples:\n *   count_valid_coin_toss_sequences(1) returns 2\n *   count_valid_coin_toss_sequences(2) returns 3", "docstring": "* Count the number of valid coin toss sequences with no consecutive heads in n tosses.\n *\n * Parameters:\n * - n (int): The number of coin tosses.\n *\n * Returns:\n * - unsigned long long: The count of valid sequences.\n *", "canonical_solution": "#include <cassert>\n#include <cmath>\n#include <cstdio>\n#include <cstring>\n\nunsigned long long count_valid_coin_toss_sequences(int n)\n\n{\n    unsigned long long a[41][2];\n    a[1][0] = a[1][1] = 1;\n\n    for(int i = 2; i <= n; i++){\n        a[i][0] = a[i - 1][1] + a[i - 1][0];\n        a[i][1] = a[i - 1][0];\n    }\n\n    return a[n][0] + a[n][1];\n}", "buggy_code": "#include <cassert>\n#include <cmath>\n#include <cstdio>\n#include <cstring>\nunsigned long long count_valid_coin_toss_sequences(int n)\n{\n    unsigned long long a[41][2];\n    a[1][0] = a[1][1] = 1;\n    for(int i = 2; i < n; i++){\n        a[i][0] = a[i - 1][1] + a[i - 1][0];\n        a[i][1] = a[i - 1][0];\n    }\n    return a[n][0] + a[n][1];\n}", "test": "int main() {\n    assert(count_valid_coin_toss_sequences(1) == 2);\n    assert(count_valid_coin_toss_sequences(2) == 3);\n    assert(count_valid_coin_toss_sequences(3) == 5);\n    assert(count_valid_coin_toss_sequences(4) == 8); // Additional test\n    assert(count_valid_coin_toss_sequences(5) == 13); // Additional test\n    // Feel free to add more tests here\n    assert(count_valid_coin_toss_sequences(40) == 267914296ULL); // Additional test\n    assert(count_valid_coin_toss_sequences(39) == 165580141ULL);\n    assert(count_valid_coin_toss_sequences(38) == 102334155ULL);\n    // printf(\"All tests passed!\\n\");\n    return 0;\n}", "instruction": " the following faulty CPP code snippet and error type list. \nYour task is to select the error type of the code based on the error list provided\n\nYou only need to answer error type. Do not write anything else in your response. \n\nFor example, if the code snippet is missing a semicolon, Your output should be 'missing_colons'.\n\nfaulty code:\n\n```\n#include <cassert>\n#include <cmath>\n#include <cstdio>\n#include <cstring>\nunsigned long long count_valid_coin_toss_sequences(int n)\n{\n    unsigned long long a[41][2];\n    a[1][0] = a[1][1] = 1;\n    for(int i = 2; i < n; i++){\n        a[i][0] = a[i - 1][1] + a[i - 1][0];\n        a[i][1] = a[i - 1][0];\n    }\n    return a[n][0] + a[n][1];\n}\n```\nerror type list:\n\n['illegal_comment', 'illegal_separation', 'missing_colons', 'misused ==and=', 'unclosed_parentheses', 'unclosed_string', 'faulty_indexing', 'function_error', 'illegal_keyword', 'undefined_methods', 'undefined_objects', 'algorithm_error', 'condition_error', 'operation_error', 'type_error', 'variable_error', 'double_bug', 'triple_bug', 'quadruple_bug', 'Misused Macro Definition', 'missing_backtick', 'misused_let', 'misused templte', 'Delayed Execution', 'Misused match', 'Misused := and =', 'Unused Variable', 'Misused === and ==', 'Misused =>', 'Misused Spread Operator', 'Misused begin/end', 'Missing $', 'illegal_indentation', 'Missing mut', 'Misused var and val', 'The digital leader is 0', 'Duplicate keys', 'struct_error', 'json_content_error']\n"}
{"question_id": "CPP/28", "category": "Logic", "subtype": "condition_error", "level": "medium", "example": "* Examples:\n *   >>> find_longest_consecutive_ones_length(7)\n *   3", "docstring": "* Find the length of the longest consecutive sequence of 1s in the binary \n * representation of a non-negative integer.\n *\n * Parameters:\n * - n (unsigned long long): A non-negative integer (0 ≤ n ≤ 2^64 - 1).\n *\n * Returns:\n * - int: The length of the longest consecutive sequence of 1s in the binary \n *        representation of the given integer.\n *", "canonical_solution": "#include <cassert>\n#include <cmath>\n#include <cstdio>\n#include <cstring>\n\nint find_longest_consecutive_ones_length(unsigned long long n)\n\n{\n    int max_length = 0;\n    int current_length = 0;\n    while (n) {\n        if (n & 1) {\n            current_length++;\n        } else {\n            if (current_length > max_length) {\n                max_length = current_length;\n            }\n            current_length = 0;\n        }\n        n >>= 1;\n    }\n    if (current_length > max_length) {\n        max_length = current_length;\n    }\n    return max_length;\n}", "buggy_code": "#include <cassert>\n#include <cmath>\n#include <cstdio>\n#include <cstring>\nint find_longest_consecutive_ones_length(unsigned long long n)\n{\n    int max_length = 0;\n    int current_length = 0;\n    while (n) {\n        if (n & 1) {\n            current_length++;\n        } else {\n            if (current_length < max_length) {\n                max_length = current_length;\n            }\n            current_length = 0;\n        }\n        n >>= 1;\n    }\n    if (current_length > max_length) {\n        max_length = current_length;\n    }\n    return max_length;\n}", "test": "int main()\n{\n    assert(find_longest_consecutive_ones_length(7) == 3);\n    assert(find_longest_consecutive_ones_length(13) == 2);\n    assert(find_longest_consecutive_ones_length(12345) == 3); // New test sample\n    assert(find_longest_consecutive_ones_length(0b11011101111) == 4); // New test sample using binary literal for clarity\n    assert(find_longest_consecutive_ones_length(0xFFFFFFFF) == 32); // New test sample: all ones for a 32-bit number\n    assert(find_longest_consecutive_ones_length(0) == 0); // New test sample: no ones in a zero\n\n    // printf(\"All tests passed!\\n\"); // In C++, you might use std::cout, but it is commented out as per the original code.\n    return 0;\n}", "instruction": " the following faulty CPP code snippet and error type list. \nYour task is to select the error type of the code based on the error list provided\n\nYou only need to answer error type. Do not write anything else in your response. \n\nFor example, if the code snippet is missing a semicolon, Your output should be 'missing_colons'.\n\nfaulty code:\n\n```\n#include <cassert>\n#include <cmath>\n#include <cstdio>\n#include <cstring>\nint find_longest_consecutive_ones_length(unsigned long long n)\n{\n    int max_length = 0;\n    int current_length = 0;\n    while (n) {\n        if (n & 1) {\n            current_length++;\n        } else {\n            if (current_length < max_length) {\n                max_length = current_length;\n            }\n            current_length = 0;\n        }\n        n >>= 1;\n    }\n    if (current_length > max_length) {\n        max_length = current_length;\n    }\n    return max_length;\n}\n```\nerror type list:\n\n['illegal_comment', 'illegal_separation', 'missing_colons', 'misused ==and=', 'unclosed_parentheses', 'unclosed_string', 'faulty_indexing', 'function_error', 'illegal_keyword', 'undefined_methods', 'undefined_objects', 'algorithm_error', 'condition_error', 'operation_error', 'type_error', 'variable_error', 'double_bug', 'triple_bug', 'quadruple_bug', 'Misused Macro Definition', 'missing_backtick', 'misused_let', 'misused templte', 'Delayed Execution', 'Misused match', 'Misused := and =', 'Unused Variable', 'Misused === and ==', 'Misused =>', 'Misused Spread Operator', 'Misused begin/end', 'Missing $', 'illegal_indentation', 'Missing mut', 'Misused var and val', 'The digital leader is 0', 'Duplicate keys', 'struct_error', 'json_content_error']\n"}
{"question_id": "CPP/29", "category": "Logic", "subtype": "condition_error", "level": "medium", "example": "* Example Usage:\n * \n * create_id(\"fish\", \"cat\") returns \"ftiasch\"\n * create_id(\"icpc\", \"acm\") returns \"imccpac\"", "docstring": "* Generates a unique identifier by interweaving two words in a specified pattern.\n * @param word1 The first word to be used in the ID creation process.\n * @param word2 The second word to be used in the ID creation process.\n * @return A unique identifier formed by alternating characters from the second word,\n *         reversed, with characters from the first word.", "canonical_solution": "#include <iostream>\n#include <string>\n#include <cassert>\n\nstd::string create_id(const std::string& word1, const std::string& word2)\n\n{\n    std::string id;\n    int j = 0, k = word2.length() - 1;\n    for (int i = 0; i < word1.length() + word2.length(); ++i) {\n        if (i % 2 == 0) {\n            id += word1[j++];\n        } else {\n            id += word2[k--];\n        }\n    }\n    return id;\n}", "buggy_code": "#include <iostream>\n#include <string>\n#include <cassert>\nstd::string create_id(const std::string& word1, const std::string& word2)\n{\n    std::string id;\n    int j = 0, k = word2.length();\n    for (int i = 0; i <= word1.length() + word2.length(); ++i) {\n        if (i % 2 == 0) {\n            id += word1[j++];\n        } else {\n            id += word2[k--];\n        }\n    }\n    return id;\n}", "test": "int main() {\n    std::string id; // To hold the results from create_id\n\n    id = create_id(\"fish\", \"cat\");\n    assert(id.compare(\"ftiasch\") == 0);\n\n    id = create_id(\"icpc\", \"acm\");\n    assert(id.compare(\"imccpac\") == 0);\n\n    id = create_id(\"oo\", \"w\");\n    assert(id.compare(\"owo\") == 0);\n\n    // Add more test samples\n    id = create_id(\"hello\", \"world\");\n    assert(id.compare(\"hdellrloow\") == 0);\n\n    id = create_id(\"abc\", \"def\");\n    assert(id.compare(\"afbecd\") == 0);\n\n    id = create_id(\"buaanb\", \"nbbuaa\");\n    assert(id.compare(\"bauaauabnbbn\") == 0);\n\n    id = create_id(\"xtuisgood\", \"ilovextu\");\n    assert(id.compare(\"xuttuxiesvgooloid\") == 0);\n\n    // std::cout << \"All tests passed!\" << std::endl;\n\n    return 0;\n}", "instruction": " the following faulty CPP code snippet and error type list. \nYour task is to select the error type of the code based on the error list provided\n\nYou only need to answer error type. Do not write anything else in your response. \n\nFor example, if the code snippet is missing a semicolon, Your output should be 'missing_colons'.\n\nfaulty code:\n\n```\n#include <iostream>\n#include <string>\n#include <cassert>\nstd::string create_id(const std::string& word1, const std::string& word2)\n{\n    std::string id;\n    int j = 0, k = word2.length();\n    for (int i = 0; i <= word1.length() + word2.length(); ++i) {\n        if (i % 2 == 0) {\n            id += word1[j++];\n        } else {\n            id += word2[k--];\n        }\n    }\n    return id;\n}\n```\nerror type list:\n\n['illegal_comment', 'illegal_separation', 'missing_colons', 'misused ==and=', 'unclosed_parentheses', 'unclosed_string', 'faulty_indexing', 'function_error', 'illegal_keyword', 'undefined_methods', 'undefined_objects', 'algorithm_error', 'condition_error', 'operation_error', 'type_error', 'variable_error', 'double_bug', 'triple_bug', 'quadruple_bug', 'Misused Macro Definition', 'missing_backtick', 'misused_let', 'misused templte', 'Delayed Execution', 'Misused match', 'Misused := and =', 'Unused Variable', 'Misused === and ==', 'Misused =>', 'Misused Spread Operator', 'Misused begin/end', 'Missing $', 'illegal_indentation', 'Missing mut', 'Misused var and val', 'The digital leader is 0', 'Duplicate keys', 'struct_error', 'json_content_error']\n"}
{"question_id": "CPP/30", "category": "Logic", "subtype": "operation_error", "level": "medium", "example": "* Example:\n *    >>> Is_Square({9})\n *    true", "docstring": "* Determines if it is possible to assemble the wooden squares from n buckets\n * into a single larger square, where each bucket contains squares with a side length of 1.\n * \n * Input: vector of numbers\n * \n * @param squares Vector containing the count of squares in each bucket.\n * @return True if it is possible to form a larger square, False otherwise.", "canonical_solution": "#include <cassert>\n#include <cmath>\n#include <vector>\n\nbool Is_Square(std::vector<int> squares)\n\n{\n    long long sum = 0;\n    for (int square : squares) {\n        sum += square; \n    }\n    int root = static_cast<int>(std::sqrt(sum));\n    return root * root == sum;\n}", "buggy_code": "#include <cassert>\n#include <cmath>\n#include <vector>\nbool Is_Square(std::vector<int> squares)\n{\n    long long sum = 0;\n    for (int square : squares) {\n        sum -= square; \n    }\n    int root = static_cast<int>(std::sqrt(sum));\n    return root * root == sum;\n}", "test": "int main() {\n    assert(Is_Square({9}) == true);\n    assert(Is_Square({14, 2}) == true);\n    assert(Is_Square({7, 7}) == false);\n    assert(Is_Square({1, 2, 3, 4, 5, 6, 7}) == false);\n    assert(Is_Square({1, 3, 5, 7, 9, 11}) == true);\n    assert(Is_Square({2, 2, 2, 2}) == false);\n\n    // Additional test cases\n    assert(Is_Square({4, 5, 6}) == false);\n    assert(Is_Square({16, 9, 4, 1}) == false);\n    assert(Is_Square({1, 1, 1, 1, 1}) == false);\n    assert(Is_Square({25, 25}) == false);\n    assert(Is_Square({10, 10, 5}) == true);\n\n    // All tests passed\n    return 0;\n}", "instruction": " the following faulty CPP code snippet and error type list. \nYour task is to select the error type of the code based on the error list provided\n\nYou only need to answer error type. Do not write anything else in your response. \n\nFor example, if the code snippet is missing a semicolon, Your output should be 'missing_colons'.\n\nfaulty code:\n\n```\n#include <cassert>\n#include <cmath>\n#include <vector>\nbool Is_Square(std::vector<int> squares)\n{\n    long long sum = 0;\n    for (int square : squares) {\n        sum -= square; \n    }\n    int root = static_cast<int>(std::sqrt(sum));\n    return root * root == sum;\n}\n```\nerror type list:\n\n['illegal_comment', 'illegal_separation', 'missing_colons', 'misused ==and=', 'unclosed_parentheses', 'unclosed_string', 'faulty_indexing', 'function_error', 'illegal_keyword', 'undefined_methods', 'undefined_objects', 'algorithm_error', 'condition_error', 'operation_error', 'type_error', 'variable_error', 'double_bug', 'triple_bug', 'quadruple_bug', 'Misused Macro Definition', 'missing_backtick', 'misused_let', 'misused templte', 'Delayed Execution', 'Misused match', 'Misused := and =', 'Unused Variable', 'Misused === and ==', 'Misused =>', 'Misused Spread Operator', 'Misused begin/end', 'Missing $', 'illegal_indentation', 'Missing mut', 'Misused var and val', 'The digital leader is 0', 'Duplicate keys', 'struct_error', 'json_content_error']\n"}
{"question_id": "CPP/31", "category": "Logic", "subtype": "operation_error", "level": "easy", "example": "Examples:\n>>> count_acute_triangles(4, 1, 1, 1, 1)\n4", "docstring": "Count the number of acute-angled triangles that can be formed by selecting any 3 edges out of\na given set of edges.\n  \nArgs:\n- edges_count: The number of edges passed.\n- An arbitrary number of integer arguments representing the lengths of the edges.\n  \nReturns:\nint: The count of distinct acute-angled triangles that can be formed.", "canonical_solution": "#include <cassert>\n#include <cmath>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cstdarg>\n\nint count_acute_triangles(int edges_count, ...)\n\n{\n    va_list args;\n    va_start(args, edges_count);\n\n    int* edges = (int*) malloc(edges_count * sizeof(int));\n    for (int i = 0; i < edges_count; i++) {\n        edges[i] = va_arg(args, int);\n    }\n    va_end(args);\n\n    qsort(edges, edges_count, sizeof(int), (int (*)(const void *, const void *)) strcmp);\n\n\n    int sum = 0;\n    for (int i = 0; i < edges_count - 2; i++) {\n        for (int j = i + 1; j < edges_count - 1; j++) {\n            for (int k = j + 1; k < edges_count; k++) {\n                int x = edges[i], y = edges[j], z = edges[k];\n                if (x + y > z && x * x + y * y > z * z) {\n                    sum++;\n                }\n            }\n        }\n    }\n\n    free(edges);\n    return sum;\n}", "buggy_code": "#include <cassert>\n#include <cmath>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cstdarg>\nint count_acute_triangles(int edges_count, ...)\n{\n    va_list args;\n    va_start(args, edges_count);\n    int* edges = (int*) malloc(edges_count * sizeof(int));\n    for (int i = 0; i < edges_count; i++) {\n        edges[i] = va_arg(args, int);\n    }\n    va_end(args);\n    qsort(edges, edges_count, sizeof(int), (int (*)(const void *, const void *)) strcmp);\n    int sum = 0;\n    for (int i = 0; i < edges_count - 2; i++) {\n        for (int j = i + 1; j < edges_count - 1; j++) {\n            for (int k = j + 1; k < edges_count; k++) {\n                int x = edges[i], y = edges[j], z = edges[k];\n                if (x + y > z || x * x + y * y > z * z) {\n                    sum++;\n                }\n            }\n        }\n    }\n    free(edges);\n    return sum;\n}", "test": "int main() {\n    assert(count_acute_triangles(4, 1, 1, 1, 1) == 4);\n    assert(count_acute_triangles(3, 1, 2, 3) == 0);\n    // Additional tests to ensure correctness\n    assert(count_acute_triangles(5, 3, 4, 5, 7, 10) == 0);\n    assert(count_acute_triangles(6, 6, 8, 10, 5, 5, 5) == 4);\n    return 0;\n}", "instruction": " the following faulty CPP code snippet and error type list. \nYour task is to select the error type of the code based on the error list provided\n\nYou only need to answer error type. Do not write anything else in your response. \n\nFor example, if the code snippet is missing a semicolon, Your output should be 'missing_colons'.\n\nfaulty code:\n\n```\n#include <cassert>\n#include <cmath>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cstdarg>\nint count_acute_triangles(int edges_count, ...)\n{\n    va_list args;\n    va_start(args, edges_count);\n    int* edges = (int*) malloc(edges_count * sizeof(int));\n    for (int i = 0; i < edges_count; i++) {\n        edges[i] = va_arg(args, int);\n    }\n    va_end(args);\n    qsort(edges, edges_count, sizeof(int), (int (*)(const void *, const void *)) strcmp);\n    int sum = 0;\n    for (int i = 0; i < edges_count - 2; i++) {\n        for (int j = i + 1; j < edges_count - 1; j++) {\n            for (int k = j + 1; k < edges_count; k++) {\n                int x = edges[i], y = edges[j], z = edges[k];\n                if (x + y > z || x * x + y * y > z * z) {\n                    sum++;\n                }\n            }\n        }\n    }\n    free(edges);\n    return sum;\n}\n```\nerror type list:\n\n['illegal_comment', 'illegal_separation', 'missing_colons', 'misused ==and=', 'unclosed_parentheses', 'unclosed_string', 'faulty_indexing', 'function_error', 'illegal_keyword', 'undefined_methods', 'undefined_objects', 'algorithm_error', 'condition_error', 'operation_error', 'type_error', 'variable_error', 'double_bug', 'triple_bug', 'quadruple_bug', 'Misused Macro Definition', 'missing_backtick', 'misused_let', 'misused templte', 'Delayed Execution', 'Misused match', 'Misused := and =', 'Unused Variable', 'Misused === and ==', 'Misused =>', 'Misused Spread Operator', 'Misused begin/end', 'Missing $', 'illegal_indentation', 'Missing mut', 'Misused var and val', 'The digital leader is 0', 'Duplicate keys', 'struct_error', 'json_content_error']\n"}
{"question_id": "CPP/32", "category": "Logic", "subtype": "operation_error", "level": "easy", "example": "* Examples:\n * >>> minRoundsToSameChar(\"aab\")\n * 1\n * >>> minRoundsToSameChar(\"abc\")\n * 2\n * >>> minRoundsToSameChar(\"aaa\")\n * 0", "docstring": "* Given a string consisting of lowercase English letters, in each round you can change\n * one of the characters to another character. The question is: what is the minimum\n * number of rounds needed to make the string composed of the same character?\n *", "canonical_solution": "#include <cassert>\n#include <cstring>\n#include <iostream>\n\nint minRoundsToSameChar(const char* s)\n\n{\n    int charCount[26] = {0};\n    for (int i = 0; i < 26; i++) {\n        charCount[i] = 0;\n    }\n    while (*s) {\n        charCount[*s - 'a']++;\n        s++;\n    }\n    int maxCount = 0;\n    for (int i = 0; i < 26; i++) {\n        if (charCount[i] != 0 ) {\n            maxCount ++;\n        }\n    }\n\n    return maxCount - 1;\n}", "buggy_code": "#include <cassert>\n#include <cstring>\n#include <iostream>\nint minRoundsToSameChar(const char* s)\n{\n    int charCount[26] = {0};\n    for (int i = 0; i < 26; i++) {\n        charCount[i] = 0;\n    }\n    while (*s) {\n        charCount[*s + 'a']++;\n        s++;\n    }\n    int maxCount = 0;\n    for (int i = 0; i < 26; i++) {\n        if (charCount[i] != 0 ) {\n            maxCount ++;\n        }\n    }\n    return maxCount - 1;\n}", "test": "int main() {\n    assert(minRoundsToSameChar(\"aab\") == 1);\n    assert(minRoundsToSameChar(\"abc\") == 2);\n    assert(minRoundsToSameChar(\"aaa\") == 0);\n    assert(minRoundsToSameChar(\"abab\") == 1);\n    assert(minRoundsToSameChar(\"zzzzz\") == 0);\n\n    return 0;\n}", "instruction": " the following faulty CPP code snippet and error type list. \nYour task is to select the error type of the code based on the error list provided\n\nYou only need to answer error type. Do not write anything else in your response. \n\nFor example, if the code snippet is missing a semicolon, Your output should be 'missing_colons'.\n\nfaulty code:\n\n```\n#include <cassert>\n#include <cstring>\n#include <iostream>\nint minRoundsToSameChar(const char* s)\n{\n    int charCount[26] = {0};\n    for (int i = 0; i < 26; i++) {\n        charCount[i] = 0;\n    }\n    while (*s) {\n        charCount[*s + 'a']++;\n        s++;\n    }\n    int maxCount = 0;\n    for (int i = 0; i < 26; i++) {\n        if (charCount[i] != 0 ) {\n            maxCount ++;\n        }\n    }\n    return maxCount - 1;\n}\n```\nerror type list:\n\n['illegal_comment', 'illegal_separation', 'missing_colons', 'misused ==and=', 'unclosed_parentheses', 'unclosed_string', 'faulty_indexing', 'function_error', 'illegal_keyword', 'undefined_methods', 'undefined_objects', 'algorithm_error', 'condition_error', 'operation_error', 'type_error', 'variable_error', 'double_bug', 'triple_bug', 'quadruple_bug', 'Misused Macro Definition', 'missing_backtick', 'misused_let', 'misused templte', 'Delayed Execution', 'Misused match', 'Misused := and =', 'Unused Variable', 'Misused === and ==', 'Misused =>', 'Misused Spread Operator', 'Misused begin/end', 'Missing $', 'illegal_indentation', 'Missing mut', 'Misused var and val', 'The digital leader is 0', 'Duplicate keys', 'struct_error', 'json_content_error']\n"}
{"question_id": "CPP/33", "category": "Logic", "subtype": "operation_error", "level": "easy", "example": "* Examples:\n *    >>> makeEqualAgain(3, (int[]){1, 2, 1})\n *    1\n *    >>> makeEqualAgain(5, (int[]){5, 5, 1, 5, 5})\n *    1", "docstring": "* You are given an array a of n integers. You can perform at most one operation where you\n * select three integers i, j, x (1 <= i <= j <= n) and replace all elements from a[i] to a[j] with x,\n * at a cost of (j - i + 1). Find the minimum cost to make all elements in the array equal.\n *", "canonical_solution": "#include <cstdio>\n#include <cassert>\n\nint makeEqualAgain(int n, int a[])\n\n{\n    int j = 0, p = 1, q = 0, c, d;\n    int k = n;\n    for (p = 1; p < k; p++) {\n        if (a[p] != a[p - 1])\n            break;\n    }\n    for (q = k - 1; q > p; q--) {\n        if (a[q] != a[p - 1])\n            break;\n    }\n    for (d = k - 2; d >= 0; d--) {\n        if (a[d] != a[d + 1])\n            break;\n    }\n    for (c = 0; c < d; c++) {\n        if (a[c] != a[c + 1])\n            break;\n    }\n    if (q - p + 1 < d - c + 1)\n        return q - p + 1;\n    else\n        return d - c + 1;\n}", "buggy_code": "#include <cstdio>\n#include <cassert>\nint makeEqualAgain(int n, int a[])\n{\n    int j = 0, p = 1, q = 0, c, d;\n    int k = n;\n    for (p = 1; p < k; p++) {\n        if (a[p] != a[p - 1])\n            break;\n    }\n    for (q = k - 1; q > p; q--) {\n        if (a[q] != a[p - 1])\n            break;\n    }\n    for (d = k - 2; d >= 0; d--) {\n        if (a[d] != a[d + 1])\n            break;\n    }\n    for (c = 0; c < d; c++) {\n        if (a[c] != a[c + 1])\n            break;\n    }\n    if (q - p + 1 < d - c + 1)\n        return q - p * 1;\n    else\n        return d - c + 1;\n}", "test": "int main() {\n    int a1[] = {1,2,3,4,5,1};\n    int a2[] = {1,1,1,1,1,1,1};\n    int a3[] = {8,8,8,1,2,8,8,8};\n    int a4[] = {1,2,3};\n    int a5[] = {4,3,2,7,1,1,3};\n    int a6[] = {9,9,2,9,2,5,5,5,3};\n    \n    assert(makeEqualAgain(6, a1) == 4);\n    assert(makeEqualAgain(7, a2) == 0);\n    assert(makeEqualAgain(8, a3) == 2);\n    assert(makeEqualAgain(3, a4) == 2);\n    assert(makeEqualAgain(7, a5) == 6);\n    assert(makeEqualAgain(9, a6) == 7);\n\n    int a7[] = {1, 2, 1};\n    int a8[] = {5, 5, 1, 5, 5};\n    int a9[] = {1, 1, 1, 1};\n    int a10[] = {2, 2, 2, 3, 2, 2};\n    int a11[] = {1};\n    int a12[] = {1, 2};\n    int a13[] = {1, 2, 2, 1};\n    int a14[] = {4, 4, 4, 3, 3, 4, 4};\n    int a15[] = {5, 4, 4, 4, 5, 5};\n    int a16[] = {1, 2, 1, 2, 1, 2, 1};\n    // Additional provided tests\n    assert(makeEqualAgain(3, a7) == 1);\n    assert(makeEqualAgain(5, a8) == 1);\n    assert(makeEqualAgain(4, a9) == 0);\n    assert(makeEqualAgain(6, a10) == 1);\n    assert(makeEqualAgain(1, a11) == 0);\n    assert(makeEqualAgain(2, a12) == 1);\n    assert(makeEqualAgain(4, a13) == 2);\n    assert(makeEqualAgain(7, a14) == 2);\n    assert(makeEqualAgain(6, a15) == 3);\n    assert(makeEqualAgain(7, a16) == 5);\n    \n    return 0;\n}", "instruction": " the following faulty CPP code snippet and error type list. \nYour task is to select the error type of the code based on the error list provided\n\nYou only need to answer error type. Do not write anything else in your response. \n\nFor example, if the code snippet is missing a semicolon, Your output should be 'missing_colons'.\n\nfaulty code:\n\n```\n#include <cstdio>\n#include <cassert>\nint makeEqualAgain(int n, int a[])\n{\n    int j = 0, p = 1, q = 0, c, d;\n    int k = n;\n    for (p = 1; p < k; p++) {\n        if (a[p] != a[p - 1])\n            break;\n    }\n    for (q = k - 1; q > p; q--) {\n        if (a[q] != a[p - 1])\n            break;\n    }\n    for (d = k - 2; d >= 0; d--) {\n        if (a[d] != a[d + 1])\n            break;\n    }\n    for (c = 0; c < d; c++) {\n        if (a[c] != a[c + 1])\n            break;\n    }\n    if (q - p + 1 < d - c + 1)\n        return q - p * 1;\n    else\n        return d - c + 1;\n}\n```\nerror type list:\n\n['illegal_comment', 'illegal_separation', 'missing_colons', 'misused ==and=', 'unclosed_parentheses', 'unclosed_string', 'faulty_indexing', 'function_error', 'illegal_keyword', 'undefined_methods', 'undefined_objects', 'algorithm_error', 'condition_error', 'operation_error', 'type_error', 'variable_error', 'double_bug', 'triple_bug', 'quadruple_bug', 'Misused Macro Definition', 'missing_backtick', 'misused_let', 'misused templte', 'Delayed Execution', 'Misused match', 'Misused := and =', 'Unused Variable', 'Misused === and ==', 'Misused =>', 'Misused Spread Operator', 'Misused begin/end', 'Missing $', 'illegal_indentation', 'Missing mut', 'Misused var and val', 'The digital leader is 0', 'Duplicate keys', 'struct_error', 'json_content_error']\n"}
{"question_id": "CPP/34", "category": "Logic", "subtype": "operation_error", "level": "easy", "example": "* Example:\n * >>> maxModeSum(3, {1, 2, 3})\n * 17\n * A sequence that reaches its maximum value is (3,2,3,1,2,2).", "docstring": "* Given n positive integers representing the count of each number from 1 to n,\n * find the maximum sum of the mode (most frequent element) for all prefixes of\n * a sequence constructed from these numbers. The mode is the largest number among\n * the most frequent elements in a sequence.\n *", "canonical_solution": "#include <cassert>\n#include <cstdio>\n\nlong long maxModeSum(int n, const int* counts)\n\n{\n    long long ans = 0;\n    int mx = 0;\n    long long f[100000];\n    for (int i = 0; i <= n; ++i) f[i] = 0;\n\n    for (int i = n; i > 0; --i) {\n        while (mx < counts[i - 1]) {\n            mx++;\n            f[mx] = f[mx - 1] + i;\n        }\n        ans += f[counts[i - 1]];\n    }\n    return ans;\n}", "buggy_code": "#include <cassert>\n#include <cstdio>\nlong long maxModeSum(int n, const int* counts)\n{\n    long long ans = 0;\n    int mx = 0;\n    long long f[100000];\n    for (int i = 0; i <= n; --i) f[i] = 0;\n    for (int i = n; i > 0; --i) {\n        while (mx < counts[i - 1]) {\n            mx++;\n            f[mx] = f[mx - 1] + i;\n        }\n        ans += f[counts[i - 1]];\n    }\n    return ans;\n}", "test": "int main() {\n    int a1[] = {1, 3, 2};\n    int a2[] = {4, 1, 2, 3};\n    int a3[] = {1, 1};\n    int a4[] = {1, 2, 3, 4, 5};\n    int a5[] = {100000};\n    int a6[] = {5, 3, 2, 4, 1};\n    int a7[] = {100000, 100000, 100000};\n    int a8[] = {2, 2, 5};\n    int a9[] = {4, 4, 4, 4};\n    int a10[] = {1, 2, 3, 4, 5, 6};\n    int a11[] = {3, 1, 2};\n\n    assert(maxModeSum(3, a1) == 17);\n    assert(maxModeSum(4, a2) == 37);\n    assert(maxModeSum(2, a3) == 4);\n    assert(maxModeSum(5, a4) == 75);\n    assert(maxModeSum(1, a5) == 100000);\n    assert(maxModeSum(5, a6) == 62);\n    assert(maxModeSum(3, a7) == 900000);\n    assert(maxModeSum(3, a8) == 27);\n    assert(maxModeSum(4, a9) == 64);\n    assert(maxModeSum(6, a10) == 126);\n    assert(maxModeSum(3, a11) == 16);\n    return 0;\n}", "instruction": " the following faulty CPP code snippet and error type list. \nYour task is to select the error type of the code based on the error list provided\n\nYou only need to answer error type. Do not write anything else in your response. \n\nFor example, if the code snippet is missing a semicolon, Your output should be 'missing_colons'.\n\nfaulty code:\n\n```\n#include <cassert>\n#include <cstdio>\nlong long maxModeSum(int n, const int* counts)\n{\n    long long ans = 0;\n    int mx = 0;\n    long long f[100000];\n    for (int i = 0; i <= n; --i) f[i] = 0;\n    for (int i = n; i > 0; --i) {\n        while (mx < counts[i - 1]) {\n            mx++;\n            f[mx] = f[mx - 1] + i;\n        }\n        ans += f[counts[i - 1]];\n    }\n    return ans;\n}\n```\nerror type list:\n\n['illegal_comment', 'illegal_separation', 'missing_colons', 'misused ==and=', 'unclosed_parentheses', 'unclosed_string', 'faulty_indexing', 'function_error', 'illegal_keyword', 'undefined_methods', 'undefined_objects', 'algorithm_error', 'condition_error', 'operation_error', 'type_error', 'variable_error', 'double_bug', 'triple_bug', 'quadruple_bug', 'Misused Macro Definition', 'missing_backtick', 'misused_let', 'misused templte', 'Delayed Execution', 'Misused match', 'Misused := and =', 'Unused Variable', 'Misused === and ==', 'Misused =>', 'Misused Spread Operator', 'Misused begin/end', 'Missing $', 'illegal_indentation', 'Missing mut', 'Misused var and val', 'The digital leader is 0', 'Duplicate keys', 'struct_error', 'json_content_error']\n"}
{"question_id": "CPP/35", "category": "Logic", "subtype": "operation_error", "level": "easy", "example": "For example:\n    >>> countBalancedSubsequences(2, 2, 2)\n    2", "docstring": "Given three integers n, m, and k, find the number of sequences consisting of n '(' and m ')',\nsuch that the longest balanced subsequence is of length 2 * k. The result should be calculated modulo 1,000,000,007 (10^9 + 7).", "canonical_solution": "#include <cassert>\n\nlong long countBalancedSubsequences(long long n, long long m, long long k)\n\n{\n    const long long P = static_cast<long long>(1e9) + 7;\n    static long long C[4001][4001] = {0};\n\n    if (C[0][0] == 0) {\n        for (long long i = 0; i <= 4000; i++) C[i][0] = 1;\n        for (long long i = 1; i <= 4000; i++)\n            for (long long j = 1; j <= i; j++)\n                C[i][j] = (C[i - 1][j - 1] + C[i - 1][j]) % P;\n    }\n\n    if (k > n || k > m) return 0;\n    return (C[n + m][k] - C[n + m][k - 1] + P) % P;\n}", "buggy_code": "#include <cassert>\nlong long countBalancedSubsequences(long long n, long long m, long long k)\n{\n    const long long P = static_cast<long long>(1e9) + 7;\n    static long long C[4001][4001] = {0};\n    if (C[0][0] == 0) {\n        for (long long i = 0; i <= 4000; i++) C[i][0] = 1;\n        for (long long i = 1; i <= 4000; i++)\n            for (long long j = 1; j <= i; j++)\n                C[i][j] = (C[i - 1][j - 1] + C[i - 1][j]) % P;\n    }\n    if (k < n || k > m) return 0;\n    return (C[n + m][k] - C[n + m][k - 1] + P) % P;\n}", "test": "int main() {\n    assert(countBalancedSubsequences(2, 2, 2) == 2);\n    assert(countBalancedSubsequences(3, 2, 3) == 0);\n    assert(countBalancedSubsequences(3, 2, 1) == 4);\n    assert(countBalancedSubsequences(4, 3, 2) == 14);\n    assert(countBalancedSubsequences(5, 5, 2) == 35);\n    assert(countBalancedSubsequences(6, 1, 1) == 6);\n    assert(countBalancedSubsequences(1, 6, 1) == 6);\n    assert(countBalancedSubsequences(7, 2, 2) == 27);\n    assert(countBalancedSubsequences(8, 3, 3) == 110);\n    assert(countBalancedSubsequences(10, 10, 5) == 10659);\n    assert(countBalancedSubsequences(20, 20, 10) == 574221648);\n    assert(countBalancedSubsequences(2000, 2000, 1000) == 854104531);\n    assert(countBalancedSubsequences(2000, 1999, 1000) == 334874485);\n    assert(countBalancedSubsequences(2000, 2000, 1999) == 259428024);\n    return 0;\n}", "instruction": " the following faulty CPP code snippet and error type list. \nYour task is to select the error type of the code based on the error list provided\n\nYou only need to answer error type. Do not write anything else in your response. \n\nFor example, if the code snippet is missing a semicolon, Your output should be 'missing_colons'.\n\nfaulty code:\n\n```\n#include <cassert>\nlong long countBalancedSubsequences(long long n, long long m, long long k)\n{\n    const long long P = static_cast<long long>(1e9) + 7;\n    static long long C[4001][4001] = {0};\n    if (C[0][0] == 0) {\n        for (long long i = 0; i <= 4000; i++) C[i][0] = 1;\n        for (long long i = 1; i <= 4000; i++)\n            for (long long j = 1; j <= i; j++)\n                C[i][j] = (C[i - 1][j - 1] + C[i - 1][j]) % P;\n    }\n    if (k < n || k > m) return 0;\n    return (C[n + m][k] - C[n + m][k - 1] + P) % P;\n}\n```\nerror type list:\n\n['illegal_comment', 'illegal_separation', 'missing_colons', 'misused ==and=', 'unclosed_parentheses', 'unclosed_string', 'faulty_indexing', 'function_error', 'illegal_keyword', 'undefined_methods', 'undefined_objects', 'algorithm_error', 'condition_error', 'operation_error', 'type_error', 'variable_error', 'double_bug', 'triple_bug', 'quadruple_bug', 'Misused Macro Definition', 'missing_backtick', 'misused_let', 'misused templte', 'Delayed Execution', 'Misused match', 'Misused := and =', 'Unused Variable', 'Misused === and ==', 'Misused =>', 'Misused Spread Operator', 'Misused begin/end', 'Missing $', 'illegal_indentation', 'Missing mut', 'Misused var and val', 'The digital leader is 0', 'Duplicate keys', 'struct_error', 'json_content_error']\n"}
{"question_id": "CPP/36", "category": "Logic", "subtype": "type_error", "level": "easy", "example": ">>> countPermutations(2, 1, [1, 2])\n    2", "docstring": "Given a permutation q of n elements and an integer k, find the number of permutations p of n elements such that f(p) = q, where f(p) is the lexicographically smallest permutation that can be obtained by dividing p into exactly k non-empty contiguous segments and sorting each segment (i.e., choose k-1 breakpoints 1 <= x_1 < x_2 < ... < x_{k-1} < n, and divide it into [1, x_1], (x_1, x_2], ..., (x_{k-1}, n]). The result should be modulo 998244353.", "canonical_solution": "#include <bits/stdc++.h>\n\nint countPermutations(int n, int k, int qq[])\n\n{\n    const int N = 505, P = 998244353;\n    int q[N], m, dp[N][N], jc[N], f[N], ans;\n    memset(q, 0, sizeof(q));\n    memset(dp, 0, sizeof(dp));\n    memset(jc, 0, sizeof(jc));\n    memset(f, 0, sizeof(f));\n    ans = 0;\n\n    for (int i = 1; i <= n; i++)\n        q[i] = qq[i - 1];\n    dp[0][0] = f[0] = 1;\n    for (int i = jc[0] = 1; i <= n; i++)\n        jc[i] = 1LL * jc[i - 1] * i % P;\n    for (int i = 1; i <= n; i++)\n    {\n        f[i] = jc[i];\n        for (int j = 1; j < i; j++)\n            f[i] = (f[i] + P - 1LL * f[j] * jc[i - j] % P) % P;\n    }\n    for (int i = 1; i <= n; i++)\n    {\n        for (int j = 0; j < i; j++)\n            for (int k = 1; k <= n; k++)\n                dp[i][k] = (dp[i][k] + dp[j][k - 1] * 1LL * f[i - j] % P) % P;\n    }\n    m = 0;\n    for (int i = 1; i <= n; i++)\n        if (q[i] > q[i + 1])\n        {\n            m = i;\n            break;\n        }\n    if (m == n)\n    {\n        for (int i = k; i <= n; i++)\n            ans = (ans + dp[n][i]) % P;\n    }\n    else\n    {\n        for (int i = m + 1; i <= n; i++)\n        {\n            if (i != m + 1 && (q[i - 1] > q[i] || q[i] < q[m]))\n                break;\n            int c = k + i - n - 1;\n            if (c >= 0)\n                ans = (ans + dp[m][c] * 1LL * jc[i - m - 1] % P) % P;\n        }\n    }\n    return ans;\n}", "buggy_code": "#include <bits/stdc++.h>\nint countPermutations(int n, int k, int qq[])\n{\n    char N = 505, P = 998244353;\n    int q[N], m, dp[N][N], jc[N], f[N], ans;\n    memset(q, 0, sizeof(q));\n    memset(dp, 0, sizeof(dp));\n    memset(jc, 0, sizeof(jc));\n    memset(f, 0, sizeof(f));\n    ans = 0;\n    for (int i = 1; i <= n; i++)\n        q[i] = qq[i - 1];\n    dp[0][0] = f[0] = 1;\n    for (int i = jc[0] = 1; i <= n; i++)\n        jc[i] = 1LL * jc[i - 1] * i % P;\n    for (int i = 1; i <= n; i++)\n    {\n        f[i] = jc[i];\n        for (int j = 1; j < i; j++)\n            f[i] = (f[i] + P - 1LL * f[j] * jc[i - j] % P) % P;\n    }\n    for (int i = 1; i <= n; i++)\n    {\n        for (int j = 0; j < i; j++)\n            for (int k = 1; k <= n; k++)\n                dp[i][k] = (dp[i][k] + dp[j][k - 1] * 1LL * f[i - j] % P) % P;\n    }\n    m = 0;\n    for (int i = 1; i <= n; i++)\n        if (q[i] > q[i + 1])\n        {\n            m = i;\n            break;\n        }\n    if (m == n)\n    {\n        for (int i = k; i <= n; i++)\n            ans = (ans + dp[n][i]) % P;\n    }\n    else\n    {\n        for (int i = m + 1; i <= n; i++)\n        {\n            if (i != m + 1 && (q[i - 1] > q[i] || q[i] < q[m]))\n                break;\n            int c = k + i - n - 1;\n            if (c >= 0)\n                ans = (ans + dp[m][c] * 1LL * jc[i - m - 1] % P) % P;\n        }\n    }\n    return ans;\n}", "test": "int main() {\n    int q1[] = {1, 2};\n    assert(countPermutations(2, 1, q1) == 2);\n\n    int q2[] = {3, 1, 2};\n    assert(countPermutations(3, 3, q2) == 1);\n\n    int q3[] = {1, 2, 3, 6, 5, 4};\n    assert(countPermutations(6, 3, q3) == 13);\n\n    int q4[] = {1, 2, 3, 4, 5, 6};\n    assert(countPermutations(6, 1, q4) == 720);\n\n    int q5[] = {1, 2, 5, 3, 4, 5};\n    assert(countPermutations(6, 3, q5) == 0);\n\n    int q6[] = {1, 2, 3, 4, 5, 6, 7, 8, 9};\n    assert(countPermutations(9, 9, q6) == 1);\n\n    int q7[] = {1, 2, 3, 4, 5, 6, 7, 9, 8};\n    assert(countPermutations(9, 2, q7) == 29093);\n    return 0;}", "instruction": " the following faulty CPP code snippet and error type list. \nYour task is to select the error type of the code based on the error list provided\n\nYou only need to answer error type. Do not write anything else in your response. \n\nFor example, if the code snippet is missing a semicolon, Your output should be 'missing_colons'.\n\nfaulty code:\n\n```\n#include <bits/stdc++.h>\nint countPermutations(int n, int k, int qq[])\n{\n    char N = 505, P = 998244353;\n    int q[N], m, dp[N][N], jc[N], f[N], ans;\n    memset(q, 0, sizeof(q));\n    memset(dp, 0, sizeof(dp));\n    memset(jc, 0, sizeof(jc));\n    memset(f, 0, sizeof(f));\n    ans = 0;\n    for (int i = 1; i <= n; i++)\n        q[i] = qq[i - 1];\n    dp[0][0] = f[0] = 1;\n    for (int i = jc[0] = 1; i <= n; i++)\n        jc[i] = 1LL * jc[i - 1] * i % P;\n    for (int i = 1; i <= n; i++)\n    {\n        f[i] = jc[i];\n        for (int j = 1; j < i; j++)\n            f[i] = (f[i] + P - 1LL * f[j] * jc[i - j] % P) % P;\n    }\n    for (int i = 1; i <= n; i++)\n    {\n        for (int j = 0; j < i; j++)\n            for (int k = 1; k <= n; k++)\n                dp[i][k] = (dp[i][k] + dp[j][k - 1] * 1LL * f[i - j] % P) % P;\n    }\n    m = 0;\n    for (int i = 1; i <= n; i++)\n        if (q[i] > q[i + 1])\n        {\n            m = i;\n            break;\n        }\n    if (m == n)\n    {\n        for (int i = k; i <= n; i++)\n            ans = (ans + dp[n][i]) % P;\n    }\n    else\n    {\n        for (int i = m + 1; i <= n; i++)\n        {\n            if (i != m + 1 && (q[i - 1] > q[i] || q[i] < q[m]))\n                break;\n            int c = k + i - n - 1;\n            if (c >= 0)\n                ans = (ans + dp[m][c] * 1LL * jc[i - m - 1] % P) % P;\n        }\n    }\n    return ans;\n}\n```\nerror type list:\n\n['illegal_comment', 'illegal_separation', 'missing_colons', 'misused ==and=', 'unclosed_parentheses', 'unclosed_string', 'faulty_indexing', 'function_error', 'illegal_keyword', 'undefined_methods', 'undefined_objects', 'algorithm_error', 'condition_error', 'operation_error', 'type_error', 'variable_error', 'double_bug', 'triple_bug', 'quadruple_bug', 'Misused Macro Definition', 'missing_backtick', 'misused_let', 'misused templte', 'Delayed Execution', 'Misused match', 'Misused := and =', 'Unused Variable', 'Misused === and ==', 'Misused =>', 'Misused Spread Operator', 'Misused begin/end', 'Missing $', 'illegal_indentation', 'Missing mut', 'Misused var and val', 'The digital leader is 0', 'Duplicate keys', 'struct_error', 'json_content_error']\n"}
{"question_id": "CPP/37", "category": "Logic", "subtype": "type_error", "level": "medium", "example": "* For example:\n *     >>> expectedCuts(3, 3, 4)\n *     3\n *     >>> expectedCuts(5, 5, 12)\n *     2", "docstring": "* Given a rectangle paper of size n x m placed on a plane Cartesian coordinate \n * system with its bottom-left corner at (0,0) and top-right corner at (n,m), \n * you need to calculate the expected number of operations to cut the paper such that \n * the remaining area is less than k. In each operation, a line is randomly chosen \n * that is parallel to the axes, passes through points with integer coordinates, \n * and cuts through (not just touching the edge) the paper. The bottom or right part \n * of the paper along this line is then discarded. The answer should be modulo 10^9+7.\n *", "canonical_solution": "#include <cassert>\n#include <cstdio>\n\nlong long expectedCuts(int n, int m, long long k)\n\n{\n    const int MD = 1000000007;\n    const int N = 1000000;\n    int vv[N * 2 + 1], i, j;\n    long long ans = 1;\n\n    vv[1] = 1;\n    for (i = 2; i <= N * 2; i++)\n        vv[i] = (long long)vv[i - MD % i] * (MD / i + 1) % MD;\n\n    if (k > (long long)n * m) {\n        return 0;\n    }\n\n    for (i = (k + m - 1) / m; i < n; i++)\n        ans = (ans + vv[i + (k + i - 1) / i - 1]) % MD;\n    for (j = (k + n - 1) / n; j < m; j++)\n        ans = (ans + vv[(k + j - 1) / j + j - 1]) % MD;\n\n    return ans;\n}", "buggy_code": "#include <cassert>\n#include <cstdio>\nlong long expectedCuts(int n, int m, long long k)\n{\n    const int MD = 1000000007;\n    const int N = 1000000;\n    int vv[N * 2 + 1], i, j;\n    char ans = 1;\n    vv[1] = 1;\n    for (i = 2; i <= N * 2; i++)\n        vv[i] = (long long)vv[i - MD % i] * (MD / i + 1) % MD;\n    if (k > (long long)n * m) {\n        return 0;\n    }\n    for (i = (k + m - 1) / m; i < n; i++)\n        ans = (ans + vv[i + (k + i - 1) / i - 1]) % MD;\n    for (j = (k + n - 1) / n; j < m; j++)\n        ans = (ans + vv[(k + j - 1) / j + j - 1]) % MD;\n    return ans;\n}", "test": "int main() {\n    assert(expectedCuts(2, 4, 10) == 0);\n    assert(expectedCuts(2, 4, 8) == 1);\n    assert(expectedCuts(2, 4, 2) == 833333342);\n    assert(expectedCuts(2, 4, 6) == 250000003);\n    assert(expectedCuts(3, 3, 4) == 666666673);\n    assert(expectedCuts(5, 5, 12) == 666666673);\n    assert(expectedCuts(6, 7, 20) == 722222229);\n    assert(expectedCuts(8, 8, 30) == 72727275);\n    assert(expectedCuts(10, 10, 50) == 714285721);\n    assert(expectedCuts(1, 10, 5) == 945634929);\n    assert(expectedCuts(10, 1, 5) == 945634929);\n    return 0;\n}", "instruction": " the following faulty CPP code snippet and error type list. \nYour task is to select the error type of the code based on the error list provided\n\nYou only need to answer error type. Do not write anything else in your response. \n\nFor example, if the code snippet is missing a semicolon, Your output should be 'missing_colons'.\n\nfaulty code:\n\n```\n#include <cassert>\n#include <cstdio>\nlong long expectedCuts(int n, int m, long long k)\n{\n    const int MD = 1000000007;\n    const int N = 1000000;\n    int vv[N * 2 + 1], i, j;\n    char ans = 1;\n    vv[1] = 1;\n    for (i = 2; i <= N * 2; i++)\n        vv[i] = (long long)vv[i - MD % i] * (MD / i + 1) % MD;\n    if (k > (long long)n * m) {\n        return 0;\n    }\n    for (i = (k + m - 1) / m; i < n; i++)\n        ans = (ans + vv[i + (k + i - 1) / i - 1]) % MD;\n    for (j = (k + n - 1) / n; j < m; j++)\n        ans = (ans + vv[(k + j - 1) / j + j - 1]) % MD;\n    return ans;\n}\n```\nerror type list:\n\n['illegal_comment', 'illegal_separation', 'missing_colons', 'misused ==and=', 'unclosed_parentheses', 'unclosed_string', 'faulty_indexing', 'function_error', 'illegal_keyword', 'undefined_methods', 'undefined_objects', 'algorithm_error', 'condition_error', 'operation_error', 'type_error', 'variable_error', 'double_bug', 'triple_bug', 'quadruple_bug', 'Misused Macro Definition', 'missing_backtick', 'misused_let', 'misused templte', 'Delayed Execution', 'Misused match', 'Misused := and =', 'Unused Variable', 'Misused === and ==', 'Misused =>', 'Misused Spread Operator', 'Misused begin/end', 'Missing $', 'illegal_indentation', 'Missing mut', 'Misused var and val', 'The digital leader is 0', 'Duplicate keys', 'struct_error', 'json_content_error']\n"}
{"question_id": "CPP/38", "category": "Logic", "subtype": "type_error", "level": "easy", "example": "* For example:\n *     >>> expectedCuts(3, 3, 4)\n *     3\n *     >>> expectedCuts(5, 5, 12)\n *     2", "docstring": "* Given a rectangle paper of size n x m placed on a plane Cartesian coordinate \n * system with its bottom-left corner at (0,0) and top-right corner at (n,m), \n * you need to calculate the expected number of operations to cut the paper such that \n * the remaining area is less than k. In each operation, a line is randomly chosen \n * that is parallel to the axes, passes through points with integer coordinates, \n * and cuts through (not just touching the edge) the paper. The bottom or right part \n * of the paper along this line is then discarded. The answer should be modulo 10^9+7.\n *", "canonical_solution": "#include <cassert>\n#include <cstdio>\n\nlong long expectedCuts(int n, int m, long long k)\n\n{\n    const int MD = 1000000007;\n    const int N = 1000000;\n    int vv[N * 2 + 1], i, j;\n    long long ans = 1;\n\n    vv[1] = 1;\n    for (i = 2; i <= N * 2; i++)\n        vv[i] = (long long)vv[i - MD % i] * (MD / i + 1) % MD;\n\n    if (k > (long long)n * m) {\n        return 0;\n    }\n\n    for (i = (k + m - 1) / m; i < n; i++)\n        ans = (ans + vv[i + (k + i - 1) / i - 1]) % MD;\n    for (j = (k + n - 1) / n; j < m; j++)\n        ans = (ans + vv[(k + j - 1) / j + j - 1]) % MD;\n\n    return ans;\n}", "buggy_code": "#include <cassert>\n#include <cstdio>\nlong long expectedCuts(int n, int m, long long k)\n{\n    const int MD = 1000000007;\n    const int N = 1000000;\n    const int vv[N * 2 + 1], i, j;\n    long long ans = 1;\n    vv[1] = 1;\n    for (i = 2; i <= N * 2; i++)\n        vv[i] = (long long)vv[i - MD % i] * (MD / i + 1) % MD;\n    if (k > (long long)n * m) {\n        return 0;\n    }\n    for (i = (k + m - 1) / m; i < n; i++)\n        ans = (ans + vv[i + (k + i - 1) / i - 1]) % MD;\n    for (j = (k + n - 1) / n; j < m; j++)\n        ans = (ans + vv[(k + j - 1) / j + j - 1]) % MD;\n    return ans;\n}", "test": "int main() {\n    assert(expectedCuts(2, 4, 10) == 0);\n    assert(expectedCuts(2, 4, 8) == 1);\n    assert(expectedCuts(2, 4, 2) == 833333342);\n    assert(expectedCuts(2, 4, 6) == 250000003);\n    assert(expectedCuts(3, 3, 4) == 666666673);\n    assert(expectedCuts(5, 5, 12) == 666666673);\n    assert(expectedCuts(6, 7, 20) == 722222229);\n    assert(expectedCuts(8, 8, 30) == 72727275);\n    assert(expectedCuts(10, 10, 50) == 714285721);\n    assert(expectedCuts(1, 10, 5) == 945634929);\n    assert(expectedCuts(10, 1, 5) == 945634929);\n    return 0;\n}", "instruction": " the following faulty CPP code snippet and error type list. \nYour task is to select the error type of the code based on the error list provided\n\nYou only need to answer error type. Do not write anything else in your response. \n\nFor example, if the code snippet is missing a semicolon, Your output should be 'missing_colons'.\n\nfaulty code:\n\n```\n#include <cassert>\n#include <cstdio>\nlong long expectedCuts(int n, int m, long long k)\n{\n    const int MD = 1000000007;\n    const int N = 1000000;\n    const int vv[N * 2 + 1], i, j;\n    long long ans = 1;\n    vv[1] = 1;\n    for (i = 2; i <= N * 2; i++)\n        vv[i] = (long long)vv[i - MD % i] * (MD / i + 1) % MD;\n    if (k > (long long)n * m) {\n        return 0;\n    }\n    for (i = (k + m - 1) / m; i < n; i++)\n        ans = (ans + vv[i + (k + i - 1) / i - 1]) % MD;\n    for (j = (k + n - 1) / n; j < m; j++)\n        ans = (ans + vv[(k + j - 1) / j + j - 1]) % MD;\n    return ans;\n}\n```\nerror type list:\n\n['illegal_comment', 'illegal_separation', 'missing_colons', 'misused ==and=', 'unclosed_parentheses', 'unclosed_string', 'faulty_indexing', 'function_error', 'illegal_keyword', 'undefined_methods', 'undefined_objects', 'algorithm_error', 'condition_error', 'operation_error', 'type_error', 'variable_error', 'double_bug', 'triple_bug', 'quadruple_bug', 'Misused Macro Definition', 'missing_backtick', 'misused_let', 'misused templte', 'Delayed Execution', 'Misused match', 'Misused := and =', 'Unused Variable', 'Misused === and ==', 'Misused =>', 'Misused Spread Operator', 'Misused begin/end', 'Missing $', 'illegal_indentation', 'Missing mut', 'Misused var and val', 'The digital leader is 0', 'Duplicate keys', 'struct_error', 'json_content_error']\n"}
{"question_id": "CPP/39", "category": "Logic", "subtype": "type_error", "level": "easy", "example": "* For example:\n *     >>> expectedCuts(3, 3, 4)\n *     3\n *     >>> expectedCuts(5, 5, 12)\n *     2", "docstring": "* Given a rectangle paper of size n x m placed on a plane Cartesian coordinate \n * system with its bottom-left corner at (0,0) and top-right corner at (n,m), \n * you need to calculate the expected number of operations to cut the paper such that \n * the remaining area is less than k. In each operation, a line is randomly chosen \n * that is parallel to the axes, passes through points with integer coordinates, \n * and cuts through (not just touching the edge) the paper. The bottom or right part \n * of the paper along this line is then discarded. The answer should be modulo 10^9+7.\n *", "canonical_solution": "#include <cassert>\n#include <cstdio>\n\nlong long expectedCuts(int n, int m, long long k)\n\n{\n    const int MD = 1000000007;\n    const int N = 1000000;\n    int vv[N * 2 + 1], i, j;\n    long long ans = 1;\n\n    vv[1] = 1;\n    for (i = 2; i <= N * 2; i++)\n        vv[i] = (long long)vv[i - MD % i] * (MD / i + 1) % MD;\n\n    if (k > (long long)n * m) {\n        return 0;\n    }\n\n    for (i = (k + m - 1) / m; i < n; i++)\n        ans = (ans + vv[i + (k + i - 1) / i - 1]) % MD;\n    for (j = (k + n - 1) / n; j < m; j++)\n        ans = (ans + vv[(k + j - 1) / j + j - 1]) % MD;\n\n    return ans;\n}", "buggy_code": "#include <cassert>\n#include <cstdio>\nlong long expectedCuts(int n, int m, long long k)\n{\n    const int MD = 1000000007;\n    float N = 1000000;\n    int vv[N * 2 + 1], i, j;\n    long long ans = 1;\n    vv[1] = 1;\n    for (i = 2; i <= N * 2; i++)\n        vv[i] = (long long)vv[i - MD % i] * (MD / i + 1) % MD;\n    if (k > (long long)n * m) {\n        return 0;\n    }\n    for (i = (k + m - 1) / m; i < n; i++)\n        ans = (ans + vv[i + (k + i - 1) / i - 1]) % MD;\n    for (j = (k + n - 1) / n; j < m; j++)\n        ans = (ans + vv[(k + j - 1) / j + j - 1]) % MD;\n    return ans;\n}", "test": "int main() {\n    assert(expectedCuts(2, 4, 10) == 0);\n    assert(expectedCuts(2, 4, 8) == 1);\n    assert(expectedCuts(2, 4, 2) == 833333342);\n    assert(expectedCuts(2, 4, 6) == 250000003);\n    assert(expectedCuts(3, 3, 4) == 666666673);\n    assert(expectedCuts(5, 5, 12) == 666666673);\n    assert(expectedCuts(6, 7, 20) == 722222229);\n    assert(expectedCuts(8, 8, 30) == 72727275);\n    assert(expectedCuts(10, 10, 50) == 714285721);\n    assert(expectedCuts(1, 10, 5) == 945634929);\n    assert(expectedCuts(10, 1, 5) == 945634929);\n    return 0;\n}", "instruction": " the following faulty CPP code snippet and error type list. \nYour task is to select the error type of the code based on the error list provided\n\nYou only need to answer error type. Do not write anything else in your response. \n\nFor example, if the code snippet is missing a semicolon, Your output should be 'missing_colons'.\n\nfaulty code:\n\n```\n#include <cassert>\n#include <cstdio>\nlong long expectedCuts(int n, int m, long long k)\n{\n    const int MD = 1000000007;\n    float N = 1000000;\n    int vv[N * 2 + 1], i, j;\n    long long ans = 1;\n    vv[1] = 1;\n    for (i = 2; i <= N * 2; i++)\n        vv[i] = (long long)vv[i - MD % i] * (MD / i + 1) % MD;\n    if (k > (long long)n * m) {\n        return 0;\n    }\n    for (i = (k + m - 1) / m; i < n; i++)\n        ans = (ans + vv[i + (k + i - 1) / i - 1]) % MD;\n    for (j = (k + n - 1) / n; j < m; j++)\n        ans = (ans + vv[(k + j - 1) / j + j - 1]) % MD;\n    return ans;\n}\n```\nerror type list:\n\n['illegal_comment', 'illegal_separation', 'missing_colons', 'misused ==and=', 'unclosed_parentheses', 'unclosed_string', 'faulty_indexing', 'function_error', 'illegal_keyword', 'undefined_methods', 'undefined_objects', 'algorithm_error', 'condition_error', 'operation_error', 'type_error', 'variable_error', 'double_bug', 'triple_bug', 'quadruple_bug', 'Misused Macro Definition', 'missing_backtick', 'misused_let', 'misused templte', 'Delayed Execution', 'Misused match', 'Misused := and =', 'Unused Variable', 'Misused === and ==', 'Misused =>', 'Misused Spread Operator', 'Misused begin/end', 'Missing $', 'illegal_indentation', 'Missing mut', 'Misused var and val', 'The digital leader is 0', 'Duplicate keys', 'struct_error', 'json_content_error']\n"}
{"question_id": "CPP/40", "category": "Logic", "subtype": "type_error", "level": "easy", "example": "* Examples:\n *   minOperations(5, {1, 2, 3, 2, 1}) -> 2", "docstring": "* You are given a 1 by n pixel image, where each pixel has a color \n * represented by an integer. You can perform an operation where you \n * pick a color and change all connected pixels of the same color to \n * the chosen color. Two pixels are connected if they are adjacent \n * and have the same color. Find the minimum number of operations \n * required to make all pixels the same color.\n *\n * Note: For each color, there are at most 20 pixels of that color.\n *", "canonical_solution": "#include <cassert>\n#include <cstdio>\n\nint minOperations(int n, int* pixels)\n\n{\n    int pre[n+1], u[n+1], f[n+1][n+1];\n    for (int i = 1; i <= n; i++) {\n        pre[i] = u[i] = 0;\n    }\n    for (int i = 1; i <= n; i++) {\n        pre[i] = u[pixels[i-1]];\n        u[pixels[i-1]] = i;\n    }\n    for (int i = 1; i <= n; i++) {\n        for (int j = 1; j <= n; j++) {\n            if (i != j) f[i][j] = 1000000000;\n            else f[i][j] = 0;\n        }\n    }\n    for (int len = 2; len <= n; len++) {\n        for (int i = 1; i <= n - len + 1; i++) {\n            int j = i + len - 1;\n            f[i][j] = f[i][j - 1] + 1;\n            for (int l = pre[j]; l >= i; l = pre[l]) {\n                f[i][j] = f[i][j] < f[i][l] + f[l + 1][j] ? f[i][j] : f[i][l] + f[l + 1][j];\n            }\n        }\n    }\n    return f[1][n];\n}", "buggy_code": "#include <cassert>\n#include <cstdio>\nint minOperations(int n, int* pixels)\n{\n    int* pre[n+1], u[n+1], f[n+1][n+1];\n    for (int i = 1; i <= n; i++) {\n        pre[i] = u[i] = 0;\n    }\n    for (int i = 1; i <= n; i++) {\n        pre[i] = u[pixels[i-1]];\n        u[pixels[i-1]] = i;\n    }\n    for (int i = 1; i <= n; i++) {\n        for (int j = 1; j <= n; j++) {\n            if (i != j) f[i][j] = 1000000000;\n            else f[i][j] = 0;\n        }\n    }\n    for (int len = 2; len <= n; len++) {\n        for (int i = 1; i <= n - len + 1; i++) {\n            int j = i + len - 1;\n            f[i][j] = f[i][j - 1] + 1;\n            for (int l = pre[j]; l >= i; l = pre[l]) {\n                f[i][j] = f[i][j] < f[i][l] + f[l + 1][j] ? f[i][j] : f[i][l] + f[l + 1][j];\n            }\n        }\n    }\n    return f[1][n];\n}", "test": "int main() {\n    int a1[] = {1, 2, 3, 2, 1};\n    int a2[] = {1, 1, 2, 2};\n    int a3[] = {1, 2, 1, 4, 2};\n    int a4[] = {5, 5, 5, 5, 5};\n    int a5[] = {1, 1, 1, 2, 2, 2};\n    int a6[] = {1, 3, 3, 3, 2, 2, 2};\n    int a7[] = {4, 4, 4, 4, 3, 3, 3, 3};\n    int a8[] = {1, 2, 3, 4, 5, 6, 7, 8, 9};\n    int a9[] = {1, 2, 1, 2, 1, 2, 1, 2, 1, 2};\n    int a10[] = {3, 3, 3};\n    int a11[] = {2, 1, 1, 2};\n    assert(minOperations(5, a1) == 2);\n    assert(minOperations(4, a2) == 1);\n    assert(minOperations(5, a3) == 3);\n    assert(minOperations(5, a4) == 0);\n    assert(minOperations(6, a5) == 1);\n    assert(minOperations(7, a6) == 2);\n    assert(minOperations(8, a7) == 1);\n    assert(minOperations(9, a8) == 8);\n    assert(minOperations(10, a9) == 5);\n    assert(minOperations(3, a10) == 0);\n    assert(minOperations(4, a11) == 1);\n    return 0;\n}", "instruction": " the following faulty CPP code snippet and error type list. \nYour task is to select the error type of the code based on the error list provided\n\nYou only need to answer error type. Do not write anything else in your response. \n\nFor example, if the code snippet is missing a semicolon, Your output should be 'missing_colons'.\n\nfaulty code:\n\n```\n#include <cassert>\n#include <cstdio>\nint minOperations(int n, int* pixels)\n{\n    int* pre[n+1], u[n+1], f[n+1][n+1];\n    for (int i = 1; i <= n; i++) {\n        pre[i] = u[i] = 0;\n    }\n    for (int i = 1; i <= n; i++) {\n        pre[i] = u[pixels[i-1]];\n        u[pixels[i-1]] = i;\n    }\n    for (int i = 1; i <= n; i++) {\n        for (int j = 1; j <= n; j++) {\n            if (i != j) f[i][j] = 1000000000;\n            else f[i][j] = 0;\n        }\n    }\n    for (int len = 2; len <= n; len++) {\n        for (int i = 1; i <= n - len + 1; i++) {\n            int j = i + len - 1;\n            f[i][j] = f[i][j - 1] + 1;\n            for (int l = pre[j]; l >= i; l = pre[l]) {\n                f[i][j] = f[i][j] < f[i][l] + f[l + 1][j] ? f[i][j] : f[i][l] + f[l + 1][j];\n            }\n        }\n    }\n    return f[1][n];\n}\n```\nerror type list:\n\n['illegal_comment', 'illegal_separation', 'missing_colons', 'misused ==and=', 'unclosed_parentheses', 'unclosed_string', 'faulty_indexing', 'function_error', 'illegal_keyword', 'undefined_methods', 'undefined_objects', 'algorithm_error', 'condition_error', 'operation_error', 'type_error', 'variable_error', 'double_bug', 'triple_bug', 'quadruple_bug', 'Misused Macro Definition', 'missing_backtick', 'misused_let', 'misused templte', 'Delayed Execution', 'Misused match', 'Misused := and =', 'Unused Variable', 'Misused === and ==', 'Misused =>', 'Misused Spread Operator', 'Misused begin/end', 'Missing $', 'illegal_indentation', 'Missing mut', 'Misused var and val', 'The digital leader is 0', 'Duplicate keys', 'struct_error', 'json_content_error']\n"}
{"question_id": "CPP/41", "category": "Logic", "subtype": "variable_error", "level": "medium", "example": "* Examples:\n *   minOperations(5, {1, 2, 3, 2, 1}) -> 2", "docstring": "* You are given a 1 by n pixel image, where each pixel has a color \n * represented by an integer. You can perform an operation where you \n * pick a color and change all connected pixels of the same color to \n * the chosen color. Two pixels are connected if they are adjacent \n * and have the same color. Find the minimum number of operations \n * required to make all pixels the same color.\n *\n * Note: For each color, there are at most 20 pixels of that color.\n *", "canonical_solution": "#include <cassert>\n#include <cstdio>\n\nint minOperations(int n, int* pixels)\n\n{\n    int pre[n+1], u[n+1], f[n+1][n+1];\n    for (int i = 1; i <= n; i++) {\n        pre[i] = u[i] = 0;\n    }\n    for (int i = 1; i <= n; i++) {\n        pre[i] = u[pixels[i-1]];\n        u[pixels[i-1]] = i;\n    }\n    for (int i = 1; i <= n; i++) {\n        for (int j = 1; j <= n; j++) {\n            if (i != j) f[i][j] = 1000000000;\n            else f[i][j] = 0;\n        }\n    }\n    for (int len = 2; len <= n; len++) {\n        for (int i = 1; i <= n - len + 1; i++) {\n            int j = i + len - 1;\n            f[i][j] = f[i][j - 1] + 1;\n            for (int l = pre[j]; l >= i; l = pre[l]) {\n                f[i][j] = f[i][j] < f[i][l] + f[l + 1][j] ? f[i][j] : f[i][l] + f[l + 1][j];\n            }\n        }\n    }\n    return f[1][n];\n}", "buggy_code": "#include <cassert>\n#include <cstdio>\nint minOperations(int n, int* pixels)\n{\n    int pre[n+1], u[n+1], f[n+1];\n    for (int i = 1; i <= n; i++) {\n        pre[i] = u[i] = 0;\n    }\n    for (int i = 1; i <= n; i++) {\n        pre[i] = u[pixels[i-1]];\n        u[pixels[i-1]] = i;\n    }\n    for (int i = 1; i <= n; i++) {\n        for (int j = 1; j <= n; j++) {\n            if (i != j) f[i][j] = 1000000000;\n            else f[i][j] = 0;\n        }\n    }\n    for (int len = 2; len <= n; len++) {\n        for (int i = 1; i <= n - len + 1; i++) {\n            int j = i + len - 1;\n            f[i][j] = f[i][j - 1] + 1;\n            for (int l = pre[j]; l >= i; l = pre[l]) {\n                f[i][j] = f[i][j] < f[i][l] + f[l + 1][j] ? f[i][j] : f[i][l] + f[l + 1][j];\n            }\n        }\n    }\n    return f[1][n];\n}", "test": "int main() {\n    int a1[] = {1, 2, 3, 2, 1};\n    int a2[] = {1, 1, 2, 2};\n    int a3[] = {1, 2, 1, 4, 2};\n    int a4[] = {5, 5, 5, 5, 5};\n    int a5[] = {1, 1, 1, 2, 2, 2};\n    int a6[] = {1, 3, 3, 3, 2, 2, 2};\n    int a7[] = {4, 4, 4, 4, 3, 3, 3, 3};\n    int a8[] = {1, 2, 3, 4, 5, 6, 7, 8, 9};\n    int a9[] = {1, 2, 1, 2, 1, 2, 1, 2, 1, 2};\n    int a10[] = {3, 3, 3};\n    int a11[] = {2, 1, 1, 2};\n    assert(minOperations(5, a1) == 2);\n    assert(minOperations(4, a2) == 1);\n    assert(minOperations(5, a3) == 3);\n    assert(minOperations(5, a4) == 0);\n    assert(minOperations(6, a5) == 1);\n    assert(minOperations(7, a6) == 2);\n    assert(minOperations(8, a7) == 1);\n    assert(minOperations(9, a8) == 8);\n    assert(minOperations(10, a9) == 5);\n    assert(minOperations(3, a10) == 0);\n    assert(minOperations(4, a11) == 1);\n    return 0;\n}", "instruction": " the following faulty CPP code snippet and error type list. \nYour task is to select the error type of the code based on the error list provided\n\nYou only need to answer error type. Do not write anything else in your response. \n\nFor example, if the code snippet is missing a semicolon, Your output should be 'missing_colons'.\n\nfaulty code:\n\n```\n#include <cassert>\n#include <cstdio>\nint minOperations(int n, int* pixels)\n{\n    int pre[n+1], u[n+1], f[n+1];\n    for (int i = 1; i <= n; i++) {\n        pre[i] = u[i] = 0;\n    }\n    for (int i = 1; i <= n; i++) {\n        pre[i] = u[pixels[i-1]];\n        u[pixels[i-1]] = i;\n    }\n    for (int i = 1; i <= n; i++) {\n        for (int j = 1; j <= n; j++) {\n            if (i != j) f[i][j] = 1000000000;\n            else f[i][j] = 0;\n        }\n    }\n    for (int len = 2; len <= n; len++) {\n        for (int i = 1; i <= n - len + 1; i++) {\n            int j = i + len - 1;\n            f[i][j] = f[i][j - 1] + 1;\n            for (int l = pre[j]; l >= i; l = pre[l]) {\n                f[i][j] = f[i][j] < f[i][l] + f[l + 1][j] ? f[i][j] : f[i][l] + f[l + 1][j];\n            }\n        }\n    }\n    return f[1][n];\n}\n```\nerror type list:\n\n['illegal_comment', 'illegal_separation', 'missing_colons', 'misused ==and=', 'unclosed_parentheses', 'unclosed_string', 'faulty_indexing', 'function_error', 'illegal_keyword', 'undefined_methods', 'undefined_objects', 'algorithm_error', 'condition_error', 'operation_error', 'type_error', 'variable_error', 'double_bug', 'triple_bug', 'quadruple_bug', 'Misused Macro Definition', 'missing_backtick', 'misused_let', 'misused templte', 'Delayed Execution', 'Misused match', 'Misused := and =', 'Unused Variable', 'Misused === and ==', 'Misused =>', 'Misused Spread Operator', 'Misused begin/end', 'Missing $', 'illegal_indentation', 'Missing mut', 'Misused var and val', 'The digital leader is 0', 'Duplicate keys', 'struct_error', 'json_content_error']\n"}
{"question_id": "CPP/42", "category": "Logic", "subtype": "variable_error", "level": "easy", "example": "* Examples:\n *   minOperations(5, {1, 2, 3, 2, 1}) -> 2", "docstring": "* You are given a 1 by n pixel image, where each pixel has a color \n * represented by an integer. You can perform an operation where you \n * pick a color and change all connected pixels of the same color to \n * the chosen color. Two pixels are connected if they are adjacent \n * and have the same color. Find the minimum number of operations \n * required to make all pixels the same color.\n *\n * Note: For each color, there are at most 20 pixels of that color.\n *", "canonical_solution": "#include <cassert>\n#include <cstdio>\n\nint minOperations(int n, int* pixels)\n\n{\n    int pre[n+1], u[n+1], f[n+1][n+1];\n    for (int i = 1; i <= n; i++) {\n        pre[i] = u[i] = 0;\n    }\n    for (int i = 1; i <= n; i++) {\n        pre[i] = u[pixels[i-1]];\n        u[pixels[i-1]] = i;\n    }\n    for (int i = 1; i <= n; i++) {\n        for (int j = 1; j <= n; j++) {\n            if (i != j) f[i][j] = 1000000000;\n            else f[i][j] = 0;\n        }\n    }\n    for (int len = 2; len <= n; len++) {\n        for (int i = 1; i <= n - len + 1; i++) {\n            int j = i + len - 1;\n            f[i][j] = f[i][j - 1] + 1;\n            for (int l = pre[j]; l >= i; l = pre[l]) {\n                f[i][j] = f[i][j] < f[i][l] + f[l + 1][j] ? f[i][j] : f[i][l] + f[l + 1][j];\n            }\n        }\n    }\n    return f[1][n];\n}", "buggy_code": "#include <cassert>\n#include <cstdio>\nint minOperations(int n, int* pixels)\n{\n    int u[n+1], f[n+1][n+1];\n    for (int i = 1; i <= n; i++) {\n        pre[i] = u[i] = 0;\n    }\n    for (int i = 1; i <= n; i++) {\n        pre[i] = u[pixels[i-1]];\n        u[pixels[i-1]] = i;\n    }\n    for (int i = 1; i <= n; i++) {\n        for (int j = 1; j <= n; j++) {\n            if (i != j) f[i][j] = 1000000000;\n            else f[i][j] = 0;\n        }\n    }\n    for (int len = 2; len <= n; len++) {\n        for (int i = 1; i <= n - len + 1; i++) {\n            int j = i + len - 1;\n            f[i][j] = f[i][j - 1] + 1;\n            for (int l = pre[j]; l >= i; l = pre[l]) {\n                f[i][j] = f[i][j] < f[i][l] + f[l + 1][j] ? f[i][j] : f[i][l] + f[l + 1][j];\n            }\n        }\n    }\n    return f[1][n];\n}", "test": "int main() {\n    int a1[] = {1, 2, 3, 2, 1};\n    int a2[] = {1, 1, 2, 2};\n    int a3[] = {1, 2, 1, 4, 2};\n    int a4[] = {5, 5, 5, 5, 5};\n    int a5[] = {1, 1, 1, 2, 2, 2};\n    int a6[] = {1, 3, 3, 3, 2, 2, 2};\n    int a7[] = {4, 4, 4, 4, 3, 3, 3, 3};\n    int a8[] = {1, 2, 3, 4, 5, 6, 7, 8, 9};\n    int a9[] = {1, 2, 1, 2, 1, 2, 1, 2, 1, 2};\n    int a10[] = {3, 3, 3};\n    int a11[] = {2, 1, 1, 2};\n    assert(minOperations(5, a1) == 2);\n    assert(minOperations(4, a2) == 1);\n    assert(minOperations(5, a3) == 3);\n    assert(minOperations(5, a4) == 0);\n    assert(minOperations(6, a5) == 1);\n    assert(minOperations(7, a6) == 2);\n    assert(minOperations(8, a7) == 1);\n    assert(minOperations(9, a8) == 8);\n    assert(minOperations(10, a9) == 5);\n    assert(minOperations(3, a10) == 0);\n    assert(minOperations(4, a11) == 1);\n    return 0;\n}", "instruction": " the following faulty CPP code snippet and error type list. \nYour task is to select the error type of the code based on the error list provided\n\nYou only need to answer error type. Do not write anything else in your response. \n\nFor example, if the code snippet is missing a semicolon, Your output should be 'missing_colons'.\n\nfaulty code:\n\n```\n#include <cassert>\n#include <cstdio>\nint minOperations(int n, int* pixels)\n{\n    int u[n+1], f[n+1][n+1];\n    for (int i = 1; i <= n; i++) {\n        pre[i] = u[i] = 0;\n    }\n    for (int i = 1; i <= n; i++) {\n        pre[i] = u[pixels[i-1]];\n        u[pixels[i-1]] = i;\n    }\n    for (int i = 1; i <= n; i++) {\n        for (int j = 1; j <= n; j++) {\n            if (i != j) f[i][j] = 1000000000;\n            else f[i][j] = 0;\n        }\n    }\n    for (int len = 2; len <= n; len++) {\n        for (int i = 1; i <= n - len + 1; i++) {\n            int j = i + len - 1;\n            f[i][j] = f[i][j - 1] + 1;\n            for (int l = pre[j]; l >= i; l = pre[l]) {\n                f[i][j] = f[i][j] < f[i][l] + f[l + 1][j] ? f[i][j] : f[i][l] + f[l + 1][j];\n            }\n        }\n    }\n    return f[1][n];\n}\n```\nerror type list:\n\n['illegal_comment', 'illegal_separation', 'missing_colons', 'misused ==and=', 'unclosed_parentheses', 'unclosed_string', 'faulty_indexing', 'function_error', 'illegal_keyword', 'undefined_methods', 'undefined_objects', 'algorithm_error', 'condition_error', 'operation_error', 'type_error', 'variable_error', 'double_bug', 'triple_bug', 'quadruple_bug', 'Misused Macro Definition', 'missing_backtick', 'misused_let', 'misused templte', 'Delayed Execution', 'Misused match', 'Misused := and =', 'Unused Variable', 'Misused === and ==', 'Misused =>', 'Misused Spread Operator', 'Misused begin/end', 'Missing $', 'illegal_indentation', 'Missing mut', 'Misused var and val', 'The digital leader is 0', 'Duplicate keys', 'struct_error', 'json_content_error']\n"}
{"question_id": "CPP/43", "category": "Logic", "subtype": "variable_error", "level": "easy", "example": "* Examples:\n *   >>> isPalindrome(\"racecar\")\n *   true\n *   >>> isPalindrome(\"hello\")\n *   false", "docstring": "* Determine if a given string is a palindrome. A palindrome is a word, phrase,\n * number, or other sequence of characters that reads the same forward and\n * backward (ignoring spaces, punctuation, and capitalization).", "canonical_solution": "#include <cassert>\n#include <cctype> \n#include <cstring>\n\nbool isPalindrome(const char* str)\n\n{\n    int start = 0;\n    int end = strlen(str) - 1;\n    \n    while (start < end) {\n        while (!isalnum(str[start]) && start < end) start++;\n        while (!isalnum(str[end]) && start < end) end--;\n        if (tolower(str[start]) != tolower(str[end]))\n            return false;\n        start++;\n        end--;\n    }\n    return true;\n}", "buggy_code": "#include <cassert>\n#include <cctype> \n#include <cstring>\nbool isPalindrome(const char* str)\n{\n    int end = strlen(str) - 1;\n    \n    while (start < end) {\n        while (!isalnum(str[start]) && start < end) start++;\n        while (!isalnum(str[end]) && start < end) end--;\n        if (tolower(str[start]) != tolower(str[end]))\n            return false;\n        start++;\n        end--;\n    }\n    return true;\n}", "test": "int main()\n{\n    assert(isPalindrome(\"A man a plan a canal Panama\") == true);\n    assert(isPalindrome(\"No lemon, no melon\") == true);\n    assert(isPalindrome(\"Was it a car or a cat I saw\") == true);\n    assert(isPalindrome(\"Madam, in Eden, I'm Adam\") == true);\n    assert(isPalindrome(\"Never odd or even\") == true);\n    assert(isPalindrome(\"Eva, can I see bees in a cave\") == true);\n    assert(isPalindrome(\"hello\") == false);\n    assert(isPalindrome(\"GitHub\") == false);\n    assert(isPalindrome(\"programming\") == false);\n    \n    return 0;\n}", "instruction": " the following faulty CPP code snippet and error type list. \nYour task is to select the error type of the code based on the error list provided\n\nYou only need to answer error type. Do not write anything else in your response. \n\nFor example, if the code snippet is missing a semicolon, Your output should be 'missing_colons'.\n\nfaulty code:\n\n```\n#include <cassert>\n#include <cctype> \n#include <cstring>\nbool isPalindrome(const char* str)\n{\n    int end = strlen(str) - 1;\n    \n    while (start < end) {\n        while (!isalnum(str[start]) && start < end) start++;\n        while (!isalnum(str[end]) && start < end) end--;\n        if (tolower(str[start]) != tolower(str[end]))\n            return false;\n        start++;\n        end--;\n    }\n    return true;\n}\n```\nerror type list:\n\n['illegal_comment', 'illegal_separation', 'missing_colons', 'misused ==and=', 'unclosed_parentheses', 'unclosed_string', 'faulty_indexing', 'function_error', 'illegal_keyword', 'undefined_methods', 'undefined_objects', 'algorithm_error', 'condition_error', 'operation_error', 'type_error', 'variable_error', 'double_bug', 'triple_bug', 'quadruple_bug', 'Misused Macro Definition', 'missing_backtick', 'misused_let', 'misused templte', 'Delayed Execution', 'Misused match', 'Misused := and =', 'Unused Variable', 'Misused === and ==', 'Misused =>', 'Misused Spread Operator', 'Misused begin/end', 'Missing $', 'illegal_indentation', 'Missing mut', 'Misused var and val', 'The digital leader is 0', 'Duplicate keys', 'struct_error', 'json_content_error']\n"}
{"question_id": "CPP/44", "category": "Logic", "subtype": "variable_error", "level": "medium", "example": "* Examples:\n *   >>> isPalindrome(\"racecar\")\n *   true\n *   >>> isPalindrome(\"hello\")\n *   false", "docstring": "* Determine if a given string is a palindrome. A palindrome is a word, phrase,\n * number, or other sequence of characters that reads the same forward and\n * backward (ignoring spaces, punctuation, and capitalization).", "canonical_solution": "#include <cassert>\n#include <cctype> \n#include <cstring>\n\nbool isPalindrome(const char* str)\n\n{\n    int start = 0;\n    int end = strlen(str) - 1;\n    \n    while (start < end) {\n        while (!isalnum(str[start]) && start < end) start++;\n        while (!isalnum(str[end]) && start < end) end--;\n        if (tolower(str[start]) != tolower(str[end]))\n            return false;\n        start++;\n        end--;\n    }\n    return true;\n}", "buggy_code": "#include <cassert>\n#include <cctype> \n#include <cstring>\nbool isPalindrome(const char* str)\n{\n    int start = 0;\n    int end = strlen(str) + 1;\n    \n    while (start < end) {\n        while (!isalnum(str[start]) && start < end) start++;\n        while (!isalnum(str[end]) && start < end) end--;\n        if (tolower(str[start]) != tolower(str[end]))\n            return false;\n        start++;\n        end--;\n    }\n    return true;\n}", "test": "int main()\n{\n    assert(isPalindrome(\"A man a plan a canal Panama\") == true);\n    assert(isPalindrome(\"No lemon, no melon\") == true);\n    assert(isPalindrome(\"Was it a car or a cat I saw\") == true);\n    assert(isPalindrome(\"Madam, in Eden, I'm Adam\") == true);\n    assert(isPalindrome(\"Never odd or even\") == true);\n    assert(isPalindrome(\"Eva, can I see bees in a cave\") == true);\n    assert(isPalindrome(\"hello\") == false);\n    assert(isPalindrome(\"GitHub\") == false);\n    assert(isPalindrome(\"programming\") == false);\n    \n    return 0;\n}", "instruction": " the following faulty CPP code snippet and error type list. \nYour task is to select the error type of the code based on the error list provided\n\nYou only need to answer error type. Do not write anything else in your response. \n\nFor example, if the code snippet is missing a semicolon, Your output should be 'missing_colons'.\n\nfaulty code:\n\n```\n#include <cassert>\n#include <cctype> \n#include <cstring>\nbool isPalindrome(const char* str)\n{\n    int start = 0;\n    int end = strlen(str) + 1;\n    \n    while (start < end) {\n        while (!isalnum(str[start]) && start < end) start++;\n        while (!isalnum(str[end]) && start < end) end--;\n        if (tolower(str[start]) != tolower(str[end]))\n            return false;\n        start++;\n        end--;\n    }\n    return true;\n}\n```\nerror type list:\n\n['illegal_comment', 'illegal_separation', 'missing_colons', 'misused ==and=', 'unclosed_parentheses', 'unclosed_string', 'faulty_indexing', 'function_error', 'illegal_keyword', 'undefined_methods', 'undefined_objects', 'algorithm_error', 'condition_error', 'operation_error', 'type_error', 'variable_error', 'double_bug', 'triple_bug', 'quadruple_bug', 'Misused Macro Definition', 'missing_backtick', 'misused_let', 'misused templte', 'Delayed Execution', 'Misused match', 'Misused := and =', 'Unused Variable', 'Misused === and ==', 'Misused =>', 'Misused Spread Operator', 'Misused begin/end', 'Missing $', 'illegal_indentation', 'Missing mut', 'Misused var and val', 'The digital leader is 0', 'Duplicate keys', 'struct_error', 'json_content_error']\n"}
{"question_id": "CPP/45", "category": "Multiple", "subtype": "double_bug", "level": "medium", "example": ">>> Example call: \nint max, min;\nfind_max_min(1,2,3, &max, &min);\nassert(max == 3 && min == 1);", "docstring": "Find the maximum and minimum of three distinct integers.\nParameters:\na (int): The first integer.\nb (int): The second integer.\nc (int): The third integer.\n\nReturns:\nTuple[int, int]: A tuple is not a concept in C; instead, we will return by Reference.", "canonical_solution": "#include <cassert>\n#include <cstdio>\n\nvoid find_max_min(int a, int b, int c, int *max, int *min)\n\n{\n    if (a > b) {\n        if (a > c) {\n            *max = a;\n            *min = (b < c) ? b : c;\n        } else {\n            *max = c;\n            *min = b;\n        }\n    } else if (b > c) {\n        *max = b;\n        *min = (a < c) ? a : c;\n    } else {\n        *max = c;\n        *min = a;\n    }\n}", "buggy_code": "#include <cassert>\n#include <cstdio>\nvoid find_max_min(int a, int b, int c, int max, int *min)\n{\n    if (a > b) {\n        if (a > c) {\n            *max = a;\n            *min = (b < c) ? b : c;\n        } else {\n            *max = c;\n            *min = b;\n        }\n    } else if (b > c) {\n        *max = b;\n        *min = (a < c) ? a : c;\n    } else {\n        *max = c;\n        *min = b;\n    }\n}", "test": "int main() {\n    int max, min;\n\n    // Test with a set of values\n    find_max_min(1, 2, 3, &max, &min);\n    assert(max == 3 && min == 1);\n\n    // Additional tests\n    find_max_min(5, 3, 4, &max, &min);\n    assert(max == 5 && min == 3);\n\n    find_max_min(10, -2, 7, &max, &min);\n    assert(max == 10 && min == -2);\n\n    find_max_min(-1, -3, -2, &max, &min);\n    assert(max == -1 && min == -3);\n\n    return 0;\n}", "instruction": " the following faulty CPP code snippet and error type list. \nYour task is to select the error type of the code based on the error list provided\n\nYou only need to answer error type. Do not write anything else in your response. \n\nFor example, if the code snippet is missing a semicolon, Your output should be 'missing_colons'.\n\nfaulty code:\n\n```\n#include <cassert>\n#include <cstdio>\nvoid find_max_min(int a, int b, int c, int max, int *min)\n{\n    if (a > b) {\n        if (a > c) {\n            *max = a;\n            *min = (b < c) ? b : c;\n        } else {\n            *max = c;\n            *min = b;\n        }\n    } else if (b > c) {\n        *max = b;\n        *min = (a < c) ? a : c;\n    } else {\n        *max = c;\n        *min = b;\n    }\n}\n```\nerror type list:\n\n['illegal_comment', 'illegal_separation', 'missing_colons', 'misused ==and=', 'unclosed_parentheses', 'unclosed_string', 'faulty_indexing', 'function_error', 'illegal_keyword', 'undefined_methods', 'undefined_objects', 'algorithm_error', 'condition_error', 'operation_error', 'type_error', 'variable_error', 'double_bug', 'triple_bug', 'quadruple_bug', 'Misused Macro Definition', 'missing_backtick', 'misused_let', 'misused templte', 'Delayed Execution', 'Misused match', 'Misused := and =', 'Unused Variable', 'Misused === and ==', 'Misused =>', 'Misused Spread Operator', 'Misused begin/end', 'Missing $', 'illegal_indentation', 'Missing mut', 'Misused var and val', 'The digital leader is 0', 'Duplicate keys', 'struct_error', 'json_content_error']\n"}
{"question_id": "CPP/46", "category": "Multiple", "subtype": "double_bug", "level": "medium", "example": "* Examples:\n * >>> process_request(1)\n * 1\n * >>> process_request(10)\n * 6266", "docstring": "* Calculates the factorial of N modulo 10007.\n * \n * Parameters:\n * - N (int): An integer representing the input value (N <= 10000).\n * \n * Returns:\n * int: The result after calculating the factorial of N and\n * taking the modulo 10007.\n *", "canonical_solution": "#include <cassert>\n#include <cmath>\n#include <cstdio>\n#include <cstring>\n\nint process_request(int n)\n\n{\n    int a[10010];\n    a[0] = 1;\n    a[1] = 1;\n    for (register int i = 2; i <= 10000; i++) {\n        a[i] = (a[i - 1] * i) % 10007;\n    }\n    return a[n];\n}", "buggy_code": "#include <cassert>\n#include <cmath>\n#include <cstdio>\n#include <cstring>\nint process_request(int n)\n{\n    int a[10010];\n    a[0] = 0;\n    a[1] = 1;\n    for (register int i = 2; i <= 10000; i++) {\n        a[i] = (a[i-1] + i) % 10007;\n    }\n    return a[n];\n}", "test": "int main()\n{\n    assert(process_request(0) == 1); // Added test for boundary condition\n    assert(process_request(1) == 1);\n    assert(process_request(2) == 2);\n    assert(process_request(3) == 6);\n    assert(process_request(4) == 24);\n    assert(process_request(10) == 6266); // 10! % 10007 = 3628800 % 10007 = 6266\n    assert(process_request(10000) == 6991); // Added a test for upper boundary condition\n    // printf(\"All tests passed.\\n\");\n    return 0;\n}", "instruction": " the following faulty CPP code snippet and error type list. \nYour task is to select the error type of the code based on the error list provided\n\nYou only need to answer error type. Do not write anything else in your response. \n\nFor example, if the code snippet is missing a semicolon, Your output should be 'missing_colons'.\n\nfaulty code:\n\n```\n#include <cassert>\n#include <cmath>\n#include <cstdio>\n#include <cstring>\nint process_request(int n)\n{\n    int a[10010];\n    a[0] = 0;\n    a[1] = 1;\n    for (register int i = 2; i <= 10000; i++) {\n        a[i] = (a[i-1] + i) % 10007;\n    }\n    return a[n];\n}\n```\nerror type list:\n\n['illegal_comment', 'illegal_separation', 'missing_colons', 'misused ==and=', 'unclosed_parentheses', 'unclosed_string', 'faulty_indexing', 'function_error', 'illegal_keyword', 'undefined_methods', 'undefined_objects', 'algorithm_error', 'condition_error', 'operation_error', 'type_error', 'variable_error', 'double_bug', 'triple_bug', 'quadruple_bug', 'Misused Macro Definition', 'missing_backtick', 'misused_let', 'misused templte', 'Delayed Execution', 'Misused match', 'Misused := and =', 'Unused Variable', 'Misused === and ==', 'Misused =>', 'Misused Spread Operator', 'Misused begin/end', 'Missing $', 'illegal_indentation', 'Missing mut', 'Misused var and val', 'The digital leader is 0', 'Duplicate keys', 'struct_error', 'json_content_error']\n"}
{"question_id": "CPP/47", "category": "Multiple", "subtype": "double_bug", "level": "medium", "example": ">>> hamming_distance(1,2)\n\t2", "docstring": "Calculate the Hamming distance between two integers in binary representation.\n​    Parameters:\n- x (int): The first positive integer (x <= 1,000,000,000).\n- y (int): The second positive integer (y <= 1,000,000,000).\n​    Returns:\n​    int: The Hamming distance between x and y, i.e., the number of bits that need to be flipped\n​         to transform x into y in binary.", "canonical_solution": "#include <bits/stdc++.h>\n\nint hamming_distance(int x, int y)\n\n{\n    int distance = 0;\n    int xor_result = x ^ y;\n    while (xor_result) {\n        if (xor_result & 1) {\n            distance++;\n        }\n        xor_result >>= 1;\n    }\n    return distance;\n}", "buggy_code": "#include <bits/stdc++.h>\nint hamming_distance(int x, int y)\n{\n    int distance = 1;\n    int xor_result = x ^ y;\n    while (xor_result) {\n        if (xor_result & 1) {\n            distance++;\n        }\n    }\n    xor_result >>= 1;\n    return distance;\n}", "test": "int main() {\n    assert(hamming_distance(1, 2) == 2); // 01 and 10 have 2 different bits\n    assert(hamming_distance(4, 7) == 2); // 100 and 111 have 2 different bits\n    assert(hamming_distance(25, 30) == 3); // Additional test: 11001 and 11110 have 3 different bits\n    assert(hamming_distance(0, 0) == 0); // Additional test: Same numbers have 0 different bits\n    assert(hamming_distance(0xFFFFFFF, 0x0000000) == 28); // Additional test: Max unsigned int and 0 have 32 different bits\n    return 0;\n}", "instruction": " the following faulty CPP code snippet and error type list. \nYour task is to select the error type of the code based on the error list provided\n\nYou only need to answer error type. Do not write anything else in your response. \n\nFor example, if the code snippet is missing a semicolon, Your output should be 'missing_colons'.\n\nfaulty code:\n\n```\n#include <bits/stdc++.h>\nint hamming_distance(int x, int y)\n{\n    int distance = 1;\n    int xor_result = x ^ y;\n    while (xor_result) {\n        if (xor_result & 1) {\n            distance++;\n        }\n    }\n    xor_result >>= 1;\n    return distance;\n}\n```\nerror type list:\n\n['illegal_comment', 'illegal_separation', 'missing_colons', 'misused ==and=', 'unclosed_parentheses', 'unclosed_string', 'faulty_indexing', 'function_error', 'illegal_keyword', 'undefined_methods', 'undefined_objects', 'algorithm_error', 'condition_error', 'operation_error', 'type_error', 'variable_error', 'double_bug', 'triple_bug', 'quadruple_bug', 'Misused Macro Definition', 'missing_backtick', 'misused_let', 'misused templte', 'Delayed Execution', 'Misused match', 'Misused := and =', 'Unused Variable', 'Misused === and ==', 'Misused =>', 'Misused Spread Operator', 'Misused begin/end', 'Missing $', 'illegal_indentation', 'Missing mut', 'Misused var and val', 'The digital leader is 0', 'Duplicate keys', 'struct_error', 'json_content_error']\n"}
{"question_id": "CPP/48", "category": "Multiple", "subtype": "double_bug", "level": "meidum", "example": "* Usage:\n *   count_odd_numbers(5, 1, 4, 3, 2, 5) should return 3", "docstring": "* Count the number of odd integers in a given list of numbers.\n * Parameters:\n * - count (int): The number of integers to evaluate.\n * - ... (int): A sequence of integers.\n * Returns:\n *   int: The count of odd numbers in the input list.", "canonical_solution": "#include <assert.h>\n#include <stdarg.h>\n\n\nint count_odd_numbers(int count, ...)\n\n{\n    va_list args;\n    va_start(args, count);\n    int ans = 0;\n    for (int i = 0; i < count; i++) {\n        int num = va_arg(args, int);\n        if (num & 1) {\n            ans++;\n        }\n    }\n    va_end(args);\n    return ans;\n}", "buggy_code": "#include <assert.h>\n#include <stdarg.h>\nint count_odd_numbers(int count, ...)\n{\n    va_list args;\n    va_start(args, count);\n    int ans = 1;\n    for (int i = 0; i <= count; i++) {\n        int num = va_arg(args, int);\n        if (num & 1) {\n            ans++;\n        }\n    }\n    va_end(args);\n    return ans;\n}", "test": "int main() {\n    assert(count_odd_numbers(5, 1, 4, 3, 2, 5) == 3);\n    assert(count_odd_numbers(4, 2, 2, 0, 0) == 0);\n    assert(count_odd_numbers(6, 7, 7, 8, 1, 9, 10) == 4); // Additional Test Sample\n    // Uncomment the following line to print a success message\n    // std::printf(\"All tests passed!\\n\");\n    return 0;\n}", "instruction": " the following faulty CPP code snippet and error type list. \nYour task is to select the error type of the code based on the error list provided\n\nYou only need to answer error type. Do not write anything else in your response. \n\nFor example, if the code snippet is missing a semicolon, Your output should be 'missing_colons'.\n\nfaulty code:\n\n```\n#include <assert.h>\n#include <stdarg.h>\nint count_odd_numbers(int count, ...)\n{\n    va_list args;\n    va_start(args, count);\n    int ans = 1;\n    for (int i = 0; i <= count; i++) {\n        int num = va_arg(args, int);\n        if (num & 1) {\n            ans++;\n        }\n    }\n    va_end(args);\n    return ans;\n}\n```\nerror type list:\n\n['illegal_comment', 'illegal_separation', 'missing_colons', 'misused ==and=', 'unclosed_parentheses', 'unclosed_string', 'faulty_indexing', 'function_error', 'illegal_keyword', 'undefined_methods', 'undefined_objects', 'algorithm_error', 'condition_error', 'operation_error', 'type_error', 'variable_error', 'double_bug', 'triple_bug', 'quadruple_bug', 'Misused Macro Definition', 'missing_backtick', 'misused_let', 'misused templte', 'Delayed Execution', 'Misused match', 'Misused := and =', 'Unused Variable', 'Misused === and ==', 'Misused =>', 'Misused Spread Operator', 'Misused begin/end', 'Missing $', 'illegal_indentation', 'Missing mut', 'Misused var and val', 'The digital leader is 0', 'Duplicate keys', 'struct_error', 'json_content_error']\n"}
{"question_id": "CPP/49", "category": "Multiple", "subtype": "double_bug", "level": "medium", "example": "Example usage:\nassert(decode_numbers(\"0000\") == 4);", "docstring": "Decode a series of numbers to reveal the pattern and understand the actual values \neach digit represents.\n\nEquations provided for Reference:\n0000=4 8888=8 1234=1 5678=3 9012=2 1357=0 2468=4\n\nParameters:\n- data_str: A constant character array (C-style string) representing a series of numbers. Length does not exceed 100.\n\nReturns:\nint: The result of each data string corresponding to the right-hand side of the equation.", "canonical_solution": "#include <cassert>\n#include <cstring>\n#include <iostream>\n\nint decode_numbers(const char* data_str)\n\n{\n    int a[] = {1, 0, 0, 0, 1, 0, 1, 0, 2, 1};\n    int ans = 0;\n    for(int i = 0; i < std::strlen(data_str); i++) {\n        ans += a[data_str[i] - '0'];\n    }\n    return ans;\n}", "buggy_code": "#include <cassert>\n#include <cstring>\n#include <iostream>\nint decode_numbers(const char* data_str)\n{\n    int a[] = {1, 0, 0, 0, 1, 0, 1, 0, 2, 1};\n    int ans = 0;\n    for(int i = 0; i < std:strlen(data_str); i++) {\n        ans += a[data_str[i] + '0'];\n    }\n    return ans;\n}", "test": "int main() {\n    // Assert basic provided test cases\n    assert(decode_numbers(\"0000\") == 4);\n    assert(decode_numbers(\"8888\") == 8);\n    assert(decode_numbers(\"1234\") == 1);\n    assert(decode_numbers(\"5678\") == 3);\n    assert(decode_numbers(\"9012\") == 2);\n    assert(decode_numbers(\"1357\") == 0);\n    assert(decode_numbers(\"2468\") == 4);\n\n    // Assert additional test cases\n    assert(decode_numbers(\"9999\") == 4);\n    assert(decode_numbers(\"1111\") == 0);\n    assert(decode_numbers(\"2222\") == 0);\n    assert(decode_numbers(\"3333\") == 0);\n    assert(decode_numbers(\"4444\") == 4);\n    assert(decode_numbers(\"5555\") == 0);\n    assert(decode_numbers(\"6666\") == 4);\n    assert(decode_numbers(\"7777\") == 0);\n    assert(decode_numbers(\"0001\") == 3);\n    assert(decode_numbers(\"2301\") == 1);\n\n    // Indicate that all tests passed\n    // std::cout << \"All tests passed successfully!\" << std::endl;\n\n    return 0;\n}", "instruction": " the following faulty CPP code snippet and error type list. \nYour task is to select the error type of the code based on the error list provided\n\nYou only need to answer error type. Do not write anything else in your response. \n\nFor example, if the code snippet is missing a semicolon, Your output should be 'missing_colons'.\n\nfaulty code:\n\n```\n#include <cassert>\n#include <cstring>\n#include <iostream>\nint decode_numbers(const char* data_str)\n{\n    int a[] = {1, 0, 0, 0, 1, 0, 1, 0, 2, 1};\n    int ans = 0;\n    for(int i = 0; i < std:strlen(data_str); i++) {\n        ans += a[data_str[i] + '0'];\n    }\n    return ans;\n}\n```\nerror type list:\n\n['illegal_comment', 'illegal_separation', 'missing_colons', 'misused ==and=', 'unclosed_parentheses', 'unclosed_string', 'faulty_indexing', 'function_error', 'illegal_keyword', 'undefined_methods', 'undefined_objects', 'algorithm_error', 'condition_error', 'operation_error', 'type_error', 'variable_error', 'double_bug', 'triple_bug', 'quadruple_bug', 'Misused Macro Definition', 'missing_backtick', 'misused_let', 'misused templte', 'Delayed Execution', 'Misused match', 'Misused := and =', 'Unused Variable', 'Misused === and ==', 'Misused =>', 'Misused Spread Operator', 'Misused begin/end', 'Missing $', 'illegal_indentation', 'Missing mut', 'Misused var and val', 'The digital leader is 0', 'Duplicate keys', 'struct_error', 'json_content_error']\n"}
{"question_id": "CPP/50", "category": "Multiple", "subtype": "double_bug", "level": "medium", "example": ">>> shift_characters(\"NS BFW, JAJSYX TK NRUTWYFSHJ FWJ YMJ WJXZQY TK YWNANFQ HFZXJX\")\n\"IN WAR, EVENTS OF IMPORTANCE ARE THE RESULT OF TRIVIAL CAUSES\"", "docstring": "Shifts all characters by 5 positions in alphabetical order. Only letters are replaced,\nand all letters are in uppercase.\n\nParameters:\ntext (std::string&): The input text to be processed, modified in place.\n\nReturns:\nstd::string&: The transformed text with characters shifted by 5 positions.", "canonical_solution": "#include <bits/stdc++.h>\n\nstd::string& shift_characters(std::string& text)\n\n{\n    size_t len = text.length();\n    for (size_t i = 0; i < len; ++i) {\n        if ('A' <= text[i] && text[i] <= 'E') {\n            text[i] = text[i] + 'V' - 'A';\n        } else if ('F' <= text[i] && text[i] <= 'Z') {\n            text[i] = text[i] + 'A' - 'F';\n        }\n    }\n    return text;\n}", "buggy_code": "#include <bits/stdc++.h>\nstd::string& shift_characters(std::string& text)\n{\n    size_t len = text.length;\n    for (size_t i = 0; i < len; ++i) {\n        if ('A' <= text[i] && text[i] <= 'E') {\n            text[i] = text[i] + 'V' - 'A';\n        } else if ('F' <= text[i] || text[i] <= 'Z') {\n            text[i] = text[i] + 'A' - 'F';\n        }\n    }\n    return text;\n}", "test": "int main()\n{\n    std::string test1 = \"NS BFW, JAJSYX TK NRUTWYFSHJ FWJ YMJ WJXZQY TK YWNANFQ HFZXJX\";\n    std::string test2 = \"N BTZQI WFYMJW GJ KNWXY NS F QNYYQJ NGJWNFS ANQQFLJ YMFS XJHTSI NS WTRJ\";\n    std::string test3 = \"IFSLJW PSTBX KZQQ BJQQ YMFY HFJXFW NX RTWJ IFSLJWTZX YMFS MJ\";\n\n    assert(shift_characters(test1) == \"IN WAR, EVENTS OF IMPORTANCE ARE THE RESULT OF TRIVIAL CAUSES\");\n    assert(shift_characters(test2) == \"I WOULD RATHER BE FIRST IN A LITTLE IBERIAN VILLAGE THAN SECOND IN ROME\");\n    assert(shift_characters(test3) == \"DANGER KNOWS FULL WELL THAT CAESAR IS MORE DANGEROUS THAN HE\");\n    return 0;\n}", "instruction": " the following faulty CPP code snippet and error type list. \nYour task is to select the error type of the code based on the error list provided\n\nYou only need to answer error type. Do not write anything else in your response. \n\nFor example, if the code snippet is missing a semicolon, Your output should be 'missing_colons'.\n\nfaulty code:\n\n```\n#include <bits/stdc++.h>\nstd::string& shift_characters(std::string& text)\n{\n    size_t len = text.length;\n    for (size_t i = 0; i < len; ++i) {\n        if ('A' <= text[i] && text[i] <= 'E') {\n            text[i] = text[i] + 'V' - 'A';\n        } else if ('F' <= text[i] || text[i] <= 'Z') {\n            text[i] = text[i] + 'A' - 'F';\n        }\n    }\n    return text;\n}\n```\nerror type list:\n\n['illegal_comment', 'illegal_separation', 'missing_colons', 'misused ==and=', 'unclosed_parentheses', 'unclosed_string', 'faulty_indexing', 'function_error', 'illegal_keyword', 'undefined_methods', 'undefined_objects', 'algorithm_error', 'condition_error', 'operation_error', 'type_error', 'variable_error', 'double_bug', 'triple_bug', 'quadruple_bug', 'Misused Macro Definition', 'missing_backtick', 'misused_let', 'misused templte', 'Delayed Execution', 'Misused match', 'Misused := and =', 'Unused Variable', 'Misused === and ==', 'Misused =>', 'Misused Spread Operator', 'Misused begin/end', 'Missing $', 'illegal_indentation', 'Missing mut', 'Misused var and val', 'The digital leader is 0', 'Duplicate keys', 'struct_error', 'json_content_error']\n"}
{"question_id": "CPP/51", "category": "Multiple", "subtype": "triple_bug", "level": "hard", "example": "* Examples:\n * count_coloring_methods(1,1) returns 1\n * count_coloring_methods(2,2) returns 2", "docstring": "* Counts the number of different coloring methods for n squares with m colors,\n * considering the requirement that adjacent squares and the first/last squares\n * must have different colors.\n * \n * @param n The number of squares.\n * @param m The number of colors.\n * @return The count of different coloring methods satisfying the specified conditions.\n *         The result is modulo 1000003.\n *", "canonical_solution": "#include <cassert>\n#include <iostream>\n\nint count_coloring_methods(int n, int m)\n\n{\n    int f[1111];\n    if (n == 1) return m;\n    if (n == 2) return static_cast<long long>(m) * (m - 1) % 1000003;\n    f[1] = m;\n    f[2] = static_cast<long long>(m) * (m - 1) % 1000003;\n    f[3] = static_cast<long long>(f[2]) * (m - 2) % 1000003;\n    for(int i = 4; i <= n; ++i) {\n        f[i] = (static_cast<long long>(f[i - 1]) * (m - 2) % 1000003 +\n                static_cast<long long>(f[i - 2]) * (m - 1) % 1000003) % 1000003;\n    }\n    return f[n];\n}", "buggy_code": "#include <cassert>\n#include <iostream>\nint count_coloring_methods(int n, int m)\n{\n    int f[1111];\n    if (n = 1) return m;\n    if (n == 2) return static_cast<long long>(m) * (m - 1) % 1000003;\n    f[1] = n;\n    f[2] = static_cast<long long>(m) * (m - 1) % 1000003;\n    f[3] = static_cast<long long>(f[2]) * (m - 2) % 1000003;\n    for(int i = 4; i <= n; ++i) {\n        f[i+1] = (static_cast<long long>(f[i - 1]) * (m - 2) % 1000003 +\n                static_cast<long long>(f[i - 2]) * (m - 1) % 1000003) % 1000003;\n    }\n    return f[n];\n}", "test": "int main() {\n    assert(count_coloring_methods(1, 1) == 1);\n    assert(count_coloring_methods(2, 2) == 2);\n    assert(count_coloring_methods(3, 3) == 6);\n    assert(count_coloring_methods(4, 2) == 2);\n    assert(count_coloring_methods(1000, 10) == 566585); // We don't have the expected result for this case\n\n    // Additional test cases\n    assert(count_coloring_methods(2, 3) == 6);\n    assert(count_coloring_methods(1000, 1000) == 67911);\n    assert(count_coloring_methods(999, 66) == 501817);\n    assert(count_coloring_methods(5, 3) == 30); // Example of an expected output\n\n    // std::cout << \"All tests passed!\\n\";\n    return 0;\n}", "instruction": " the following faulty CPP code snippet and error type list. \nYour task is to select the error type of the code based on the error list provided\n\nYou only need to answer error type. Do not write anything else in your response. \n\nFor example, if the code snippet is missing a semicolon, Your output should be 'missing_colons'.\n\nfaulty code:\n\n```\n#include <cassert>\n#include <iostream>\nint count_coloring_methods(int n, int m)\n{\n    int f[1111];\n    if (n = 1) return m;\n    if (n == 2) return static_cast<long long>(m) * (m - 1) % 1000003;\n    f[1] = n;\n    f[2] = static_cast<long long>(m) * (m - 1) % 1000003;\n    f[3] = static_cast<long long>(f[2]) * (m - 2) % 1000003;\n    for(int i = 4; i <= n; ++i) {\n        f[i+1] = (static_cast<long long>(f[i - 1]) * (m - 2) % 1000003 +\n                static_cast<long long>(f[i - 2]) * (m - 1) % 1000003) % 1000003;\n    }\n    return f[n];\n}\n```\nerror type list:\n\n['illegal_comment', 'illegal_separation', 'missing_colons', 'misused ==and=', 'unclosed_parentheses', 'unclosed_string', 'faulty_indexing', 'function_error', 'illegal_keyword', 'undefined_methods', 'undefined_objects', 'algorithm_error', 'condition_error', 'operation_error', 'type_error', 'variable_error', 'double_bug', 'triple_bug', 'quadruple_bug', 'Misused Macro Definition', 'missing_backtick', 'misused_let', 'misused templte', 'Delayed Execution', 'Misused match', 'Misused := and =', 'Unused Variable', 'Misused === and ==', 'Misused =>', 'Misused Spread Operator', 'Misused begin/end', 'Missing $', 'illegal_indentation', 'Missing mut', 'Misused var and val', 'The digital leader is 0', 'Duplicate keys', 'struct_error', 'json_content_error']\n"}
{"question_id": "CPP/52", "category": "Multiple", "subtype": "triple_bug", "level": "hard", "example": "* Examples:\n *   count_valid_coin_toss_sequences(1) returns 2\n *   count_valid_coin_toss_sequences(2) returns 3", "docstring": "* Count the number of valid coin toss sequences with no consecutive heads in n tosses.\n *\n * Parameters:\n * - n (int): The number of coin tosses.\n *\n * Returns:\n * - unsigned long long: The count of valid sequences.\n *", "canonical_solution": "#include <cassert>\n#include <cmath>\n#include <cstdio>\n#include <cstring>\n\nunsigned long long count_valid_coin_toss_sequences(int n)\n\n{\n    unsigned long long a[41][2];\n    a[1][0] = a[1][1] = 1;\n\n    for(int i = 2; i <= n; i++){\n        a[i][0] = a[i - 1][1] + a[i - 1][0];\n        a[i][1] = a[i - 1][0];\n    }\n\n    return a[n][0] + a[n][1];\n}", "buggy_code": "#include <cassert>\n#include <cmath>\n#include <cstdio>\n#include <cstring>\nunsigned long long count_valid_coin_toss_sequences(int* n)\n{\n    unsigned long long a[41][2];\n    a[1][0] = a[1][1] = 1;\n    for(int i = 2; i < n; i++){\n        a[i][0] = a[i - 1][0] + a[i - 1][0];\n        a[i][1] = a[i - 1][0];\n    }\n    return a[n][0] + a[n][1];\n}", "test": "int main() {\n    assert(count_valid_coin_toss_sequences(1) == 2);\n    assert(count_valid_coin_toss_sequences(2) == 3);\n    assert(count_valid_coin_toss_sequences(3) == 5);\n    assert(count_valid_coin_toss_sequences(4) == 8); // Additional test\n    assert(count_valid_coin_toss_sequences(5) == 13); // Additional test\n    // Feel free to add more tests here\n    assert(count_valid_coin_toss_sequences(40) == 267914296ULL); // Additional test\n    assert(count_valid_coin_toss_sequences(39) == 165580141ULL);\n    assert(count_valid_coin_toss_sequences(38) == 102334155ULL);\n    // printf(\"All tests passed!\\n\");\n    return 0;\n}", "instruction": " the following faulty CPP code snippet and error type list. \nYour task is to select the error type of the code based on the error list provided\n\nYou only need to answer error type. Do not write anything else in your response. \n\nFor example, if the code snippet is missing a semicolon, Your output should be 'missing_colons'.\n\nfaulty code:\n\n```\n#include <cassert>\n#include <cmath>\n#include <cstdio>\n#include <cstring>\nunsigned long long count_valid_coin_toss_sequences(int* n)\n{\n    unsigned long long a[41][2];\n    a[1][0] = a[1][1] = 1;\n    for(int i = 2; i < n; i++){\n        a[i][0] = a[i - 1][0] + a[i - 1][0];\n        a[i][1] = a[i - 1][0];\n    }\n    return a[n][0] + a[n][1];\n}\n```\nerror type list:\n\n['illegal_comment', 'illegal_separation', 'missing_colons', 'misused ==and=', 'unclosed_parentheses', 'unclosed_string', 'faulty_indexing', 'function_error', 'illegal_keyword', 'undefined_methods', 'undefined_objects', 'algorithm_error', 'condition_error', 'operation_error', 'type_error', 'variable_error', 'double_bug', 'triple_bug', 'quadruple_bug', 'Misused Macro Definition', 'missing_backtick', 'misused_let', 'misused templte', 'Delayed Execution', 'Misused match', 'Misused := and =', 'Unused Variable', 'Misused === and ==', 'Misused =>', 'Misused Spread Operator', 'Misused begin/end', 'Missing $', 'illegal_indentation', 'Missing mut', 'Misused var and val', 'The digital leader is 0', 'Duplicate keys', 'struct_error', 'json_content_error']\n"}
{"question_id": "CPP/53", "category": "Multiple", "subtype": "triple_bug", "level": "hard", "example": "* Examples:\n *   >>> find_longest_consecutive_ones_length(7)\n *   3", "docstring": "* Find the length of the longest consecutive sequence of 1s in the binary \n * representation of a non-negative integer.\n *\n * Parameters:\n * - n (unsigned long long): A non-negative integer (0 ≤ n ≤ 2^64 - 1).\n *\n * Returns:\n * - int: The length of the longest consecutive sequence of 1s in the binary \n *        representation of the given integer.\n *", "canonical_solution": "#include <cassert>\n#include <cmath>\n#include <cstdio>\n#include <cstring>\n\nint find_longest_consecutive_ones_length(unsigned long long n)\n\n{\n    int max_length = 0;\n    int current_length = 0;\n    while (n) {\n        if (n & 1) {\n            current_length++;\n        } else {\n            if (current_length > max_length) {\n                max_length = current_length;\n            }\n            current_length = 0;\n        }\n        n >>= 1;\n    }\n    if (current_length > max_length) {\n        max_length = current_length;\n    }\n    return max_length;\n}", "buggy_code": "#include <cassert>\n#include <cmath>\n#include <cstdio>\n#include <cstring>\nint find_longest_consecutive_ones_length(int n)\n{\n    int max_length = 0;\n    int current_length = 0;\n    while (n) {\n        if (n | 1) {\n            current_length++;\n        } else {\n            if (current_length > max_length) {\n                max_length = current_length;\n            }\n            current_length = 0;\n        }\n        n >>= 1;\n    }\n    if (current_length < max_length) {\n        max_length = current_length;\n    }\n    return max_length;\n}", "test": "int main()\n{\n    assert(find_longest_consecutive_ones_length(7) == 3);\n    assert(find_longest_consecutive_ones_length(13) == 2);\n    assert(find_longest_consecutive_ones_length(12345) == 3); // New test sample\n    assert(find_longest_consecutive_ones_length(0b11011101111) == 4); // New test sample using binary literal for clarity\n    assert(find_longest_consecutive_ones_length(0xFFFFFFFF) == 32); // New test sample: all ones for a 32-bit number\n    assert(find_longest_consecutive_ones_length(0) == 0); // New test sample: no ones in a zero\n\n    // printf(\"All tests passed!\\n\"); // In C++, you might use std::cout, but it is commented out as per the original code.\n    return 0;\n}", "instruction": " the following faulty CPP code snippet and error type list. \nYour task is to select the error type of the code based on the error list provided\n\nYou only need to answer error type. Do not write anything else in your response. \n\nFor example, if the code snippet is missing a semicolon, Your output should be 'missing_colons'.\n\nfaulty code:\n\n```\n#include <cassert>\n#include <cmath>\n#include <cstdio>\n#include <cstring>\nint find_longest_consecutive_ones_length(int n)\n{\n    int max_length = 0;\n    int current_length = 0;\n    while (n) {\n        if (n | 1) {\n            current_length++;\n        } else {\n            if (current_length > max_length) {\n                max_length = current_length;\n            }\n            current_length = 0;\n        }\n        n >>= 1;\n    }\n    if (current_length < max_length) {\n        max_length = current_length;\n    }\n    return max_length;\n}\n```\nerror type list:\n\n['illegal_comment', 'illegal_separation', 'missing_colons', 'misused ==and=', 'unclosed_parentheses', 'unclosed_string', 'faulty_indexing', 'function_error', 'illegal_keyword', 'undefined_methods', 'undefined_objects', 'algorithm_error', 'condition_error', 'operation_error', 'type_error', 'variable_error', 'double_bug', 'triple_bug', 'quadruple_bug', 'Misused Macro Definition', 'missing_backtick', 'misused_let', 'misused templte', 'Delayed Execution', 'Misused match', 'Misused := and =', 'Unused Variable', 'Misused === and ==', 'Misused =>', 'Misused Spread Operator', 'Misused begin/end', 'Missing $', 'illegal_indentation', 'Missing mut', 'Misused var and val', 'The digital leader is 0', 'Duplicate keys', 'struct_error', 'json_content_error']\n"}
{"question_id": "CPP/54", "category": "Multiple", "subtype": "double_bug", "level": "hard", "example": "* Example Usage:\n * \n * create_id(\"fish\", \"cat\") returns \"ftiasch\"\n * create_id(\"icpc\", \"acm\") returns \"imccpac\"", "docstring": "* Generates a unique identifier by interweaving two words in a specified pattern.\n * @param word1 The first word to be used in the ID creation process.\n * @param word2 The second word to be used in the ID creation process.\n * @return A unique identifier formed by alternating characters from the second word,\n *         reversed, with characters from the first word.", "canonical_solution": "#include <iostream>\n#include <string>\n#include <cassert>\n\nstd::string create_id(const std::string& word1, const std::string& word2)\n\n{\n    std::string id;\n    int j = 0, k = word2.length() - 1;\n    for (int i = 0; i < word1.length() + word2.length(); ++i) {\n        if (i % 2 == 0) {\n            id += word1[j++];\n        } else {\n            id += word2[k--];\n        }\n    }\n    return id;\n}", "buggy_code": "#include <iostream>\n#include <string>\n#include <cassert>\nstd::string create_id(const std::string& word1, const std::string& word2)\n{\n    std:string id;\n    int j = 0, k = word2.length();\n    for (int i = 0; i < word1.length() + word2.length(); ++i) {\n        if (i % 2 == 0) {\n            id += word1[k++];\n        } else {\n            id += word2[k--];\n        }\n    }\n    return id;\n}", "test": "int main() {\n    std::string id; // To hold the results from create_id\n\n    id = create_id(\"fish\", \"cat\");\n    assert(id.compare(\"ftiasch\") == 0);\n\n    id = create_id(\"icpc\", \"acm\");\n    assert(id.compare(\"imccpac\") == 0);\n\n    id = create_id(\"oo\", \"w\");\n    assert(id.compare(\"owo\") == 0);\n\n    // Add more test samples\n    id = create_id(\"hello\", \"world\");\n    assert(id.compare(\"hdellrloow\") == 0);\n\n    id = create_id(\"abc\", \"def\");\n    assert(id.compare(\"afbecd\") == 0);\n\n    id = create_id(\"buaanb\", \"nbbuaa\");\n    assert(id.compare(\"bauaauabnbbn\") == 0);\n\n    id = create_id(\"xtuisgood\", \"ilovextu\");\n    assert(id.compare(\"xuttuxiesvgooloid\") == 0);\n\n    // std::cout << \"All tests passed!\" << std::endl;\n\n    return 0;\n}", "instruction": " the following faulty CPP code snippet and error type list. \nYour task is to select the error type of the code based on the error list provided\n\nYou only need to answer error type. Do not write anything else in your response. \n\nFor example, if the code snippet is missing a semicolon, Your output should be 'missing_colons'.\n\nfaulty code:\n\n```\n#include <iostream>\n#include <string>\n#include <cassert>\nstd::string create_id(const std::string& word1, const std::string& word2)\n{\n    std:string id;\n    int j = 0, k = word2.length();\n    for (int i = 0; i < word1.length() + word2.length(); ++i) {\n        if (i % 2 == 0) {\n            id += word1[k++];\n        } else {\n            id += word2[k--];\n        }\n    }\n    return id;\n}\n```\nerror type list:\n\n['illegal_comment', 'illegal_separation', 'missing_colons', 'misused ==and=', 'unclosed_parentheses', 'unclosed_string', 'faulty_indexing', 'function_error', 'illegal_keyword', 'undefined_methods', 'undefined_objects', 'algorithm_error', 'condition_error', 'operation_error', 'type_error', 'variable_error', 'double_bug', 'triple_bug', 'quadruple_bug', 'Misused Macro Definition', 'missing_backtick', 'misused_let', 'misused templte', 'Delayed Execution', 'Misused match', 'Misused := and =', 'Unused Variable', 'Misused === and ==', 'Misused =>', 'Misused Spread Operator', 'Misused begin/end', 'Missing $', 'illegal_indentation', 'Missing mut', 'Misused var and val', 'The digital leader is 0', 'Duplicate keys', 'struct_error', 'json_content_error']\n"}
{"question_id": "CPP/55", "category": "Multiple", "subtype": "triple_bug", "level": "hard", "example": "* Example:\n *    >>> Is_Square({9})\n *    true", "docstring": "* Determines if it is possible to assemble the wooden squares from n buckets\n * into a single larger square, where each bucket contains squares with a side length of 1.\n * \n * Input: vector of numbers\n * \n * @param squares Vector containing the count of squares in each bucket.\n * @return True if it is possible to form a larger square, False otherwise.", "canonical_solution": "#include <cassert>\n#include <cmath>\n#include <vector>\n\nbool Is_Square(std::vector<int> squares)\n\n{\n    long long sum = 0;\n    for (int square : squares) {\n        sum += square; \n    }\n    int root = static_cast<int>(std::sqrt(sum));\n    return root * root == sum;\n}", "buggy_code": "#include <cassert>\n#include <cmath>\n#include <vector>\nbool Is_Square(std::vector<int> squares)\n{\n    int g sum = 0;\n    for (int square : squares) {\n        sum += square; \n    }\n    int root = static_cast<int>(std:sqrt(sum));\n    return root * root = sum;\n}", "test": "int main() {\n    assert(Is_Square({9}) == true);\n    assert(Is_Square({14, 2}) == true);\n    assert(Is_Square({7, 7}) == false);\n    assert(Is_Square({1, 2, 3, 4, 5, 6, 7}) == false);\n    assert(Is_Square({1, 3, 5, 7, 9, 11}) == true);\n    assert(Is_Square({2, 2, 2, 2}) == false);\n\n    // Additional test cases\n    assert(Is_Square({4, 5, 6}) == false);\n    assert(Is_Square({16, 9, 4, 1}) == false);\n    assert(Is_Square({1, 1, 1, 1, 1}) == false);\n    assert(Is_Square({25, 25}) == false);\n    assert(Is_Square({10, 10, 5}) == true);\n\n    // All tests passed\n    return 0;\n}", "instruction": " the following faulty CPP code snippet and error type list. \nYour task is to select the error type of the code based on the error list provided\n\nYou only need to answer error type. Do not write anything else in your response. \n\nFor example, if the code snippet is missing a semicolon, Your output should be 'missing_colons'.\n\nfaulty code:\n\n```\n#include <cassert>\n#include <cmath>\n#include <vector>\nbool Is_Square(std::vector<int> squares)\n{\n    int g sum = 0;\n    for (int square : squares) {\n        sum += square; \n    }\n    int root = static_cast<int>(std:sqrt(sum));\n    return root * root = sum;\n}\n```\nerror type list:\n\n['illegal_comment', 'illegal_separation', 'missing_colons', 'misused ==and=', 'unclosed_parentheses', 'unclosed_string', 'faulty_indexing', 'function_error', 'illegal_keyword', 'undefined_methods', 'undefined_objects', 'algorithm_error', 'condition_error', 'operation_error', 'type_error', 'variable_error', 'double_bug', 'triple_bug', 'quadruple_bug', 'Misused Macro Definition', 'missing_backtick', 'misused_let', 'misused templte', 'Delayed Execution', 'Misused match', 'Misused := and =', 'Unused Variable', 'Misused === and ==', 'Misused =>', 'Misused Spread Operator', 'Misused begin/end', 'Missing $', 'illegal_indentation', 'Missing mut', 'Misused var and val', 'The digital leader is 0', 'Duplicate keys', 'struct_error', 'json_content_error']\n"}
{"question_id": "CPP/56", "category": "Multiple", "subtype": "quadruple_bug", "level": "hard", "example": "Examples:\n>>> count_acute_triangles(4, 1, 1, 1, 1)\n4", "docstring": "Count the number of acute-angled triangles that can be formed by selecting any 3 edges out of\na given set of edges.\n  \nArgs:\n- edges_count: The number of edges passed.\n- An arbitrary number of integer arguments representing the lengths of the edges.\n  \nReturns:\nint: The count of distinct acute-angled triangles that can be formed.", "canonical_solution": "#include <cassert>\n#include <cmath>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cstdarg>\n\nint count_acute_triangles(int edges_count, ...)\n\n{\n    va_list args;\n    va_start(args, edges_count);\n\n    int* edges = (int*) malloc(edges_count * sizeof(int));\n    for (int i = 0; i < edges_count; i++) {\n        edges[i] = va_arg(args, int);\n    }\n    va_end(args);\n\n    qsort(edges, edges_count, sizeof(int), (int (*)(const void *, const void *)) strcmp);\n\n\n    int sum = 0;\n    for (int i = 0; i < edges_count - 2; i++) {\n        for (int j = i + 1; j < edges_count - 1; j++) {\n            for (int k = j + 1; k < edges_count; k++) {\n                int x = edges[i], y = edges[j], z = edges[k];\n                if (x + y > z && x * x + y * y > z * z) {\n                    sum++;\n                }\n            }\n        }\n    }\n\n    free(edges);\n    return sum;\n}", "buggy_code": "#include <cassert>\n#include <cmath>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cstdarg>\nint count_acute_triangles(int edges_count)\n{\n    va_list args;\n    va_start(args, edges_count);\n    int edges = (int*) malloc(edges_count * sizeof(int));\n    for (int i = 0; i < edges_count; i++) {\n        edges[i] = va_arg(args, int);\n    }\n    va_end(args);\n    qsort(edges, edges_count, sizeof(int), (int (*)(const void *, const void *) strcmp);\n    int sum = 0;\n    for (int i = 0; i < edges_count - 2; i++) {\n        for (int j = i; j < edges_count - 1; j++) {\n            for (int k = j + 1; k < edges_count; k++) {\n                int x = edges[i], y = edges[j], z = edges[k];\n                if (x + y > z && x * x + y * y > z * z) {\n                    sum++;\n                }\n            }\n        }\n    }\n    free(edges);\n    return sum;\n}", "test": "int main() {\n    assert(count_acute_triangles(4, 1, 1, 1, 1) == 4);\n    assert(count_acute_triangles(3, 1, 2, 3) == 0);\n    // Additional tests to ensure correctness\n    assert(count_acute_triangles(5, 3, 4, 5, 7, 10) == 0);\n    assert(count_acute_triangles(6, 6, 8, 10, 5, 5, 5) == 4);\n    return 0;\n}", "instruction": " the following faulty CPP code snippet and error type list. \nYour task is to select the error type of the code based on the error list provided\n\nYou only need to answer error type. Do not write anything else in your response. \n\nFor example, if the code snippet is missing a semicolon, Your output should be 'missing_colons'.\n\nfaulty code:\n\n```\n#include <cassert>\n#include <cmath>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cstdarg>\nint count_acute_triangles(int edges_count)\n{\n    va_list args;\n    va_start(args, edges_count);\n    int edges = (int*) malloc(edges_count * sizeof(int));\n    for (int i = 0; i < edges_count; i++) {\n        edges[i] = va_arg(args, int);\n    }\n    va_end(args);\n    qsort(edges, edges_count, sizeof(int), (int (*)(const void *, const void *) strcmp);\n    int sum = 0;\n    for (int i = 0; i < edges_count - 2; i++) {\n        for (int j = i; j < edges_count - 1; j++) {\n            for (int k = j + 1; k < edges_count; k++) {\n                int x = edges[i], y = edges[j], z = edges[k];\n                if (x + y > z && x * x + y * y > z * z) {\n                    sum++;\n                }\n            }\n        }\n    }\n    free(edges);\n    return sum;\n}\n```\nerror type list:\n\n['illegal_comment', 'illegal_separation', 'missing_colons', 'misused ==and=', 'unclosed_parentheses', 'unclosed_string', 'faulty_indexing', 'function_error', 'illegal_keyword', 'undefined_methods', 'undefined_objects', 'algorithm_error', 'condition_error', 'operation_error', 'type_error', 'variable_error', 'double_bug', 'triple_bug', 'quadruple_bug', 'Misused Macro Definition', 'missing_backtick', 'misused_let', 'misused templte', 'Delayed Execution', 'Misused match', 'Misused := and =', 'Unused Variable', 'Misused === and ==', 'Misused =>', 'Misused Spread Operator', 'Misused begin/end', 'Missing $', 'illegal_indentation', 'Missing mut', 'Misused var and val', 'The digital leader is 0', 'Duplicate keys', 'struct_error', 'json_content_error']\n"}
{"question_id": "CPP/57", "category": "Multiple", "subtype": "quadruple_bug", "level": "hard", "example": "* Examples:\n * >>> minRoundsToSameChar(\"aab\")\n * 1\n * >>> minRoundsToSameChar(\"abc\")\n * 2\n * >>> minRoundsToSameChar(\"aaa\")\n * 0", "docstring": "* Given a string consisting of lowercase English letters, in each round you can change\n * one of the characters to another character. The question is: what is the minimum\n * number of rounds needed to make the string composed of the same character?\n *", "canonical_solution": "#include <cassert>\n#include <cstring>\n#include <iostream>\n\nint minRoundsToSameChar(const char* s)\n\n{\n    int charCount[26] = {0};\n    for (int i = 0; i < 26; i++) {\n        charCount[i] = 0;\n    }\n    while (*s) {\n        charCount[*s - 'a']++;\n        s++;\n    }\n    int maxCount = 0;\n    for (int i = 0; i < 26; i++) {\n        if (charCount[i] != 0 ) {\n            maxCount ++;\n        }\n    }\n\n    return maxCount - 1;\n}", "buggy_code": "#include <assert.h>\n#include <stdio.h>\n#include <string.h>\nint minRoundsToSameChar(const char s)\n{\n    char charCount[26] = 0;\n    for (int i = 0; i < 26; i++) {\n        charCount[i] = 0;\n    }\n    while (*s) {\n        charCount[s + 'a']++;\n        s++;\n    }\n    int maxCount = 0;\n    for (int i = 0; i <= 26; i++) {\n        if (charCount[i] == 0 ) {\n            maxCount ++;\n        }\n    }\n    return maxCount;\n}", "test": "int main() {\n    assert(minRoundsToSameChar(\"aab\") == 1);\n    assert(minRoundsToSameChar(\"abc\") == 2);\n    assert(minRoundsToSameChar(\"aaa\") == 0);\n    assert(minRoundsToSameChar(\"abab\") == 1);\n    assert(minRoundsToSameChar(\"zzzzz\") == 0);\n\n    return 0;\n}", "instruction": " the following faulty CPP code snippet and error type list. \nYour task is to select the error type of the code based on the error list provided\n\nYou only need to answer error type. Do not write anything else in your response. \n\nFor example, if the code snippet is missing a semicolon, Your output should be 'missing_colons'.\n\nfaulty code:\n\n```\n#include <assert.h>\n#include <stdio.h>\n#include <string.h>\nint minRoundsToSameChar(const char s)\n{\n    char charCount[26] = 0;\n    for (int i = 0; i < 26; i++) {\n        charCount[i] = 0;\n    }\n    while (*s) {\n        charCount[s + 'a']++;\n        s++;\n    }\n    int maxCount = 0;\n    for (int i = 0; i <= 26; i++) {\n        if (charCount[i] == 0 ) {\n            maxCount ++;\n        }\n    }\n    return maxCount;\n}\n```\nerror type list:\n\n['illegal_comment', 'illegal_separation', 'missing_colons', 'misused ==and=', 'unclosed_parentheses', 'unclosed_string', 'faulty_indexing', 'function_error', 'illegal_keyword', 'undefined_methods', 'undefined_objects', 'algorithm_error', 'condition_error', 'operation_error', 'type_error', 'variable_error', 'double_bug', 'triple_bug', 'quadruple_bug', 'Misused Macro Definition', 'missing_backtick', 'misused_let', 'misused templte', 'Delayed Execution', 'Misused match', 'Misused := and =', 'Unused Variable', 'Misused === and ==', 'Misused =>', 'Misused Spread Operator', 'Misused begin/end', 'Missing $', 'illegal_indentation', 'Missing mut', 'Misused var and val', 'The digital leader is 0', 'Duplicate keys', 'struct_error', 'json_content_error']\n"}
{"question_id": "CPP/58", "category": "Multiple", "subtype": "quadruple_bug", "level": "hard", "example": "* Examples:\n *    >>> makeEqualAgain(3, (int[]){1, 2, 1})\n *    1\n *    >>> makeEqualAgain(5, (int[]){5, 5, 1, 5, 5})\n *    1", "docstring": "* You are given an array a of n integers. You can perform at most one operation where you\n * select three integers i, j, x (1 <= i <= j <= n) and replace all elements from a[i] to a[j] with x,\n * at a cost of (j - i + 1). Find the minimum cost to make all elements in the array equal.\n *", "canonical_solution": "#include <cstdio>\n#include <cassert>\n\nint makeEqualAgain(int n, int a[])\n\n{\n    int j = 0, p = 1, q = 0, c, d;\n    int k = n;\n    for (p = 1; p < k; p++) {\n        if (a[p] != a[p - 1])\n            break;\n    }\n    for (q = k - 1; q > p; q--) {\n        if (a[q] != a[p - 1])\n            break;\n    }\n    for (d = k - 2; d >= 0; d--) {\n        if (a[d] != a[d + 1])\n            break;\n    }\n    for (c = 0; c < d; c++) {\n        if (a[c] != a[c + 1])\n            break;\n    }\n    if (q - p + 1 < d - c + 1)\n        return q - p + 1;\n    else\n        return d - c + 1;\n}", "buggy_code": "#include <cstdio>\n#include <cassert>\nint makeEqualAgain(int n, int a)\n{\n    int p = 1, q = 0, c, d;\n    int k == n;\n    for (p = 1; p < k; p++) {\n        if (a[p] != a[p - 1])\n            break;\n    }\n    for (q = k - 1; q > p; q++) {\n        if (a[q] != a[p - 1])\n            break;\n    }\n    for (d = k - 2; d >= 0; d--) {\n        if (a[d] != a[d + 1])\n            break;\n    }\n    for (c = 0; c < d; c++) {\n        if (a[c] != a[c + 1])\n            break;\n    }\n    if (q - p + 1 > d - c + 1)\n        return q - p + 1;\n    else\n        return d - c + 1;\n}", "test": "int main() {\n    int a1[] = {1,2,3,4,5,1};\n    int a2[] = {1,1,1,1,1,1,1};\n    int a3[] = {8,8,8,1,2,8,8,8};\n    int a4[] = {1,2,3};\n    int a5[] = {4,3,2,7,1,1,3};\n    int a6[] = {9,9,2,9,2,5,5,5,3};\n    \n    assert(makeEqualAgain(6, a1) == 4);\n    assert(makeEqualAgain(7, a2) == 0);\n    assert(makeEqualAgain(8, a3) == 2);\n    assert(makeEqualAgain(3, a4) == 2);\n    assert(makeEqualAgain(7, a5) == 6);\n    assert(makeEqualAgain(9, a6) == 7);\n\n    int a7[] = {1, 2, 1};\n    int a8[] = {5, 5, 1, 5, 5};\n    int a9[] = {1, 1, 1, 1};\n    int a10[] = {2, 2, 2, 3, 2, 2};\n    int a11[] = {1};\n    int a12[] = {1, 2};\n    int a13[] = {1, 2, 2, 1};\n    int a14[] = {4, 4, 4, 3, 3, 4, 4};\n    int a15[] = {5, 4, 4, 4, 5, 5};\n    int a16[] = {1, 2, 1, 2, 1, 2, 1};\n    // Additional provided tests\n    assert(makeEqualAgain(3, a7) == 1);\n    assert(makeEqualAgain(5, a8) == 1);\n    assert(makeEqualAgain(4, a9) == 0);\n    assert(makeEqualAgain(6, a10) == 1);\n    assert(makeEqualAgain(1, a11) == 0);\n    assert(makeEqualAgain(2, a12) == 1);\n    assert(makeEqualAgain(4, a13) == 2);\n    assert(makeEqualAgain(7, a14) == 2);\n    assert(makeEqualAgain(6, a15) == 3);\n    assert(makeEqualAgain(7, a16) == 5);\n    \n    return 0;\n}", "instruction": " the following faulty CPP code snippet and error type list. \nYour task is to select the error type of the code based on the error list provided\n\nYou only need to answer error type. Do not write anything else in your response. \n\nFor example, if the code snippet is missing a semicolon, Your output should be 'missing_colons'.\n\nfaulty code:\n\n```\n#include <cstdio>\n#include <cassert>\nint makeEqualAgain(int n, int a)\n{\n    int p = 1, q = 0, c, d;\n    int k == n;\n    for (p = 1; p < k; p++) {\n        if (a[p] != a[p - 1])\n            break;\n    }\n    for (q = k - 1; q > p; q++) {\n        if (a[q] != a[p - 1])\n            break;\n    }\n    for (d = k - 2; d >= 0; d--) {\n        if (a[d] != a[d + 1])\n            break;\n    }\n    for (c = 0; c < d; c++) {\n        if (a[c] != a[c + 1])\n            break;\n    }\n    if (q - p + 1 > d - c + 1)\n        return q - p + 1;\n    else\n        return d - c + 1;\n}\n```\nerror type list:\n\n['illegal_comment', 'illegal_separation', 'missing_colons', 'misused ==and=', 'unclosed_parentheses', 'unclosed_string', 'faulty_indexing', 'function_error', 'illegal_keyword', 'undefined_methods', 'undefined_objects', 'algorithm_error', 'condition_error', 'operation_error', 'type_error', 'variable_error', 'double_bug', 'triple_bug', 'quadruple_bug', 'Misused Macro Definition', 'missing_backtick', 'misused_let', 'misused templte', 'Delayed Execution', 'Misused match', 'Misused := and =', 'Unused Variable', 'Misused === and ==', 'Misused =>', 'Misused Spread Operator', 'Misused begin/end', 'Missing $', 'illegal_indentation', 'Missing mut', 'Misused var and val', 'The digital leader is 0', 'Duplicate keys', 'struct_error', 'json_content_error']\n"}
{"question_id": "CPP/59", "category": "Multiple", "subtype": "quadruple_bug", "level": "hard", "example": "* Example:\n * >>> maxModeSum(3, {1, 2, 3})\n * 17\n * A sequence that reaches its maximum value is (3,2,3,1,2,2).", "docstring": "* Given n positive integers representing the count of each number from 1 to n,\n * find the maximum sum of the mode (most frequent element) for all prefixes of\n * a sequence constructed from these numbers. The mode is the largest number among\n * the most frequent elements in a sequence.\n *", "canonical_solution": "#include <cassert>\n#include <cstdio>\n\nlong long maxModeSum(int n, const int* counts)\n\n{\n    long long ans = 0;\n    int mx = 0;\n    long long f[100000];\n    for (int i = 0; i <= n; ++i) f[i] = 0;\n\n    for (int i = n; i > 0; --i) {\n        while (mx < counts[i - 1]) {\n            mx++;\n            f[mx] = f[mx - 1] + i;\n        }\n        ans += f[counts[i - 1]];\n    }\n    return ans;\n}", "buggy_code": "#include <cassert>\n#include <cstdio>\nlong long maxModeSum(int n, const int counts)\n{\n    long ans = 0;\n    int mx = 0;\n    long long f[100000];\n    for (int i = 0; i < n; ++i) f[i] = 0;\n    for (int i = n; i > 0; --i) {\n        while (mx < counts[i - 1]) {\n            mx++;\n            f[mx] = f[mx - 1];\n        }\n        ans += f[counts[i - 1]];\n    }\n    return ans;\n}", "test": "int main() {\n    int a1[] = {1, 3, 2};\n    int a2[] = {4, 1, 2, 3};\n    int a3[] = {1, 1};\n    int a4[] = {1, 2, 3, 4, 5};\n    int a5[] = {100000};\n    int a6[] = {5, 3, 2, 4, 1};\n    int a7[] = {100000, 100000, 100000};\n    int a8[] = {2, 2, 5};\n    int a9[] = {4, 4, 4, 4};\n    int a10[] = {1, 2, 3, 4, 5, 6};\n    int a11[] = {3, 1, 2};\n\n    assert(maxModeSum(3, a1) == 17);\n    assert(maxModeSum(4, a2) == 37);\n    assert(maxModeSum(2, a3) == 4);\n    assert(maxModeSum(5, a4) == 75);\n    assert(maxModeSum(1, a5) == 100000);\n    assert(maxModeSum(5, a6) == 62);\n    assert(maxModeSum(3, a7) == 900000);\n    assert(maxModeSum(3, a8) == 27);\n    assert(maxModeSum(4, a9) == 64);\n    assert(maxModeSum(6, a10) == 126);\n    assert(maxModeSum(3, a11) == 16);\n    return 0;\n}", "instruction": " the following faulty CPP code snippet and error type list. \nYour task is to select the error type of the code based on the error list provided\n\nYou only need to answer error type. Do not write anything else in your response. \n\nFor example, if the code snippet is missing a semicolon, Your output should be 'missing_colons'.\n\nfaulty code:\n\n```\n#include <cassert>\n#include <cstdio>\nlong long maxModeSum(int n, const int counts)\n{\n    long ans = 0;\n    int mx = 0;\n    long long f[100000];\n    for (int i = 0; i < n; ++i) f[i] = 0;\n    for (int i = n; i > 0; --i) {\n        while (mx < counts[i - 1]) {\n            mx++;\n            f[mx] = f[mx - 1];\n        }\n        ans += f[counts[i - 1]];\n    }\n    return ans;\n}\n```\nerror type list:\n\n['illegal_comment', 'illegal_separation', 'missing_colons', 'misused ==and=', 'unclosed_parentheses', 'unclosed_string', 'faulty_indexing', 'function_error', 'illegal_keyword', 'undefined_methods', 'undefined_objects', 'algorithm_error', 'condition_error', 'operation_error', 'type_error', 'variable_error', 'double_bug', 'triple_bug', 'quadruple_bug', 'Misused Macro Definition', 'missing_backtick', 'misused_let', 'misused templte', 'Delayed Execution', 'Misused match', 'Misused := and =', 'Unused Variable', 'Misused === and ==', 'Misused =>', 'Misused Spread Operator', 'Misused begin/end', 'Missing $', 'illegal_indentation', 'Missing mut', 'Misused var and val', 'The digital leader is 0', 'Duplicate keys', 'struct_error', 'json_content_error']\n"}
{"question_id": "CPP/60", "category": "Multiple", "subtype": "quadruple_bug", "level": "hard", "example": "For example:\n    >>> countBalancedSubsequences(2, 2, 2)\n    2", "docstring": "Given three integers n, m, and k, find the number of sequences consisting of n '(' and m ')',\nsuch that the longest balanced subsequence is of length 2 * k. The result should be calculated modulo 1,000,000,007 (10^9 + 7).", "canonical_solution": "#include <cassert>\n\nlong long countBalancedSubsequences(long long n, long long m, long long k)\n\n{\n    const long long P = static_cast<long long>(1e9) + 7;\n    static long long C[4001][4001] = {0};\n\n    if (C[0][0] == 0) {\n        for (long long i = 0; i <= 4000; i++) C[i][0] = 1;\n        for (long long i = 1; i <= 4000; i++)\n            for (long long j = 1; j <= i; j++)\n                C[i][j] = (C[i - 1][j - 1] + C[i - 1][j]) % P;\n    }\n\n    if (k > n || k > m) return 0;\n    return (C[n + m][k] - C[n + m][k - 1] + P) % P;\n}", "buggy_code": "#include <cassert>\nlong long countBalancedSubsequences(long long n, long long m, long long k)\n{\n    const long long P = static_cast<int>(1e9) + 7;\n    static long long const[4001][4001] = {0};\n    if (C[0][0] == 0) {\n        for (long long i = 0; i < 4000; i++) C[i][0] = 1;\n        for (long long i = 1; i <= 4000; i++)\n            for (long long j = 1; j <= i; j++)\n                C[i][j] = (C[i - 1][j - 1] + C[i - 1][j]) % P;\n    }\n    if (k > n && k > m) return 0;\n    return (C[n + m][k] - C[n + m][k - 1] + P) % P;\n}", "test": "int main() {\n    assert(countBalancedSubsequences(2, 2, 2) == 2);\n    assert(countBalancedSubsequences(3, 2, 3) == 0);\n    assert(countBalancedSubsequences(3, 2, 1) == 4);\n    assert(countBalancedSubsequences(4, 3, 2) == 14);\n    assert(countBalancedSubsequences(5, 5, 2) == 35);\n    assert(countBalancedSubsequences(6, 1, 1) == 6);\n    assert(countBalancedSubsequences(1, 6, 1) == 6);\n    assert(countBalancedSubsequences(7, 2, 2) == 27);\n    assert(countBalancedSubsequences(8, 3, 3) == 110);\n    assert(countBalancedSubsequences(10, 10, 5) == 10659);\n    assert(countBalancedSubsequences(20, 20, 10) == 574221648);\n    assert(countBalancedSubsequences(2000, 2000, 1000) == 854104531);\n    assert(countBalancedSubsequences(2000, 1999, 1000) == 334874485);\n    assert(countBalancedSubsequences(2000, 2000, 1999) == 259428024);\n    return 0;\n}", "instruction": " the following faulty CPP code snippet and error type list. \nYour task is to select the error type of the code based on the error list provided\n\nYou only need to answer error type. Do not write anything else in your response. \n\nFor example, if the code snippet is missing a semicolon, Your output should be 'missing_colons'.\n\nfaulty code:\n\n```\n#include <cassert>\nlong long countBalancedSubsequences(long long n, long long m, long long k)\n{\n    const long long P = static_cast<int>(1e9) + 7;\n    static long long const[4001][4001] = {0};\n    if (C[0][0] == 0) {\n        for (long long i = 0; i < 4000; i++) C[i][0] = 1;\n        for (long long i = 1; i <= 4000; i++)\n            for (long long j = 1; j <= i; j++)\n                C[i][j] = (C[i - 1][j - 1] + C[i - 1][j]) % P;\n    }\n    if (k > n && k > m) return 0;\n    return (C[n + m][k] - C[n + m][k - 1] + P) % P;\n}\n```\nerror type list:\n\n['illegal_comment', 'illegal_separation', 'missing_colons', 'misused ==and=', 'unclosed_parentheses', 'unclosed_string', 'faulty_indexing', 'function_error', 'illegal_keyword', 'undefined_methods', 'undefined_objects', 'algorithm_error', 'condition_error', 'operation_error', 'type_error', 'variable_error', 'double_bug', 'triple_bug', 'quadruple_bug', 'Misused Macro Definition', 'missing_backtick', 'misused_let', 'misused templte', 'Delayed Execution', 'Misused match', 'Misused := and =', 'Unused Variable', 'Misused === and ==', 'Misused =>', 'Misused Spread Operator', 'Misused begin/end', 'Missing $', 'illegal_indentation', 'Missing mut', 'Misused var and val', 'The digital leader is 0', 'Duplicate keys', 'struct_error', 'json_content_error']\n"}
{"question_id": "CPP/61", "category": "Special", "subtype": "Misused Macro Definition", "level": "easy", "example": "shift_characters(\"NS BFW, JAJSYX TK NRUTWYFSHJ FWJ YMJ WJXZQY TK YWNANFQ HFZXJX\")\n\"IN WAR, EVENTS OF IMPORTANCE ARE THE RESULT OF TRIVIAL CAUSES\"\n", "docstring": "Shifts all characters by 5 positions in alphabetical order. Only letters are replaced, and all letters are in uppercase.\n\nParameters:\ntext (std::string&): The input text to be processed, modified in place.\n\nReturns:\nstd::string&: The transformed text with characters shifted by 5 positions.\n", "canonical_solution": "#include <bits/stdc++.h>\n/*\nShifts all characters by 5 positions in alphabetical order. Only letters are replaced,\nand all letters are in uppercase.\n\nParameters:\ntext (std::string&): The input text to be processed, modified in place.\n\nReturns:\nstd::string&: The transformed text with characters shifted by 5 positions.\n\n>>> shift_characters(\"NS BFW, JAJSYX TK NRUTWYFSHJ FWJ YMJ WJXZQY TK YWNANFQ HFZXJX\")\n\"IN WAR, EVENTS OF IMPORTANCE ARE THE RESULT OF TRIVIAL CAUSES\"\n*/\nstd::string& shift_characters(std::string& text)\n\n{\n    size_t len = text.length();\n    for (size_t i = 0; i < len; ++i) {\n        if ('A' <= text[i] && text[i] <= 'E') {\n            text[i] = text[i] + 'V' - 'A';\n        } else if ('F' <= text[i] && text[i] <= 'Z') {\n            text[i] = text[i] + 'A' - 'F';\n        }\n    }\n    return text;\n}", "buggy_code": "#include <bits/stdc++.h>\n\nstd::string& shift_characters(std::string& text)\n{\n    size_t len = text.length();\n    for (size_t i = 0; i < len; ++i) {\n        if ('A' <= text[i] && text[i] <= 'E') {\n            text[i] = text[i] + 'V' - 'A';\n        } else if ('F' <= text[i] && text[i] <= 'Z') {\n            text[i] = text[i] + 'A' - 'F';\n        }\n    }\n    return text;\n}\n\n#define 'A' 'F'", "test": "int main()\n{\n    std::string test1 = \"NS BFW, JAJSYX TK NRUTWYFSHJ FWJ YMJ WJXZQY TK YWNANFQ HFZXJX\";\n    std::string test2 = \"N BTZQI WFYMJW GJ KNWXY NS F QNYYQJ NGJWNFS ANQQFLJ YMFS XJHTSI NS WTRJ\";\n    std::string test3 = \"IFSLJW PSTBX KZQQ BJQQ YMFY HFJXFW NX RTWJ IFSLJWTZX YMFS MJ\";\n\n    assert(shift_characters(test1) == \"IN WAR, EVENTS OF IMPORTANCE ARE THE RESULT OF TRIVIAL CAUSES\");\n    assert(shift_characters(test2) == \"I WOULD RATHER BE FIRST IN A LITTLE IBERIAN VILLAGE THAN SECOND IN ROME\");\n    assert(shift_characters(test3) == \"DANGER KNOWS FULL WELL THAT CAESAR IS MORE DANGEROUS THAN HE\");\n    return 0;\n}", "instruction": " the following faulty CPP code snippet and error type list. \nYour task is to select the error type of the code based on the error list provided\n\nYou only need to answer error type. Do not write anything else in your response. \n\nFor example, if the code snippet is missing a semicolon, Your output should be 'missing_colons'.\n\nfaulty code:\n\n```\n#include <bits/stdc++.h>\n\nstd::string& shift_characters(std::string& text)\n{\n    size_t len = text.length();\n    for (size_t i = 0; i < len; ++i) {\n        if ('A' <= text[i] && text[i] <= 'E') {\n            text[i] = text[i] + 'V' - 'A';\n        } else if ('F' <= text[i] && text[i] <= 'Z') {\n            text[i] = text[i] + 'A' - 'F';\n        }\n    }\n    return text;\n}\n\n#define 'A' 'F'\n```\nerror type list:\n\n['illegal_comment', 'illegal_separation', 'missing_colons', 'misused ==and=', 'unclosed_parentheses', 'unclosed_string', 'faulty_indexing', 'function_error', 'illegal_keyword', 'undefined_methods', 'undefined_objects', 'algorithm_error', 'condition_error', 'operation_error', 'type_error', 'variable_error', 'double_bug', 'triple_bug', 'quadruple_bug', 'Misused Macro Definition', 'missing_backtick', 'misused_let', 'misused templte', 'Delayed Execution', 'Misused match', 'Misused := and =', 'Unused Variable', 'Misused === and ==', 'Misused =>', 'Misused Spread Operator', 'Misused begin/end', 'Missing $', 'illegal_indentation', 'Missing mut', 'Misused var and val', 'The digital leader is 0', 'Duplicate keys', 'struct_error', 'json_content_error']\n"}
{"question_id": "CPP/62", "category": "Special", "subtype": "Misused Macro Definition", "level": "middle", "example": "Examples:\n>>> minRoundsToSameChar(\"aab\")\n1\n>>> minRoundsToSameChar(\"abc\")\n2\n>>> minRoundsToSameChar(\"aaa\")\n0", "docstring": "Given a string consisting of lowercase English letters, in each round you can change\none of the characters to another character. The question is: what is the minimum\nnumber of rounds needed to make the string composed of the same character?", "canonical_solution": "#include <cassert>\n#include <cstring>\n#include <iostream>\n/**\n * Given a string consisting of lowercase English letters, in each round you can change\n * one of the characters to another character. The question is: what is the minimum\n * number of rounds needed to make the string composed of the same character?\n * \n * Examples:\n * >>> minRoundsToSameChar(\"aab\")\n * 1\n * >>> minRoundsToSameChar(\"abc\")\n * 2\n * >>> minRoundsToSameChar(\"aaa\")\n * 0\n */\nint minRoundsToSameChar(const char* s)\n\n{\n    int charCount[26] = {0}; // Assuming only lowercase letters\n    for (int i = 0; i < 26; i++) {\n        charCount[i] = 0;\n    }\n    while (*s) {\n        charCount[*s - 'a']++;\n        s++;\n    }\n    int maxCount = 0;\n    for (int i = 0; i < 26; i++) {\n        if (charCount[i] != 0 ) {\n            maxCount ++;\n        }\n    }\n\n    return maxCount - 1;\n}\n\n", "buggy_code": "#include <cassert>\n#include <cstring>\n#include <iostream>\n\n#define MAX_CHAR 25\n\nint minRoundsToSameChar(const char* s)\n{\n    int charCount[MAX_CHAR] = {0}; // Assuming only lowercase letters\n    for (int i = 0; i < MAX_CHAR; i++) {\n        charCount[i] = 0;\n    }\n    while (*s) {\n        charCount[*s - 'a']++;\n        s++;\n    }\n    int maxCount = 0;\n    for (int i = 0; i < MAX_CHAR; i++) {\n        if (charCount[i] != 0 ) {\n            maxCount ++;\n        }\n    }\n\n    return maxCount - 1;\n}", "test": "int main() {\n    assert(minRoundsToSameChar(\"aab\") == 1);\n    assert(minRoundsToSameChar(\"abc\") == 2);\n    assert(minRoundsToSameChar(\"aaa\") == 0);\n    assert(minRoundsToSameChar(\"abab\") == 1);\n    assert(minRoundsToSameChar(\"zzzzz\") == 0);\n\n    return 0;\n}", "instruction": " the following faulty CPP code snippet and error type list. \nYour task is to select the error type of the code based on the error list provided\n\nYou only need to answer error type. Do not write anything else in your response. \n\nFor example, if the code snippet is missing a semicolon, Your output should be 'missing_colons'.\n\nfaulty code:\n\n```\n#include <cassert>\n#include <cstring>\n#include <iostream>\n\n#define MAX_CHAR 25\n\nint minRoundsToSameChar(const char* s)\n{\n    int charCount[MAX_CHAR] = {0}; // Assuming only lowercase letters\n    for (int i = 0; i < MAX_CHAR; i++) {\n        charCount[i] = 0;\n    }\n    while (*s) {\n        charCount[*s - 'a']++;\n        s++;\n    }\n    int maxCount = 0;\n    for (int i = 0; i < MAX_CHAR; i++) {\n        if (charCount[i] != 0 ) {\n            maxCount ++;\n        }\n    }\n\n    return maxCount - 1;\n}\n```\nerror type list:\n\n['illegal_comment', 'illegal_separation', 'missing_colons', 'misused ==and=', 'unclosed_parentheses', 'unclosed_string', 'faulty_indexing', 'function_error', 'illegal_keyword', 'undefined_methods', 'undefined_objects', 'algorithm_error', 'condition_error', 'operation_error', 'type_error', 'variable_error', 'double_bug', 'triple_bug', 'quadruple_bug', 'Misused Macro Definition', 'missing_backtick', 'misused_let', 'misused templte', 'Delayed Execution', 'Misused match', 'Misused := and =', 'Unused Variable', 'Misused === and ==', 'Misused =>', 'Misused Spread Operator', 'Misused begin/end', 'Missing $', 'illegal_indentation', 'Missing mut', 'Misused var and val', 'The digital leader is 0', 'Duplicate keys', 'struct_error', 'json_content_error']\n"}
{"question_id": "CPP/63", "category": "Special", "subtype": "Misused Macro Definition", "level": "easy", "example": "Example:\n   newModuloFactorial(3, 7) returns 6\n", "docstring": "Given a prime number p, you need to handle several queries where you're given\nan integer n and you must compute n! ⊕ p. Here, n! is the factorial of n.\n", "canonical_solution": "#include <cassert>\n#include <cstdio>\n/**\n * This problem introduces a custom modulo operation, denoted by \"⊕\".\n * When calculating x ⊕ y, if x is not a multiple of y, the result is x % y.\n * If x is a multiple of y, divide x by y repeatedly until x is no longer a\n * multiple of y, denoting this final value as x'. Then the result is x' % y.\n * For example:\n * - 4⊕5=4,\n * - 20⊕5=4,\n * - 100⊕5=4.\n * Given a prime number p, you need to handle several queries where you're given\n * an integer n and you must compute n! ⊕ p. Here, n! is the factorial of n.\n * Example:\n *    newModuloFactorial(3, 7) returns 6\n */\nunsigned long long newModuloFactorial(unsigned long long n, unsigned long long p)\n\n{\n    unsigned long long pj[p];\n    pj[0] = 1;\n    pj[1] = 1;\n    for (unsigned long long i = 2; i < p; i++) pj[i] = i * pj[i - 1] % p;\n\n    unsigned long long ans = 1;\n    while (n) {\n        ans = ans * pj[n % p] % p;\n        ans = (n / p) & 1 ? p - ans : ans;\n        n /= p;\n    }\n    return ans;\n}", "buggy_code": "#include <cassert>\n#include <cstdio>\n\n#define p 5\n\nunsigned long long newModuloFactorial(unsigned long long n)\n{\n    unsigned long long pj[p];\n    pj[0] = 1;\n    pj[1] = 1;\n    for (unsigned long long i = 2; i < p; i++) pj[i] = i * pj[i - 1] % p;\n\n    unsigned long long ans = 1;\n    while (n) {\n        ans = ans * pj[n % p] % p;\n        ans = (n / p) & 1 ? p - ans : ans;\n        n /= p;\n    }\n    return ans;\n}", "test": "int main() {\n    // Test cases\n    assert(newModuloFactorial(3, 7) == 6);\n    assert(newModuloFactorial(10, 3) == 1);\n    assert(newModuloFactorial(11, 7) == 4);\n    assert(newModuloFactorial(45, 7) == 1);\n    assert(newModuloFactorial(14, 7) == 2);\n    assert(newModuloFactorial(1919, 10007) == 3152);\n    assert(newModuloFactorial(810, 10007) == 3679);\n    assert(newModuloFactorial(3, 7) == 6);\n    assert(newModuloFactorial(10, 3) == 1);\n    assert(newModuloFactorial(1, 2) == 1);\n    assert(newModuloFactorial(5, 11) == 10);\n    assert(newModuloFactorial(6, 13) == 5);\n    assert(newModuloFactorial(8, 17) == 13);\n    assert(newModuloFactorial(15, 19) == 16);\n    assert(newModuloFactorial(21, 23) == 1);\n    assert(newModuloFactorial(30, 29) == 28);\n    assert(newModuloFactorial(100, 101) == 100);\n    return 0;\n}", "instruction": " the following faulty CPP code snippet and error type list. \nYour task is to select the error type of the code based on the error list provided\n\nYou only need to answer error type. Do not write anything else in your response. \n\nFor example, if the code snippet is missing a semicolon, Your output should be 'missing_colons'.\n\nfaulty code:\n\n```\n#include <cassert>\n#include <cstdio>\n\n#define p 5\n\nunsigned long long newModuloFactorial(unsigned long long n)\n{\n    unsigned long long pj[p];\n    pj[0] = 1;\n    pj[1] = 1;\n    for (unsigned long long i = 2; i < p; i++) pj[i] = i * pj[i - 1] % p;\n\n    unsigned long long ans = 1;\n    while (n) {\n        ans = ans * pj[n % p] % p;\n        ans = (n / p) & 1 ? p - ans : ans;\n        n /= p;\n    }\n    return ans;\n}\n```\nerror type list:\n\n['illegal_comment', 'illegal_separation', 'missing_colons', 'misused ==and=', 'unclosed_parentheses', 'unclosed_string', 'faulty_indexing', 'function_error', 'illegal_keyword', 'undefined_methods', 'undefined_objects', 'algorithm_error', 'condition_error', 'operation_error', 'type_error', 'variable_error', 'double_bug', 'triple_bug', 'quadruple_bug', 'Misused Macro Definition', 'missing_backtick', 'misused_let', 'misused templte', 'Delayed Execution', 'Misused match', 'Misused := and =', 'Unused Variable', 'Misused === and ==', 'Misused =>', 'Misused Spread Operator', 'Misused begin/end', 'Missing $', 'illegal_indentation', 'Missing mut', 'Misused var and val', 'The digital leader is 0', 'Duplicate keys', 'struct_error', 'json_content_error']\n"}
{"question_id": "CPP/64", "category": "Special", "subtype": "misused templte", "level": "easy", "example": "Examples:\ncalculate_distance(0, 0, 3, 4) returns 5", "docstring": "Calculate the distance between two points A (xa, ya) and B (xb, yb).\n\nParameters:\n- xa (double): x-coordinate of point A.\n- ya (double): y-coordinate of point A.\n- xb (double): x-coordinate of point B.\n- yb (double): y-coordinate of point B.\n\nReturns:\ndouble: The distance between points A and B.", "canonical_solution": "#include <cassert>\n#include <cmath>\n#include <cstring>\n/**\n * Calculate the distance between two points A (xa, ya) and B (xb, yb).\n * \n * Parameters:\n * - xa (double): x-coordinate of point A.\n * - ya (double): y-coordinate of point A.\n * - xb (double): x-coordinate of point B.\n * - yb (double): y-coordinate of point B.\n * \n * Returns:\n * double: The distance between points A and B.\n * \n * Examples:\n * calculate_distance(0, 0, 3, 4) returns 5\n */\ndouble calculate_distance(double xa, double ya, double xb, double yb)\n\n{\n    return sqrt((xa - xb) * (xa - xb) + (ya - yb) * (ya - yb));\n}", "buggy_code": "#include <cassert>\n#include <cmath>\n#include <cstring>\n\ntemplate <typename T>\nT calculate_distance(T xa, T ya, T xb, T yb)\n{\n    return sqrt((xa - xb) * (xa - xb) + (ya - yb) * (ya - yb));\n}", "test": "int main() \n{\n    assert(fabs(calculate_distance(0, 0, 3, 4) - 5) < 1e-6);\n    assert(fabs(calculate_distance(0, 0, 0, 0) - 0) < 1e-6);\n    assert(fabs(calculate_distance(-1, -1, 2, 2) - 4.242640687) < 1e-6);\n    assert(fabs(calculate_distance(1.5, 3.9, 4.2, -1.1) - 5.68243) < 1e-6);\n    //std::cout << \"All test cases passed!\\n\"; // printf can be replaced with std::cout\n    return 0;\n}", "instruction": " the following faulty CPP code snippet and error type list. \nYour task is to select the error type of the code based on the error list provided\n\nYou only need to answer error type. Do not write anything else in your response. \n\nFor example, if the code snippet is missing a semicolon, Your output should be 'missing_colons'.\n\nfaulty code:\n\n```\n#include <cassert>\n#include <cmath>\n#include <cstring>\n\ntemplate <typename T>\nT calculate_distance(T xa, T ya, T xb, T yb)\n{\n    return sqrt((xa - xb) * (xa - xb) + (ya - yb) * (ya - yb));\n}\n```\nerror type list:\n\n['illegal_comment', 'illegal_separation', 'missing_colons', 'misused ==and=', 'unclosed_parentheses', 'unclosed_string', 'faulty_indexing', 'function_error', 'illegal_keyword', 'undefined_methods', 'undefined_objects', 'algorithm_error', 'condition_error', 'operation_error', 'type_error', 'variable_error', 'double_bug', 'triple_bug', 'quadruple_bug', 'Misused Macro Definition', 'missing_backtick', 'misused_let', 'misused templte', 'Delayed Execution', 'Misused match', 'Misused := and =', 'Unused Variable', 'Misused === and ==', 'Misused =>', 'Misused Spread Operator', 'Misused begin/end', 'Missing $', 'illegal_indentation', 'Missing mut', 'Misused var and val', 'The digital leader is 0', 'Duplicate keys', 'struct_error', 'json_content_error']\n"}
{"question_id": "CPP/65", "category": "Special", "subtype": "misused templte", "level": "easy", "example": "\nExample:\n   >>> Is_Square({9})\n   true\n", "docstring": "Determines if it is possible to assemble the wooden squares from n buckets\ninto a single larger square, where each bucket contains squares with a side length of 1.\n\nInput: vector of numbers\n\n@param squares Vector containing the count of squares in each bucket.\n@return True if it is possible to form a larger square, False otherwise.\n", "canonical_solution": "#include <cassert>\n#include <cmath>\n#include <vector>\n/**\n * Determines if it is possible to assemble the wooden squares from n buckets\n * into a single larger square, where each bucket contains squares with a side length of 1.\n * \n * Input: vector of numbers\n * Example:\n *    >>> Is_Square({9})\n *    true\n * \n * @param squares Vector containing the count of squares in each bucket.\n * @return True if it is possible to form a larger square, False otherwise.\n */\nbool Is_Square(std::vector<int> squares)\n\n{\n    long long sum = 0;\n    for (int square : squares) {\n        sum += square; // Sum the squares\n    }\n    int root = static_cast<int>(std::sqrt(sum));\n    return root * root == sum; // Check if the sum is a perfect square\n}", "buggy_code": "#include <cassert>\n#include <cmath>\n#include <vector>\n\ntemplate<typename T>\nbool Is_Square(std::vector<T> squares)\n{\n    long long sum = 0;\n    for (T square : squares) {\n        sum += square; // Sum the squares\n    }\n    int root = static_cast<int>(std::sqrt(sum));\n    return root * root == sum; // Check if the sum is a perfect square\n}", "test": "int main() {\n    assert(Is_Square({9}) == true);\n    assert(Is_Square({14, 2}) == true);\n    assert(Is_Square({7, 7}) == false);\n    assert(Is_Square({1, 2, 3, 4, 5, 6, 7}) == false);\n    assert(Is_Square({1, 3, 5, 7, 9, 11}) == true);\n    assert(Is_Square({2, 2, 2, 2}) == false);\n\n    // Additional test cases\n    assert(Is_Square({4, 5, 6}) == false);\n    assert(Is_Square({16, 9, 4, 1}) == false);\n    assert(Is_Square({1, 1, 1, 1, 1}) == false);\n    assert(Is_Square({25, 25}) == false);\n    assert(Is_Square({10, 10, 5}) == true);\n\n    // All tests passed\n    return 0;\n}", "instruction": " the following faulty CPP code snippet and error type list. \nYour task is to select the error type of the code based on the error list provided\n\nYou only need to answer error type. Do not write anything else in your response. \n\nFor example, if the code snippet is missing a semicolon, Your output should be 'missing_colons'.\n\nfaulty code:\n\n```\n#include <cassert>\n#include <cmath>\n#include <vector>\n\ntemplate<typename T>\nbool Is_Square(std::vector<T> squares)\n{\n    long long sum = 0;\n    for (T square : squares) {\n        sum += square; // Sum the squares\n    }\n    int root = static_cast<int>(std::sqrt(sum));\n    return root * root == sum; // Check if the sum is a perfect square\n}\n```\nerror type list:\n\n['illegal_comment', 'illegal_separation', 'missing_colons', 'misused ==and=', 'unclosed_parentheses', 'unclosed_string', 'faulty_indexing', 'function_error', 'illegal_keyword', 'undefined_methods', 'undefined_objects', 'algorithm_error', 'condition_error', 'operation_error', 'type_error', 'variable_error', 'double_bug', 'triple_bug', 'quadruple_bug', 'Misused Macro Definition', 'missing_backtick', 'misused_let', 'misused templte', 'Delayed Execution', 'Misused match', 'Misused := and =', 'Unused Variable', 'Misused === and ==', 'Misused =>', 'Misused Spread Operator', 'Misused begin/end', 'Missing $', 'illegal_indentation', 'Missing mut', 'Misused var and val', 'The digital leader is 0', 'Duplicate keys', 'struct_error', 'json_content_error']\n"}
{"question_id": "CPP/66", "category": "Special", "subtype": "misused templte", "level": "easy", "example": "Example:\nint asciiCode = display_ascii_info('A');\nstd::cout << asciiCode; // Output: 65", "docstring": "Displays the ASCII information for a given character.\n\n@param character The input character for which ASCII information is to be displayed.\n@return The corresponding ASCII code.", "canonical_solution": "#include <cassert>\n#include <cstdio>\n/**\n * Displays the ASCII information for a given character.\n * \n * @param character The input character for which ASCII information is to be displayed.\n * @return The corresponding ASCII code.\n * \n * Example:\n * ```cpp\n * int asciiCode = display_ascii_info('A');\n * std::cout << asciiCode; // Output: 65\n * ```\n */\nint display_ascii_info(char character)\n\n{\n    return character;\n}", "buggy_code": "#include <cassert>\n#include <cstdio>\n\ntemplate <typename T>\nT display_ascii_info(char character)\n{\n    return character;\n}", "test": "int main() {\n    assert(display_ascii_info('A') == 65);\n    assert(display_ascii_info('B') == 66); // Additional test case\n    assert(display_ascii_info('0') == 48); // Additional test case\n    assert(display_ascii_info(' ') == 32); // Additional test case\n    \n    // Uncomment the line below to print a success message if compiled outside a test framework\n    // std::printf(\"All tests passed.\\n\");\n\n    return 0;\n}", "instruction": " the following faulty CPP code snippet and error type list. \nYour task is to select the error type of the code based on the error list provided\n\nYou only need to answer error type. Do not write anything else in your response. \n\nFor example, if the code snippet is missing a semicolon, Your output should be 'missing_colons'.\n\nfaulty code:\n\n```\n#include <cassert>\n#include <cstdio>\n\ntemplate <typename T>\nT display_ascii_info(char character)\n{\n    return character;\n}\n```\nerror type list:\n\n['illegal_comment', 'illegal_separation', 'missing_colons', 'misused ==and=', 'unclosed_parentheses', 'unclosed_string', 'faulty_indexing', 'function_error', 'illegal_keyword', 'undefined_methods', 'undefined_objects', 'algorithm_error', 'condition_error', 'operation_error', 'type_error', 'variable_error', 'double_bug', 'triple_bug', 'quadruple_bug', 'Misused Macro Definition', 'missing_backtick', 'misused_let', 'misused templte', 'Delayed Execution', 'Misused match', 'Misused := and =', 'Unused Variable', 'Misused === and ==', 'Misused =>', 'Misused Spread Operator', 'Misused begin/end', 'Missing $', 'illegal_indentation', 'Missing mut', 'Misused var and val', 'The digital leader is 0', 'Duplicate keys', 'struct_error', 'json_content_error']\n"}
