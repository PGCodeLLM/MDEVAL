{"question_id": "Python/1", "category": "Syntax", "subtype": "illegal_comment", "level": "easy", "example": "Example:\n        >>> find_number_combinations()\n        [(123, 246, 369), (124, 248, 372), ...]", "docstring": "Generate all unique combinations of three numbers, each formed from the digits 1 to 9 without repetition,\n    such that the second number is twice the first and the third is three times the first.\n\n    Returns:\n        list of tuples: A sorted list of tuples, where each tuple contains three integers representing the\n                        valid number combinations in ascending order based on the first number.\n\n    ", "canonical_solution": "from itertools import permutations\n\ndef find_number_combinations():\n    \n    valid_combinations = []\n\n    for perm in permutations(range(1, 10)):\n        num1 = perm[0] * 100 + perm[1] * 10 + perm[2]\n        num2 = perm[3] * 100 + perm[4] * 10 + perm[5]\n        num3 = perm[6] * 100 + perm[7] * 10 + perm[8]\n\n        if num2 == 2 * num1 and num3 == 3 * num1:\n            valid_combinations.append((num1, num2, num3))\n\n    valid_combinations.sort()\n\n    return valid_combinations", "buggy_code": "from itertools import permutations\n\ndef find_number_combinations():\n    \n    # Store the valid combinations valid_combinations = []\n\n    for perm in permutations(range(1, 10)):\n        num1 = perm[0] * 100 + perm[1] * 10 + perm[2]\n        num2 = perm[3] * 100 + perm[4] * 10 + perm[5]\n        num3 = perm[6] * 100 + perm[7] * 10 + perm[8]\n\n        if num2 == 2 * num1 and num3 == 3 * num1:\n            valid_combinations.append((num1, num2, num3))\n\n    valid_combinations.sort()\n\n    return valid_combinations", "bug_with_line_numbers": "   1 | from itertools import permutations\n   2 | def find_number_combinations():\n   3 |     # Store the valid combinations valid_combinations = []\n   4 |     for perm in permutations(range(1, 10)):\n   5 |         num1 = perm[0] * 100 + perm[1] * 10 + perm[2]\n   6 |         num2 = perm[3] * 100 + perm[4] * 10 + perm[5]\n   7 |         num3 = perm[6] * 100 + perm[7] * 10 + perm[8]\n   8 |         if num2 == 2 * num1 and num3 == 3 * num1:\n   9 |             valid_combinations.append((num1, num2, num3))\n  10 |     valid_combinations.sort()\n  11 |     return valid_combinations", "fragment_lines": [3], "fragment_content": ["    # Store the valid combinations valid_combinations = []"], "test": "def check():\n    # Call the function to get the combinations\n    combinations = find_number_combinations()\n\n    # Check that we have at least one valid combination\n    assert len(combinations) > 0, \"There should be at least one valid combination.\"\n\n    # Iterate over each combination to perform further checks\n    for combo in combinations:\n        # Each combination should have exactly three numbers\n        assert len(combo) == 3, \"Each combination should have three numbers.\"\n\n        # Check if numbers are 3-digit numbers\n        for num in combo:\n            assert 100 <= num <= 999, f\"Each number should be a 3-digit number, got {num}.\"\n\n        # Check the 1:2:3 ratio\n        assert combo[1] == 2 * combo[0] and combo[2] == 3 * combo[0], \"The numbers should be in a 1:2:3 ratio.\"\n\n    print(\"All test cases passed!\")\n    \ncheck()", "instruction": "Observe the following faulty Python code and its example\ncode:\n```python\nfrom itertools import permutations\n\ndef find_number_combinations():\n    \n    # Store the valid combinations valid_combinations = []\n\n    for perm in permutations(range(1, 10)):\n        num1 = perm[0] * 100 + perm[1] * 10 + perm[2]\n        num2 = perm[3] * 100 + perm[4] * 10 + perm[5]\n        num3 = perm[6] * 100 + perm[7] * 10 + perm[8]\n\n        if num2 == 2 * num1 and num3 == 3 * num1:\n            valid_combinations.append((num1, num2, num3))\n\n    valid_combinations.sort()\n\n    return valid_combinations\n```\ncode example:\nExample:\n        >>> find_number_combinations()\n        [(123, 246, 369), (124, 248, 372), ...]\nFix bugs in the given code snippet. The fixed code must be placed between ```python```. Do not generate any test, main,example usage or check code!\n"}
{"question_id": "Python/2", "category": "Syntax", "subtype": "illegal_comment", "level": "easy", "example": "Examples:\n    - calculate_arrangements(2, 4, [3, 2]) returns 2.\n    - calculate_arrangements(3, 3, [1, 2, 3]) returns 6.", "docstring": "Compute the number of ways to arrange m pots of flowers using up to n types,\n    where the ith type can have at most a[i] pots, and the arrangement must be in\n    increasing order of flower types.\n\n    Args:\n    - n (int): The number of flower types available.\n    - m (int): The total number of flower pots to arrange.\n    - a (list of int): A list where a[i] is the maximum number of pots for the ith type of flower.\n\n    Returns:\n    - int: The number of distinct arrangements modulo (10^6 + 7).\n\n    ", "canonical_solution": "def calculate_arrangements(n, m, a) -> int:\n    \n    MOD = 10 ** 6 + 7\n    dp = [[0] * (m + 1) for _ in range(n + 1)]\n    dp[0][0] = 1\n    for i in range(1, n + 1):\n        for j in range(m + 1):\n            for k in range(min(j, a[i - 1]) + 1):\n                dp[i][j] += dp[i - 1][j - k]\n                dp[i][j] %= MOD\n    return dp[n][m]", "buggy_code": "def calculate_arrangements(n, m, a) -> int:\n    \n    MOD = 10 ** 6 + 7\n    dp = [[0] * (m + 1) for _ in range(n + 1)]\n    dp[0][0] = 1\n    for i in range(1, n + 1):\n        for j in range(m + 1):\n            for k in range(min(j, a[i - 1]) + 1):\n                # dp[i][j] += dp[i - 1][j - k]\n                dp[i][j] %= MOD\n    return dp[n][m]", "bug_with_line_numbers": "   1 | def calculate_arrangements(n, m, a) -> int:\n   2 |     MOD = 10 ** 6 + 7\n   3 |     dp = [[0] * (m + 1) for _ in range(n + 1)]\n   4 |     dp[0][0] = 1\n   5 |     for i in range(1, n + 1):\n   6 |         for j in range(m + 1):\n   7 |             for k in range(min(j, a[i - 1]) + 1):\n   8 |                 # dp[i][j] += dp[i - 1][j - k]\n   9 |                 dp[i][j] %= MOD\n  10 |     return dp[n][m]", "fragment_lines": [8], "fragment_content": ["                # dp[i][j] += dp[i - 1][j - k]"], "test": "def check():\n    # Helper function to compare expected and actual results\n    def assert_equal(actual, expected, message):\n        assert actual == expected, message\n\n    # Test Case 1\n    n, m, a = 2, 4, [3, 2]\n    expected = 2\n    assert_equal(calculate_arrangements(n, m, a), expected, f\"Test Case 1 failed: expected {expected}, got {calculate_arrangements(n, m, a)}\")\n\n    # Test Case 2\n    n, m, a = 3, 3, [1, 2, 3]\n    expected = 6\n    assert_equal(calculate_arrangements(n, m, a), expected, f\"Test Case 2 failed: expected {expected}, got {calculate_arrangements(n, m, a)}\")\n\n    # Test Case 3\n    n, m, a = 1, 5, [5]\n    expected = 1\n    assert_equal(calculate_arrangements(n, m, a), expected, f\"Test Case 3 failed: expected {expected}, got {calculate_arrangements(n, m, a)}\")\n\n    print(\"All tests passed!\")\n\ncheck()", "instruction": "Observe the following faulty Python code and its example\ncode:\n```python\ndef calculate_arrangements(n, m, a) -> int:\n    \n    MOD = 10 ** 6 + 7\n    dp = [[0] * (m + 1) for _ in range(n + 1)]\n    dp[0][0] = 1\n    for i in range(1, n + 1):\n        for j in range(m + 1):\n            for k in range(min(j, a[i - 1]) + 1):\n                # dp[i][j] += dp[i - 1][j - k]\n                dp[i][j] %= MOD\n    return dp[n][m]\n```\ncode example:\nExamples:\n    - calculate_arrangements(2, 4, [3, 2]) returns 2.\n    - calculate_arrangements(3, 3, [1, 2, 3]) returns 6.\nFix bugs in the given code snippet. The fixed code must be placed between ```python```. Do not generate any test, main,example usage or check code!\n"}
{"question_id": "Python/3", "category": "Syntax", "subtype": "illegal_separation", "level": "easy", "example": "Examples:\n    >>> find_topmost_carpet(3, [(1, 0, 2, 3), (0, 2, 3, 3), (2, 1, 3, 3)], (2, 2))\n    3\n    >>> find_topmost_carpet(3, [(1, 0, 2, 3), (0, 2, 3, 3), (2, 1, 3, 3)], (4, 5))\n    -1", "docstring": "Finds the topmost carpet covering a given point on the coordinate plane.\n\n    Args:\n    n (int): The total number of carpets.\n    carpets (list of tuples): A list containing n tuples, each representing a carpet's information.\n                              Each tuple contains four integers (a, b, g, k) where (a, b) is the\n                              coordinates of the bottom-left corner of the carpet and (g, k) are\n                              the lengths of the carpet along the x and y axis respectively.\n    point (tuple): A tuple containing two integers (x, y), the coordinates of the point to check.\n\n    Returns:\n    int: The number of the topmost carpet covering the point (x, y), or -1 if no carpet covers it.\n\n    ", "canonical_solution": "def find_topmost_carpet(n, carpets, point) -> int:\n    \n    x, y = point\n    # Iterate through the carpets in reverse order, since the last one is on top\n    for i in range(n - 1, -1, -1):\n        a, b, g, k = carpets[i]\n        if a <= x <= a + g and b <= y <= b + k:\n            return i + 1\n    return -1", "buggy_code": "def find_topmost_carpet(n, carpets, point) -> int:\n    \n    x y = point\n    # Iterate through the carpets in reverse order, since the last one is on top\n    for i in range(n - 1, -1, -1):\n        a, b, g, k = carpets[i]\n        if a <= x <= a + g and b <= y <= b + k:\n            return i + 1\n    return -1", "bug_with_line_numbers": "   1 | def find_topmost_carpet(n, carpets, point) -> int:\n   2 |     x y = point\n   3 |     # Iterate through the carpets in reverse order, since the last one is on top\n   4 |     for i in range(n - 1, -1, -1):\n   5 |         a, b, g, k = carpets[i]\n   6 |         if a <= x <= a + g and b <= y <= b + k:\n   7 |             return i + 1\n   8 |     return -1", "fragment_lines": [2], "fragment_content": ["    x y = point"], "test": "def check():\n    # Test case 1: Point is on topmost carpet (carpet 3)\n    assert find_topmost_carpet(3, [(1, 0, 2, 3), (0, 2, 3, 3), (2, 1, 3, 3)], (2, 2)) == 3\n\n    # Test case 2: Point is not covered by any carpet\n    assert find_topmost_carpet(3, [(1, 0, 2, 3), (0, 2, 3, 3), (2, 1, 3, 3)], (4, 5)) == -1\n\n    # Test case 3: Point is on the edge of the carpet (carpet 1)\n    assert find_topmost_carpet(2, [(1, 1, 3, 3), (4, 4, 2, 2)], (4, 1)) == 1\n\n    # Test case 4: Point is at the corner of the carpet (carpet 2)\n    assert find_topmost_carpet(2, [(1, 1, 3, 3), (4, 4, 2, 2)], (6, 4)) == 2\n\n    # Test case 5: Multiple carpets cover the point, but the last one is on top (carpet 4)\n    assert find_topmost_carpet(4, [(0, 0, 5, 5), (1, 1, 5, 5), (2, 2, 5, 5), (3, 3, 5, 5)], (4, 4)) == 4\n\n    # Test case 6: No carpets at all, should return -1\n    assert find_topmost_carpet(0, [], (0, 0)) == -1\n\n    # Test case 8: Point is covered by the first carpet and no others (carpet 1)\n    assert find_topmost_carpet(3, [(0, 0, 2, 2), (2, 2, 2, 2), (4, 4, 2, 2)], (1, 1)) == 1\n\n    print(\"All test cases passed!\")\n\ncheck()\n", "instruction": "Observe the following faulty Python code and its example\ncode:\n```python\ndef find_topmost_carpet(n, carpets, point) -> int:\n    \n    x y = point\n    # Iterate through the carpets in reverse order, since the last one is on top\n    for i in range(n - 1, -1, -1):\n        a, b, g, k = carpets[i]\n        if a <= x <= a + g and b <= y <= b + k:\n            return i + 1\n    return -1\n```\ncode example:\nExamples:\n    >>> find_topmost_carpet(3, [(1, 0, 2, 3), (0, 2, 3, 3), (2, 1, 3, 3)], (2, 2))\n    3\n    >>> find_topmost_carpet(3, [(1, 0, 2, 3), (0, 2, 3, 3), (2, 1, 3, 3)], (4, 5))\n    -1\nFix bugs in the given code snippet. The fixed code must be placed between ```python```. Do not generate any test, main,example usage or check code!\n"}
{"question_id": "Python/4", "category": "Syntax", "subtype": "illegal_separation", "level": "easy", "example": "Examples:\n    - optimize_seating(4, 5, 1, 2, 3, [(4, 2, 4, 3), (2, 3, 3, 3), (2, 5, 2, 4)])\n    Returns: ('2', '2 4')\n\n    - optimize_seating(3, 3, 1, 1, 2, [(1, 2, 1, 3), (2, 1, 3, 1)])\n    Returns: ('2', '2')", "docstring": "Optimize the placement of aisles in a classroom to minimize the amount of chatting between students.\n\n    Args:\n    M (int): The number of rows in the classroom.\n    N (int): The number of columns in the classroom.\n    K (int): The number of horizontal aisles to add.\n    L (int): The number of vertical aisles to add.\n    D (int): The number of chatting pairs in the classroom.\n    chatting_pairs (list of tuples): A list of tuples, each containing the positions (Xi, Yi) and (Pi, Qi) of a chatting pair.\n\n    Returns:\n    (str, str): Two space-separated strings representing the optimal row and column indices for the aisles.\n\n    The function works by counting the number of chatting pairs that can be separated by adding an aisle in each possible position.\n    It then selects the most effective positions for aisles, aiming to separate as many chatting pairs as possible.\n\n    ", "canonical_solution": "def optimize_seating(M: int, N: int, K: int, L: int, D: int, chatting_pairs: list) -> (str, str):\n    \n    row_counter = [0] * (M - 1)\n    col_counter = [0] * (N - 1)\n\n    for Xi, Yi, Pi, Qi in chatting_pairs:\n        if Xi == Pi:  \n            col_counter[min(Yi, Qi) - 1] += 1\n        elif Yi == Qi:  \n            row_counter[min(Xi, Pi) - 1] += 1\n\n    sorted_rows = sorted(range(M - 1), key=lambda i: row_counter[i], reverse=True)\n    sorted_cols = sorted(range(N - 1), key=lambda i: col_counter[i], reverse=True)\n\n    aisle_rows = sorted(sorted_rows[:K])\n    aisle_cols = sorted(sorted_cols[:L])\n\n    return ' '.join(str(row + 1) for row in aisle_rows), ' '.join(str(col + 1) for col in aisle_cols)", "buggy_code": "def optimize_seating(M: int, N: int, K: int, L: int, D: int, chatting_pairs: list) -> (str, str):\n    \n    row_counter = [0] * (M - 1)\n    col_counter = [0] * (N - 1)\n\n    for Xi, Yi, Pi, Qi in chatting_pairs:\n        if Xi == Pi:  \n            col_counter[min(Yi, Qi) - 1] += 1\n        elif Yi == Qi:  \n            row_counter[min(Xi, Pi) - 1] += 1\n\n    sorted_rows = sorted(range(M - 1), key=lambda i: row_counter[i], reverse=True)\n    sorted_cols = sorted(range(N - 1), key=lambda i: col_counter[i], reverse=True)\n\n    aisle_rows = sorted(sorted_rows[:K])\n    aisle_cols = sorted(sorted_cols[:L])\n\n    return ' '.join(str(row + 1) for row in aisle_rows) ' '.join(str(col + 1) for col in aisle_cols)", "bug_with_line_numbers": "   1 | def optimize_seating(M: int, N: int, K: int, L: int, D: int, chatting_pairs: list) -> (str, str):\n   2 |     row_counter = [0] * (M - 1)\n   3 |     col_counter = [0] * (N - 1)\n   4 |     for Xi, Yi, Pi, Qi in chatting_pairs:\n   5 |         if Xi == Pi:  \n   6 |             col_counter[min(Yi, Qi) - 1] += 1\n   7 |         elif Yi == Qi:  \n   8 |             row_counter[min(Xi, Pi) - 1] += 1\n   9 |     sorted_rows = sorted(range(M - 1), key=lambda i: row_counter[i], reverse=True)\n  10 |     sorted_cols = sorted(range(N - 1), key=lambda i: col_counter[i], reverse=True)\n  11 |     aisle_rows = sorted(sorted_rows[:K])\n  12 |     aisle_cols = sorted(sorted_cols[:L])\n  13 |     return ' '.join(str(row + 1) for row in aisle_rows) ' '.join(str(col + 1) for col in aisle_cols)", "fragment_lines": [13], "fragment_content": ["    return ' '.join(str(row + 1) for row in aisle_rows) ' '.join(str(col + 1) for col in aisle_cols)"], "test": "def check():\n    test_cases = [\n        # Test case 1 from the provided example\n        {\n            'M': 4, 'N': 5, 'K': 1, 'L': 2, 'D': 3,\n            'chatting_pairs': [(4, 2, 4, 3), (2, 3, 3, 3), (2, 5, 2, 4)],\n            'expected': ('2', '2 4')\n        },\n        # Corrected Test case 2\n        {\n            'M': 5, 'N': 6, 'K': 2, 'L': 3, 'D': 4,\n            'chatting_pairs': [(1, 1, 1, 2), (2, 2, 3, 2), (4, 5, 4, 6), (5, 1, 5, 2)],\n            'expected': ('1 2', '1 2 5')  # Corrected expected output\n        },\n        # Test case 3\n        {\n            'M': 3, 'N': 3, 'K': 1, 'L': 1, 'D': 2,\n            'chatting_pairs': [(1, 2, 1, 3), (2, 1, 3, 1)],\n            'expected': ('2', '2')\n        },\n    ]\n\n    for i, test in enumerate(test_cases, 1):\n        row_output, col_output = optimize_seating(\n            test['M'], test['N'], test['K'], test['L'], test['D'], test['chatting_pairs']\n        )\n        assert row_output == test['expected'][0], f\"Test case {i} failed: row_output {row_output} does not match expected {test['expected'][0]}\"\n        assert col_output == test['expected'][1], f\"Test case {i} failed: col_output {col_output} does not match expected {test['expected'][1]}\"\n        print(f\"Test case {i} passed.\")\n\n# Run the test function\ncheck()", "instruction": "Observe the following faulty Python code and its example\ncode:\n```python\ndef optimize_seating(M: int, N: int, K: int, L: int, D: int, chatting_pairs: list) -> (str, str):\n    \n    row_counter = [0] * (M - 1)\n    col_counter = [0] * (N - 1)\n\n    for Xi, Yi, Pi, Qi in chatting_pairs:\n        if Xi == Pi:  \n            col_counter[min(Yi, Qi) - 1] += 1\n        elif Yi == Qi:  \n            row_counter[min(Xi, Pi) - 1] += 1\n\n    sorted_rows = sorted(range(M - 1), key=lambda i: row_counter[i], reverse=True)\n    sorted_cols = sorted(range(N - 1), key=lambda i: col_counter[i], reverse=True)\n\n    aisle_rows = sorted(sorted_rows[:K])\n    aisle_cols = sorted(sorted_cols[:L])\n\n    return ' '.join(str(row + 1) for row in aisle_rows) ' '.join(str(col + 1) for col in aisle_cols)\n```\ncode example:\nExamples:\n    - optimize_seating(4, 5, 1, 2, 3, [(4, 2, 4, 3), (2, 3, 3, 3), (2, 5, 2, 4)])\n    Returns: ('2', '2 4')\n\n    - optimize_seating(3, 3, 1, 1, 2, [(1, 2, 1, 3), (2, 1, 3, 1)])\n    Returns: ('2', '2')\nFix bugs in the given code snippet. The fixed code must be placed between ```python```. Do not generate any test, main,example usage or check code!\n"}
{"question_id": "Python/5", "category": "Syntax", "subtype": "illegal_separation", "level": "easy", "example": "Examples:\n        >>> vigenere_decrypt(\"CompleteVictory\", \"Yvqgpxaimmklongnzfwpvxmniytm\")\n        'Wherethereisawillthereisaway'\n\n        >>> vigenere_decrypt(\"ABC\", \"DEF\")\n        'DCB'", "docstring": "Decrypts a ciphertext encrypted with the Vigenère cipher using the provided key.\n    \n    The Vigenère cipher is a method of encrypting alphabetic text by using a series of\n    Caesar ciphers based on the letters of a keyword. This function reverses the process\n    to recover the original plaintext from the ciphertext.\n\n    Args:\n        key (str): The encryption key used to encrypt the original plaintext.\n                   This key should consist only of alphabetic characters.\n        ciphertext (str): The encrypted text that needs to be decrypted.\n                          The ciphertext should consist only of alphabetic characters.\n\n    Returns:\n        str: The decrypted plaintext corresponding to the input ciphertext.\n\n    ", "canonical_solution": "def vigenere_decrypt(key: str, ciphertext: str) -> str:\n    \n    # Convert the key to uppercase for simplicity\n    key = key.upper()\n    key_length = len(key)\n    \n    # Define the alphabet\n    alphabet = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ'\n    \n    # Initialize the plaintext result\n    plaintext = []\n    \n    # Decryption process\n    for i, char in enumerate(ciphertext):\n        if char.isalpha():  # Check if the character is an alphabet\n            # Find the position of the char and key[i] in the alphabet\n            char_index = alphabet.index(char.upper())\n            key_index = alphabet.index(key[i % key_length])\n            \n            # Decrypt the character and preserve the case\n            decrypted_char = alphabet[(char_index - key_index) % 26]\n            if char.islower():\n                decrypted_char = decrypted_char.lower()\n            \n            plaintext.append(decrypted_char)\n        else:\n            plaintext.append(char)\n    \n    # Join the decrypted characters into a single string\n    return ''.join(plaintext)", "buggy_code": "def vigenere_decrypt(key: str, ciphertext: str) -> str:\n    \n    # Convert the key to uppercase for simplicity\n    key = key.upper()\n    key_length = len(key)\n    \n    # Define the alphabet\n    alphabet = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ'\n    \n    # Initialize the plaintext result\n    plaintext = []\n    \n    # Decryption process\n    for i char in enumerate(ciphertext):\n        if char.isalpha():  # Check if the character is an alphabet\n            # Find the position of the char and key[i] in the alphabet\n            char_index = alphabet.index(char.upper())\n            key_index = alphabet.index(key[i % key_length])\n            \n            # Decrypt the character and preserve the case\n            decrypted_char = alphabet[(char_index - key_index) % 26]\n            if char.islower():\n                decrypted_char = decrypted_char.lower()\n            \n            plaintext.append(decrypted_char)\n        else:\n            plaintext.append(char)\n    \n    # Join the decrypted characters into a single string\n    return ''.join(plaintext)", "bug_with_line_numbers": "   1 | def vigenere_decrypt(key: str, ciphertext: str) -> str:\n   2 |     # Convert the key to uppercase for simplicity\n   3 |     key = key.upper()\n   4 |     key_length = len(key)\n   5 |     # Define the alphabet\n   6 |     alphabet = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ'\n   7 |     # Initialize the plaintext result\n   8 |     plaintext = []\n   9 |     # Decryption process\n  10 |     for i char in enumerate(ciphertext):\n  11 |         if char.isalpha():  # Check if the character is an alphabet\n  12 |             # Find the position of the char and key[i] in the alphabet\n  13 |             char_index = alphabet.index(char.upper())\n  14 |             key_index = alphabet.index(key[i % key_length])\n  15 |             # Decrypt the character and preserve the case\n  16 |             decrypted_char = alphabet[(char_index - key_index) % 26]\n  17 |             if char.islower():\n  18 |                 decrypted_char = decrypted_char.lower()\n  19 |             plaintext.append(decrypted_char)\n  20 |         else:\n  21 |             plaintext.append(char)\n  22 |     # Join the decrypted characters into a single string\n  23 |     return ''.join(plaintext)", "fragment_lines": [6], "fragment_content": ["    for i char in enumerate(ciphertext):"], "test": "def check():\n    # Test case 1: Example provided in the problem statement\n    key1 = \"CompleteVictory\"\n    ciphertext1 = \"Yvqgpxaimmklongnzfwpvxmniytm\"\n    expected_plaintext1 = \"Wherethereisawillthereisaway\"\n    assert vigenere_decrypt(key1, ciphertext1) == expected_plaintext1, \"Test case 1 failed\"\n\n    # Test case 2: All uppercase characters\n    key2 = \"ABC\"\n    ciphertext2 = \"DEF\"\n    expected_plaintext2 = \"DDD\"\n    assert vigenere_decrypt(key2, ciphertext2) == expected_plaintext2, \"Test case 2 failed\"\n\n    # Test case 3: All lowercase characters\n    key3 = \"xyz\"\n    ciphertext3 = \"abc\"\n    expected_plaintext3 = \"ddd\"\n    assert vigenere_decrypt(key3, ciphertext3) == expected_plaintext3, \"Test case 3 failed\"\n\n    # Test case 4: Mixed case characters\n    key4 = \"MiXeD\"\n    ciphertext4 = \"JpOeR\"\n    expected_plaintext4 = \"XhRaO\"\n    assert vigenere_decrypt(key4, ciphertext4) == expected_plaintext4, \"Test case 4 failed\"\n\n    # Test case 5: Key shorter than ciphertext\n    key5 = \"short\"\n    ciphertext5 = \"PqrsPqrsPq\"\n    expected_plaintext5 = \"XjdbWykeYx\"\n    assert vigenere_decrypt(key5, ciphertext5) == expected_plaintext5, \"Test case 5 failed\"\n\n    print(\"All test cases passed!\")\n\n# Run the test function\ncheck()", "instruction": "Observe the following faulty Python code and its example\ncode:\n```python\ndef vigenere_decrypt(key: str, ciphertext: str) -> str:\n    \n    # Convert the key to uppercase for simplicity\n    key = key.upper()\n    key_length = len(key)\n    \n    # Define the alphabet\n    alphabet = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ'\n    \n    # Initialize the plaintext result\n    plaintext = []\n    \n    # Decryption process\n    for i char in enumerate(ciphertext):\n        if char.isalpha():  # Check if the character is an alphabet\n            # Find the position of the char and key[i] in the alphabet\n            char_index = alphabet.index(char.upper())\n            key_index = alphabet.index(key[i % key_length])\n            \n            # Decrypt the character and preserve the case\n            decrypted_char = alphabet[(char_index - key_index) % 26]\n            if char.islower():\n                decrypted_char = decrypted_char.lower()\n            \n            plaintext.append(decrypted_char)\n        else:\n            plaintext.append(char)\n    \n    # Join the decrypted characters into a single string\n    return ''.join(plaintext)\n```\ncode example:\nExamples:\n        >>> vigenere_decrypt(\"CompleteVictory\", \"Yvqgpxaimmklongnzfwpvxmniytm\")\n        'Wherethereisawillthereisaway'\n\n        >>> vigenere_decrypt(\"ABC\", \"DEF\")\n        'DCB'\nFix bugs in the given code snippet. The fixed code must be placed between ```python```. Do not generate any test, main,example usage or check code!\n"}
{"question_id": "Python/6", "category": "Syntax", "subtype": "missing_colons", "level": "easy", "example": "has_close_elements([1.0, 2.0, 3.0], 0.5)\nFalse\nhas_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\nTrue", "docstring": "Check if in given list of numbers, are any two numbers closer to each other than\n    given threshold.\n    >>> has_close_elements([1.0, 2.0, 3.0], 0.5)\n    False\n    >>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\n    True", "canonical_solution": "from typing import List\n \ndef has_close_elements(numbers: List[float], threshold: float) -> bool:\n    \n    for idx, elem in enumerate(numbers):\n        for idx2, elem2 in enumerate(numbers):\n            if idx != idx2:\n                distance = abs(elem - elem2)\n                if distance < threshold:\n                    return True\n\n    return False", "buggy_code": "from typing import List\n \ndef has_close_elements(numbers: List[float], threshold: float) -> bool:\n    \n    for idx, elem in enumerate(numbers)\n        for idx2, elem2 in enumerate(numbers)\n            if idx != idx2:\n                distance = abs(elem - elem2)\n                if distance < threshold:\n                    return True\n\n    return False", "bug_with_line_numbers": "   1 | from typing import List\n   2 | def has_close_elements(numbers: List[float], threshold: float) -> bool:\n   3 |     for idx, elem in enumerate(numbers)\n   4 |         for idx2, elem2 in enumerate(numbers)\n   5 |             if idx != idx2:\n   6 |                 distance = abs(elem - elem2)\n   7 |                 if distance < threshold:\n   8 |                     return True\n   9 |     return False", "fragment_lines": [3, 4], "fragment_content": ["    for idx, elem in enumerate(numbers)", "        for idx2, elem2 in enumerate(numbers)"], "test": "def check():\n    assert has_close_elements([1.0, 2.0, 3.9, 4.0, 5.0, 2.2], 0.3) == True\n    assert has_close_elements([1.0, 2.0, 3.9, 4.0, 5.0, 2.2], 0.05) == False\n    assert has_close_elements([1.0, 2.0, 5.9, 4.0, 5.0], 0.95) == True\n    assert has_close_elements([1.0, 2.0, 5.9, 4.0, 5.0], 0.8) == False\n    assert has_close_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.0], 0.1) == True\n    assert has_close_elements([1.1, 2.2, 3.1, 4.1, 5.1], 1.0) == True\n    assert has_close_elements([1.1, 2.2, 3.1, 4.1, 5.1], 0.5) == False\n \ncheck()", "instruction": "Observe the following faulty Python code and its example\ncode:\n```python\nfrom typing import List\n \ndef has_close_elements(numbers: List[float], threshold: float) -> bool:\n    \n    for idx, elem in enumerate(numbers)\n        for idx2, elem2 in enumerate(numbers)\n            if idx != idx2:\n                distance = abs(elem - elem2)\n                if distance < threshold:\n                    return True\n\n    return False\n```\ncode example:\nhas_close_elements([1.0, 2.0, 3.0], 0.5)\nFalse\nhas_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\nTrue\nFix bugs in the given code snippet. The fixed code must be placed between ```python```. Do not generate any test, main,example usage or check code!\n"}
{"question_id": "Python/7", "category": "Syntax", "subtype": "missing_colons", "level": "easy", "example": "Examples:\n        >>> vigenere_decrypt(\"CompleteVictory\", \"Yvqgpxaimmklongnzfwpvxmniytm\")\n        'Wherethereisawillthereisaway'\n\n        >>> vigenere_decrypt(\"ABC\", \"DEF\")\n        'DCB'", "docstring": "Decrypts a ciphertext encrypted with the Vigenère cipher using the provided key.\n    \n    The Vigenère cipher is a method of encrypting alphabetic text by using a series of\n    Caesar ciphers based on the letters of a keyword. This function reverses the process\n    to recover the original plaintext from the ciphertext.\n\n    Args:\n        key (str): The encryption key used to encrypt the original plaintext.\n                   This key should consist only of alphabetic characters.\n        ciphertext (str): The encrypted text that needs to be decrypted.\n                          The ciphertext should consist only of alphabetic characters.\n\n    Returns:\n        str: The decrypted plaintext corresponding to the input ciphertext.\n\n    ", "canonical_solution": "def vigenere_decrypt(key: str, ciphertext: str) -> str:\n    \n    # Convert the key to uppercase for simplicity\n    key = key.upper()\n    key_length = len(key)\n    \n    # Define the alphabet\n    alphabet = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ'\n    \n    # Initialize the plaintext result\n    plaintext = []\n    \n    # Decryption process\n    for i, char in enumerate(ciphertext):\n        if char.isalpha():  # Check if the character is an alphabet\n            # Find the position of the char and key[i] in the alphabet\n            char_index = alphabet.index(char.upper())\n            key_index = alphabet.index(key[i % key_length])\n            \n            # Decrypt the character and preserve the case\n            decrypted_char = alphabet[(char_index - key_index) % 26]\n            if char.islower():\n                decrypted_char = decrypted_char.lower()\n            \n            plaintext.append(decrypted_char)\n        else:\n            plaintext.append(char)\n    \n    # Join the decrypted characters into a single string\n    return ''.join(plaintext)", "buggy_code": "def vigenere_decrypt(key: str, ciphertext: str) -> str\n    \n    # Convert the key to uppercase for simplicity\n    key = key.upper()\n    key_length = len(key)\n    \n    # Define the alphabet\n    alphabet = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ'\n    \n    # Initialize the plaintext result\n    plaintext = []\n    \n    # Decryption process\n    for i, char in enumerate(ciphertext):\n        if char.isalpha():  # Check if the character is an alphabet\n            # Find the position of the char and key[i] in the alphabet\n            char_index = alphabet.index(char.upper())\n            key_index = alphabet.index(key[i % key_length])\n            \n            # Decrypt the character and preserve the case\n            decrypted_char = alphabet[(char_index - key_index) % 26]\n            if char.islower():\n                decrypted_char = decrypted_char.lower()\n            \n            plaintext.append(decrypted_char)\n        else:\n            plaintext.append(char)\n    \n    # Join the decrypted characters into a single string\n    return ''.join(plaintext)", "bug_with_line_numbers": "   1 | def vigenere_decrypt(key: str, ciphertext: str) -> str\n   2 |     # Convert the key to uppercase for simplicity\n   3 |     key = key.upper()\n   4 |     key_length = len(key)\n   5 |     # Define the alphabet\n   6 |     alphabet = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ'\n   7 |     # Initialize the plaintext result\n   8 |     plaintext = []\n   9 |     # Decryption process\n  10 |     for i, char in enumerate(ciphertext):\n  11 |         if char.isalpha():  # Check if the character is an alphabet\n  12 |             # Find the position of the char and key[i] in the alphabet\n  13 |             char_index = alphabet.index(char.upper())\n  14 |             key_index = alphabet.index(key[i % key_length])\n  15 |             # Decrypt the character and preserve the case\n  16 |             decrypted_char = alphabet[(char_index - key_index) % 26]\n  17 |             if char.islower():\n  18 |                 decrypted_char = decrypted_char.lower()\n  19 |             plaintext.append(decrypted_char)\n  20 |         else:\n  21 |             plaintext.append(char)\n  22 |     # Join the decrypted characters into a single string\n  23 |     return ''.join(plaintext)", "fragment_lines": [1], "fragment_content": ["def vigenere_decrypt(key: str, ciphertext: str) -> str"], "test": "def check():\n    # Test case 1: Example provided in the problem statement\n    key1 = \"CompleteVictory\"\n    ciphertext1 = \"Yvqgpxaimmklongnzfwpvxmniytm\"\n    expected_plaintext1 = \"Wherethereisawillthereisaway\"\n    assert vigenere_decrypt(key1, ciphertext1) == expected_plaintext1, \"Test case 1 failed\"\n\n    # Test case 2: All uppercase characters\n    key2 = \"ABC\"\n    ciphertext2 = \"DEF\"\n    expected_plaintext2 = \"DDD\"\n    assert vigenere_decrypt(key2, ciphertext2) == expected_plaintext2, \"Test case 2 failed\"\n\n    # Test case 3: All lowercase characters\n    key3 = \"xyz\"\n    ciphertext3 = \"abc\"\n    expected_plaintext3 = \"ddd\"\n    assert vigenere_decrypt(key3, ciphertext3) == expected_plaintext3, \"Test case 3 failed\"\n\n    # Test case 4: Mixed case characters\n    key4 = \"MiXeD\"\n    ciphertext4 = \"JpOeR\"\n    expected_plaintext4 = \"XhRaO\"\n    assert vigenere_decrypt(key4, ciphertext4) == expected_plaintext4, \"Test case 4 failed\"\n\n    # Test case 5: Key shorter than ciphertext\n    key5 = \"short\"\n    ciphertext5 = \"PqrsPqrsPq\"\n    expected_plaintext5 = \"XjdbWykeYx\"\n    assert vigenere_decrypt(key5, ciphertext5) == expected_plaintext5, \"Test case 5 failed\"\n\n    print(\"All test cases passed!\")\n\n# Run the test function\ncheck()", "instruction": "Observe the following faulty Python code and its example\ncode:\n```python\ndef vigenere_decrypt(key: str, ciphertext: str) -> str\n    \n    # Convert the key to uppercase for simplicity\n    key = key.upper()\n    key_length = len(key)\n    \n    # Define the alphabet\n    alphabet = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ'\n    \n    # Initialize the plaintext result\n    plaintext = []\n    \n    # Decryption process\n    for i, char in enumerate(ciphertext):\n        if char.isalpha():  # Check if the character is an alphabet\n            # Find the position of the char and key[i] in the alphabet\n            char_index = alphabet.index(char.upper())\n            key_index = alphabet.index(key[i % key_length])\n            \n            # Decrypt the character and preserve the case\n            decrypted_char = alphabet[(char_index - key_index) % 26]\n            if char.islower():\n                decrypted_char = decrypted_char.lower()\n            \n            plaintext.append(decrypted_char)\n        else:\n            plaintext.append(char)\n    \n    # Join the decrypted characters into a single string\n    return ''.join(plaintext)\n```\ncode example:\nExamples:\n        >>> vigenere_decrypt(\"CompleteVictory\", \"Yvqgpxaimmklongnzfwpvxmniytm\")\n        'Wherethereisawillthereisaway'\n\n        >>> vigenere_decrypt(\"ABC\", \"DEF\")\n        'DCB'\nFix bugs in the given code snippet. The fixed code must be placed between ```python```. Do not generate any test, main,example usage or check code!\n"}
{"question_id": "Python/8", "category": "Syntax", "subtype": "misused ==and=", "level": "easy", "example": ">>> separate_paren_groups('( ) (( )) (( )( ))')\n    ['()', '(())', '(()())']", "docstring": "Input to this function is a string containing multiple groups of nested parentheses. Your goal is to\n    separate those group into separate strings and return the list of those.\n    Separate groups are balanced (each open brace is properly closed) and not nested within each other\n    Ignore any spaces in the input string.\n    ", "canonical_solution": "from typing import List\n \n \ndef separate_paren_groups(paren_string: str) -> List[str]:\n    \n    paren_string = paren_string.replace(\" \", \"\")\n    \n    current_group = \"\"\n    stack = []\n    result = []\n    \n    for char in paren_string:\n\n        if char == \"(\":\n            stack.append(char)\n            current_group += char\n\n        elif char == \")\" and stack:\n            stack.pop()\n            current_group += char\n\n            if not stack:\n                result.append(current_group)\n                current_group = \"\" \n\n    return result", "buggy_code": "from typing import List\n \n \ndef separate_paren_groups(paren_string: str) -> List[str]:\n    \n    paren_string = paren_string.replace(\" \", \"\")\n    \n    current_group = \"\"\n    stack = []\n    result = []\n    \n    for char in paren_string:\n\n        if char = \"(\":\n            stack.append(char)\n            current_group += char\n\n        elif char = \")\" and stack:\n            stack.pop()\n            current_group += char\n\n            if not stack:\n                result.append(current_group)\n                current_group = \"\" \n\n    return result", "bug_with_line_numbers": "   1 | from typing import List\n   2 | def separate_paren_groups(paren_string: str) -> List[str]:\n   3 |     paren_string = paren_string.replace(\" \", \"\")\n   4 |     current_group = \"\"\n   5 |     stack = []\n   6 |     result = []\n   7 |     for char in paren_string:\n   8 |         if char = \"(\":\n   9 |             stack.append(char)\n  10 |             current_group += char\n  11 |         elif char = \")\" and stack:\n  12 |             stack.pop()\n  13 |             current_group += char\n  14 |             if not stack:\n  15 |                 result.append(current_group)\n  16 |                 current_group = \"\" \n  17 |     return result", "fragment_lines": [8, 11], "fragment_content": ["        if char = \"(\":", "        elif char = \")\" and stack:"], "test": "def check():\n    assert separate_paren_groups('(()()) ((())) () ((())()())') == [\n    '(()())', '((()))', '()', '((())()())'\n    ]\n    assert separate_paren_groups('() (()) ((())) (((())))') == [\n    '()', '(())', '((()))', '(((())))'\n    ]\n    assert separate_paren_groups('(()(())((())))') == [\n    '(()(())((())))'\n    ]\n    assert separate_paren_groups('( ) (( )) (( )( ))') == ['()', '(())', '(()())']\n \ncheck()", "instruction": "Observe the following faulty Python code and its example\ncode:\n```python\nfrom typing import List\n \n \ndef separate_paren_groups(paren_string: str) -> List[str]:\n    \n    paren_string = paren_string.replace(\" \", \"\")\n    \n    current_group = \"\"\n    stack = []\n    result = []\n    \n    for char in paren_string:\n\n        if char = \"(\":\n            stack.append(char)\n            current_group += char\n\n        elif char = \")\" and stack:\n            stack.pop()\n            current_group += char\n\n            if not stack:\n                result.append(current_group)\n                current_group = \"\" \n\n    return result\n```\ncode example:\n>>> separate_paren_groups('( ) (( )) (( )( ))')\n    ['()', '(())', '(()())']\nFix bugs in the given code snippet. The fixed code must be placed between ```python```. Do not generate any test, main,example usage or check code!\n"}
{"question_id": "Python/9", "category": "Syntax", "subtype": "misused ==and=", "level": "easy", "example": "Example:\n        >>> find_number_combinations()\n        [(123, 246, 369), (124, 248, 372), ...]", "docstring": "Generate all unique combinations of three numbers, each formed from the digits 1 to 9 without repetition,\n    such that the second number is twice the first and the third is three times the first.\n\n    Returns:\n        list of tuples: A sorted list of tuples, where each tuple contains three integers representing the\n                        valid number combinations in ascending order based on the first number.\n\n    ", "canonical_solution": "from itertools import permutations\n\ndef find_number_combinations():\n    \n    valid_combinations = []\n\n    for perm in permutations(range(1, 10)):\n        num1 = perm[0] * 100 + perm[1] * 10 + perm[2]\n        num2 = perm[3] * 100 + perm[4] * 10 + perm[5]\n        num3 = perm[6] * 100 + perm[7] * 10 + perm[8]\n\n        if num2 == 2 * num1 and num3 == 3 * num1:\n            valid_combinations.append((num1, num2, num3))\n\n    valid_combinations.sort()\n\n    return valid_combinations", "buggy_code": "from itertools import permutations\n\ndef find_number_combinations():\n    \n    valid_combinations = []\n\n    for perm in permutations(range(1, 10)):\n        num1 = perm[0] * 100 + perm[1] * 10 + perm[2]\n        num2 = perm[3] * 100 + perm[4] * 10 + perm[5]\n        num3 = perm[6] * 100 + perm[7] * 10 + perm[8]\n\n        if num2 = 2 * num1 and num3 == 3 * num1:\n            valid_combinations.append((num1, num2, num3))\n\n    valid_combinations.sort()\n\n    return valid_combinations", "bug_with_line_numbers": "   1 | from itertools import permutations\n   2 | def find_number_combinations():\n   3 |     valid_combinations = []\n   4 |     for perm in permutations(range(1, 10)):\n   5 |         num1 = perm[0] * 100 + perm[1] * 10 + perm[2]\n   6 |         num2 = perm[3] * 100 + perm[4] * 10 + perm[5]\n   7 |         num3 = perm[6] * 100 + perm[7] * 10 + perm[8]\n   8 |         if num2 = 2 * num1 and num3 == 3 * num1:\n   9 |             valid_combinations.append((num1, num2, num3))\n  10 |     valid_combinations.sort()\n  11 |     return valid_combinations", "fragment_lines": [8], "fragment_content": ["        if num2 = 2 * num1 and num3 == 3 * num1:"], "test": "def check():\n    # Call the function to get the combinations\n    combinations = find_number_combinations()\n\n    # Check that we have at least one valid combination\n    assert len(combinations) > 0, \"There should be at least one valid combination.\"\n\n    # Iterate over each combination to perform further checks\n    for combo in combinations:\n        # Each combination should have exactly three numbers\n        assert len(combo) == 3, \"Each combination should have three numbers.\"\n\n        # Check if numbers are 3-digit numbers\n        for num in combo:\n            assert 100 <= num <= 999, f\"Each number should be a 3-digit number, got {num}.\"\n\n        # Check the 1:2:3 ratio\n        assert combo[1] == 2 * combo[0] and combo[2] == 3 * combo[0], \"The numbers should be in a 1:2:3 ratio.\"\n\n    print(\"All test cases passed!\")\n    \ncheck()", "instruction": "Observe the following faulty Python code and its example\ncode:\n```python\nfrom itertools import permutations\n\ndef find_number_combinations():\n    \n    valid_combinations = []\n\n    for perm in permutations(range(1, 10)):\n        num1 = perm[0] * 100 + perm[1] * 10 + perm[2]\n        num2 = perm[3] * 100 + perm[4] * 10 + perm[5]\n        num3 = perm[6] * 100 + perm[7] * 10 + perm[8]\n\n        if num2 = 2 * num1 and num3 == 3 * num1:\n            valid_combinations.append((num1, num2, num3))\n\n    valid_combinations.sort()\n\n    return valid_combinations\n```\ncode example:\nExample:\n        >>> find_number_combinations()\n        [(123, 246, 369), (124, 248, 372), ...]\nFix bugs in the given code snippet. The fixed code must be placed between ```python```. Do not generate any test, main,example usage or check code!\n"}
{"question_id": "Python/10", "category": "Syntax", "subtype": "misused ==and=", "level": "easy", "example": "Examples:\n    >>> verify_isbn(\"0-670-82162-4\")\n    'Right'\n    \n    >>> verify_isbn(\"0-670-82162-0\")\n    '0-670-82162-4'", "docstring": "Verify the correctness of a given ISBN number and correct it if necessary.\n\n    The function checks the provided ISBN number against the ISBN standard checksum calculation.\n    If the checksum is correct, the function returns \"Right\". If the checksum is incorrect,\n    the function returns the corrected ISBN number.\n\n    Args:\n    isbn: A string representing the ISBN number to be verified. The format should be 'x-xxx-xxxxx-x',\n          where 'x' is a digit, and the last 'x' could also be 'X' representing the checksum digit.\n\n    Returns:\n    A string that is either \"Right\" if the ISBN checksum is correct, or the corrected ISBN number\n    in the same format as the input if the checksum is incorrect.\n\n    ", "canonical_solution": "def verify_isbn(isbn: str) -> str:\n    \n    isbn_digits = isbn.replace('-', '')\n\n    total_sum = sum((i + 1) * int(digit) for i, digit in enumerate(isbn_digits[:-1]))\n    \n    check_digit = total_sum % 11\n\n    if check_digit == 10:\n        check_digit = 'X'\n    else:\n        check_digit = str(check_digit)\n\n    if check_digit == isbn_digits[-1]:\n        return \"Right\"\n    else:\n        return isbn[:-1] + check_digit", "buggy_code": "def verify_isbn(isbn: str) -> str:\n    \n    isbn_digits = isbn.replace('-', '')\n\n    total_sum = sum((i + 1) * int(digit) for i, digit in enumerate(isbn_digits[:-1]))\n    \n    check_digit = total_sum % 11\n\n    if check_digit = 10:\n        check_digit = 'X'\n    else:\n        check_digit = str(check_digit)\n\n    if check_digit == isbn_digits[-1]:\n        return \"Right\"\n    else:\n        return isbn[:-1] + check_digit", "bug_with_line_numbers": "   1 | def verify_isbn(isbn: str) -> str:\n   2 |     isbn_digits = isbn.replace('-', '')\n   3 |     total_sum = sum((i + 1) * int(digit) for i, digit in enumerate(isbn_digits[:-1]))\n   4 |     check_digit = total_sum % 11\n   5 |     if check_digit = 10:\n   6 |         check_digit = 'X'\n   7 |     else:\n   8 |         check_digit = str(check_digit)\n   9 |     if check_digit == isbn_digits[-1]:\n  10 |         return \"Right\"\n  11 |     else:\n  12 |         return isbn[:-1] + check_digit", "fragment_lines": [5], "fragment_content": ["    if check_digit = 10:"], "test": "def check():\n    # Test case 1: Correct ISBN number\n    assert verify_isbn(\"0-670-82162-4\") == \"Right\", \"Test case 1 failed\"\n\n    # Test case 2: Incorrect ISBN number with wrong checksum digit\n    assert verify_isbn(\"0-670-82162-0\") == \"0-670-82162-4\", \"Test case 2 failed\"\n\n    print(\"All test cases passed!\")\n\n# Run the test cases\ncheck()", "instruction": "Observe the following faulty Python code and its example\ncode:\n```python\ndef verify_isbn(isbn: str) -> str:\n    \n    isbn_digits = isbn.replace('-', '')\n\n    total_sum = sum((i + 1) * int(digit) for i, digit in enumerate(isbn_digits[:-1]))\n    \n    check_digit = total_sum % 11\n\n    if check_digit = 10:\n        check_digit = 'X'\n    else:\n        check_digit = str(check_digit)\n\n    if check_digit == isbn_digits[-1]:\n        return \"Right\"\n    else:\n        return isbn[:-1] + check_digit\n```\ncode example:\nExamples:\n    >>> verify_isbn(\"0-670-82162-4\")\n    'Right'\n    \n    >>> verify_isbn(\"0-670-82162-0\")\n    '0-670-82162-4'\nFix bugs in the given code snippet. The fixed code must be placed between ```python```. Do not generate any test, main,example usage or check code!\n"}
{"question_id": "Python/11", "category": "Syntax", "subtype": "unclosed_parentheses", "level": "easy", "example": "Cases:\n    >>> count_passing_ways(3, 3)\n    2\n    >>> count_passing_ways(5, 4)\n    6", "docstring": "Counts the number of different ways to pass a ball among 'n' students arranged in a circle \n    such that after 'm' passes, the ball returns to the starting student.\n\n    The function uses dynamic programming to determine the number of passing sequences. Each student\n    can pass the ball either to the left neighbor or to the right neighbor.\n\n    Args:\n    n: The number of students standing in a circle.\n    m: The number of times the ball is passed.\n\n    Returns:\n    An integer representing the number of distinct passing ways that result in the ball\n    returning to the starting student after 'm' passes.\n\n    ", "canonical_solution": "def count_passing_ways(n: int, m: int) -> int:\n    \n    dp = [[0] * n for _ in range(m + 1)]\n\n    dp[0][0] = 1\n\n    for i in range(1, m + 1):\n        for j in range(n):\n            dp[i][j] = dp[i - 1][(j - 1 + n) % n] + dp[i - 1][(j + 1) % n]\n\n    return dp[m][0]", "buggy_code": "def count_passing_ways(n: int, m: int) -> int:\n    \n    dp = [[0] * n for _ in range(m + 1)]\n\n    dp[0][0] = 1\n\n    for i in range(1, m + 1):\n        for j in range(n):\n            dp[i][j] = dp[i - 1][(j - 1 + n % n] + dp[i - 1][(j + 1) % n]\n\n    return dp[m][0]", "bug_with_line_numbers": "   1 | def count_passing_ways(n: int, m: int) -> int:\n   2 |     dp = [[0] * n for _ in range(m + 1)]\n   3 |     dp[0][0] = 1\n   4 |     for i in range(1, m + 1):\n   5 |         for j in range(n):\n   6 |             dp[i][j] = dp[i - 1][(j - 1 + n % n] + dp[i - 1][(j + 1) % n]\n   7 |     return dp[m][0]", "fragment_lines": [6], "fragment_content": ["            dp[i][j] = dp[i - 1][(j - 1 + n % n] + dp[i - 1][(j + 1) % n]"], "test": "def check():\n    test_cases = [\n        # Test case 1: simple case\n        {\n            'n': 3,\n            'm': 1,\n            'expected': 0\n        },\n        # Test case 2: another simple case\n        {\n            'n': 4,\n            'm': 2,\n            'expected': 2\n        },\n        # Test case 3: larger number of students and passes\n        {\n            'n': 5,\n            'm': 3,\n            'expected': 0\n        },\n    ]\n\n    for i, test in enumerate(test_cases, 1):\n        result = count_passing_ways(test['n'], test['m'])\n        assert result == test['expected'], f\"Test case {i} failed: result {result} does not match expected {test['expected']}\"\n        print(f\"Test case {i} passed with result {result}.\")\n\n# Run the test function\ncheck()\n", "instruction": "Observe the following faulty Python code and its example\ncode:\n```python\ndef count_passing_ways(n: int, m: int) -> int:\n    \n    dp = [[0] * n for _ in range(m + 1)]\n\n    dp[0][0] = 1\n\n    for i in range(1, m + 1):\n        for j in range(n):\n            dp[i][j] = dp[i - 1][(j - 1 + n % n] + dp[i - 1][(j + 1) % n]\n\n    return dp[m][0]\n```\ncode example:\nCases:\n    >>> count_passing_ways(3, 3)\n    2\n    >>> count_passing_ways(5, 4)\n    6\nFix bugs in the given code snippet. The fixed code must be placed between ```python```. Do not generate any test, main,example usage or check code!\n"}
{"question_id": "Python/12", "category": "Syntax", "subtype": "unclosed_parentheses", "level": "easy", "example": "Cases:\n    >>> count_passing_ways(3, 3)\n    2\n    >>> count_passing_ways(5, 4)\n    6", "docstring": "Counts the number of different ways to pass a ball among 'n' students arranged in a circle \n    such that after 'm' passes, the ball returns to the starting student.\n\n    The function uses dynamic programming to determine the number of passing sequences. Each student\n    can pass the ball either to the left neighbor or to the right neighbor.\n\n    Args:\n    n: The number of students standing in a circle.\n    m: The number of times the ball is passed.\n\n    Returns:\n    An integer representing the number of distinct passing ways that result in the ball\n    returning to the starting student after 'm' passes.\n\n    ", "canonical_solution": "def count_passing_ways(n: int, m: int) -> int:\n    \n    dp = [[0] * n for _ in range(m + 1)]\n\n    dp[0][0] = 1\n\n    for i in range(1, m + 1):\n        for j in range(n):\n            dp[i][j] = dp[i - 1][(j - 1 + n) % n] + dp[i - 1][(j + 1) % n]\n\n    return dp[m][0]", "buggy_code": "def count_passing_ways(n: int, m: int) -> int:\n    \n    dp = [[0] * n for _ in range(m + 1)]\n\n    dp[0][0] = 1\n\n    for i in range(1, m + 1):\n        for j in range(n):\n            dp[i][j] = dp[i - 1][(j - 1 + n) % n] + dp[i - 1][(j + 1) % n\n\n    return dp[m][0]", "bug_with_line_numbers": "   1 | def count_passing_ways(n: int, m: int) -> int:\n   2 |     dp = [[0] * n for _ in range(m + 1)]\n   3 |     dp[0][0] = 1\n   4 |     for i in range(1, m + 1):\n   5 |         for j in range(n):\n   6 |             dp[i][j] = dp[i - 1][(j - 1 + n) % n] + dp[i - 1][(j + 1) % n\n   7 |     return dp[m][0]", "fragment_lines": [6], "fragment_content": ["            dp[i][j] = dp[i - 1][(j - 1 + n) % n] + dp[i - 1][(j + 1) % n"], "test": "def check():\n    test_cases = [\n        # Test case 1: simple case\n        {\n            'n': 3,\n            'm': 1,\n            'expected': 0\n        },\n        # Test case 2: another simple case\n        {\n            'n': 4,\n            'm': 2,\n            'expected': 2\n        },\n        # Test case 3: larger number of students and passes\n        {\n            'n': 5,\n            'm': 3,\n            'expected': 0\n        },\n    ]\n\n    for i, test in enumerate(test_cases, 1):\n        result = count_passing_ways(test['n'], test['m'])\n        assert result == test['expected'], f\"Test case {i} failed: result {result} does not match expected {test['expected']}\"\n        print(f\"Test case {i} passed with result {result}.\")\n\n# Run the test function\ncheck()\n", "instruction": "Observe the following faulty Python code and its example\ncode:\n```python\ndef count_passing_ways(n: int, m: int) -> int:\n    \n    dp = [[0] * n for _ in range(m + 1)]\n\n    dp[0][0] = 1\n\n    for i in range(1, m + 1):\n        for j in range(n):\n            dp[i][j] = dp[i - 1][(j - 1 + n) % n] + dp[i - 1][(j + 1) % n\n\n    return dp[m][0]\n```\ncode example:\nCases:\n    >>> count_passing_ways(3, 3)\n    2\n    >>> count_passing_ways(5, 4)\n    6\nFix bugs in the given code snippet. The fixed code must be placed between ```python```. Do not generate any test, main,example usage or check code!\n"}
{"question_id": "Python/13", "category": "Syntax", "subtype": "unclosed_string", "level": "easy", "example": ">>> separate_paren_groups('( ) (( )) (( )( ))')\n    ['()', '(())', '(()())']s", "docstring": "Input to this function is a string containing multiple groups of nested parentheses. Your goal is to\n    separate those group into separate strings and return the list of those.\n    Separate groups are balanced (each open brace is properly closed) and not nested within each other\n    Ignore any spaces in the input string.\n    >>> separate_paren_groups('( ) (( )) (( )( ))')\n    ['()', '(())', '(()())']", "canonical_solution": "from typing import List\n \n \ndef separate_paren_groups(paren_string: str) -> List[str]:\n    \n    paren_string = paren_string.replace(\" \", \"\")\n    \n    current_group = \"\"\n    stack = []\n    result = []\n    \n    for char in paren_string:\n\n        if char == \"(\":\n            stack.append(char)\n            current_group += char\n\n        elif char == \")\" and stack:\n            stack.pop()\n            current_group += char\n\n            if not stack:\n                result.append(current_group)\n                current_group = \"\" \n\n    return result", "buggy_code": "from typing import List\n \n \ndef separate_paren_groups(paren_string: str) -> List[str]:\n    \n    paren_string = paren_string.replace(\" \", \"\")\n    \n    current_group = \"\"\n    stack = []\n    result = []\n    \n    for char in paren_string:\n\n        if char == \"(:\n            stack.append(char)\n            current_group += char\n\n        elif char == )\" and stack:\n            stack.pop()\n            current_group += char\n\n            if not stack:\n                result.append(current_group)\n                current_group = \"\" \n\n    return result", "bug_with_line_numbers": "   1 | from typing import List\n   2 | def separate_paren_groups(paren_string: str) -> List[str]:\n   3 |     paren_string = paren_string.replace(\" \", \"\")\n   4 |     current_group = \"\"\n   5 |     stack = []\n   6 |     result = []\n   7 |     for char in paren_string:\n   8 |         if char == \"(:\n   9 |             stack.append(char)\n  10 |             current_group += char\n  11 |         elif char == )\" and stack:\n  12 |             stack.pop()\n  13 |             current_group += char\n  14 |             if not stack:\n  15 |                 result.append(current_group)\n  16 |                 current_group = \"\" \n  17 |     return result", "fragment_lines": [8, 11], "fragment_content": ["        if char == \"(:", "        elif char == )\" and stack:"], "test": "def check():\n    assert separate_paren_groups('(()()) ((())) () ((())()())') == [\n    '(()())', '((()))', '()', '((())()())'\n    ]\n    assert separate_paren_groups('() (()) ((())) (((())))') == [\n    '()', '(())', '((()))', '(((())))'\n    ]\n    assert separate_paren_groups('(()(())((())))') == [\n    '(()(())((())))'\n    ]\n    assert separate_paren_groups('( ) (( )) (( )( ))') == ['()', '(())', '(()())']\n \ncheck()", "instruction": "Observe the following faulty Python code and its example\ncode:\n```python\nfrom typing import List\n \n \ndef separate_paren_groups(paren_string: str) -> List[str]:\n    \n    paren_string = paren_string.replace(\" \", \"\")\n    \n    current_group = \"\"\n    stack = []\n    result = []\n    \n    for char in paren_string:\n\n        if char == \"(:\n            stack.append(char)\n            current_group += char\n\n        elif char == )\" and stack:\n            stack.pop()\n            current_group += char\n\n            if not stack:\n                result.append(current_group)\n                current_group = \"\" \n\n    return result\n```\ncode example:\n>>> separate_paren_groups('( ) (( )) (( )( ))')\n    ['()', '(())', '(()())']s\nFix bugs in the given code snippet. The fixed code must be placed between ```python```. Do not generate any test, main,example usage or check code!\n"}
{"question_id": "Python/14", "category": "Syntax", "subtype": "unclosed_string", "level": "easy", "example": "cantor_numbering(1) -> \"1/1\"", "docstring": "Determines the numerator and denominator of the N-th term in the Cantor table.\n\n    Args:\n    - N (int): The position in the Cantor table to find the corresponding fraction for.\n\n    Returns:\n    - str: A string representation of the fraction at the N-th position in the Cantor table.", "canonical_solution": "def cantor_numbering(N: int) -> str:\n    \n    line = 1\n    while N > line:\n        N -= line\n        line += 1\n\n    if line % 2 == 0:\n        numerator = N\n        denominator = line - N + 1\n    else:\n        numerator = line - N + 1\n        denominator = N\n\n    return f\"{numerator}/{denominator}\"", "buggy_code": "def cantor_numbering(N: int) -> str:\n    \n    line = 1\n    while N > line:\n        N -= line\n        line += 1\n\n    if line % 2 == 0:\n        numerator = N\n        denominator = line - N + 1\n    else:\n        numerator = line - N + 1\n        denominator = N\n\n    return f\"{numerator}/{denominator}", "bug_with_line_numbers": "   1 | def cantor_numbering(N: int) -> str:\n   2 |     line = 1\n   3 |     while N > line:\n   4 |         N -= line\n   5 |         line += 1\n   6 |     if line % 2 == 0:\n   7 |         numerator = N\n   8 |         denominator = line - N + 1\n   9 |     else:\n  10 |         numerator = line - N + 1\n  11 |         denominator = N\n  12 |     return f\"{numerator}/{denominator}", "fragment_lines": [12], "fragment_content": ["    return f\"{numerator}/{denominator}"], "test": "def check():\n    # Test case 1: N = 1, the first element, should be \"1/1\"\n    assert cantor_numbering(1)==\"1/1\"\n\n    # Test case 2: N = 2, the second element, should be \"1/2\"\n    assert cantor_numbering(2)==\"1/2\"\n\n    # Test case 3: N = 6, the sixth element, should be \"1/3\"\n    assert cantor_numbering(6)==\"1/3\"\n\n    # Corrected test case: N = 7, the seventh element, should be \"1/4\"\n    assert cantor_numbering(7) == \"1/4\"\n\n    # Additional test case: N = 8, the eighth element, should be \"2/3\"\n    assert cantor_numbering(8) == \"2/3\"\n\n\ncheck()", "instruction": "Observe the following faulty Python code and its example\ncode:\n```python\ndef cantor_numbering(N: int) -> str:\n    \n    line = 1\n    while N > line:\n        N -= line\n        line += 1\n\n    if line % 2 == 0:\n        numerator = N\n        denominator = line - N + 1\n    else:\n        numerator = line - N + 1\n        denominator = N\n\n    return f\"{numerator}/{denominator}\n```\ncode example:\ncantor_numbering(1) -> \"1/1\"\nFix bugs in the given code snippet. The fixed code must be placed between ```python```. Do not generate any test, main,example usage or check code!\n"}
{"question_id": "Python/15", "category": "Syntax", "subtype": "unclosed_string", "level": "easy", "example": "Examples:\n        >>> vigenere_decrypt(\"CompleteVictory\", \"Yvqgpxaimmklongnzfwpvxmniytm\")\n        'Wherethereisawillthereisaway'\n\n        >>> vigenere_decrypt(\"ABC\", \"DEF\")\n        'DCB'", "docstring": "Decrypts a ciphertext encrypted with the Vigenère cipher using the provided key.\n    \n    The Vigenère cipher is a method of encrypting alphabetic text by using a series of\n    Caesar ciphers based on the letters of a keyword. This function reverses the process\n    to recover the original plaintext from the ciphertext.\n\n    Args:\n        key (str): The encryption key used to encrypt the original plaintext.\n                   This key should consist only of alphabetic characters.\n        ciphertext (str): The encrypted text that needs to be decrypted.\n                          The ciphertext should consist only of alphabetic characters.\n\n    Returns:\n        str: The decrypted plaintext corresponding to the input ciphertext.\n\n    ", "canonical_solution": "def vigenere_decrypt(key: str, ciphertext: str) -> str:\n    \n    # Convert the key to uppercase for simplicity\n    key = key.upper()\n    key_length = len(key)\n    \n    # Define the alphabet\n    alphabet = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ'\n    \n    # Initialize the plaintext result\n    plaintext = []\n    \n    # Decryption process\n    for i, char in enumerate(ciphertext):\n        if char.isalpha():  # Check if the character is an alphabet\n            # Find the position of the char and key[i] in the alphabet\n            char_index = alphabet.index(char.upper())\n            key_index = alphabet.index(key[i % key_length])\n            \n            # Decrypt the character and preserve the case\n            decrypted_char = alphabet[(char_index - key_index) % 26]\n            if char.islower():\n                decrypted_char = decrypted_char.lower()\n            \n            plaintext.append(decrypted_char)\n        else:\n            plaintext.append(char)\n    \n    # Join the decrypted characters into a single string\n    return ''.join(plaintext)", "buggy_code": "def vigenere_decrypt(key: str, ciphertext: str) -> str:\n    \n    # Convert the key to uppercase for simplicity\n    key = key.upper()\n    key_length = len(key)\n    \n    # Define the alphabet\n    alphabet = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ\"\n    \n    # Initialize the plaintext result\n    plaintext = []\n    \n    # Decryption process\n    for i, char in enumerate(ciphertext):\n        if char.isalpha():  # Check if the character is an alphabet\n            # Find the position of the char and key[i] in the alphabet\n            char_index = alphabet.index(char.upper())\n            key_index = alphabet.index(key[i % key_length])\n            \n            # Decrypt the character and preserve the case\n            decrypted_char = alphabet[(char_index - key_index) % 26]\n            if char.islower():\n                decrypted_char = decrypted_char.lower()\n            \n            plaintext.append(decrypted_char)\n        else:\n            plaintext.append(char)\n    \n    # Join the decrypted characters into a single string\n    return ''.join(plaintext)", "bug_with_line_numbers": "   1 | def vigenere_decrypt(key: str, ciphertext: str) -> str:\n   2 |     # Convert the key to uppercase for simplicity\n   3 |     key = key.upper()\n   4 |     key_length = len(key)\n   5 |     # Define the alphabet\n   6 |     alphabet = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ\"\n   7 |     # Initialize the plaintext result\n   8 |     plaintext = []\n   9 |     # Decryption process\n  10 |     for i, char in enumerate(ciphertext):\n  11 |         if char.isalpha():  # Check if the character is an alphabet\n  12 |             # Find the position of the char and key[i] in the alphabet\n  13 |             char_index = alphabet.index(char.upper())\n  14 |             key_index = alphabet.index(key[i % key_length])\n  15 |             # Decrypt the character and preserve the case\n  16 |             decrypted_char = alphabet[(char_index - key_index) % 26]\n  17 |             if char.islower():\n  18 |                 decrypted_char = decrypted_char.lower()\n  19 |             plaintext.append(decrypted_char)\n  20 |         else:\n  21 |             plaintext.append(char)\n  22 |     # Join the decrypted characters into a single string\n  23 |     return ''.join(plaintext)", "fragment_lines": [4], "fragment_content": ["    alphabet = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ\""], "test": "def check():\n    # Test case 1: Example provided in the problem statement\n    key1 = \"CompleteVictory\"\n    ciphertext1 = \"Yvqgpxaimmklongnzfwpvxmniytm\"\n    expected_plaintext1 = \"Wherethereisawillthereisaway\"\n    assert vigenere_decrypt(key1, ciphertext1) == expected_plaintext1, \"Test case 1 failed\"\n\n    # Test case 2: All uppercase characters\n    key2 = \"ABC\"\n    ciphertext2 = \"DEF\"\n    expected_plaintext2 = \"DDD\"\n    assert vigenere_decrypt(key2, ciphertext2) == expected_plaintext2, \"Test case 2 failed\"\n\n    # Test case 3: All lowercase characters\n    key3 = \"xyz\"\n    ciphertext3 = \"abc\"\n    expected_plaintext3 = \"ddd\"\n    assert vigenere_decrypt(key3, ciphertext3) == expected_plaintext3, \"Test case 3 failed\"\n\n    # Test case 4: Mixed case characters\n    key4 = \"MiXeD\"\n    ciphertext4 = \"JpOeR\"\n    expected_plaintext4 = \"XhRaO\"\n    assert vigenere_decrypt(key4, ciphertext4) == expected_plaintext4, \"Test case 4 failed\"\n\n    # Test case 5: Key shorter than ciphertext\n    key5 = \"short\"\n    ciphertext5 = \"PqrsPqrsPq\"\n    expected_plaintext5 = \"XjdbWykeYx\"\n    assert vigenere_decrypt(key5, ciphertext5) == expected_plaintext5, \"Test case 5 failed\"\n\n    print(\"All test cases passed!\")\n\n# Run the test function\ncheck()", "instruction": "Observe the following faulty Python code and its example\ncode:\n```python\ndef vigenere_decrypt(key: str, ciphertext: str) -> str:\n    \n    # Convert the key to uppercase for simplicity\n    key = key.upper()\n    key_length = len(key)\n    \n    # Define the alphabet\n    alphabet = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ\"\n    \n    # Initialize the plaintext result\n    plaintext = []\n    \n    # Decryption process\n    for i, char in enumerate(ciphertext):\n        if char.isalpha():  # Check if the character is an alphabet\n            # Find the position of the char and key[i] in the alphabet\n            char_index = alphabet.index(char.upper())\n            key_index = alphabet.index(key[i % key_length])\n            \n            # Decrypt the character and preserve the case\n            decrypted_char = alphabet[(char_index - key_index) % 26]\n            if char.islower():\n                decrypted_char = decrypted_char.lower()\n            \n            plaintext.append(decrypted_char)\n        else:\n            plaintext.append(char)\n    \n    # Join the decrypted characters into a single string\n    return ''.join(plaintext)\n```\ncode example:\nExamples:\n        >>> vigenere_decrypt(\"CompleteVictory\", \"Yvqgpxaimmklongnzfwpvxmniytm\")\n        'Wherethereisawillthereisaway'\n\n        >>> vigenere_decrypt(\"ABC\", \"DEF\")\n        'DCB'\nFix bugs in the given code snippet. The fixed code must be placed between ```python```. Do not generate any test, main,example usage or check code!\n"}
{"question_id": "Python/16", "category": "Reference", "subtype": "faulty_indexing", "level": "medium", "example": "Examples:\n    >>> find_topmost_carpet(3, [(1, 0, 2, 3), (0, 2, 3, 3), (2, 1, 3, 3)], (2, 2))\n    3\n    >>> find_topmost_carpet(3, [(1, 0, 2, 3), (0, 2, 3, 3), (2, 1, 3, 3)], (4, 5))\n    -1", "docstring": "Finds the topmost carpet covering a given point on the coordinate plane.\n\n    Args:\n    n (int): The total number of carpets.\n    carpets (list of tuples): A list containing n tuples, each representing a carpet's information.\n                              Each tuple contains four integers (a, b, g, k) where (a, b) is the\n                              coordinates of the bottom-left corner of the carpet and (g, k) are\n                              the lengths of the carpet along the x and y axis respectively.\n    point (tuple): A tuple containing two integers (x, y), the coordinates of the point to check.\n\n    Returns:\n    int: The number of the topmost carpet covering the point (x, y), or -1 if no carpet covers it.\n\n    ", "canonical_solution": "def find_topmost_carpet(n, carpets, point) -> int:\n    \n    x, y = point\n    # Iterate through the carpets in reverse order, since the last one is on top\n    for i in range(n - 1, -1, -1):\n        a, b, g, k = carpets[i]\n        if a <= x <= a + g and b <= y <= b + k:\n            return i + 1\n    return -1", "buggy_code": "def find_topmost_carpet(n, carpets, point) -> int:\n    \n    x, y = point\n    # Iterate through the carpets in reverse order, since the last one is on top\n    for i in range(n, -1, -1):\n        a, b, g, k = carpets[i]\n        if a <= x <= a + g and b <= y <= b + k:\n            return i + 1\n    return -1", "bug_with_line_numbers": "   1 | def find_topmost_carpet(n, carpets, point) -> int:\n   2 |     x, y = point\n   3 |     # Iterate through the carpets in reverse order, since the last one is on top\n   4 |     for i in range(n, -1, -1):\n   5 |         a, b, g, k = carpets[i]\n   6 |         if a <= x <= a + g and b <= y <= b + k:\n   7 |             return i + 1\n   8 |     return -1", "fragment_lines": [3], "fragment_content": ["    for i in range(n, -1, -1):"], "test": "def check():\n    # Test case 1: Point is on topmost carpet (carpet 3)\n    assert find_topmost_carpet(3, [(1, 0, 2, 3), (0, 2, 3, 3), (2, 1, 3, 3)], (2, 2)) == 3\n\n    # Test case 2: Point is not covered by any carpet\n    assert find_topmost_carpet(3, [(1, 0, 2, 3), (0, 2, 3, 3), (2, 1, 3, 3)], (4, 5)) == -1\n\n    # Test case 3: Point is on the edge of the carpet (carpet 1)\n    assert find_topmost_carpet(2, [(1, 1, 3, 3), (4, 4, 2, 2)], (4, 1)) == 1\n\n    # Test case 4: Point is at the corner of the carpet (carpet 2)\n    assert find_topmost_carpet(2, [(1, 1, 3, 3), (4, 4, 2, 2)], (6, 4)) == 2\n\n    # Test case 5: Multiple carpets cover the point, but the last one is on top (carpet 4)\n    assert find_topmost_carpet(4, [(0, 0, 5, 5), (1, 1, 5, 5), (2, 2, 5, 5), (3, 3, 5, 5)], (4, 4)) == 4\n\n    # Test case 6: No carpets at all, should return -1\n    assert find_topmost_carpet(0, [], (0, 0)) == -1\n\n    # Test case 8: Point is covered by the first carpet and no others (carpet 1)\n    assert find_topmost_carpet(3, [(0, 0, 2, 2), (2, 2, 2, 2), (4, 4, 2, 2)], (1, 1)) == 1\n\n    print(\"All test cases passed!\")\n\ncheck()\n", "instruction": "Observe the following faulty Python code and its example\ncode:\n```python\ndef find_topmost_carpet(n, carpets, point) -> int:\n    \n    x, y = point\n    # Iterate through the carpets in reverse order, since the last one is on top\n    for i in range(n, -1, -1):\n        a, b, g, k = carpets[i]\n        if a <= x <= a + g and b <= y <= b + k:\n            return i + 1\n    return -1\n```\ncode example:\nExamples:\n    >>> find_topmost_carpet(3, [(1, 0, 2, 3), (0, 2, 3, 3), (2, 1, 3, 3)], (2, 2))\n    3\n    >>> find_topmost_carpet(3, [(1, 0, 2, 3), (0, 2, 3, 3), (2, 1, 3, 3)], (4, 5))\n    -1\nFix bugs in the given code snippet. The fixed code must be placed between ```python```. Do not generate any test, main,example usage or check code!\n"}
{"question_id": "Python/17", "category": "Reference", "subtype": "faulty_indexing", "level": "medium", "example": "Examples:\n    - calculate_arrangements(2, 4, [3, 2]) returns 2.\n    - calculate_arrangements(3, 3, [1, 2, 3]) returns 6.", "docstring": "Compute the number of ways to arrange m pots of flowers using up to n types,\n    where the ith type can have at most a[i] pots, and the arrangement must be in\n    increasing order of flower types.\n\n    Args:\n    - n (int): The number of flower types available.\n    - m (int): The total number of flower pots to arrange.\n    - a (list of int): A list where a[i] is the maximum number of pots for the ith type of flower.\n\n    Returns:\n    - int: The number of distinct arrangements modulo (10^6 + 7).\n\n    ", "canonical_solution": "def calculate_arrangements(n, m, a) -> int:\n    \n    MOD = 10 ** 6 + 7\n    dp = [[0] * (m + 1) for _ in range(n + 1)]\n    dp[0][0] = 1\n    for i in range(1, n + 1):\n        for j in range(m + 1):\n            for k in range(min(j, a[i - 1]) + 1):\n                dp[i][j] += dp[i - 1][j - k]\n                dp[i][j] %= MOD\n    return dp[n][m]", "buggy_code": "def calculate_arrangements(n, m, a) -> int:\n    \n    MOD = 10 ** 6 + 7\n    dp = [[0] * (m + 1) for _ in range(n + 1)]\n    dp[0][0] = 1\n    for i in range(1, n + 1):\n        for j in range(m + 1):\n            for k in range(min(j, a[i]) + 1):\n                dp[i][j] += dp[i - 1][j - k]\n                dp[i][j] %= MOD\n    return dp[n][m]", "bug_with_line_numbers": "   1 | def calculate_arrangements(n, m, a) -> int:\n   2 |     MOD = 10 ** 6 + 7\n   3 |     dp = [[0] * (m + 1) for _ in range(n + 1)]\n   4 |     dp[0][0] = 1\n   5 |     for i in range(1, n + 1):\n   6 |         for j in range(m + 1):\n   7 |             for k in range(min(j, a[i]) + 1):\n   8 |                 dp[i][j] += dp[i - 1][j - k]\n   9 |                 dp[i][j] %= MOD\n  10 |     return dp[n][m]", "fragment_lines": [7], "fragment_content": ["            for k in range(min(j, a[i]) + 1):"], "test": "def check():\n    # Helper function to compare expected and actual results\n    def assert_equal(actual, expected, message):\n        assert actual == expected, message\n\n    # Test Case 1\n    n, m, a = 2, 4, [3, 2]\n    expected = 2\n    assert_equal(calculate_arrangements(n, m, a), expected, f\"Test Case 1 failed: expected {expected}, got {calculate_arrangements(n, m, a)}\")\n\n    # Test Case 2\n    n, m, a = 3, 3, [1, 2, 3]\n    expected = 6\n    assert_equal(calculate_arrangements(n, m, a), expected, f\"Test Case 2 failed: expected {expected}, got {calculate_arrangements(n, m, a)}\")\n\n    # Test Case 3\n    n, m, a = 1, 5, [5]\n    expected = 1\n    assert_equal(calculate_arrangements(n, m, a), expected, f\"Test Case 3 failed: expected {expected}, got {calculate_arrangements(n, m, a)}\")\n\n    print(\"All tests passed!\")\n\ncheck()", "instruction": "Observe the following faulty Python code and its example\ncode:\n```python\ndef calculate_arrangements(n, m, a) -> int:\n    \n    MOD = 10 ** 6 + 7\n    dp = [[0] * (m + 1) for _ in range(n + 1)]\n    dp[0][0] = 1\n    for i in range(1, n + 1):\n        for j in range(m + 1):\n            for k in range(min(j, a[i]) + 1):\n                dp[i][j] += dp[i - 1][j - k]\n                dp[i][j] %= MOD\n    return dp[n][m]\n```\ncode example:\nExamples:\n    - calculate_arrangements(2, 4, [3, 2]) returns 2.\n    - calculate_arrangements(3, 3, [1, 2, 3]) returns 6.\nFix bugs in the given code snippet. The fixed code must be placed between ```python```. Do not generate any test, main,example usage or check code!\n"}
{"question_id": "Python/18", "category": "Reference", "subtype": "faulty_indexing", "level": "medium", "example": "Cases:\n    >>> generate_numbers(234, [(2, 5), (3, 6)])\n    4\n    >>> generate_numbers(100, [(1, 9)])\n    2", "docstring": "Generate all unique numbers from the given number by applying transformation rules.\n\n    Each rule allows a single digit to be transformed into another. A breadth-first search\n    (BFS) is used to explore all possible transformations. The function returns the count\n    of unique numbers that can be generated from the original number, including the number itself.\n\n    Args:\n    - n (int): The original integer number to transform.\n    - rules (list of tuples): A list of transformation rules, where each rule is represented\n                              as a tuple (x, y) indicating that digit x can be transformed into y.\n\n    Returns:\n    - int: The total count of unique numbers that can be generated.\n\n    ", "canonical_solution": "from collections import deque\ndef generate_numbers(n, rules) -> int:\n    \n    str_n = str(n)\n    unique_numbers = {str_n}\n    queue = deque([str_n])\n    \n    while queue:\n        current = queue.popleft()\n        for i in range(len(current)):\n            for x, y in rules:\n                if current[i] == str(x):\n                    new_number = current[:i] + str(y) + current[i+1:]\n                    if new_number not in unique_numbers:\n                        unique_numbers.add(new_number)\n                        queue.append(new_number)\n    return len(unique_numbers)", "buggy_code": "from collections import deque\ndef generate_numbers(n, rules) -> int:\n    \n    str_n = str(n)\n    unique_numbers = {str_n}\n    queue = deque([str_n])\n    \n    while queue:\n        current = queue.popleft()\n        for i in range(len(current)):\n            for x, y in rules:\n                if current[i] == str(x):\n                    new_number = current[:i] + str(y) + current[i:]\n                    if new_number not in unique_numbers:\n                        unique_numbers.add(new_number)\n                        queue.append(new_number)\n    return len(unique_numbers)", "bug_with_line_numbers": "   1 | from collections import deque\n   2 | def generate_numbers(n, rules) -> int:\n   3 |     str_n = str(n)\n   4 |     unique_numbers = {str_n}\n   5 |     queue = deque([str_n])\n   6 |     while queue:\n   7 |         current = queue.popleft()\n   8 |         for i in range(len(current)):\n   9 |             for x, y in rules:\n  10 |                 if current[i] == str(x):\n  11 |                     new_number = current[:i] + str(y) + current[i:]\n  12 |                     if new_number not in unique_numbers:\n  13 |                         unique_numbers.add(new_number)\n  14 |                         queue.append(new_number)\n  15 |     return len(unique_numbers)", "fragment_lines": [11], "fragment_content": ["                    new_number = current[:i] + str(y) + current[i:]"], "test": "def check():\n    # Test case 1\n    n1, k1 = 234, 2\n    rules1 = [(2, 5), (3, 6)]\n    assert generate_numbers(n1, rules1) == 4, \"Test case 1 failed\"\n\n    # Test case 2\n    n2, k2 = 123, 3\n    rules2 = [(1, 9), (2, 8), (3, 7)]\n    assert generate_numbers(n2, rules2) == 8, \"Test case 2 failed\"\n\n    # Test case 3\n    n3, k3 = 999, 1\n    rules3 = [(9, 1)]\n    assert generate_numbers(n3, rules3) == 8, \"Test case 3 failed\"\n\n    print(\"All test cases passed!\")\n\n# Call the test function\ncheck()", "instruction": "Observe the following faulty Python code and its example\ncode:\n```python\nfrom collections import deque\ndef generate_numbers(n, rules) -> int:\n    \n    str_n = str(n)\n    unique_numbers = {str_n}\n    queue = deque([str_n])\n    \n    while queue:\n        current = queue.popleft()\n        for i in range(len(current)):\n            for x, y in rules:\n                if current[i] == str(x):\n                    new_number = current[:i] + str(y) + current[i:]\n                    if new_number not in unique_numbers:\n                        unique_numbers.add(new_number)\n                        queue.append(new_number)\n    return len(unique_numbers)\n```\ncode example:\nCases:\n    >>> generate_numbers(234, [(2, 5), (3, 6)])\n    4\n    >>> generate_numbers(100, [(1, 9)])\n    2\nFix bugs in the given code snippet. The fixed code must be placed between ```python```. Do not generate any test, main,example usage or check code!\n"}
{"question_id": "Python/19", "category": "Reference", "subtype": "function_error", "level": "easy", "example": "Examples:\n    >>> minimum_cost_to_merge_fruits([1, 2, 9])\n    15\n    >>> minimum_cost_to_merge_fruits([10, 20, 30, 40, 50])\n    300 .", "docstring": "Calculates the minimum total cost to merge multiple heaps of fruits into a single heap.\n    The cost of merging two heaps is equal to the sum of their weights. The function utilizes\n    a greedy algorithm with a min-heap (priority queue) to ensure the smallest heaps are merged first,\n    minimizing the total cost.\n\n    Parameters:\n    fruit_counts (List[int]): A list of integers representing the counts of each type of fruit.\n\n    Returns:\n    int: The minimum total cost required to merge all heaps of fruits.\n\n    ", "canonical_solution": "import heapq\nfrom typing import List \n\ndef minimum_cost_to_merge_fruits(fruit_counts: List[int]) -> int:\n    \n    heapq.heapify(fruit_counts)\n    \n    total_cost = 0\n    \n    while len(fruit_counts) > 1:\n        first = heapq.heappop(fruit_counts)\n        second = heapq.heappop(fruit_counts)\n        \n        cost = first + second\n        total_cost += cost\n        \n        heapq.heappush(fruit_counts, cost)\n    \n    return total_cost", "buggy_code": "import heapq\nfrom typing import List \n\ndef minimum_cost_to_merge_fruits(fruit_counts: List[int]) -> int:\n    \n    heapq.heapify(fruit_counts)\n    \n    total_cost = 0\n    \n    while len(fruit_counts) > 1:\n        first = heapq.heappop(fruit_counts)\n        second = heapq.heappop(fruit_counts)\n        \n        cost = first + second\n        total_cost += cost\n        \n        heapq.heappush(fruit_counts)\n    \n    return total_cost", "bug_with_line_numbers": "   1 | import heapq\n   2 | from typing import List \n   3 | def minimum_cost_to_merge_fruits(fruit_counts: List[int]) -> int:\n   4 |     heapq.heapify(fruit_counts)\n   5 |     total_cost = 0\n   6 |     while len(fruit_counts) > 1:\n   7 |         first = heapq.heappop(fruit_counts)\n   8 |         second = heapq.heappop(fruit_counts)\n   9 |         cost = first + second\n  10 |         total_cost += cost\n  11 |         heapq.heappush(fruit_counts)\n  12 |     return total_cost", "fragment_lines": [11], "fragment_content": ["        heapq.heappush(fruit_counts)"], "test": "def check():\n    # Test case 1: As provided in the problem statement example\n    fruits1 = [1, 2, 9]\n    assert minimum_cost_to_merge_fruits(fruits1) == 15, \"Test case 1 failed\"\n\n    # Test case 2: Simple case with only two types of fruits\n    fruits2 = [5, 5]\n    assert minimum_cost_to_merge_fruits(fruits2) == 10, \"Test case 2 failed\"\n\n    # Test case 3: More complex case with multiple types of fruits\n    fruits3 = [10, 20, 30, 40, 50]\n    assert minimum_cost_to_merge_fruits(fruits3) == 330, \"Test case 3 failed\"\n\n    # Test case 4: Case with fruits having the same count\n    fruits4 = [3, 3, 3, 3]\n    assert minimum_cost_to_merge_fruits(fruits4) == 24, \"Test case 4 failed\"\n\n    # Test case 5: Case with a single type of fruit\n    fruits5 = [7]\n    assert minimum_cost_to_merge_fruits(fruits5) == 0, \"Test case 5 failed\"\n\n    print(\"All test cases passed.\")\n\n# Run the test function\ncheck()", "instruction": "Observe the following faulty Python code and its example\ncode:\n```python\nimport heapq\nfrom typing import List \n\ndef minimum_cost_to_merge_fruits(fruit_counts: List[int]) -> int:\n    \n    heapq.heapify(fruit_counts)\n    \n    total_cost = 0\n    \n    while len(fruit_counts) > 1:\n        first = heapq.heappop(fruit_counts)\n        second = heapq.heappop(fruit_counts)\n        \n        cost = first + second\n        total_cost += cost\n        \n        heapq.heappush(fruit_counts)\n    \n    return total_cost\n```\ncode example:\nExamples:\n    >>> minimum_cost_to_merge_fruits([1, 2, 9])\n    15\n    >>> minimum_cost_to_merge_fruits([10, 20, 30, 40, 50])\n    300 .\nFix bugs in the given code snippet. The fixed code must be placed between ```python```. Do not generate any test, main,example usage or check code!\n"}
{"question_id": "Python/20", "category": "Reference", "subtype": "function_error", "level": "medium", "example": "Examples:\n      >>> mod_inverse(3, 10)\n      7\n\n      >>> mod_inverse(42, 2017)\n      None", "docstring": "Calculate the modular multiplicative inverse of `a` modulo `b`.\n    \n    This function finds an integer `x` such that (a * x) % b == 1, provided that\n    `a` and `b` are coprime (i.e., gcd(a, b) == 1). It uses the Extended Euclidean\n    Algorithm to compute the inverse. If `a` and `b` are not coprime, the modular\n    inverse does not exist, and the function returns `None`.\n    \n    Args:\n      a (int): The integer whose modular inverse is to be found.\n      b (int): The modulus with respect to which the inverse is sought.\n    \n    Returns:\n      int: The modular inverse of `a` modulo `b` if it exists, otherwise `None`.\n    \n    ", "canonical_solution": "def mod_inverse(a, b):\n    \n    def extended_gcd(a, b):\n        if a == 0:\n            return b, 0, 1\n        gcd, x1, y1 = extended_gcd(b % a, a)\n        x = y1 - (b // a) * x1\n        y = x1\n        return gcd, x, y\n    gcd, x, _ = extended_gcd(a, b)\n    if gcd != 1:\n        # Modular inverse does not exist since a and b are not coprime\n        return None\n    else:\n        # Make sure the result is positive\n        return x % b", "buggy_code": "def mod_inverse(a, b):\n    \n    def extended_gcd(a, b):\n        if a == 0:\n            return b, 0, 1\n        gcd, x1, y1 = extended_gcd(a % b, a)\n        x = y1 - (b // a) * x1\n        y = x1\n        return gcd, x, y\n    gcd, x, _ = extended_gcd(a, b)\n    if gcd != 1:\n        # Modular inverse does not exist since a and b are not coprime\n        return None\n    else:\n        # Make sure the result is positive\n        return x % b", "bug_with_line_numbers": "   1 | def mod_inverse(a, b):\n   2 |     def extended_gcd(a, b):\n   3 |         if a == 0:\n   4 |             return b, 0, 1\n   5 |         gcd, x1, y1 = extended_gcd(a % b, a)\n   6 |         x = y1 - (b // a) * x1\n   7 |         y = x1\n   8 |         return gcd, x, y\n   9 |     gcd, x, _ = extended_gcd(a, b)\n  10 |     if gcd != 1:\n  11 |         # Modular inverse does not exist since a and b are not coprime\n  12 |         return None\n  13 |     else:\n  14 |         # Make sure the result is positive\n  15 |         return x % b", "fragment_lines": [5], "fragment_content": ["        gcd, x1, y1 = extended_gcd(a % b, a)"], "test": "def check():\n    test_cases = [\n        (3, 10),  # Test case 1: gcd(3, 10) = 1, inverse should be 7\n        (17, 3120),  # Test case 2: gcd(17, 3120) = 1, inverse should be 2753\n        (42, 2017),  # Test case 3: gcd(42, 2017) = 1, inverse should be 1969\n    ]\n    expected_results = [\n        7,  # Expected result for test case 1\n        2753,  # Expected result for test case 2\n        1969,  # Expected result for test case 3\n    ]\n\n    for i, (a, b) in enumerate(test_cases):\n        actual_result = mod_inverse(a, b)\n        expected_result = expected_results[i]\n        assert actual_result == expected_result, f\"Test case {i+1} failed: expected {expected_result}, got {actual_result}\"\n        print(f\"Test case {i+1} passed: a={a}, b={b}, x0={actual_result}\")\n\n# Run the test function\ncheck()", "instruction": "Observe the following faulty Python code and its example\ncode:\n```python\ndef mod_inverse(a, b):\n    \n    def extended_gcd(a, b):\n        if a == 0:\n            return b, 0, 1\n        gcd, x1, y1 = extended_gcd(a % b, a)\n        x = y1 - (b // a) * x1\n        y = x1\n        return gcd, x, y\n    gcd, x, _ = extended_gcd(a, b)\n    if gcd != 1:\n        # Modular inverse does not exist since a and b are not coprime\n        return None\n    else:\n        # Make sure the result is positive\n        return x % b\n```\ncode example:\nExamples:\n      >>> mod_inverse(3, 10)\n      7\n\n      >>> mod_inverse(42, 2017)\n      None\nFix bugs in the given code snippet. The fixed code must be placed between ```python```. Do not generate any test, main,example usage or check code!\n"}
{"question_id": "Python/21", "category": "Reference", "subtype": "illegal_keyword", "level": "easy", "example": ">>> has_close_elements([1.0, 2.0, 3.0], 0.5)\n    False\n    >>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\n    True", "docstring": "Check if in given list of numbers, are any two numbers closer to each other than\n    given threshold.\n    ", "canonical_solution": "from typing import List\n \ndef has_close_elements(numbers: List[float], threshold: float) -> bool:\n    \n    for idx, elem in enumerate(numbers):\n        for idx2, elem2 in enumerate(numbers):\n            if idx != idx2:\n                distance = abs(elem - elem2)\n                if distance < threshold:\n                    return True\n\n    return False", "buggy_code": "from typing import List\n \ndef has_close_elements(numbers: List[float], threshold: float) -> bool:\n    \n    for idx, elem in enumerate(numbers):\n        for idx2, elem2 in enumerate(numbers):\n            if idx != idx2:\n                distance = abs(elem - elem2)\n                if distance < threshold:\n                    return true\n\n    return False", "bug_with_line_numbers": "   1 | from typing import List\n   2 | def has_close_elements(numbers: List[float], threshold: float) -> bool:\n   3 |     for idx, elem in enumerate(numbers):\n   4 |         for idx2, elem2 in enumerate(numbers):\n   5 |             if idx != idx2:\n   6 |                 distance = abs(elem - elem2)\n   7 |                 if distance < threshold:\n   8 |                     return true\n   9 |     return False", "fragment_lines": [8], "fragment_content": ["                    return true"], "test": "def check():\n    assert has_close_elements([1.0, 2.0, 3.9, 4.0, 5.0, 2.2], 0.3) == True\n    assert has_close_elements([1.0, 2.0, 3.9, 4.0, 5.0, 2.2], 0.05) == False\n    assert has_close_elements([1.0, 2.0, 5.9, 4.0, 5.0], 0.95) == True\n    assert has_close_elements([1.0, 2.0, 5.9, 4.0, 5.0], 0.8) == False\n    assert has_close_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.0], 0.1) == True\n    assert has_close_elements([1.1, 2.2, 3.1, 4.1, 5.1], 1.0) == True\n    assert has_close_elements([1.1, 2.2, 3.1, 4.1, 5.1], 0.5) == False\n \ncheck()", "instruction": "Observe the following faulty Python code and its example\ncode:\n```python\nfrom typing import List\n \ndef has_close_elements(numbers: List[float], threshold: float) -> bool:\n    \n    for idx, elem in enumerate(numbers):\n        for idx2, elem2 in enumerate(numbers):\n            if idx != idx2:\n                distance = abs(elem - elem2)\n                if distance < threshold:\n                    return true\n\n    return False\n```\ncode example:\n>>> has_close_elements([1.0, 2.0, 3.0], 0.5)\n    False\n    >>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\n    True\nFix bugs in the given code snippet. The fixed code must be placed between ```python```. Do not generate any test, main,example usage or check code!\n"}
{"question_id": "Python/22", "category": "Reference", "subtype": "illegal_keyword", "level": "medium", "example": "max_product(\"123\", 3, 1) returns 36", "docstring": "Function name: max_product\n    Arguments:\n    num_str (str): A string representing the number string.\n    N (int): An integer representing the length of the number string.\n    K (int): An integer representing the number of multiplication signs to insert.\n    Return type: int (The function returns the maximum product that can be obtained by inserting Kmultiplication signs into the number string.)", "canonical_solution": "def max_product(num_str: str, N: int, K: int) -> int:\n    \n    digits = [int(num_str[i]) for i in range(N)]\n    dp = [[0] * (K+1) for _ in range(N+1)]\n\n    for i in range(1, N+1):\n        dp[i][0] = dp[i-1][0] * 10 + digits[i-1]\n\n    for i in range(1, N+1):\n        for k in range(1, min(i, K)+1):\n            for j in range(k, i+1): \n                dp[i][k] = max(dp[i][k], dp[j-1][k-1] * int(num_str[j-1:i]))\n\n    return dp[N][K]", "buggy_code": "def max_product(num_str: str, N: int, K: int) -> int:\n    \n    digits = [int(num_str[i]) for i in range(N)]\n    dp = [[0] * (K+1) for _ in range(N+1)]\n\n    for i in range(1, N+1):\n        dp[i][0] = dp[i-1][0] * 10 + digits[i-1]\n\n    for i in range(1, N+1):\n        for k in range(1, min(i, K)+1):\n            for j in range(k, i+1): \n                dp[i][k] = max(dp[i][k], dp[j-1][k-1] * int(num_str[j:i]))\n\n    return dp[N][K]", "bug_with_line_numbers": "   1 | def max_product(num_str: str, N: int, K: int) -> int:\n   2 |     digits = [int(num_str[i]) for i in range(N)]\n   3 |     dp = [[0] * (K+1) for _ in range(N+1)]\n   4 |     for i in range(1, N+1):\n   5 |         dp[i][0] = dp[i-1][0] * 10 + digits[i-1]\n   6 |     for i in range(1, N+1):\n   7 |         for k in range(1, min(i, K)+1):\n   8 |             for j in range(k, i+1): \n   9 |                 dp[i][k] = max(dp[i][k], dp[j-1][k-1] * int(num_str[j:i]))\n  10 |     return dp[N][K]", "fragment_lines": [9], "fragment_content": ["                dp[i][k] = max(dp[i][k], dp[j-1][k-1] * int(num_str[j:i]))"], "test": "def check():\n    # Test case 1\n    num_str1 = \"123\"\n    N1 = 3\n    K1 = 1\n    expected_result1 = 36  # Corrected expected result: 1*23 = 23 or 12*3 = 36, max is 36\n    assert max_product(num_str1, N1,\n                       K1) == expected_result1, f\"Test case 1 failed. Expected {expected_result1}, got {max_product(num_str1, N1, K1)}\"\n\n    # Test case 2\n    num_str2 = \"1234\"\n    N2 = 4\n    K2 = 2\n    expected_result2 = 144  # Corrected expected result: 1*2*34 = 68 or 12*3*4 = 144, max is 144\n    assert max_product(num_str2, N2,\n                       K2) == expected_result2, f\"Test case 2 failed. Expected {expected_result2}, got {max_product(num_str2, N2, K2)}\"\n\n    # Test case 3\n    num_str3 = \"051\"\n    N3 = 3\n    K3 = 1\n    expected_result3 = 5  # 0*51 = 0 or 05*1 = 5, max is 5\n    assert max_product(num_str3, N3,\n                       K3) == expected_result3, f\"Test case 3 failed. Expected {expected_result3}, got {max_product(num_str3, N3, K3)}\"\n\n    # If no assertion is raised, all test cases passed\n    print(\"All test cases passed!\")\ncheck()", "instruction": "Observe the following faulty Python code and its example\ncode:\n```python\ndef max_product(num_str: str, N: int, K: int) -> int:\n    \n    digits = [int(num_str[i]) for i in range(N)]\n    dp = [[0] * (K+1) for _ in range(N+1)]\n\n    for i in range(1, N+1):\n        dp[i][0] = dp[i-1][0] * 10 + digits[i-1]\n\n    for i in range(1, N+1):\n        for k in range(1, min(i, K)+1):\n            for j in range(k, i+1): \n                dp[i][k] = max(dp[i][k], dp[j-1][k-1] * int(num_str[j:i]))\n\n    return dp[N][K]\n```\ncode example:\nmax_product(\"123\", 3, 1) returns 36\nFix bugs in the given code snippet. The fixed code must be placed between ```python```. Do not generate any test, main,example usage or check code!\n"}
{"question_id": "Python/23", "category": "Reference", "subtype": "illegal_keyword", "level": "easy", "example": "Cases:\n    >>> generate_numbers(234, [(2, 5), (3, 6)])\n    4\n    >>> generate_numbers(100, [(1, 9)])\n    2", "docstring": "Generate all unique numbers from the given number by applying transformation rules.\n\n    Each rule allows a single digit to be transformed into another. A breadth-first search\n    (BFS) is used to explore all possible transformations. The function returns the count\n    of unique numbers that can be generated from the original number, including the number itself.\n\n    Args:\n    - n (int): The original integer number to transform.\n    - rules (list of tuples): A list of transformation rules, where each rule is represented\n                              as a tuple (x, y) indicating that digit x can be transformed into y.\n\n    Returns:\n    - int: The total count of unique numbers that can be generated.\n\n    ", "canonical_solution": "from collections import deque\ndef generate_numbers(n, rules) -> int:\n    \n    str_n = str(n)\n    unique_numbers = {str_n}\n    queue = deque([str_n])\n    \n    while queue:\n        current = queue.popleft()\n        for i in range(len(current)):\n            for x, y in rules:\n                if current[i] == str(x):\n                    new_number = current[:i] + str(y) + current[i+1:]\n                    if new_number not in unique_numbers:\n                        unique_numbers.add(new_number)\n                        queue.append(new_number)\n    return len(unique_numbers)", "buggy_code": "from collections import deque\ndef generate_numbers(n, rules) -> int:\n    \n    str_n = str(n)\n    unique_numbers = {str_n}\n    queue = deque([str_n])\n    \n    while queue:\n        current = queue.popleft()\n        for i in range(len(current)):\n            for x, y in rules:\n                if current[i] == str(x):\n                    new_number = current[:i] + string(y) + current[i+1:]\n                    if new_number not in unique_numbers:\n                        unique_numbers.add(new_number)\n                        queue.append(new_number)\n    return len(unique_numbers)", "bug_with_line_numbers": "   1 | from collections import deque\n   2 | def generate_numbers(n, rules) -> int:\n   3 |     str_n = str(n)\n   4 |     unique_numbers = {str_n}\n   5 |     queue = deque([str_n])\n   6 |     while queue:\n   7 |         current = queue.popleft()\n   8 |         for i in range(len(current)):\n   9 |             for x, y in rules:\n  10 |                 if current[i] == str(x):\n  11 |                     new_number = current[:i] + string(y) + current[i+1:]\n  12 |                     if new_number not in unique_numbers:\n  13 |                         unique_numbers.add(new_number)\n  14 |                         queue.append(new_number)\n  15 |     return len(unique_numbers)", "fragment_lines": [11], "fragment_content": ["                    new_number = current[:i] + string(y) + current[i+1:]"], "test": "def check():\n    # Test case 1\n    n1, k1 = 234, 2\n    rules1 = [(2, 5), (3, 6)]\n    assert generate_numbers(n1, rules1) == 4, \"Test case 1 failed\"\n\n    # Test case 2\n    n2, k2 = 123, 3\n    rules2 = [(1, 9), (2, 8), (3, 7)]\n    assert generate_numbers(n2, rules2) == 8, \"Test case 2 failed\"\n\n    # Test case 3\n    n3, k3 = 999, 1\n    rules3 = [(9, 1)]\n    assert generate_numbers(n3, rules3) == 8, \"Test case 3 failed\"\n\n    print(\"All test cases passed!\")\n\n# Call the test function\ncheck()", "instruction": "Observe the following faulty Python code and its example\ncode:\n```python\nfrom collections import deque\ndef generate_numbers(n, rules) -> int:\n    \n    str_n = str(n)\n    unique_numbers = {str_n}\n    queue = deque([str_n])\n    \n    while queue:\n        current = queue.popleft()\n        for i in range(len(current)):\n            for x, y in rules:\n                if current[i] == str(x):\n                    new_number = current[:i] + string(y) + current[i+1:]\n                    if new_number not in unique_numbers:\n                        unique_numbers.add(new_number)\n                        queue.append(new_number)\n    return len(unique_numbers)\n```\ncode example:\nCases:\n    >>> generate_numbers(234, [(2, 5), (3, 6)])\n    4\n    >>> generate_numbers(100, [(1, 9)])\n    2\nFix bugs in the given code snippet. The fixed code must be placed between ```python```. Do not generate any test, main,example usage or check code!\n"}
{"question_id": "Python/24", "category": "Reference", "subtype": "undefined_methods", "level": "easy", "example": "minimum_students_to_leave([186, 186, 150, 200, 160, 130, 197, 220])\n4", "docstring": "Calculate the minimum number of students that need to leave to form a choir formation.\n    A choir formation is defined such that for some position 'i', the heights of students\n    increase from the start to 'i' and decrease from 'i' to the end of the formation.\n\n    Args:\n    heights (List[int]): A list of student heights.\n\n    Returns:\n    int: The minimum number of students that need to leave.", "canonical_solution": "def minimum_students_to_leave(heights):\n    \n    n = len(heights)\n    \n    lis = [1] * n\n    for i in range(n):\n        for j in range(i):\n            if heights[i] > heights[j]:\n                lis[i] = max(lis[i], lis[j] + 1)\n\n    lds = [1] * n\n    for i in range(n - 1, -1, -1):\n        for j in range(n - 1, i, -1):\n            if heights[i] > heights[j]:\n                lds[i] = max(lds[i], lds[j] + 1)\n\n    max_choir_length = max(lis[i] + lds[i] - 1 for i in range(n))\n    \n    return n - max_choir_length", "buggy_code": "def minimum_students_to_leave(heights):\n    \n    n = get_len(heights)\n    \n    lis = [1] * n\n    for i in range(n):\n        for j in range(i):\n            if heights[i] > heights[j]:\n                lis[i] = max(lis[i], lis[j] + 1)\n\n    lds = [1] * n\n    for i in range(n - 1, -1, -1):\n        for j in range(n - 1, i, -1):\n            if heights[i] > heights[j]:\n                lds[i] = max(lds[i], lds[j] + 1)\n\n    max_choir_length = max(lis[i] + lds[i] - 1 for i in range(n))\n    \n    return n - max_choir_length", "bug_with_line_numbers": "   1 | def minimum_students_to_leave(heights):\n   2 |     n = get_len(heights)\n   3 |     lis = [1] * n\n   4 |     for i in range(n):\n   5 |         for j in range(i):\n   6 |             if heights[i] > heights[j]:\n   7 |                 lis[i] = max(lis[i], lis[j] + 1)\n   8 |     lds = [1] * n\n   9 |     for i in range(n - 1, -1, -1):\n  10 |         for j in range(n - 1, i, -1):\n  11 |             if heights[i] > heights[j]:\n  12 |                 lds[i] = max(lds[i], lds[j] + 1)\n  13 |     max_choir_length = max(lis[i] + lds[i] - 1 for i in range(n))\n  14 |     return n - max_choir_length", "fragment_lines": [2], "fragment_content": ["    n = get_len(heights)"], "test": "def check():\n    # Test case 1: Provided example\n    assert minimum_students_to_leave([186, 186, 150, 200, 160, 130, 197, 220]) == 4, \"Test case 1 failed\"\n\n    # Test case 2: All students have the same height\n    assert minimum_students_to_leave([150, 150, 150, 150, 150]) == 4, \"Test case 2 failed\"\n\n    # Test case 3: Students are already in a choir formation\n    assert minimum_students_to_leave([130, 150, 170, 190, 170, 150, 130]) == 0, \"Test case 3 failed\"\n\n    # Test case 4: Students are in strictly increasing order\n    assert minimum_students_to_leave([130, 135, 140, 145, 150, 155]) == 0, \"Test case 4 failed\"\n\n    # Test case 5: Students are in strictly decreasing order\n    assert minimum_students_to_leave([155, 150, 145, 140, 135, 130]) == 0, \"Test case 5 failed\"\n\n    # Test case 6: Optimal choir formation is not including the first or last student\n    assert minimum_students_to_leave([200, 180, 190, 170, 210, 160, 220]) == 3, \"Test case 6 failed\"\n\n    print(\"All test cases passed!\")\n\n# Run the test function\ncheck()", "instruction": "Observe the following faulty Python code and its example\ncode:\n```python\ndef minimum_students_to_leave(heights):\n    \n    n = get_len(heights)\n    \n    lis = [1] * n\n    for i in range(n):\n        for j in range(i):\n            if heights[i] > heights[j]:\n                lis[i] = max(lis[i], lis[j] + 1)\n\n    lds = [1] * n\n    for i in range(n - 1, -1, -1):\n        for j in range(n - 1, i, -1):\n            if heights[i] > heights[j]:\n                lds[i] = max(lds[i], lds[j] + 1)\n\n    max_choir_length = max(lis[i] + lds[i] - 1 for i in range(n))\n    \n    return n - max_choir_length\n```\ncode example:\nminimum_students_to_leave([186, 186, 150, 200, 160, 130, 197, 220])\n4\nFix bugs in the given code snippet. The fixed code must be placed between ```python```. Do not generate any test, main,example usage or check code!\n"}
{"question_id": "Python/25", "category": "Reference", "subtype": "undefined_methods", "level": "easy", "example": "Examples:\n    >>> minimum_cost_to_merge_fruits([1, 2, 9])\n    15\n    >>> minimum_cost_to_merge_fruits([10, 20, 30, 40, 50])\n    300 .", "docstring": "Calculates the minimum total cost to merge multiple heaps of fruits into a single heap.\n    The cost of merging two heaps is equal to the sum of their weights. The function utilizes\n    a greedy algorithm with a min-heap (priority queue) to ensure the smallest heaps are merged first,\n    minimizing the total cost.\n\n    Parameters:\n    fruit_counts (List[int]): A list of integers representing the counts of each type of fruit.\n\n    Returns:\n    int: The minimum total cost required to merge all heaps of fruits.\n\n    ", "canonical_solution": "import heapq\nfrom typing import List \n\ndef minimum_cost_to_merge_fruits(fruit_counts: List[int]) -> int:\n    \n    heapq.heapify(fruit_counts)\n    \n    total_cost = 0\n    \n    while len(fruit_counts) > 1:\n        first = heapq.heappop(fruit_counts)\n        second = heapq.heappop(fruit_counts)\n        \n        cost = first + second\n        total_cost += cost\n        \n        heapq.heappush(fruit_counts, cost)\n    \n    return total_cost", "buggy_code": "import heapq\nfrom typing import List \n\ndef minimum_cost_to_merge_fruits(fruit_counts: List[int]) -> int:\n    \n    heapify(fruit_counts)\n    \n    total_cost = 0\n    \n    while len(fruit_counts) > 1:\n        first = heapq.heappop(fruit_counts)\n        second = heapq.heappop(fruit_counts)\n        \n        cost = first + second\n        total_cost += cost\n        \n        heapq.heappush(fruit_counts, cost)\n    \n    return total_cost", "bug_with_line_numbers": "   1 | import heapq\n   2 | from typing import List \n   3 | def minimum_cost_to_merge_fruits(fruit_counts: List[int]) -> int:\n   4 |     heapify(fruit_counts)\n   5 |     total_cost = 0\n   6 |     while len(fruit_counts) > 1:\n   7 |         first = heapq.heappop(fruit_counts)\n   8 |         second = heapq.heappop(fruit_counts)\n   9 |         cost = first + second\n  10 |         total_cost += cost\n  11 |         heapq.heappush(fruit_counts, cost)\n  12 |     return total_cost", "fragment_lines": [4], "fragment_content": ["    heapify(fruit_counts)"], "test": "def check():\n    # Test case 1: As provided in the problem statement example\n    fruits1 = [1, 2, 9]\n    assert minimum_cost_to_merge_fruits(fruits1) == 15, \"Test case 1 failed\"\n\n    # Test case 2: Simple case with only two types of fruits\n    fruits2 = [5, 5]\n    assert minimum_cost_to_merge_fruits(fruits2) == 10, \"Test case 2 failed\"\n\n    # Test case 3: More complex case with multiple types of fruits\n    fruits3 = [10, 20, 30, 40, 50]\n    assert minimum_cost_to_merge_fruits(fruits3) == 330, \"Test case 3 failed\"\n\n    # Test case 4: Case with fruits having the same count\n    fruits4 = [3, 3, 3, 3]\n    assert minimum_cost_to_merge_fruits(fruits4) == 24, \"Test case 4 failed\"\n\n    # Test case 5: Case with a single type of fruit\n    fruits5 = [7]\n    assert minimum_cost_to_merge_fruits(fruits5) == 0, \"Test case 5 failed\"\n\n    print(\"All test cases passed.\")\n\n# Run the test function\ncheck()", "instruction": "Observe the following faulty Python code and its example\ncode:\n```python\nimport heapq\nfrom typing import List \n\ndef minimum_cost_to_merge_fruits(fruit_counts: List[int]) -> int:\n    \n    heapify(fruit_counts)\n    \n    total_cost = 0\n    \n    while len(fruit_counts) > 1:\n        first = heapq.heappop(fruit_counts)\n        second = heapq.heappop(fruit_counts)\n        \n        cost = first + second\n        total_cost += cost\n        \n        heapq.heappush(fruit_counts, cost)\n    \n    return total_cost\n```\ncode example:\nExamples:\n    >>> minimum_cost_to_merge_fruits([1, 2, 9])\n    15\n    >>> minimum_cost_to_merge_fruits([10, 20, 30, 40, 50])\n    300 .\nFix bugs in the given code snippet. The fixed code must be placed between ```python```. Do not generate any test, main,example usage or check code!\n"}
{"question_id": "Python/26", "category": "Reference", "subtype": "undefined_methods", "level": "medium", "example": "Examples:\n      >>> mod_inverse(3, 10)\n      7\n\n      >>> mod_inverse(42, 2017)\n      None", "docstring": "Calculate the modular multiplicative inverse of `a` modulo `b`.\n    \n    This function finds an integer `x` such that (a * x) % b == 1, provided that\n    `a` and `b` are coprime (i.e., gcd(a, b) == 1). It uses the Extended Euclidean\n    Algorithm to compute the inverse. If `a` and `b` are not coprime, the modular\n    inverse does not exist, and the function returns `None`.\n    \n    Args:\n      a (int): The integer whose modular inverse is to be found.\n      b (int): The modulus with respect to which the inverse is sought.\n    \n    Returns:\n      int: The modular inverse of `a` modulo `b` if it exists, otherwise `None`.\n    \n    ", "canonical_solution": "def mod_inverse(a, b):\n    \n    def extended_gcd(a, b):\n        if a == 0:\n            return b, 0, 1\n        gcd, x1, y1 = extended_gcd(b % a, a)\n        x = y1 - (b // a) * x1\n        y = x1\n        return gcd, x, y\n    gcd, x, _ = extended_gcd(a, b)\n    if gcd != 1:\n        # Modular inverse does not exist since a and b are not coprime\n        return None\n    else:\n        # Make sure the result is positive\n        return x % b", "buggy_code": "def mod_inverse(a, b):\n    \n    gcd, x, _ = extended_gcd(a, b)\n    if gcd != 1:\n        # Modular inverse does not exist since a and b are not coprime\n        return None\n    else:\n        # Make sure the result is positive\n        return x % b", "bug_with_line_numbers": "   1 | def mod_inverse(a, b):\n   2 |     gcd, x, _ = extended_gcd(a, b)\n   3 |     if gcd != 1:\n   4 |         # Modular inverse does not exist since a and b are not coprime\n   5 |         return None\n   6 |     else:\n   7 |         # Make sure the result is positive\n   8 |         return x % b", "fragment_lines": [2], "fragment_content": ["    gcd, x, _ = extended_gcd(a, b)"], "test": "def check():\n    test_cases = [\n        (3, 10),  # Test case 1: gcd(3, 10) = 1, inverse should be 7\n        (17, 3120),  # Test case 2: gcd(17, 3120) = 1, inverse should be 2753\n        (42, 2017),  # Test case 3: gcd(42, 2017) = 1, inverse should be 1969\n    ]\n    expected_results = [\n        7,  # Expected result for test case 1\n        2753,  # Expected result for test case 2\n        1969,  # Expected result for test case 3\n    ]\n\n    for i, (a, b) in enumerate(test_cases):\n        actual_result = mod_inverse(a, b)\n        expected_result = expected_results[i]\n        assert actual_result == expected_result, f\"Test case {i+1} failed: expected {expected_result}, got {actual_result}\"\n        print(f\"Test case {i+1} passed: a={a}, b={b}, x0={actual_result}\")\n\n# Run the test function\ncheck()", "instruction": "Observe the following faulty Python code and its example\ncode:\n```python\ndef mod_inverse(a, b):\n    \n    gcd, x, _ = extended_gcd(a, b)\n    if gcd != 1:\n        # Modular inverse does not exist since a and b are not coprime\n        return None\n    else:\n        # Make sure the result is positive\n        return x % b\n```\ncode example:\nExamples:\n      >>> mod_inverse(3, 10)\n      7\n\n      >>> mod_inverse(42, 2017)\n      None\nFix bugs in the given code snippet. The fixed code must be placed between ```python```. Do not generate any test, main,example usage or check code!\n"}
{"question_id": "Python/27", "category": "Reference", "subtype": "undefined_objects", "level": "hard", "example": "Examples:\n    >>> max_value_on_paths(2, [(1, 2, 1), (2, 1, 2), (0, 0, 0)])\n    3\n    >>> max_value_on_paths(8, [\n    ...     (2, 3, 13), (2, 6, 6), (3, 5, 7), (4, 4, 14),\n    ...     (5, 2, 21), (5, 6, 4), (6, 3, 15), (7, 2, 14),\n    ...     (0, 0, 0)])\n    67", "docstring": "Calculate the maximum sum of values collected on two paths in an N x N grid.\n\n    This function utilizes dynamic programming to find two paths from the top-left corner to\n    the bottom-right corner of the grid which maximize the sum of the values collected. Each\n    value can be collected at most once, even if both paths pass through it.\n\n    Args:\n    - N (int): The size of the grid (N x N).\n    - grid_values (List[Tuple[int, int, int]]): A list of tuples where each tuple contains\n      the x-coordinate, y-coordinate, and value to be placed on the grid at that position.\n      The list is terminated by a tuple with all zeros.\n\n    Returns:\n    - int: The maximum sum of values collected on the two paths.\n\n    ", "canonical_solution": "from typing import List, Tuple\n\ndef max_value_on_paths(N: int, grid_values: List[Tuple[int, int, int]]) -> int:\n    \n    dp = [[[[0 for _ in range(N+1)] for _ in range(N+1)] for _ in range(N+1)] for _ in range(N+1)]\n    \n    grid = [[0 for _ in range(N+1)] for _ in range(N+1)]\n    for x, y, val in grid_values:\n        grid[x][y] = val\n    \n    for x1 in range(1, N+1):\n        for y1 in range(1, N+1):\n            for x2 in range(1, N+1):\n                for y2 in range(1, N+1):\n                    dp[x1][y1][x2][y2] = max(\n                        dp[x1-1][y1][x2-1][y2],\n                        dp[x1-1][y1][x2][y2-1],\n                        dp[x1][y1-1][x2-1][y2],\n                        dp[x1][y1-1][x2][y2-1]\n                    ) + grid[x1][y1] + (grid[x2][y2] if (x1, y1) != (x2, y2) else 0)\n    \n    return dp[N][N][N][N]", "buggy_code": "def max_value_on_paths(N: int, grid_values: List[Tuple[int, int, int]]) -> int:\n    \n    dp = [[[[0 for _ in range(N+1)] for _ in range(N+1)] for _ in range(N+1)] for _ in range(N+1)]\n    \n    grid = [[0 for _ in range(N+1)] for _ in range(N+1)]\n    for x, y, val in grid_values:\n        grid[x][y] = val\n    \n    for x1 in range(1, N+1):\n        for y1 in range(1, N+1):\n            for x2 in range(1, N+1):\n                for y2 in range(1, N+1):\n                    dp[x1][y1][x2][y2] = max(\n                        dp[x1-1][y1][x2-1][y2],\n                        dp[x1-1][y1][x2][y2-1],\n                        dp[x1][y1-1][x2-1][y2],\n                        dp[x1][y1-1][x2][y2-1]\n                    ) + grid[x1][y1] + (grid[x2][y2] if (x1, y1) != (x2, y2) else 0)\n    \n    return dp[N][N][N][N]", "bug_with_line_numbers": "   1 | def max_value_on_paths(N: int, grid_values: List[Tuple[int, int, int]]) -> int:\n   2 |     dp = [[[[0 for _ in range(N+1)] for _ in range(N+1)] for _ in range(N+1)] for _ in range(N+1)]\n   3 |     grid = [[0 for _ in range(N+1)] for _ in range(N+1)]\n   4 |     for x, y, val in grid_values:\n   5 |         grid[x][y] = val\n   6 |     for x1 in range(1, N+1):\n   7 |         for y1 in range(1, N+1):\n   8 |             for x2 in range(1, N+1):\n   9 |                 for y2 in range(1, N+1):\n  10 |                     dp[x1][y1][x2][y2] = max(\n  11 |                         dp[x1-1][y1][x2-1][y2],\n  12 |                         dp[x1-1][y1][x2][y2-1],\n  13 |                         dp[x1][y1-1][x2-1][y2],\n  14 |                         dp[x1][y1-1][x2][y2-1]\n  15 |                     ) + grid[x1][y1] + (grid[x2][y2] if (x1, y1) != (x2, y2) else 0)\n  16 |     return dp[N][N][N][N]", "fragment_lines": [-1], "fragment_content": ["missing critical code snippet"], "test": "def check():\n    # Test case 1: Small grid with clear path\n    assert max_value_on_paths(2, [(1, 2, 1), (2, 1, 2), (0, 0, 0)]) == 3\n    \n    # Test case 2: Example provided in the problem statement\n    assert max_value_on_paths(8, [\n        (2, 3, 13), (2, 6, 6), (3, 5, 7), (4, 4, 14),\n        (5, 2, 21), (5, 6, 4), (6, 3, 15), (7, 2, 14),\n        (0, 0, 0)]) == 67\n\n    print(\"All test cases passed!\")\n\ncheck()", "instruction": "Observe the following faulty Python code and its example\ncode:\n```python\ndef max_value_on_paths(N: int, grid_values: List[Tuple[int, int, int]]) -> int:\n    \n    dp = [[[[0 for _ in range(N+1)] for _ in range(N+1)] for _ in range(N+1)] for _ in range(N+1)]\n    \n    grid = [[0 for _ in range(N+1)] for _ in range(N+1)]\n    for x, y, val in grid_values:\n        grid[x][y] = val\n    \n    for x1 in range(1, N+1):\n        for y1 in range(1, N+1):\n            for x2 in range(1, N+1):\n                for y2 in range(1, N+1):\n                    dp[x1][y1][x2][y2] = max(\n                        dp[x1-1][y1][x2-1][y2],\n                        dp[x1-1][y1][x2][y2-1],\n                        dp[x1][y1-1][x2-1][y2],\n                        dp[x1][y1-1][x2][y2-1]\n                    ) + grid[x1][y1] + (grid[x2][y2] if (x1, y1) != (x2, y2) else 0)\n    \n    return dp[N][N][N][N]\n```\ncode example:\nExamples:\n    >>> max_value_on_paths(2, [(1, 2, 1), (2, 1, 2), (0, 0, 0)])\n    3\n    >>> max_value_on_paths(8, [\n    ...     (2, 3, 13), (2, 6, 6), (3, 5, 7), (4, 4, 14),\n    ...     (5, 2, 21), (5, 6, 4), (6, 3, 15), (7, 2, 14),\n    ...     (0, 0, 0)])\n    67\nFix bugs in the given code snippet. The fixed code must be placed between ```python```. Do not generate any test, main,example usage or check code!\n"}
{"question_id": "Python/28", "category": "Reference", "subtype": "undefined_objects", "level": "easy", "example": "Examples:\n    >>> sum_of_factorials_optimized(3)\n    9\n    >>> sum_of_factorials_optimized(5)\n    153", "docstring": "Compute the cumulative sum of factorial values from 1 up to a specified integer n.\n\n    This function employs a more efficient method to calculate factorials by iteratively\n    multiplying the current number to the previous factorial result, thus avoiding redundant\n    calculations. It then accumulates the factorial of each number from 1 to n inclusively.\n\n    Args:\n    n (int): The upper limit of the range for which the factorial sum is to be calculated.\n             The value of n should be in the range of 1 to 50, inclusive.\n\n    Returns:\n    int: The sum of all factorial values from 1! to n!.\n\n    ", "canonical_solution": "def sum_of_factorials_optimized(n: int) -> int:\n    \n    sum_factorials = 0\n    current_factorial = 1\n    for i in range(1, n + 1):\n        current_factorial *= i\n        sum_factorials += current_factorial\n    return sum_factorials", "buggy_code": "def sum_of_factorials_optimized(n: int) -> int:\n    \n    sum_factorials = 0\n    current_factorial = 1\n    for i in range(1, n + 1):\n        current_factorial *= i\n        sum_factorials += current_factorial\n    return sum_factorial", "bug_with_line_numbers": "   1 | def sum_of_factorials_optimized(n: int) -> int:\n   2 |     sum_factorials = 0\n   3 |     current_factorial = 1\n   4 |     for i in range(1, n + 1):\n   5 |         current_factorial *= i\n   6 |         sum_factorials += current_factorial\n   7 |     return sum_factorial", "fragment_lines": [7], "fragment_content": ["    return sum_factorial"], "test": "def check():\n    assert sum_of_factorials_optimized(1) == 1, \"Test case 1 failed: sum_of_factorials_optimized(1) should be 1.\"\n    assert sum_of_factorials_optimized(3) == 9, \"Test case 2 failed: sum_of_factorials_optimized(3) should be 9.\"\n    assert sum_of_factorials_optimized(4) == 33, \"Test case 3 failed: sum_of_factorials_optimized(4) should be 33.\"\n    assert sum_of_factorials_optimized(5) == 153, \"Test case 4 failed: sum_of_factorials_optimized(5) should be 153.\"\n    assert sum_of_factorials_optimized(6) == 873, \"Test case 5 failed: sum_of_factorials_optimized(6) should be 873.\"\n    assert sum_of_factorials_optimized(10) == 4037913, \"Test case 6 failed: sum_of_factorials_optimized(10) should be 4037913.\"\n    print(\"All test cases passed.\")\n\n# Call the test function to run the test cases\ncheck()", "instruction": "Observe the following faulty Python code and its example\ncode:\n```python\ndef sum_of_factorials_optimized(n: int) -> int:\n    \n    sum_factorials = 0\n    current_factorial = 1\n    for i in range(1, n + 1):\n        current_factorial *= i\n        sum_factorials += current_factorial\n    return sum_factorial\n```\ncode example:\nExamples:\n    >>> sum_of_factorials_optimized(3)\n    9\n    >>> sum_of_factorials_optimized(5)\n    153\nFix bugs in the given code snippet. The fixed code must be placed between ```python```. Do not generate any test, main,example usage or check code!\n"}
{"question_id": "Python/29", "category": "Reference", "subtype": "undefined_objects", "level": "easy", "example": "Examples:\n    - calculate_arrangements(2, 4, [3, 2]) returns 2.\n    - calculate_arrangements(3, 3, [1, 2, 3]) returns 6.", "docstring": "Compute the number of ways to arrange m pots of flowers using up to n types,\n    where the ith type can have at most a[i] pots, and the arrangement must be in\n    increasing order of flower types.\n\n    Args:\n    - n (int): The number of flower types available.\n    - m (int): The total number of flower pots to arrange.\n    - a (list of int): A list where a[i] is the maximum number of pots for the ith type of flower.\n\n    Returns:\n    - int: The number of distinct arrangements modulo (10^6 + 7).\n\n    ", "canonical_solution": "def calculate_arrangements(n, m, a) -> int:\n    \n    MOD = 10 ** 6 + 7\n    dp = [[0] * (m + 1) for _ in range(n + 1)]\n    dp[0][0] = 1\n    for i in range(1, n + 1):\n        for j in range(m + 1):\n            for k in range(min(j, a[i - 1]) + 1):\n                dp[i][j] += dp[i - 1][j - k]\n                dp[i][j] %= MOD\n    return dp[n][m]", "buggy_code": "def calculate_arrangements(n, m, a) -> int:\n    \n    dp = [[0] * (m + 1) for _ in range(n + 1)]\n    dp[0][0] = 1\n    for i in range(1, n + 1):\n        for j in range(m + 1):\n            for k in range(min(j, a[i - 1]) + 1):\n                dp[i][j] += dp[i - 1][j - k]\n                dp[i][j] %= MOD\n    return dp[n][m]", "bug_with_line_numbers": "   1 | def calculate_arrangements(n, m, a) -> int:\n   2 |     dp = [[0] * (m + 1) for _ in range(n + 1)]\n   3 |     dp[0][0] = 1\n   4 |     for i in range(1, n + 1):\n   5 |         for j in range(m + 1):\n   6 |             for k in range(min(j, a[i - 1]) + 1):\n   7 |                 dp[i][j] += dp[i - 1][j - k]\n   8 |                 dp[i][j] %= MOD\n   9 |     return dp[n][m]", "fragment_lines": [8], "fragment_content": ["                dp[i][j] %= MOD"], "test": "def check():\n    # Helper function to compare expected and actual results\n    def assert_equal(actual, expected, message):\n        assert actual == expected, message\n\n    # Test Case 1\n    n, m, a = 2, 4, [3, 2]\n    expected = 2\n    assert_equal(calculate_arrangements(n, m, a), expected, f\"Test Case 1 failed: expected {expected}, got {calculate_arrangements(n, m, a)}\")\n\n    # Test Case 2\n    n, m, a = 3, 3, [1, 2, 3]\n    expected = 6\n    assert_equal(calculate_arrangements(n, m, a), expected, f\"Test Case 2 failed: expected {expected}, got {calculate_arrangements(n, m, a)}\")\n\n    # Test Case 3\n    n, m, a = 1, 5, [5]\n    expected = 1\n    assert_equal(calculate_arrangements(n, m, a), expected, f\"Test Case 3 failed: expected {expected}, got {calculate_arrangements(n, m, a)}\")\n\n    print(\"All tests passed!\")\n\ncheck()", "instruction": "Observe the following faulty Python code and its example\ncode:\n```python\ndef calculate_arrangements(n, m, a) -> int:\n    \n    dp = [[0] * (m + 1) for _ in range(n + 1)]\n    dp[0][0] = 1\n    for i in range(1, n + 1):\n        for j in range(m + 1):\n            for k in range(min(j, a[i - 1]) + 1):\n                dp[i][j] += dp[i - 1][j - k]\n                dp[i][j] %= MOD\n    return dp[n][m]\n```\ncode example:\nExamples:\n    - calculate_arrangements(2, 4, [3, 2]) returns 2.\n    - calculate_arrangements(3, 3, [1, 2, 3]) returns 6.\nFix bugs in the given code snippet. The fixed code must be placed between ```python```. Do not generate any test, main,example usage or check code!\n"}
{"question_id": "Python/30", "category": "Logic", "subtype": "algorithm_error", "level": "easy", "example": ">>> separate_paren_groups('( ) (( )) (( )( ))')\n    ['()', '(())', '(()())']", "docstring": "Input to this function is a string containing multiple groups of nested parentheses. Your goal is to\n    separate those group into separate strings and return the list of those.\n    Separate groups are balanced (each open brace is properly closed) and not nested within each other\n    Ignore any spaces in the input string.\n    ", "canonical_solution": "from typing import List\n \n \ndef separate_paren_groups(paren_string: str) -> List[str]:\n    \n    paren_string = paren_string.replace(\" \", \"\")\n    \n    current_group = \"\"\n    stack = []\n    result = []\n    \n    for char in paren_string:\n\n        if char == \"(\":\n            stack.append(char)\n            current_group += char\n\n        elif char == \")\" and stack:\n            stack.pop()\n            current_group += char\n\n            if not stack:\n                result.append(current_group)\n                current_group = \"\" \n\n    return result", "buggy_code": "from typing import List\n \n \ndef separate_paren_groups(paren_string: str) -> List[str]:\n    \n    paren_string = paren_string.replace(\" \", \"\")\n    \n    current_group = \"\"\n    stack = []\n    result = []\n    \n    for char in paren_string:\n\n        if char == \"(\":\n            stack.append(char)\n            current_group += char\n\n        elif char == \")\" and stack:\n            stack.pop()\n            current_group += char \n\n    return result", "bug_with_line_numbers": "   1 | from typing import List\n   2 | def separate_paren_groups(paren_string: str) -> List[str]:\n   3 |     paren_string = paren_string.replace(\" \", \"\")\n   4 |     current_group = \"\"\n   5 |     stack = []\n   6 |     result = []\n   7 |     for char in paren_string:\n   8 |         if char == \"(\":\n   9 |             stack.append(char)\n  10 |             current_group += char\n  11 |         elif char == \")\" and stack:\n  12 |             stack.pop()\n  13 |             current_group += char \n  14 |     return result", "fragment_lines": [-1], "fragment_content": ["missing critical code snippet"], "test": "def check():\n    assert separate_paren_groups('(()()) ((())) () ((())()())') == [\n    '(()())', '((()))', '()', '((())()())'\n    ]\n    assert separate_paren_groups('() (()) ((())) (((())))') == [\n    '()', '(())', '((()))', '(((())))'\n    ]\n    assert separate_paren_groups('(()(())((())))') == [\n    '(()(())((())))'\n    ]\n    assert separate_paren_groups('( ) (( )) (( )( ))') == ['()', '(())', '(()())']\n \ncheck()", "instruction": "Observe the following faulty Python code and its example\ncode:\n```python\nfrom typing import List\n \n \ndef separate_paren_groups(paren_string: str) -> List[str]:\n    \n    paren_string = paren_string.replace(\" \", \"\")\n    \n    current_group = \"\"\n    stack = []\n    result = []\n    \n    for char in paren_string:\n\n        if char == \"(\":\n            stack.append(char)\n            current_group += char\n\n        elif char == \")\" and stack:\n            stack.pop()\n            current_group += char \n\n    return result\n```\ncode example:\n>>> separate_paren_groups('( ) (( )) (( )( ))')\n    ['()', '(())', '(()())']\nFix bugs in the given code snippet. The fixed code must be placed between ```python```. Do not generate any test, main,example usage or check code!\n"}
{"question_id": "Python/31", "category": "Logic", "subtype": "algorithm_error", "level": "medium", "example": "Examples:\n    >>> max_value_on_paths(2, [(1, 2, 1), (2, 1, 2), (0, 0, 0)])\n    3\n    >>> max_value_on_paths(8, [\n    ...     (2, 3, 13), (2, 6, 6), (3, 5, 7), (4, 4, 14),\n    ...     (5, 2, 21), (5, 6, 4), (6, 3, 15), (7, 2, 14),\n    ...     (0, 0, 0)])\n    67", "docstring": "Calculate the maximum sum of values collected on two paths in an N x N grid.\n\n    This function utilizes dynamic programming to find two paths from the top-left corner to\n    the bottom-right corner of the grid which maximize the sum of the values collected. Each\n    value can be collected at most once, even if both paths pass through it.\n\n    Args:\n    - N (int): The size of the grid (N x N).\n    - grid_values (List[Tuple[int, int, int]]): A list of tuples where each tuple contains\n      the x-coordinate, y-coordinate, and value to be placed on the grid at that position.\n      The list is terminated by a tuple with all zeros.\n\n    Returns:\n    - int: The maximum sum of values collected on the two paths.\n\n    ", "canonical_solution": "from typing import List, Tuple\n\ndef max_value_on_paths(N: int, grid_values: List[Tuple[int, int, int]]) -> int:\n    \n    dp = [[[[0 for _ in range(N+1)] for _ in range(N+1)] for _ in range(N+1)] for _ in range(N+1)]\n    \n    grid = [[0 for _ in range(N+1)] for _ in range(N+1)]\n    for x, y, val in grid_values:\n        grid[x][y] = val\n    \n    for x1 in range(1, N+1):\n        for y1 in range(1, N+1):\n            for x2 in range(1, N+1):\n                for y2 in range(1, N+1):\n                    dp[x1][y1][x2][y2] = max(\n                        dp[x1-1][y1][x2-1][y2],\n                        dp[x1-1][y1][x2][y2-1],\n                        dp[x1][y1-1][x2-1][y2],\n                        dp[x1][y1-1][x2][y2-1]\n                    ) + grid[x1][y1] + (grid[x2][y2] if (x1, y1) != (x2, y2) else 0)\n    \n    return dp[N][N][N][N]", "buggy_code": "from typing import List, Tuple\n\ndef max_value_on_paths(N: int, grid_values: List[Tuple[int, int, int]]) -> int:\n    \n    dp = [[[[0 for _ in range(N+1)] for _ in range(N+1)] for _ in range(N+1)] for _ in range(N+1)]\n    \n    grid = [[0 for _ in range(N+1)] for _ in range(N+1)]\n    for x, y, val in grid_values:\n        grid[x][y] = val\n    \n    for x1 in range(1, N+1):\n        for y1 in range(1, N+1):\n            for x2 in range(1, N+1):\n                for y2 in range(1, N+1):\n                    dp[x1][y1][x2][y2] = max(\n                        dp[x1-1][y1][x2-1][y2],\n                        dp[x1-1][y1][x2][y2-1],\n                        dp[x1][y1-1][x2-1][y2],\n                        dp[x1][y1-1][x2][y2-1]\n                    ) + grid[x1][y1] + grid[x2][y2]\n    \n    return dp[N][N][N][N]", "bug_with_line_numbers": "   1 | from typing import List, Tuple\n   2 | def max_value_on_paths(N: int, grid_values: List[Tuple[int, int, int]]) -> int:\n   3 |     dp = [[[[0 for _ in range(N+1)] for _ in range(N+1)] for _ in range(N+1)] for _ in range(N+1)]\n   4 |     grid = [[0 for _ in range(N+1)] for _ in range(N+1)]\n   5 |     for x, y, val in grid_values:\n   6 |         grid[x][y] = val\n   7 |     for x1 in range(1, N+1):\n   8 |         for y1 in range(1, N+1):\n   9 |             for x2 in range(1, N+1):\n  10 |                 for y2 in range(1, N+1):\n  11 |                     dp[x1][y1][x2][y2] = max(\n  12 |                         dp[x1-1][y1][x2-1][y2],\n  13 |                         dp[x1-1][y1][x2][y2-1],\n  14 |                         dp[x1][y1-1][x2-1][y2],\n  15 |                         dp[x1][y1-1][x2][y2-1]\n  16 |                     ) + grid[x1][y1] + grid[x2][y2]\n  17 |     return dp[N][N][N][N]", "fragment_lines": [16], "fragment_content": ["                    ) + grid[x1][y1] + grid[x2][y2]"], "test": "def check():\n    # Test case 1: Small grid with clear path\n    assert max_value_on_paths(2, [(1, 2, 1), (2, 1, 2), (0, 0, 0)]) == 3\n    \n    # Test case 2: Example provided in the problem statement\n    assert max_value_on_paths(8, [\n        (2, 3, 13), (2, 6, 6), (3, 5, 7), (4, 4, 14),\n        (5, 2, 21), (5, 6, 4), (6, 3, 15), (7, 2, 14),\n        (0, 0, 0)]) == 67\n\n    print(\"All test cases passed!\")\n\ncheck()", "instruction": "Observe the following faulty Python code and its example\ncode:\n```python\nfrom typing import List, Tuple\n\ndef max_value_on_paths(N: int, grid_values: List[Tuple[int, int, int]]) -> int:\n    \n    dp = [[[[0 for _ in range(N+1)] for _ in range(N+1)] for _ in range(N+1)] for _ in range(N+1)]\n    \n    grid = [[0 for _ in range(N+1)] for _ in range(N+1)]\n    for x, y, val in grid_values:\n        grid[x][y] = val\n    \n    for x1 in range(1, N+1):\n        for y1 in range(1, N+1):\n            for x2 in range(1, N+1):\n                for y2 in range(1, N+1):\n                    dp[x1][y1][x2][y2] = max(\n                        dp[x1-1][y1][x2-1][y2],\n                        dp[x1-1][y1][x2][y2-1],\n                        dp[x1][y1-1][x2-1][y2],\n                        dp[x1][y1-1][x2][y2-1]\n                    ) + grid[x1][y1] + grid[x2][y2]\n    \n    return dp[N][N][N][N]\n```\ncode example:\nExamples:\n    >>> max_value_on_paths(2, [(1, 2, 1), (2, 1, 2), (0, 0, 0)])\n    3\n    >>> max_value_on_paths(8, [\n    ...     (2, 3, 13), (2, 6, 6), (3, 5, 7), (4, 4, 14),\n    ...     (5, 2, 21), (5, 6, 4), (6, 3, 15), (7, 2, 14),\n    ...     (0, 0, 0)])\n    67\nFix bugs in the given code snippet. The fixed code must be placed between ```python```. Do not generate any test, main,example usage or check code!\n"}
{"question_id": "Python/32", "category": "Logic", "subtype": "algorithm_error", "level": "medium", "example": ">>> minimum_students_to_leave([186, 186, 150, 200, 160, 130, 197, 220])\n4", "docstring": "Calculate the minimum number of students that need to leave to form a choir formation.\n    A choir formation is defined such that for some position 'i', the heights of students\n    increase from the start to 'i' and decrease from 'i' to the end of the formation.\n\n    Args:\n    heights (List[int]): A list of student heights.\n\n    Returns:\n    int: The minimum number of students that need to leave.", "canonical_solution": "def minimum_students_to_leave(heights):\n    \n    n = len(heights)\n    \n    lis = [1] * n\n    for i in range(n):\n        for j in range(i):\n            if heights[i] > heights[j]:\n                lis[i] = max(lis[i], lis[j] + 1)\n\n    lds = [1] * n\n    for i in range(n - 1, -1, -1):\n        for j in range(n - 1, i, -1):\n            if heights[i] > heights[j]:\n                lds[i] = max(lds[i], lds[j] + 1)\n\n    max_choir_length = max(lis[i] + lds[i] - 1 for i in range(n))\n    \n    return n - max_choir_length", "buggy_code": "def minimum_students_to_leave(heights):\n    \n    n = len(heights)\n    \n    lis = [1] * n\n    for i in range(n):\n        for j in range(i):\n            if heights[i] > heights[j]:\n                lis[i] = max(lis[i], lis[j] + 1)\n\n    lds = [1] * n\n    for i in range(n - 1, -1, -1):\n        for j in range(n - 1, i, -1):\n            if heights[i] > heights[j]:\n                lds[i] = max(lds[i], lds[j] + 1)\n\n    max_choir_length = max(lis[i] + lds[i] for i in range(n))\n    \n    return n - max_choir_length", "bug_with_line_numbers": "   1 | def minimum_students_to_leave(heights):\n   2 |     n = len(heights)\n   3 |     lis = [1] * n\n   4 |     for i in range(n):\n   5 |         for j in range(i):\n   6 |             if heights[i] > heights[j]:\n   7 |                 lis[i] = max(lis[i], lis[j] + 1)\n   8 |     lds = [1] * n\n   9 |     for i in range(n - 1, -1, -1):\n  10 |         for j in range(n - 1, i, -1):\n  11 |             if heights[i] > heights[j]:\n  12 |                 lds[i] = max(lds[i], lds[j] + 1)\n  13 |     max_choir_length = max(lis[i] + lds[i] for i in range(n))\n  14 |     return n - max_choir_length", "fragment_lines": [13], "fragment_content": ["    max_choir_length = max(lis[i] + lds[i] for i in range(n))"], "test": "def check():\n    # Test case 1: Provided example\n    assert minimum_students_to_leave([186, 186, 150, 200, 160, 130, 197, 220]) == 4, \"Test case 1 failed\"\n\n    # Test case 2: All students have the same height\n    assert minimum_students_to_leave([150, 150, 150, 150, 150]) == 4, \"Test case 2 failed\"\n\n    # Test case 3: Students are already in a choir formation\n    assert minimum_students_to_leave([130, 150, 170, 190, 170, 150, 130]) == 0, \"Test case 3 failed\"\n\n    # Test case 4: Students are in strictly increasing order\n    assert minimum_students_to_leave([130, 135, 140, 145, 150, 155]) == 0, \"Test case 4 failed\"\n\n    # Test case 5: Students are in strictly decreasing order\n    assert minimum_students_to_leave([155, 150, 145, 140, 135, 130]) == 0, \"Test case 5 failed\"\n\n    # Test case 6: Optimal choir formation is not including the first or last student\n    assert minimum_students_to_leave([200, 180, 190, 170, 210, 160, 220]) == 3, \"Test case 6 failed\"\n\n    print(\"All test cases passed!\")\n\n# Run the test function\ncheck()", "instruction": "Observe the following faulty Python code and its example\ncode:\n```python\ndef minimum_students_to_leave(heights):\n    \n    n = len(heights)\n    \n    lis = [1] * n\n    for i in range(n):\n        for j in range(i):\n            if heights[i] > heights[j]:\n                lis[i] = max(lis[i], lis[j] + 1)\n\n    lds = [1] * n\n    for i in range(n - 1, -1, -1):\n        for j in range(n - 1, i, -1):\n            if heights[i] > heights[j]:\n                lds[i] = max(lds[i], lds[j] + 1)\n\n    max_choir_length = max(lis[i] + lds[i] for i in range(n))\n    \n    return n - max_choir_length\n```\ncode example:\n>>> minimum_students_to_leave([186, 186, 150, 200, 160, 130, 197, 220])\n4\nFix bugs in the given code snippet. The fixed code must be placed between ```python```. Do not generate any test, main,example usage or check code!\n"}
{"question_id": "Python/33", "category": "Logic", "subtype": "algorithm_error", "level": "hard", "example": "Examples:\n        >>> polynomial_to_string(5, [100, -1, 1, -3, 0, 10])\n        '100x^5-x^4+x^3-3x^2+10'\n\n        >>> polynomial_to_string(3, [-50, 0, 0, 1])\n        '-50x^3+1'", "docstring": "Converts a list of polynomial coefficients into a formatted string representation.\n\n    The function takes in the highest degree `n` of the polynomial and a list of coefficients `coeffs`,\n    which are ordered from the highest degree term to the constant term. It returns a string that\n    represents the polynomial with the following rules:\n    - Terms with a coefficient of zero are omitted.\n    - The sign of each term is determined (+ for positive, - for negative), with no leading '+' for the first term.\n    - The absolute value of the coefficient is shown unless it's 1 and the term includes the variable `x`.\n    - The variable part is formatted based on its degree; `x^degree` for degree > 1, `x` for degree 1, and\n      nothing for degree 0 (constant term).\n    - Terms are joined without additional spaces, starting with the highest degree term.\n\n    Args:\n        n (int): The highest degree of the polynomial.\n        coeffs (List[int]): A list of coefficients, starting with the coefficient of the highest degree term.\n\n    Returns:\n        str: The string representation of the polynomial.\n\n    ", "canonical_solution": "from typing import List \ndef polynomial_to_string(n: int, coeffs: List[int]) -> str:\n    \n    result = []\n\n    for i in range(n + 1):\n        coeff = coeffs[i]\n        degree = n - i\n\n        if coeff == 0:\n            continue\n        sign = '-' if coeff < 0 else '+'\n        if i == 0:\n            sign = '-' if coeff < 0 else ''\n        \n        abs_coeff = abs(coeff)\n        if abs_coeff == 1 and degree != 0:\n            abs_coeff_str = ''\n        else:\n            abs_coeff_str = str(abs_coeff)\n        \n        if degree == 0:\n            term = abs_coeff_str\n        elif degree == 1:\n            term = f\"{abs_coeff_str}x\"\n        else:\n            term = f\"{abs_coeff_str}x^{degree}\"\n\n        result.append(f\"{sign}{term}\")\n\n    return ''.join(result)", "buggy_code": "from typing import List \ndef polynomial_to_string(n: int, coeffs: List[int]) -> str:\n    \n    result = []\n\n    for i in range(n + 1):\n        coeff = coeffs[i]\n        degree = n - i\n\n        sign = '-' if coeff < 0 else '+'\n        \n        abs_coeff = abs(coeff)\n        if abs_coeff == 1 and degree != 0:\n            abs_coeff_str = ''\n        else:\n            abs_coeff_str = str(abs_coeff)\n        \n        if degree == 0:\n            term = abs_coeff_str\n        elif degree == 1:\n            term = f\"{abs_coeff_str}x\"\n        else:\n            term = f\"{abs_coeff_str}x^{degree}\"\n\n        result.append(f\"{sign}{term}\")\n\n    return ''.join(result)", "bug_with_line_numbers": "   1 | from typing import List \n   2 | def polynomial_to_string(n: int, coeffs: List[int]) -> str:\n   3 |     result = []\n   4 |     for i in range(n + 1):\n   5 |         coeff = coeffs[i]\n   6 |         degree = n - i\n   7 |         sign = '-' if coeff < 0 else '+'\n   8 |         abs_coeff = abs(coeff)\n   9 |         if abs_coeff == 1 and degree != 0:\n  10 |             abs_coeff_str = ''\n  11 |         else:\n  12 |             abs_coeff_str = str(abs_coeff)\n  13 |         if degree == 0:\n  14 |             term = abs_coeff_str\n  15 |         elif degree == 1:\n  16 |             term = f\"{abs_coeff_str}x\"\n  17 |         else:\n  18 |             term = f\"{abs_coeff_str}x^{degree}\"\n  19 |         result.append(f\"{sign}{term}\")\n  20 |     return ''.join(result)", "fragment_lines": [-1], "fragment_content": ["missing critical code snippet"], "test": "def check():\n    test_cases = [\n        (4, [3, -2, 0, 1, -5], \"3x^4-2x^3+x-5\"),\n        (2, [0, 4, -1], \"+4x-1\"),\n        (0, [7], \"7\"),\n        (3, [1, -1, 0, 1], \"x^3-x^2+1\"),\n    ]\n\n    for i, (n, coeffs, expected) in enumerate(test_cases):\n        result = polynomial_to_string(n, coeffs)\n\n        assert result == expected, f\"Test case {i + 1} failed: expected {expected}, got {result}\"\n        print(f\"Test case {i + 1} passed: expected {expected}, got {result}\")\n\n\ncheck()", "instruction": "Observe the following faulty Python code and its example\ncode:\n```python\nfrom typing import List \ndef polynomial_to_string(n: int, coeffs: List[int]) -> str:\n    \n    result = []\n\n    for i in range(n + 1):\n        coeff = coeffs[i]\n        degree = n - i\n\n        sign = '-' if coeff < 0 else '+'\n        \n        abs_coeff = abs(coeff)\n        if abs_coeff == 1 and degree != 0:\n            abs_coeff_str = ''\n        else:\n            abs_coeff_str = str(abs_coeff)\n        \n        if degree == 0:\n            term = abs_coeff_str\n        elif degree == 1:\n            term = f\"{abs_coeff_str}x\"\n        else:\n            term = f\"{abs_coeff_str}x^{degree}\"\n\n        result.append(f\"{sign}{term}\")\n\n    return ''.join(result)\n```\ncode example:\nExamples:\n        >>> polynomial_to_string(5, [100, -1, 1, -3, 0, 10])\n        '100x^5-x^4+x^3-3x^2+10'\n\n        >>> polynomial_to_string(3, [-50, 0, 0, 1])\n        '-50x^3+1'\nFix bugs in the given code snippet. The fixed code must be placed between ```python```. Do not generate any test, main,example usage or check code!\n"}
{"question_id": "Python/34", "category": "Logic", "subtype": "condition_error", "level": "medium", "example": ">>> has_close_elements([1.0, 2.0, 3.0], 0.5)\n    False\n    >>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\n    True", "docstring": "Check if in given list of numbers, are any two numbers closer to each other than\n    given threshold.\n    ", "canonical_solution": "from typing import List\n \ndef has_close_elements(numbers: List[float], threshold: float) -> bool:\n    \n    for idx, elem in enumerate(numbers):\n        for idx2, elem2 in enumerate(numbers):\n            if idx != idx2:\n                distance = abs(elem - elem2)\n                if distance < threshold:\n                    return True\n\n    return False", "buggy_code": "from typing import List\n \ndef has_close_elements(numbers: List[float], threshold: float) -> bool:\n    \n    for idx, elem in enumerate(numbers):\n        for idx2, elem2 in enumerate(numbers):\n            if idx != idx2:\n                distance = abs(elem - elem2)\n                if distance > threshold:\n                    return True\n\n    return False", "bug_with_line_numbers": "   1 | from typing import List\n   2 | def has_close_elements(numbers: List[float], threshold: float) -> bool:\n   3 |     for idx, elem in enumerate(numbers):\n   4 |         for idx2, elem2 in enumerate(numbers):\n   5 |             if idx != idx2:\n   6 |                 distance = abs(elem - elem2)\n   7 |                 if distance > threshold:\n   8 |                     return True\n   9 |     return False", "fragment_lines": [7], "fragment_content": ["                if distance > threshold:"], "test": "def check():\n    assert has_close_elements([1.0, 2.0, 3.9, 4.0, 5.0, 2.2], 0.3) == True\n    assert has_close_elements([1.0, 2.0, 3.9, 4.0, 5.0, 2.2], 0.05) == False\n    assert has_close_elements([1.0, 2.0, 5.9, 4.0, 5.0], 0.95) == True\n    assert has_close_elements([1.0, 2.0, 5.9, 4.0, 5.0], 0.8) == False\n    assert has_close_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.0], 0.1) == True\n    assert has_close_elements([1.1, 2.2, 3.1, 4.1, 5.1], 1.0) == True\n    assert has_close_elements([1.1, 2.2, 3.1, 4.1, 5.1], 0.5) == False\n \ncheck()", "instruction": "Observe the following faulty Python code and its example\ncode:\n```python\nfrom typing import List\n \ndef has_close_elements(numbers: List[float], threshold: float) -> bool:\n    \n    for idx, elem in enumerate(numbers):\n        for idx2, elem2 in enumerate(numbers):\n            if idx != idx2:\n                distance = abs(elem - elem2)\n                if distance > threshold:\n                    return True\n\n    return False\n```\ncode example:\n>>> has_close_elements([1.0, 2.0, 3.0], 0.5)\n    False\n    >>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\n    True\nFix bugs in the given code snippet. The fixed code must be placed between ```python```. Do not generate any test, main,example usage or check code!\n"}
{"question_id": "Python/35", "category": "Logic", "subtype": "condition_error", "level": "easy", "example": ":\n    >>> sum_of_factorials_optimized(3)\n    9\n    >>> sum_of_factorials_optimized(5)\n    153", "docstring": "Compute the cumulative sum of factorial values from 1 up to a specified integer n.\n\n    This function employs a more efficient method to calculate factorials by iteratively\n    multiplying the current number to the previous factorial result, thus avoiding redundant\n    calculations. It then accumulates the factorial of each number from 1 to n inclusively.\n\n    Args:\n    n (int): The upper limit of the range for which the factorial sum is to be calculated.\n             The value of n should be in the range of 1 to 50, inclusive.\n\n    Returns:\n    int: The sum of all factorial values from 1! to n!.\n\n    Examples", "canonical_solution": "def sum_of_factorials_optimized(n: int) -> int:\n    \n    sum_factorials = 0\n    current_factorial = 1\n    for i in range(1, n + 1):\n        current_factorial *= i\n        sum_factorials += current_factorial\n    return sum_factorials", "buggy_code": "def sum_of_factorials_optimized(n: int) -> int:\n    \n    sum_factorials = 0\n    current_factorial = 1\n    for i in range(1, n):\n        current_factorial *= i\n        sum_factorials += current_factorial\n    return sum_factorials", "bug_with_line_numbers": "   1 | def sum_of_factorials_optimized(n: int) -> int:\n   2 |     sum_factorials = 0\n   3 |     current_factorial = 1\n   4 |     for i in range(1, n):\n   5 |         current_factorial *= i\n   6 |         sum_factorials += current_factorial\n   7 |     return sum_factorials", "fragment_lines": [4], "fragment_content": ["    for i in range(1, n):"], "test": "def check():\n    assert sum_of_factorials_optimized(1) == 1, \"Test case 1 failed: sum_of_factorials_optimized(1) should be 1.\"\n    assert sum_of_factorials_optimized(3) == 9, \"Test case 2 failed: sum_of_factorials_optimized(3) should be 9.\"\n    assert sum_of_factorials_optimized(4) == 33, \"Test case 3 failed: sum_of_factorials_optimized(4) should be 33.\"\n    assert sum_of_factorials_optimized(5) == 153, \"Test case 4 failed: sum_of_factorials_optimized(5) should be 153.\"\n    assert sum_of_factorials_optimized(6) == 873, \"Test case 5 failed: sum_of_factorials_optimized(6) should be 873.\"\n    assert sum_of_factorials_optimized(10) == 4037913, \"Test case 6 failed: sum_of_factorials_optimized(10) should be 4037913.\"\n    print(\"All test cases passed.\")\n\n# Call the test function to run the test cases\ncheck()", "instruction": "Observe the following faulty Python code and its example\ncode:\n```python\ndef sum_of_factorials_optimized(n: int) -> int:\n    \n    sum_factorials = 0\n    current_factorial = 1\n    for i in range(1, n):\n        current_factorial *= i\n        sum_factorials += current_factorial\n    return sum_factorials\n```\ncode example:\n:\n    >>> sum_of_factorials_optimized(3)\n    9\n    >>> sum_of_factorials_optimized(5)\n    153\nFix bugs in the given code snippet. The fixed code must be placed between ```python```. Do not generate any test, main,example usage or check code!\n"}
{"question_id": "Python/36", "category": "Logic", "subtype": "condition_error", "level": "easy", "example": "Examples:\n    >>> minimum_cost_to_merge_fruits([1, 2, 9])\n    15\n    >>> minimum_cost_to_merge_fruits([10, 20, 30, 40, 50])\n    300 .", "docstring": "Calculates the minimum total cost to merge multiple heaps of fruits into a single heap.\n    The cost of merging two heaps is equal to the sum of their weights. The function utilizes\n    a greedy algorithm with a min-heap (priority queue) to ensure the smallest heaps are merged first,\n    minimizing the total cost.\n\n    Parameters:\n    fruit_counts (List[int]): A list of integers representing the counts of each type of fruit.\n\n    Returns:\n    int: The minimum total cost required to merge all heaps of fruits.\n\n    ", "canonical_solution": "import heapq\nfrom typing import List \n\ndef minimum_cost_to_merge_fruits(fruit_counts: List[int]) -> int:\n    \n    heapq.heapify(fruit_counts)\n    \n    total_cost = 0\n    \n    while len(fruit_counts) > 1:\n        first = heapq.heappop(fruit_counts)\n        second = heapq.heappop(fruit_counts)\n        \n        cost = first + second\n        total_cost += cost\n        \n        heapq.heappush(fruit_counts, cost)\n    \n    return total_cost", "buggy_code": "import heapq\nfrom typing import List \n\ndef minimum_cost_to_merge_fruits(fruit_counts: List[int]) -> int:\n    \n    heapq.heapify(fruit_counts)\n    \n    total_cost = 0\n    \n    while len(fruit_counts) > 0:\n        first = heapq.heappop(fruit_counts)\n        second = heapq.heappop(fruit_counts)\n        \n        cost = first + second\n        total_cost += cost\n        \n        heapq.heappush(fruit_counts, cost)\n    \n    return total_cost", "bug_with_line_numbers": "   1 | import heapq\n   2 | from typing import List \n   3 | def minimum_cost_to_merge_fruits(fruit_counts: List[int]) -> int:\n   4 |     heapq.heapify(fruit_counts)\n   5 |     total_cost = 0\n   6 |     while len(fruit_counts) > 0:\n   7 |         first = heapq.heappop(fruit_counts)\n   8 |         second = heapq.heappop(fruit_counts)\n   9 |         cost = first + second\n  10 |         total_cost += cost\n  11 |         heapq.heappush(fruit_counts, cost)\n  12 |     return total_cost", "fragment_lines": [6], "fragment_content": ["    while len(fruit_counts) > 0:"], "test": "def check():\n    # Test case 1: As provided in the problem statement example\n    fruits1 = [1, 2, 9]\n    assert minimum_cost_to_merge_fruits(fruits1) == 15, \"Test case 1 failed\"\n\n    # Test case 2: Simple case with only two types of fruits\n    fruits2 = [5, 5]\n    assert minimum_cost_to_merge_fruits(fruits2) == 10, \"Test case 2 failed\"\n\n    # Test case 3: More complex case with multiple types of fruits\n    fruits3 = [10, 20, 30, 40, 50]\n    assert minimum_cost_to_merge_fruits(fruits3) == 330, \"Test case 3 failed\"\n\n    # Test case 4: Case with fruits having the same count\n    fruits4 = [3, 3, 3, 3]\n    assert minimum_cost_to_merge_fruits(fruits4) == 24, \"Test case 4 failed\"\n\n    # Test case 5: Case with a single type of fruit\n    fruits5 = [7]\n    assert minimum_cost_to_merge_fruits(fruits5) == 0, \"Test case 5 failed\"\n\n    print(\"All test cases passed.\")\n\n# Run the test function\ncheck()\n\n'''fragment\nheapq.heappush(fruit_counts)\n'''\n\n'''level\nmedium\n'''", "instruction": "Observe the following faulty Python code and its example\ncode:\n```python\nimport heapq\nfrom typing import List \n\ndef minimum_cost_to_merge_fruits(fruit_counts: List[int]) -> int:\n    \n    heapq.heapify(fruit_counts)\n    \n    total_cost = 0\n    \n    while len(fruit_counts) > 0:\n        first = heapq.heappop(fruit_counts)\n        second = heapq.heappop(fruit_counts)\n        \n        cost = first + second\n        total_cost += cost\n        \n        heapq.heappush(fruit_counts, cost)\n    \n    return total_cost\n```\ncode example:\nExamples:\n    >>> minimum_cost_to_merge_fruits([1, 2, 9])\n    15\n    >>> minimum_cost_to_merge_fruits([10, 20, 30, 40, 50])\n    300 .\nFix bugs in the given code snippet. The fixed code must be placed between ```python```. Do not generate any test, main,example usage or check code!\n"}
{"question_id": "Python/37", "category": "Logic", "subtype": "operation_error", "level": "medium", "example": "Examples:\n    >>> find_topmost_carpet(3, [(1, 0, 2, 3), (0, 2, 3, 3), (2, 1, 3, 3)], (2, 2))\n    3\n    >>> find_topmost_carpet(3, [(1, 0, 2, 3), (0, 2, 3, 3), (2, 1, 3, 3)], (4, 5))\n    -1", "docstring": "Finds the topmost carpet covering a given point on the coordinate plane.\n\n    Args:\n    n (int): The total number of carpets.\n    carpets (list of tuples): A list containing n tuples, each representing a carpet's information.\n                              Each tuple contains four integers (a, b, g, k) where (a, b) is the\n                              coordinates of the bottom-left corner of the carpet and (g, k) are\n                              the lengths of the carpet along the x and y axis respectively.\n    point (tuple): A tuple containing two integers (x, y), the coordinates of the point to check.\n\n    Returns:\n    int: The number of the topmost carpet covering the point (x, y), or -1 if no carpet covers it.\n\n    ", "canonical_solution": "def find_topmost_carpet(n, carpets, point) -> int:\n    \n    x, y = point\n    # Iterate through the carpets in reverse order, since the last one is on top\n    for i in range(n - 1, -1, -1):\n        a, b, g, k = carpets[i]\n        if a <= x <= a + g and b <= y <= b + k:\n            return i + 1\n    return -1", "buggy_code": "def find_topmost_carpet(n, carpets, point) -> int:\n    \n    x, y = point\n    # Iterate through the carpets in reverse order, since the last one is on top\n    for i in range(n - 1, -1, -1):\n        a, b, g, k = carpets[i]\n        if a <= x <= a + g and b <= y <= b + k:\n            return ++i\n    return -1", "bug_with_line_numbers": "   1 | def find_topmost_carpet(n, carpets, point) -> int:\n   2 |     x, y = point\n   3 |     # Iterate through the carpets in reverse order, since the last one is on top\n   4 |     for i in range(n - 1, -1, -1):\n   5 |         a, b, g, k = carpets[i]\n   6 |         if a <= x <= a + g and b <= y <= b + k:\n   7 |             return ++i\n   8 |     return -1", "fragment_lines": [6], "fragment_content": ["            return ++i"], "test": "def check():\n    # Test case 1: Point is on topmost carpet (carpet 3)\n    assert find_topmost_carpet(3, [(1, 0, 2, 3), (0, 2, 3, 3), (2, 1, 3, 3)], (2, 2)) == 3\n\n    # Test case 2: Point is not covered by any carpet\n    assert find_topmost_carpet(3, [(1, 0, 2, 3), (0, 2, 3, 3), (2, 1, 3, 3)], (4, 5)) == -1\n\n    # Test case 3: Point is on the edge of the carpet (carpet 1)\n    assert find_topmost_carpet(2, [(1, 1, 3, 3), (4, 4, 2, 2)], (4, 1)) == 1\n\n    # Test case 4: Point is at the corner of the carpet (carpet 2)\n    assert find_topmost_carpet(2, [(1, 1, 3, 3), (4, 4, 2, 2)], (6, 4)) == 2\n\n    # Test case 5: Multiple carpets cover the point, but the last one is on top (carpet 4)\n    assert find_topmost_carpet(4, [(0, 0, 5, 5), (1, 1, 5, 5), (2, 2, 5, 5), (3, 3, 5, 5)], (4, 4)) == 4\n\n    # Test case 6: No carpets at all, should return -1\n    assert find_topmost_carpet(0, [], (0, 0)) == -1\n\n    # Test case 8: Point is covered by the first carpet and no others (carpet 1)\n    assert find_topmost_carpet(3, [(0, 0, 2, 2), (2, 2, 2, 2), (4, 4, 2, 2)], (1, 1)) == 1\n\n    print(\"All test cases passed!\")\n\ncheck()\n", "instruction": "Observe the following faulty Python code and its example\ncode:\n```python\ndef find_topmost_carpet(n, carpets, point) -> int:\n    \n    x, y = point\n    # Iterate through the carpets in reverse order, since the last one is on top\n    for i in range(n - 1, -1, -1):\n        a, b, g, k = carpets[i]\n        if a <= x <= a + g and b <= y <= b + k:\n            return ++i\n    return -1\n```\ncode example:\nExamples:\n    >>> find_topmost_carpet(3, [(1, 0, 2, 3), (0, 2, 3, 3), (2, 1, 3, 3)], (2, 2))\n    3\n    >>> find_topmost_carpet(3, [(1, 0, 2, 3), (0, 2, 3, 3), (2, 1, 3, 3)], (4, 5))\n    -1\nFix bugs in the given code snippet. The fixed code must be placed between ```python```. Do not generate any test, main,example usage or check code!\n"}
{"question_id": "Python/38", "category": "Logic", "subtype": "operation_error", "level": "easy", "example": "Examples:\n    >>> verify_isbn(\"0-670-82162-4\")\n    'Right'\n    \n    >>> verify_isbn(\"0-670-82162-0\")\n    '0-670-82162-4'", "docstring": "Verify the correctness of a given ISBN number and correct it if necessary.\n\n    The function checks the provided ISBN number against the ISBN standard checksum calculation.\n    If the checksum is correct, the function returns \"Right\". If the checksum is incorrect,\n    the function returns the corrected ISBN number.\n\n    Args:\n    isbn: A string representing the ISBN number to be verified. The format should be 'x-xxx-xxxxx-x',\n          where 'x' is a digit, and the last 'x' could also be 'X' representing the checksum digit.\n\n    Returns:\n    A string that is either \"Right\" if the ISBN checksum is correct, or the corrected ISBN number\n    in the same format as the input if the checksum is incorrect.\n\n    ", "canonical_solution": "def verify_isbn(isbn: str) -> str:\n    \n    isbn_digits = isbn.replace('-', '')\n\n    total_sum = sum((i + 1) * int(digit) for i, digit in enumerate(isbn_digits[:-1]))\n    \n    check_digit = total_sum % 11\n\n    if check_digit == 10:\n        check_digit = 'X'\n    else:\n        check_digit = str(check_digit)\n\n    if check_digit == isbn_digits[-1]:\n        return \"Right\"\n    else:\n        return isbn[:-1] + check_digit", "buggy_code": "def verify_isbn(isbn: str) -> str:\n    \n    isbn_digits = isbn.replace('-', '')\n\n    total_sum = sum((i + 1) * int(digit) for i, digit in enumerate(isbn_digits[:-1]))\n    \n    check_digit = total_sum %% 11\n\n    if check_digit == 10:\n        check_digit = 'X'\n    else:\n        check_digit = str(check_digit)\n\n    if check_digit == isbn_digits[-1]:\n        return \"Right\"\n    else:\n        return isbn[:-1] + check_digit", "bug_with_line_numbers": "   1 | def verify_isbn(isbn: str) -> str:\n   2 |     isbn_digits = isbn.replace('-', '')\n   3 |     total_sum = sum((i + 1) * int(digit) for i, digit in enumerate(isbn_digits[:-1]))\n   4 |     check_digit = total_sum %% 11\n   5 |     if check_digit == 10:\n   6 |         check_digit = 'X'\n   7 |     else:\n   8 |         check_digit = str(check_digit)\n   9 |     if check_digit == isbn_digits[-1]:\n  10 |         return \"Right\"\n  11 |     else:\n  12 |         return isbn[:-1] + check_digit", "fragment_lines": [4], "fragment_content": ["    check_digit = total_sum %% 11"], "test": "def check():\n    # Test case 1: Correct ISBN number\n    assert verify_isbn(\"0-670-82162-4\") == \"Right\", \"Test case 1 failed\"\n\n    # Test case 2: Incorrect ISBN number with wrong checksum digit\n    assert verify_isbn(\"0-670-82162-0\") == \"0-670-82162-4\", \"Test case 2 failed\"\n\n    print(\"All test cases passed!\")\n\n# Run the test cases\ncheck()", "instruction": "Observe the following faulty Python code and its example\ncode:\n```python\ndef verify_isbn(isbn: str) -> str:\n    \n    isbn_digits = isbn.replace('-', '')\n\n    total_sum = sum((i + 1) * int(digit) for i, digit in enumerate(isbn_digits[:-1]))\n    \n    check_digit = total_sum %% 11\n\n    if check_digit == 10:\n        check_digit = 'X'\n    else:\n        check_digit = str(check_digit)\n\n    if check_digit == isbn_digits[-1]:\n        return \"Right\"\n    else:\n        return isbn[:-1] + check_digit\n```\ncode example:\nExamples:\n    >>> verify_isbn(\"0-670-82162-4\")\n    'Right'\n    \n    >>> verify_isbn(\"0-670-82162-0\")\n    '0-670-82162-4'\nFix bugs in the given code snippet. The fixed code must be placed between ```python```. Do not generate any test, main,example usage or check code!\n"}
{"question_id": "Python/39", "category": "Logic", "subtype": "operation_error", "level": "medium", "example": "Examples:\n      >>> mod_inverse(3, 10)\n      7\n\n      >>> mod_inverse(42, 2017)\n      None", "docstring": "Calculate the modular multiplicative inverse of `a` modulo `b`.\n    \n    This function finds an integer `x` such that (a * x) % b == 1, provided that\n    `a` and `b` are coprime (i.e., gcd(a, b) == 1). It uses the Extended Euclidean\n    Algorithm to compute the inverse. If `a` and `b` are not coprime, the modular\n    inverse does not exist, and the function returns `None`.\n    \n    Args:\n      a (int): The integer whose modular inverse is to be found.\n      b (int): The modulus with respect to which the inverse is sought.\n    \n    Returns:\n      int: The modular inverse of `a` modulo `b` if it exists, otherwise `None`.\n    \n    ", "canonical_solution": "def mod_inverse(a, b):\n    \n    def extended_gcd(a, b):\n        if a == 0:\n            return b, 0, 1\n        gcd, x1, y1 = extended_gcd(b % a, a)\n        x = y1 - (b // a) * x1\n        y = x1\n        return gcd, x, y\n    gcd, x, _ = extended_gcd(a, b)\n    if gcd != 1:\n        # Modular inverse does not exist since a and b are not coprime\n        return None\n    else:\n        # Make sure the result is positive\n        return x % b", "buggy_code": "def mod_inverse(a, b):\n    \n    def extended_gcd(a, b):\n        if a == 0:\n            return b, 0, 1\n        gcd, x1, y1 = extended_gcd(b % a, a)\n        x = y1 - (b / a) * x1\n        y = x1\n        return gcd, x, y\n    gcd, x, _ = extended_gcd(a, b)\n    if gcd != 1:\n        # Modular inverse does not exist since a and b are not coprime\n        return None\n    else:\n        # Make sure the result is positive\n        return x % b", "bug_with_line_numbers": "   1 | def mod_inverse(a, b):\n   2 |     def extended_gcd(a, b):\n   3 |         if a == 0:\n   4 |             return b, 0, 1\n   5 |         gcd, x1, y1 = extended_gcd(b % a, a)\n   6 |         x = y1 - (b / a) * x1\n   7 |         y = x1\n   8 |         return gcd, x, y\n   9 |     gcd, x, _ = extended_gcd(a, b)\n  10 |     if gcd != 1:\n  11 |         # Modular inverse does not exist since a and b are not coprime\n  12 |         return None\n  13 |     else:\n  14 |         # Make sure the result is positive\n  15 |         return x % b", "fragment_lines": [6], "fragment_content": ["        x = y1 - (b / a) * x1"], "test": "def check():\n    test_cases = [\n        (3, 10),  # Test case 1: gcd(3, 10) = 1, inverse should be 7\n        (17, 3120),  # Test case 2: gcd(17, 3120) = 1, inverse should be 2753\n        (42, 2017),  # Test case 3: gcd(42, 2017) = 1, inverse should be 1969\n    ]\n    expected_results = [\n        7,  # Expected result for test case 1\n        2753,  # Expected result for test case 2\n        1969,  # Expected result for test case 3\n    ]\n\n    for i, (a, b) in enumerate(test_cases):\n        actual_result = mod_inverse(a, b)\n        expected_result = expected_results[i]\n        assert actual_result == expected_result, f\"Test case {i+1} failed: expected {expected_result}, got {actual_result}\"\n        print(f\"Test case {i+1} passed: a={a}, b={b}, x0={actual_result}\")\n\n# Run the test function\ncheck()", "instruction": "Observe the following faulty Python code and its example\ncode:\n```python\ndef mod_inverse(a, b):\n    \n    def extended_gcd(a, b):\n        if a == 0:\n            return b, 0, 1\n        gcd, x1, y1 = extended_gcd(b % a, a)\n        x = y1 - (b / a) * x1\n        y = x1\n        return gcd, x, y\n    gcd, x, _ = extended_gcd(a, b)\n    if gcd != 1:\n        # Modular inverse does not exist since a and b are not coprime\n        return None\n    else:\n        # Make sure the result is positive\n        return x % b\n```\ncode example:\nExamples:\n      >>> mod_inverse(3, 10)\n      7\n\n      >>> mod_inverse(42, 2017)\n      None\nFix bugs in the given code snippet. The fixed code must be placed between ```python```. Do not generate any test, main,example usage or check code!\n"}
{"question_id": "Python/40", "category": "Logic", "subtype": "operation_error", "level": "easy", "example": "Cases:\n    >>> is_prime(2)\n    True\n    >>> is_prime(15)\n    False", "docstring": "Determine whether a given integer is a prime number.\n\n    A prime number is a natural number greater than 1 that has no positive divisors other than 1 and itself. The function checks for primality by eliminating non-prime numbers using several tests. First, it handles edge cases for numbers less than or equal to 1, which are not prime, and small numbers (2 and 3) which are prime. It then checks for divisibility by 2 and 3. For larger numbers, it uses a 6k +/- 1 optimization to test for factors up to the square root of the number.\n\n    Args:\n    num (int): The integer to check for primality.\n\n    Returns:\n    bool: True if `num` is a prime number, False otherwise.\n\n    ", "canonical_solution": "def is_prime(num: int) -> bool:\n    \n    \"\"\"Check if a number is a prime.\"\"\"\n    if num <= 1:\n        return False\n    if num <= 3:\n        return True\n    if num % 2 == 0 or num % 3 == 0:\n        return False\n    i = 5\n    while i * i <= num:\n        if num % i == 0 or num % (i + 2) == 0:\n            return False\n        i += 6\n    return True", "buggy_code": "def is_prime(num: int) -> bool:\n    \n    \"\"\"Check if a number is a prime.\"\"\"\n    if num <= 1:\n        return False\n    if num <= 3:\n        return True\n    if num % 2 == 0 || num % 3 == 0:\n        return False\n    i = 5\n    while i * i <= num:\n        if num % i == 0 or num % (i + 2) == 0:\n            return False\n        i += 6\n    return True", "bug_with_line_numbers": "   1 | def is_prime(num: int) -> bool:\n   2 |     \"\"\"Check if a number is a prime.\"\"\"\n   3 |     if num <= 1:\n   4 |         return False\n   5 |     if num <= 3:\n   6 |         return True\n   7 |     if num % 2 == 0 || num % 3 == 0:\n   8 |         return False\n   9 |     i = 5\n  10 |     while i * i <= num:\n  11 |         if num % i == 0 or num % (i + 2) == 0:\n  12 |             return False\n  13 |         i += 6\n  14 |     return True", "fragment_lines": [7], "fragment_content": ["    if num % 2 == 0 || num % 3 == 0:"], "test": "def check():\n    # Test case 1: Test a prime number\n    prime_number = 29\n    assert is_prime(prime_number) == True, f\"Test case 1 failed: {prime_number} is a prime number.\"\n\n    # Test case 2: Test a non-prime number\n    non_prime_number = 21  # 21 = 3 * 7, so it's not prime\n    assert is_prime(non_prime_number) == False, f\"Test case 2 failed: {non_prime_number} is not a prime number.\"\n\n    # Test case 3: Test a number less than 2 (should not be prime)\n    less_than_two = 1\n    assert is_prime(less_than_two) == False, f\"Test case 3 failed: {less_than_two} is not a prime number.\"\n\n    # Test case 4: Test another prime number\n    another_prime_number = 97\n    assert is_prime(another_prime_number) == True, f\"Test case 4 failed: {another_prime_number} is a prime number.\"\n\n    # Test case 5: Test zero (should not be prime)\n    zero = 0\n    assert is_prime(zero) == False, f\"Test case 5 failed: {zero} is not a prime number.\"\n\n    print(\"All test cases passed.\")\n\n# Run the test function\ncheck()", "instruction": "Observe the following faulty Python code and its example\ncode:\n```python\ndef is_prime(num: int) -> bool:\n    \n    \"\"\"Check if a number is a prime.\"\"\"\n    if num <= 1:\n        return False\n    if num <= 3:\n        return True\n    if num % 2 == 0 || num % 3 == 0:\n        return False\n    i = 5\n    while i * i <= num:\n        if num % i == 0 or num % (i + 2) == 0:\n            return False\n        i += 6\n    return True\n```\ncode example:\nCases:\n    >>> is_prime(2)\n    True\n    >>> is_prime(15)\n    False\nFix bugs in the given code snippet. The fixed code must be placed between ```python```. Do not generate any test, main,example usage or check code!\n"}
{"question_id": "Python/41", "category": "Logic", "subtype": "type_error", "level": "medium", "example": ">>> cantor_numbering(1)\n'1/1'", "docstring": "Determines the numerator and denominator of the N-th term in the Cantor table.\n\n    Args:\n    - N (int): The position in the Cantor table to find the corresponding fraction for.\n\n    Returns:\n    - str: A string representation of the fraction at the N-th position in the Cantor table.", "canonical_solution": "def cantor_numbering(N: int) -> str:\n    \n    line = 1\n    while N > line:\n        N -= line\n        line += 1\n\n    if line % 2 == 0:\n        numerator = N\n        denominator = line - N + 1\n    else:\n        numerator = line - N + 1\n        denominator = N\n\n    return f\"{numerator}/{denominator}\"", "buggy_code": "def cantor_numbering(N: int) -> str:\n    \n    line = 1\n    while N > line:\n        N -= line\n        line += 1\n\n    if line % 2 == 0:\n        numerator = N\n        denominator = line - N + 1\n    else:\n        numerator = line - N + 1\n        denominator = N\n\n    return numerator/denominator", "bug_with_line_numbers": "   1 | def cantor_numbering(N: int) -> str:\n   2 |     line = 1\n   3 |     while N > line:\n   4 |         N -= line\n   5 |         line += 1\n   6 |     if line % 2 == 0:\n   7 |         numerator = N\n   8 |         denominator = line - N + 1\n   9 |     else:\n  10 |         numerator = line - N + 1\n  11 |         denominator = N\n  12 |     return numerator/denominator", "fragment_lines": [12], "fragment_content": ["    return numerator/denominator"], "test": "def check():\n    # Test case 1: N = 1, the first element, should be \"1/1\"\n    assert cantor_numbering(1)==\"1/1\"\n\n    # Test case 2: N = 2, the second element, should be \"1/2\"\n    assert cantor_numbering(2)==\"1/2\"\n\n    # Test case 3: N = 6, the sixth element, should be \"1/3\"\n    assert cantor_numbering(6)==\"1/3\"\n\n    # Corrected test case: N = 7, the seventh element, should be \"1/4\"\n    assert cantor_numbering(7) == \"1/4\"\n\n    # Additional test case: N = 8, the eighth element, should be \"2/3\"\n    assert cantor_numbering(8) == \"2/3\"\n\n\ncheck()", "instruction": "Observe the following faulty Python code and its example\ncode:\n```python\ndef cantor_numbering(N: int) -> str:\n    \n    line = 1\n    while N > line:\n        N -= line\n        line += 1\n\n    if line % 2 == 0:\n        numerator = N\n        denominator = line - N + 1\n    else:\n        numerator = line - N + 1\n        denominator = N\n\n    return numerator/denominator\n```\ncode example:\n>>> cantor_numbering(1)\n'1/1'\nFix bugs in the given code snippet. The fixed code must be placed between ```python```. Do not generate any test, main,example usage or check code!\n"}
{"question_id": "Python/42", "category": "Logic", "subtype": "type_error", "level": "medium", "example": "max_product(\"123\", 3, 1)\n36", "docstring": "Function name: max_product\n    Arguments:\n    num_str (str): A string representing the number string.\n    N (int): An integer representing the length of the number string.\n    K (int): An integer representing the number of multiplication signs to insert.\n    Return type: int (The function returns the maximum product that can be obtained by inserting Kmultiplication signs into the number string.)", "canonical_solution": "def max_product(num_str: str, N: int, K: int) -> int:\n    \n    digits = [int(num_str[i]) for i in range(N)]\n    dp = [[0] * (K+1) for _ in range(N+1)]\n\n    for i in range(1, N+1):\n        dp[i][0] = dp[i-1][0] * 10 + digits[i-1]\n\n    for i in range(1, N+1):\n        for k in range(1, min(i, K)+1):\n            for j in range(k, i+1): \n                dp[i][k] = max(dp[i][k], dp[j-1][k-1] * int(num_str[j-1:i]))\n\n    return dp[N][K]", "buggy_code": "def max_product(num_str: str, N: int, K: int) -> int:\n    \n    digits = [num_str[i] for i in range(N)]\n    dp = [[0] * (K+1) for _ in range(N+1)]\n\n    for i in range(1, N+1):\n        dp[i][0] = dp[i-1][0] * 10 + digits[i-1]\n\n    for i in range(1, N+1):\n        for k in range(1, min(i, K)+1):\n            for j in range(k, i+1): \n                dp[i][k] = max(dp[i][k], dp[j-1][k-1] * int(num_str[j-1:i]))\n\n    return dp[N][K]", "bug_with_line_numbers": "   1 | def max_product(num_str: str, N: int, K: int) -> int:\n   2 |     digits = [num_str[i] for i in range(N)]\n   3 |     dp = [[0] * (K+1) for _ in range(N+1)]\n   4 |     for i in range(1, N+1):\n   5 |         dp[i][0] = dp[i-1][0] * 10 + digits[i-1]\n   6 |     for i in range(1, N+1):\n   7 |         for k in range(1, min(i, K)+1):\n   8 |             for j in range(k, i+1): \n   9 |                 dp[i][k] = max(dp[i][k], dp[j-1][k-1] * int(num_str[j-1:i]))\n  10 |     return dp[N][K]", "fragment_lines": [5], "fragment_content": ["        dp[i][0] = dp[i-1][0] * 10 + digits[i-1]"], "test": "def check():\n    # Test case 1\n    num_str1 = \"123\"\n    N1 = 3\n    K1 = 1\n    expected_result1 = 36  # Corrected expected result: 1*23 = 23 or 12*3 = 36, max is 36\n    assert max_product(num_str1, N1,\n                       K1) == expected_result1, f\"Test case 1 failed. Expected {expected_result1}, got {max_product(num_str1, N1, K1)}\"\n\n    # Test case 2\n    num_str2 = \"1234\"\n    N2 = 4\n    K2 = 2\n    expected_result2 = 144  # Corrected expected result: 1*2*34 = 68 or 12*3*4 = 144, max is 144\n    assert max_product(num_str2, N2,\n                       K2) == expected_result2, f\"Test case 2 failed. Expected {expected_result2}, got {max_product(num_str2, N2, K2)}\"\n\n    # Test case 3\n    num_str3 = \"051\"\n    N3 = 3\n    K3 = 1\n    expected_result3 = 5  # 0*51 = 0 or 05*1 = 5, max is 5\n    assert max_product(num_str3, N3,\n                       K3) == expected_result3, f\"Test case 3 failed. Expected {expected_result3}, got {max_product(num_str3, N3, K3)}\"\n\n    # If no assertion is raised, all test cases passed\n    print(\"All test cases passed!\")\ncheck()", "instruction": "Observe the following faulty Python code and its example\ncode:\n```python\ndef max_product(num_str: str, N: int, K: int) -> int:\n    \n    digits = [num_str[i] for i in range(N)]\n    dp = [[0] * (K+1) for _ in range(N+1)]\n\n    for i in range(1, N+1):\n        dp[i][0] = dp[i-1][0] * 10 + digits[i-1]\n\n    for i in range(1, N+1):\n        for k in range(1, min(i, K)+1):\n            for j in range(k, i+1): \n                dp[i][k] = max(dp[i][k], dp[j-1][k-1] * int(num_str[j-1:i]))\n\n    return dp[N][K]\n```\ncode example:\nmax_product(\"123\", 3, 1)\n36\nFix bugs in the given code snippet. The fixed code must be placed between ```python```. Do not generate any test, main,example usage or check code!\n"}
{"question_id": "Python/43", "category": "Logic", "subtype": "type_error", "level": "easy", "example": "Examples:\n    >>> verify_isbn(\"0-670-82162-4\")\n    'Right'\n    \n    >>> verify_isbn(\"0-670-82162-0\")\n    '0-670-82162-4'", "docstring": "Verify the correctness of a given ISBN number and correct it if necessary.\n\n    The function checks the provided ISBN number against the ISBN standard checksum calculation.\n    If the checksum is correct, the function returns \"Right\". If the checksum is incorrect,\n    the function returns the corrected ISBN number.\n\n    Args:\n    isbn: A string representing the ISBN number to be verified. The format should be 'x-xxx-xxxxx-x',\n          where 'x' is a digit, and the last 'x' could also be 'X' representing the checksum digit.\n\n    Returns:\n    A string that is either \"Right\" if the ISBN checksum is correct, or the corrected ISBN number\n    in the same format as the input if the checksum is incorrect.\n\n    ", "canonical_solution": "def verify_isbn(isbn: str) -> str:\n    \n    isbn_digits = isbn.replace('-', '')\n\n    total_sum = sum((i + 1) * int(digit) for i, digit in enumerate(isbn_digits[:-1]))\n    \n    check_digit = total_sum % 11\n\n    if check_digit == 10:\n        check_digit = 'X'\n    else:\n        check_digit = str(check_digit)\n\n    if check_digit == isbn_digits[-1]:\n        return \"Right\"\n    else:\n        return isbn[:-1] + check_digit", "buggy_code": "def verify_isbn(isbn: str) -> str:\n    \n    isbn_digits = isbn.replace('-', '')\n\n    total_sum = sum((i + 1) * int(digit) for i, digit in enumerate(isbn_digits[:-1]))\n    \n    check_digit = total_sum % 11\n\n    if check_digit == 10:\n        check_digit = 'X'\n    else:\n        check_digit = check_digit\n\n    if check_digit == isbn_digits[-1]:\n        return \"Right\"\n    else:\n        return isbn[:-1] + check_digit", "bug_with_line_numbers": "   1 | def verify_isbn(isbn: str) -> str:\n   2 |     isbn_digits = isbn.replace('-', '')\n   3 |     total_sum = sum((i + 1) * int(digit) for i, digit in enumerate(isbn_digits[:-1]))\n   4 |     check_digit = total_sum % 11\n   5 |     if check_digit == 10:\n   6 |         check_digit = 'X'\n   7 |     else:\n   8 |         check_digit = check_digit\n   9 |     if check_digit == isbn_digits[-1]:\n  10 |         return \"Right\"\n  11 |     else:\n  12 |         return isbn[:-1] + check_digit", "fragment_lines": [8], "fragment_content": ["        check_digit = check_digit"], "test": "def check():\n    # Test case 1: Correct ISBN number\n    assert verify_isbn(\"0-670-82162-4\") == \"Right\", \"Test case 1 failed\"\n\n    # Test case 2: Incorrect ISBN number with wrong checksum digit\n    assert verify_isbn(\"0-670-82162-0\") == \"0-670-82162-4\", \"Test case 2 failed\"\n\n    print(\"All test cases passed!\")\n\n# Run the test cases\ncheck()", "instruction": "Observe the following faulty Python code and its example\ncode:\n```python\ndef verify_isbn(isbn: str) -> str:\n    \n    isbn_digits = isbn.replace('-', '')\n\n    total_sum = sum((i + 1) * int(digit) for i, digit in enumerate(isbn_digits[:-1]))\n    \n    check_digit = total_sum % 11\n\n    if check_digit == 10:\n        check_digit = 'X'\n    else:\n        check_digit = check_digit\n\n    if check_digit == isbn_digits[-1]:\n        return \"Right\"\n    else:\n        return isbn[:-1] + check_digit\n```\ncode example:\nExamples:\n    >>> verify_isbn(\"0-670-82162-4\")\n    'Right'\n    \n    >>> verify_isbn(\"0-670-82162-0\")\n    '0-670-82162-4'\nFix bugs in the given code snippet. The fixed code must be placed between ```python```. Do not generate any test, main,example usage or check code!\n"}
{"question_id": "Python/44", "category": "Logic", "subtype": "type_error", "level": "hard", "example": "Cases:\n    >>> generate_numbers(234, [(2, 5), (3, 6)])\n    4\n    >>> generate_numbers(100, [(1, 9)])\n    2", "docstring": "Generate all unique numbers from the given number by applying transformation rules.\n\n    Each rule allows a single digit to be transformed into another. A breadth-first search\n    (BFS) is used to explore all possible transformations. The function returns the count\n    of unique numbers that can be generated from the original number, including the number itself.\n\n    Args:\n    - n (int): The original integer number to transform.\n    - rules (list of tuples): A list of transformation rules, where each rule is represented\n                              as a tuple (x, y) indicating that digit x can be transformed into y.\n\n    Returns:\n    - int: The total count of unique numbers that can be generated.\n\n    ", "canonical_solution": "from collections import deque\ndef generate_numbers(n, rules) -> int:\n    \n    str_n = str(n)\n    unique_numbers = {str_n}\n    queue = deque([str_n])\n    \n    while queue:\n        current = queue.popleft()\n        for i in range(len(current)):\n            for x, y in rules:\n                if current[i] == str(x):\n                    new_number = current[:i] + str(y) + current[i+1:]\n                    if new_number not in unique_numbers:\n                        unique_numbers.add(new_number)\n                        queue.append(new_number)\n    return len(unique_numbers)", "buggy_code": "from collections import deque\n\ndef generate_numbers(n, rules) -> int:\n    \n    str_n = str(n)\n    unique_numbers = {str_n}\n    queue = deque([str_n])\n    while queue:\n        current = queue.popleft()\n        for i in range(len(current)):\n            for x, y in rules:\n                if current[i] == x:\n                    new_number = current[:i] + y + current[i+1:]\n                    if new_number not in unique_numbers:\n                        unique_numbers.add(new_number)\n                        queue.append(new_number)\n    return len(unique_numbers)", "bug_with_line_numbers": "   1 | from collections import deque\n   2 | def generate_numbers(n, rules) -> int:\n   3 |     str_n = str(n)\n   4 |     unique_numbers = {str_n}\n   5 |     queue = deque([str_n])\n   6 |     while queue:\n   7 |         current = queue.popleft()\n   8 |         for i in range(len(current)):\n   9 |             for x, y in rules:\n  10 |                 if current[i] == x:\n  11 |                     new_number = current[:i] + y + current[i+1:]\n  12 |                     if new_number not in unique_numbers:\n  13 |                         unique_numbers.add(new_number)\n  14 |                         queue.append(new_number)\n  15 |     return len(unique_numbers)", "fragment_lines": [10, 11], "fragment_content": ["                if current[i] == x:", "                    new_number = current[:i] + y + current[i+1:]"], "test": "def check():\n    # Test case 1\n    n1, k1 = 234, 2\n    rules1 = [(2, 5), (3, 6)]\n    assert generate_numbers(n1, rules1) == 4, \"Test case 1 failed\"\n\n    # Test case 2\n    n2, k2 = 123, 3\n    rules2 = [(1, 9), (2, 8), (3, 7)]\n    assert generate_numbers(n2, rules2) == 8, \"Test case 2 failed\"\n\n    # Test case 3\n    n3, k3 = 999, 1\n    rules3 = [(9, 1)]\n    assert generate_numbers(n3, rules3) == 8, \"Test case 3 failed\"\n\n    print(\"All test cases passed!\")\n\n# Call the test function\ncheck()", "instruction": "Observe the following faulty Python code and its example\ncode:\n```python\nfrom collections import deque\n\ndef generate_numbers(n, rules) -> int:\n    \n    str_n = str(n)\n    unique_numbers = {str_n}\n    queue = deque([str_n])\n    while queue:\n        current = queue.popleft()\n        for i in range(len(current)):\n            for x, y in rules:\n                if current[i] == x:\n                    new_number = current[:i] + y + current[i+1:]\n                    if new_number not in unique_numbers:\n                        unique_numbers.add(new_number)\n                        queue.append(new_number)\n    return len(unique_numbers)\n```\ncode example:\nCases:\n    >>> generate_numbers(234, [(2, 5), (3, 6)])\n    4\n    >>> generate_numbers(100, [(1, 9)])\n    2\nFix bugs in the given code snippet. The fixed code must be placed between ```python```. Do not generate any test, main,example usage or check code!\n"}
{"question_id": "Python/45", "category": "Logic", "subtype": "variable_error", "level": "medium", "example": "Examples:\n    >>> max_value_on_paths(2, [(1, 2, 1), (2, 1, 2), (0, 0, 0)])\n    3\n    >>> max_value_on_paths(8, [\n    ...     (2, 3, 13), (2, 6, 6), (3, 5, 7), (4, 4, 14),\n    ...     (5, 2, 21), (5, 6, 4), (6, 3, 15), (7, 2, 14),\n    ...     (0, 0, 0)])\n    67", "docstring": "Calculate the maximum sum of values collected on two paths in an N x N grid.\n\n    This function utilizes dynamic programming to find two paths from the top-left corner to\n    the bottom-right corner of the grid which maximize the sum of the values collected. Each\n    value can be collected at most once, even if both paths pass through it.\n\n    Args:\n    - N (int): The size of the grid (N x N).\n    - grid_values (List[Tuple[int, int, int]]): A list of tuples where each tuple contains\n      the x-coordinate, y-coordinate, and value to be placed on the grid at that position.\n      The list is terminated by a tuple with all zeros.\n\n    Returns:\n    - int: The maximum sum of values collected on the two paths.\n\n    ", "canonical_solution": "from typing import List, Tuple\n\ndef max_value_on_paths(N: int, grid_values: List[Tuple[int, int, int]]) -> int:\n    \n    dp = [[[[0 for _ in range(N+1)] for _ in range(N+1)] for _ in range(N+1)] for _ in range(N+1)]\n    \n    grid = [[0 for _ in range(N+1)] for _ in range(N+1)]\n    for x, y, val in grid_values:\n        grid[x][y] = val\n    \n    for x1 in range(1, N+1):\n        for y1 in range(1, N+1):\n            for x2 in range(1, N+1):\n                for y2 in range(1, N+1):\n                    dp[x1][y1][x2][y2] = max(\n                        dp[x1-1][y1][x2-1][y2],\n                        dp[x1-1][y1][x2][y2-1],\n                        dp[x1][y1-1][x2-1][y2],\n                        dp[x1][y1-1][x2][y2-1]\n                    ) + grid[x1][y1] + (grid[x2][y2] if (x1, y1) != (x2, y2) else 0)\n    \n    return dp[N][N][N][N]", "buggy_code": "from typing import List, Tuple\n\ndef max_value_on_paths(N: int, grid_values: List[Tuple[int, int, int]]) -> int:\n    \n    dp = [[[[0 for _ in range(N+1)] for _ in range(N+1)] for _ in range(N+1)] for _ in range(N+1)]\n    \n    grid = [[]]\n    for x, y, val in grid_values:\n        grid[x][y] = val\n    \n    for x1 in range(1, N+1):\n        for y1 in range(1, N+1):\n            for x2 in range(1, N+1):\n                for y2 in range(1, N+1):\n                    dp[x1][y1][x2][y2] = max(\n                        dp[x1-1][y1][x2-1][y2],\n                        dp[x1-1][y1][x2][y2-1],\n                        dp[x1][y1-1][x2-1][y2],\n                        dp[x1][y1-1][x2][y2-1]\n                    ) + grid[x1][y1] + (grid[x2][y2] if (x1, y1) != (x2, y2) else 0)\n    \n    return dp[N][N][N][N]", "bug_with_line_numbers": "   1 | from typing import List, Tuple\n   2 | def max_value_on_paths(N: int, grid_values: List[Tuple[int, int, int]]) -> int:\n   3 |     dp = [[[[0 for _ in range(N+1)] for _ in range(N+1)] for _ in range(N+1)] for _ in range(N+1)]\n   4 |     grid = [[]]\n   5 |     for x, y, val in grid_values:\n   6 |         grid[x][y] = val\n   7 |     for x1 in range(1, N+1):\n   8 |         for y1 in range(1, N+1):\n   9 |             for x2 in range(1, N+1):\n  10 |                 for y2 in range(1, N+1):\n  11 |                     dp[x1][y1][x2][y2] = max(\n  12 |                         dp[x1-1][y1][x2-1][y2],\n  13 |                         dp[x1-1][y1][x2][y2-1],\n  14 |                         dp[x1][y1-1][x2-1][y2],\n  15 |                         dp[x1][y1-1][x2][y2-1]\n  16 |                     ) + grid[x1][y1] + (grid[x2][y2] if (x1, y1) != (x2, y2) else 0)\n  17 |     return dp[N][N][N][N]", "fragment_lines": [4], "fragment_content": ["    grid = [[]]"], "test": "def check():\n    # Test case 1: Small grid with clear path\n    assert max_value_on_paths(2, [(1, 2, 1), (2, 1, 2), (0, 0, 0)]) == 3\n    \n    # Test case 2: Example provided in the problem statement\n    assert max_value_on_paths(8, [\n        (2, 3, 13), (2, 6, 6), (3, 5, 7), (4, 4, 14),\n        (5, 2, 21), (5, 6, 4), (6, 3, 15), (7, 2, 14),\n        (0, 0, 0)]) == 67\n\n    print(\"All test cases passed!\")\n\ncheck()", "instruction": "Observe the following faulty Python code and its example\ncode:\n```python\nfrom typing import List, Tuple\n\ndef max_value_on_paths(N: int, grid_values: List[Tuple[int, int, int]]) -> int:\n    \n    dp = [[[[0 for _ in range(N+1)] for _ in range(N+1)] for _ in range(N+1)] for _ in range(N+1)]\n    \n    grid = [[]]\n    for x, y, val in grid_values:\n        grid[x][y] = val\n    \n    for x1 in range(1, N+1):\n        for y1 in range(1, N+1):\n            for x2 in range(1, N+1):\n                for y2 in range(1, N+1):\n                    dp[x1][y1][x2][y2] = max(\n                        dp[x1-1][y1][x2-1][y2],\n                        dp[x1-1][y1][x2][y2-1],\n                        dp[x1][y1-1][x2-1][y2],\n                        dp[x1][y1-1][x2][y2-1]\n                    ) + grid[x1][y1] + (grid[x2][y2] if (x1, y1) != (x2, y2) else 0)\n    \n    return dp[N][N][N][N]\n```\ncode example:\nExamples:\n    >>> max_value_on_paths(2, [(1, 2, 1), (2, 1, 2), (0, 0, 0)])\n    3\n    >>> max_value_on_paths(8, [\n    ...     (2, 3, 13), (2, 6, 6), (3, 5, 7), (4, 4, 14),\n    ...     (5, 2, 21), (5, 6, 4), (6, 3, 15), (7, 2, 14),\n    ...     (0, 0, 0)])\n    67\nFix bugs in the given code snippet. The fixed code must be placed between ```python```. Do not generate any test, main,example usage or check code!\n"}
{"question_id": "Python/46", "category": "Logic", "subtype": "variable_error", "level": "easy", "example": "Examples:\n    >>> sum_of_factorials_optimized(3)\n    9\n    >>> sum_of_factorials_optimized(5)\n    153", "docstring": "Compute the cumulative sum of factorial values from 1 up to a specified integer n.\n\n    This function employs a more efficient method to calculate factorials by iteratively\n    multiplying the current number to the previous factorial result, thus avoiding redundant\n    calculations. It then accumulates the factorial of each number from 1 to n inclusively.\n\n    Args:\n    n (int): The upper limit of the range for which the factorial sum is to be calculated.\n             The value of n should be in the range of 1 to 50, inclusive.\n\n    Returns:\n    int: The sum of all factorial values from 1! to n!.\n\n    ", "canonical_solution": "def sum_of_factorials_optimized(n: int) -> int:\n    \n    sum_factorials = 0\n    current_factorial = 1\n    for i in range(1, n + 1):\n        current_factorial *= i\n        sum_factorials += current_factorial\n    return sum_factorials", "buggy_code": "def sum_of_factorials_optimized(n: int) -> int:\n    \n    sum_factorials = 0\n    current_factorial = 0\n    for i in range(1, n + 1):\n        current_factorial *= i\n        sum_factorials += current_factorial\n    return sum_factorials", "bug_with_line_numbers": "   1 | def sum_of_factorials_optimized(n: int) -> int:\n   2 |     sum_factorials = 0\n   3 |     current_factorial = 0\n   4 |     for i in range(1, n + 1):\n   5 |         current_factorial *= i\n   6 |         sum_factorials += current_factorial\n   7 |     return sum_factorials", "fragment_lines": [3], "fragment_content": ["    current_factorial = 0"], "test": "def check():\n    assert sum_of_factorials_optimized(1) == 1, \"Test case 1 failed: sum_of_factorials_optimized(1) should be 1.\"\n    assert sum_of_factorials_optimized(3) == 9, \"Test case 2 failed: sum_of_factorials_optimized(3) should be 9.\"\n    assert sum_of_factorials_optimized(4) == 33, \"Test case 3 failed: sum_of_factorials_optimized(4) should be 33.\"\n    assert sum_of_factorials_optimized(5) == 153, \"Test case 4 failed: sum_of_factorials_optimized(5) should be 153.\"\n    assert sum_of_factorials_optimized(6) == 873, \"Test case 5 failed: sum_of_factorials_optimized(6) should be 873.\"\n    assert sum_of_factorials_optimized(10) == 4037913, \"Test case 6 failed: sum_of_factorials_optimized(10) should be 4037913.\"\n    print(\"All test cases passed.\")\n\n# Call the test function to run the test cases\ncheck()", "instruction": "Observe the following faulty Python code and its example\ncode:\n```python\ndef sum_of_factorials_optimized(n: int) -> int:\n    \n    sum_factorials = 0\n    current_factorial = 0\n    for i in range(1, n + 1):\n        current_factorial *= i\n        sum_factorials += current_factorial\n    return sum_factorials\n```\ncode example:\nExamples:\n    >>> sum_of_factorials_optimized(3)\n    9\n    >>> sum_of_factorials_optimized(5)\n    153\nFix bugs in the given code snippet. The fixed code must be placed between ```python```. Do not generate any test, main,example usage or check code!\n"}
{"question_id": "Python/47", "category": "Logic", "subtype": "variable_error", "level": "medium", "example": "Cases:\n    >>> count_passing_ways(3, 3)\n    2\n    >>> count_passing_ways(5, 4)\n    6", "docstring": "Counts the number of different ways to pass a ball among 'n' students arranged in a circle \n    such that after 'm' passes, the ball returns to the starting student.\n\n    The function uses dynamic programming to determine the number of passing sequences. Each student\n    can pass the ball either to the left neighbor or to the right neighbor.\n\n    Args:\n    n: The number of students standing in a circle.\n    m: The number of times the ball is passed.\n\n    Returns:\n    An integer representing the number of distinct passing ways that result in the ball\n    returning to the starting student after 'm' passes.\n\n    ", "canonical_solution": "def count_passing_ways(n: int, m: int) -> int:\n    \n    dp = [[0] * n for _ in range(m + 1)]\n\n    dp[0][0] = 1\n\n    for i in range(1, m + 1):\n        for j in range(n):\n            dp[i][j] = dp[i - 1][(j - 1 + n) % n] + dp[i - 1][(j + 1) % n]\n\n    return dp[m][0]", "buggy_code": "def count_passing_ways(n: int, m: int) -> int:\n    \n    dp = [[0] * n for _ in range(m + 1)]\n\n    for i in range(1, m + 1):\n        for j in range(n):\n            dp[i][j] = dp[i - 1][(j - 1 + n) % n] + dp[i - 1][(j + 1) % n]\n\n    return dp[m][0]", "bug_with_line_numbers": "   1 | def count_passing_ways(n: int, m: int) -> int:\n   2 |     dp = [[0] * n for _ in range(m + 1)]\n   3 |     for i in range(1, m + 1):\n   4 |         for j in range(n):\n   5 |             dp[i][j] = dp[i - 1][(j - 1 + n) % n] + dp[i - 1][(j + 1) % n]\n   6 |     return dp[m][0]", "fragment_lines": [-1], "fragment_content": ["missing critical code snippet"], "test": "def check():\n    test_cases = [\n        # Test case 1: simple case\n        {\n            'n': 3,\n            'm': 1,\n            'expected': 0\n        },\n        # Test case 2: another simple case\n        {\n            'n': 4,\n            'm': 2,\n            'expected': 2\n        },\n        # Test case 3: larger number of students and passes\n        {\n            'n': 5,\n            'm': 3,\n            'expected': 0\n        },\n    ]\n\n    for i, test in enumerate(test_cases, 1):\n        result = count_passing_ways(test['n'], test['m'])\n        assert result == test['expected'], f\"Test case {i} failed: result {result} does not match expected {test['expected']}\"\n        print(f\"Test case {i} passed with result {result}.\")\n\n# Run the test function\ncheck()\n", "instruction": "Observe the following faulty Python code and its example\ncode:\n```python\ndef count_passing_ways(n: int, m: int) -> int:\n    \n    dp = [[0] * n for _ in range(m + 1)]\n\n    for i in range(1, m + 1):\n        for j in range(n):\n            dp[i][j] = dp[i - 1][(j - 1 + n) % n] + dp[i - 1][(j + 1) % n]\n\n    return dp[m][0]\n```\ncode example:\nCases:\n    >>> count_passing_ways(3, 3)\n    2\n    >>> count_passing_ways(5, 4)\n    6\nFix bugs in the given code snippet. The fixed code must be placed between ```python```. Do not generate any test, main,example usage or check code!\n"}
{"question_id": "Python/48", "category": "Logic", "subtype": "variable_error", "level": "easy", "example": "Cases:\n    >>> is_prime(2)\n    True\n    >>> is_prime(15)\n    False\n    \"\"\"", "docstring": "Determine whether a given integer is a prime number.\n\n    A prime number is a natural number greater than 1 that has no positive divisors other than 1 and itself. The function checks for primality by eliminating non-prime numbers using several tests. First, it handles edge cases for numbers less than or equal to 1, which are not prime, and small numbers (2 and 3) which are prime. It then checks for divisibility by 2 and 3. For larger numbers, it uses a 6k +/- 1 optimization to test for factors up to the square root of the number.\n\n    Args:\n    num (int): The integer to check for primality.\n\n    Returns:\n    bool: True if `num` is a prime number, False otherwise.\n\n    Cases:\n    >>> is_prime(2)\n    True\n    >>> is_prime(15)\n    False", "canonical_solution": "def is_prime(num: int) -> bool:\n    \n    \"\"\"Check if a number is a prime.\"\"\"\n    if num <= 1:\n        return False\n    if num <= 3:\n        return True\n    if num % 2 == 0 or num % 3 == 0:\n        return False\n    i = 5\n    while i * i <= num:\n        if num % i == 0 or num % (i + 2) == 0:\n            return False\n        i += 6\n    return True", "buggy_code": "def is_prime(num: int) -> bool:\n    \n    \"\"\"Check if a number is a prime.\"\"\"\n    if num <= 1:\n        return False\n    if num <= 3:\n        return True\n    if num % 2 == 0 or num % 3 == 0:\n        return False\n    i = 1\n    while i * i <= num:\n        if num % i == 0 or num % (i + 2) == 0:\n            return False\n        i += 6\n    return True", "bug_with_line_numbers": "   1 | def is_prime(num: int) -> bool:\n   2 |     \"\"\"Check if a number is a prime.\"\"\"\n   3 |     if num <= 1:\n   4 |         return False\n   5 |     if num <= 3:\n   6 |         return True\n   7 |     if num % 2 == 0 or num % 3 == 0:\n   8 |         return False\n   9 |     i = 1\n  10 |     while i * i <= num:\n  11 |         if num % i == 0 or num % (i + 2) == 0:\n  12 |             return False\n  13 |         i += 6\n  14 |     return True", "fragment_lines": [9], "fragment_content": ["    i = 1"], "test": "def check():\n    # Test case 1: Test a prime number\n    prime_number = 29\n    assert is_prime(prime_number) == True, f\"Test case 1 failed: {prime_number} is a prime number.\"\n\n    # Test case 2: Test a non-prime number\n    non_prime_number = 21  # 21 = 3 * 7, so it's not prime\n    assert is_prime(non_prime_number) == False, f\"Test case 2 failed: {non_prime_number} is not a prime number.\"\n\n    # Test case 3: Test a number less than 2 (should not be prime)\n    less_than_two = 1\n    assert is_prime(less_than_two) == False, f\"Test case 3 failed: {less_than_two} is not a prime number.\"\n\n    # Test case 4: Test another prime number\n    another_prime_number = 97\n    assert is_prime(another_prime_number) == True, f\"Test case 4 failed: {another_prime_number} is a prime number.\"\n\n    # Test case 5: Test zero (should not be prime)\n    zero = 0\n    assert is_prime(zero) == False, f\"Test case 5 failed: {zero} is not a prime number.\"\n\n    print(\"All test cases passed.\")\n\n# Run the test function\ncheck()", "instruction": "Observe the following faulty Python code and its example\ncode:\n```python\ndef is_prime(num: int) -> bool:\n    \n    \"\"\"Check if a number is a prime.\"\"\"\n    if num <= 1:\n        return False\n    if num <= 3:\n        return True\n    if num % 2 == 0 or num % 3 == 0:\n        return False\n    i = 1\n    while i * i <= num:\n        if num % i == 0 or num % (i + 2) == 0:\n            return False\n        i += 6\n    return True\n```\ncode example:\nCases:\n    >>> is_prime(2)\n    True\n    >>> is_prime(15)\n    False\n    \"\"\"\nFix bugs in the given code snippet. The fixed code must be placed between ```python```. Do not generate any test, main,example usage or check code!\n"}
{"question_id": "Python/49", "category": "Multiple", "subtype": "double_bug", "level": "hard", "example": "Examples:\n    >>> string_transformation(\"abcd\", \"xyz\", [(\"abc\", \"xu\"), (\"ud\", \"y\"), (\"y\", \"yz\")])\n    3\n    >>> string_transformation(\"aaa\", \"bbbb\", [(\"a\", \"b\"), (\"aa\", \"bb\"), (\"aaa\", \"bbb\")])\n    'NO ANSWER!'", "docstring": "Perform string transformation from A to B using a set of transformation rules.\n\n    This function takes an initial string A and a target string B, along with a list\n    of transformation rules, and attempts to transform A into B using the rules.\n    A Breadth-First Search (BFS) algorithm is used to explore the possible transformations\n    up to a maximum of 10 steps. If A can be transformed into B within 10 steps, the function\n    returns the minimum number of steps required. If it's not possible, the function returns\n    \"NO ANSWER!\".\n\n    Parameters:\n    A (str): The initial string to be transformed.\n    B (str): The target string to be achieved.\n    rules (list of tuples): A list of transformation rules, where each rule is a tuple\n                            containing the source substring (to be replaced) and the\n                            target substring (to replace with).\n\n    Returns:\n    Union[int, str]: The minimum number of transformation steps if possible, otherwise \"NO ANSWER!\".\n\n    ", "canonical_solution": "from collections import deque\nfrom typing import Union\ndef string_transformation(A: str, B: str, rules: list) -> Union[int, str]:\n    \n\n    queue = deque([(A, 0)]) \n    visited = set([A])\n\n    # Perform BFS\n    while queue:\n        current, steps = queue.popleft()\n        if current == B:\n            return steps\n        if steps == 10:\n            continue\n        for source, target in rules:\n            index = current.find(source)\n            while index != -1:\n                next_string = current[:index] + target + current[index + len(source):]\n                if next_string not in visited:\n                    visited.add(next_string)\n                    queue.append((next_string, steps + 1))\n                index = current.find(source, index + 1)\n    return \"NO ANSWER!\"", "buggy_code": "from collections import deque\nfrom typing import Union\ndef string_transformation(A: str, B: str, rules: list) -> Union[int, str]:\n    \n\n    queue = deque([(A, 0)]) \n    visited = set([A])\n\n    while queue:\n        current, steps = queue.popleft()\n        if current == B:\n            return steps\n        if steps == 10:\n            continue\n        for source, target in rules:\n            index = current.find(source)\n            while index != -1:\n                next_string = current[:index] + target + current[len(source):]\n                if next_string not in visited:\n                    visited.add(next_string)\n                    queue.append((next_string, steps))\n                index = current.find(source, index + 1)\n    return \"NO ANSWER!\"", "bug_with_line_numbers": "   1 | from collections import deque\n   2 | from typing import Union\n   3 | def string_transformation(A: str, B: str, rules: list) -> Union[int, str]:\n   4 |     queue = deque([(A, 0)]) \n   5 |     visited = set([A])\n   6 |     while queue:\n   7 |         current, steps = queue.popleft()\n   8 |         if current == B:\n   9 |             return steps\n  10 |         if steps == 10:\n  11 |             continue\n  12 |         for source, target in rules:\n  13 |             index = current.find(source)\n  14 |             while index != -1:\n  15 |                 next_string = current[:index] + target + current[len(source):]\n  16 |                 if next_string not in visited:\n  17 |                     visited.add(next_string)\n  18 |                     queue.append((next_string, steps))\n  19 |                 index = current.find(source, index + 1)\n  20 |     return \"NO ANSWER!\"", "fragment_lines": [15, 18], "fragment_content": ["                next_string = current[:index] + target + current[len(source):]", "                    queue.append((next_string, steps))"], "test": "def check():\n    # Test case 1\n    A1 = \"abcd\"\n    B1 = \"xyz\"\n    rules1 = [(\"abc\", \"xu\"), (\"ud\", \"y\"), (\"y\", \"yz\")]\n    expected_result1 = 3\n    assert string_transformation(A1, B1, rules1) == expected_result1, \"Test case 1 failed\"\n\n    # Test case 2\n    A2 = \"aaa\"\n    B2 = \"bbbb\"\n    rules2 = [(\"a\", \"b\"), (\"aa\", \"bb\"), (\"aaa\", \"bbb\")]\n    expected_result2 = \"NO ANSWER!\"\n    assert string_transformation(A2, B2, rules2) == expected_result2, \"Test case 2 failed\"\n\n    # Test case 3\n    A3 = \"hello\"\n    B3 = \"world\"\n    rules3 = [(\"h\", \"w\"), (\"e\", \"o\"), (\"l\", \"r\"), (\"lol\", \"ldr\")]\n    expected_result3 = \"NO ANSWER!\"\n    assert string_transformation(A3, B3, rules3) == expected_result3, \"Test case 3 failed\"\n\n    print(\"All test cases passed!\")\n\n# Run the test function\ncheck()", "instruction": "Observe the following faulty Python code and its example\ncode:\n```python\nfrom collections import deque\nfrom typing import Union\ndef string_transformation(A: str, B: str, rules: list) -> Union[int, str]:\n    \n\n    queue = deque([(A, 0)]) \n    visited = set([A])\n\n    while queue:\n        current, steps = queue.popleft()\n        if current == B:\n            return steps\n        if steps == 10:\n            continue\n        for source, target in rules:\n            index = current.find(source)\n            while index != -1:\n                next_string = current[:index] + target + current[len(source):]\n                if next_string not in visited:\n                    visited.add(next_string)\n                    queue.append((next_string, steps))\n                index = current.find(source, index + 1)\n    return \"NO ANSWER!\"\n```\ncode example:\nExamples:\n    >>> string_transformation(\"abcd\", \"xyz\", [(\"abc\", \"xu\"), (\"ud\", \"y\"), (\"y\", \"yz\")])\n    3\n    >>> string_transformation(\"aaa\", \"bbbb\", [(\"a\", \"b\"), (\"aa\", \"bb\"), (\"aaa\", \"bbb\")])\n    'NO ANSWER!'\nFix bugs in the given code snippet. The fixed code must be placed between ```python```. Do not generate any test, main,example usage or check code!\n"}
{"question_id": "Python/50", "category": "Multiple", "subtype": "double_bug", "level": "easy", "example": "Examples:\n    >>> string_transformation(\"abcd\", \"xyz\", [(\"abc\", \"xu\"), (\"ud\", \"y\"), (\"y\", \"yz\")])\n    3\n    >>> string_transformation(\"aaa\", \"bbbb\", [(\"a\", \"b\"), (\"aa\", \"bb\"), (\"aaa\", \"bbb\")])\n    'NO ANSWER!'", "docstring": "Reconstructs the binary tree from its inorder and postorder traversals and\n    returns the preorder traversal as a string.\n\n    Args:\n    inorder (str): The inorder traversal of the binary tree.\n    postorder (str): The postorder traversal of the binary tree.\n\n    Returns:\n    str: The preorder traversal of the binary tree.\n\n    Example:\n    >>> preorder_traversal('BADC', 'BDCA')\n    'ABCD'\n    >>> preorder_traversal('A', 'A')\n    'A'", "canonical_solution": "def preorder_traversal(inorder: str, postorder: str) -> str:\n    \n    if not inorder or not postorder:\n        return \"\"\n    root = postorder[-1]\n    root_index = inorder.index(root)\n    left_preorder = preorder_traversal(inorder[:root_index], postorder[:root_index])\n    right_preorder = preorder_traversal(inorder[root_index+1:], postorder[root_index:-1])\n    return root + left_preorder + right_preorder", "buggy_code": "def preorder_traversal(inorder: str, postorder: str) -> str:\n    \n    if not inorder or not postorder:\n        return \"\"\n    root = postorder[-1]\n    root_index = inorder.index(root)\n    left_preorder = preorder_traversal(postorder[:root_index],inorder[:root_index])\n    right_preorder = preorder_traversal(inorder[root_index+1:], postorder[root_index:])\n    return root + left_preorder + right_preorder", "bug_with_line_numbers": "   1 | def preorder_traversal(inorder: str, postorder: str) -> str:\n   2 |     if not inorder or not postorder:\n   3 |         return \"\"\n   4 |     root = postorder[-1]\n   5 |     root_index = inorder.index(root)\n   6 |     left_preorder = preorder_traversal(postorder[:root_index],inorder[:root_index])\n   7 |     right_preorder = preorder_traversal(inorder[root_index+1:], postorder[root_index:])\n   8 |     return root + left_preorder + right_preorder", "fragment_lines": [6, 7], "fragment_content": ["    left_preorder = preorder_traversal(postorder[:root_index],inorder[:root_index])", "    right_preorder = preorder_traversal(inorder[root_index+1:], postorder[root_index:])"], "test": "def check():\n    # Test case 1\n    inorder1 = \"BADC\"\n    postorder1 = \"BDCA\"\n    expected_preorder1 = \"ABCD\"\n    assert preorder_traversal(inorder1, postorder1) == expected_preorder1\n    print(f\"Test case 1 passed. Preorder: {preorder_traversal(inorder1, postorder1)}\")\n\n    # Test case 2\n    inorder2 = \"DBGEACF\"\n    postorder2 = \"DGEBFCA\"\n    expected_preorder2 = \"ABDEGCF\"\n    assert preorder_traversal(inorder2, postorder2) == expected_preorder2\n    print(f\"Test case 2 passed. Preorder: {preorder_traversal(inorder2, postorder2)}\")\n\n    # Test case 3\n    inorder3 = \"A\"\n    postorder3 = \"A\"\n    expected_preorder3 = \"A\"\n    assert preorder_traversal(inorder3, postorder3) == expected_preorder3\n    print(f\"Test case 3 passed. Preorder: {preorder_traversal(inorder3, postorder3)}\")\n\n# Run the test function\ncheck()", "instruction": "Observe the following faulty Python code and its example\ncode:\n```python\ndef preorder_traversal(inorder: str, postorder: str) -> str:\n    \n    if not inorder or not postorder:\n        return \"\"\n    root = postorder[-1]\n    root_index = inorder.index(root)\n    left_preorder = preorder_traversal(postorder[:root_index],inorder[:root_index])\n    right_preorder = preorder_traversal(inorder[root_index+1:], postorder[root_index:])\n    return root + left_preorder + right_preorder\n```\ncode example:\nExamples:\n    >>> string_transformation(\"abcd\", \"xyz\", [(\"abc\", \"xu\"), (\"ud\", \"y\"), (\"y\", \"yz\")])\n    3\n    >>> string_transformation(\"aaa\", \"bbbb\", [(\"a\", \"b\"), (\"aa\", \"bb\"), (\"aaa\", \"bbb\")])\n    'NO ANSWER!'\nFix bugs in the given code snippet. The fixed code must be placed between ```python```. Do not generate any test, main,example usage or check code!\n"}
{"question_id": "Python/51", "category": "Multiple", "subtype": "double_bug", "level": "medium", "example": "cantor_numbering(1)\n\"1/1\"", "docstring": "Determines the numerator and denominator of the N-th term in the Cantor table.\n\n    Args:\n    - N (int): The position in the Cantor table to find the corresponding fraction for.\n\n    Returns:\n    - str: A string representation of the fraction at the N-th position in the Cantor table.", "canonical_solution": "def cantor_numbering(N: int) -> str:\n    \n    line = 1\n    while N > line:\n        N -= line\n        line += 1\n\n    if line % 2 == 0:\n        numerator = N\n        denominator = line - N + 1\n    else:\n        numerator = line - N + 1\n        denominator = N\n\n    return f\"{numerator}/{denominator}\"", "buggy_code": "def cantor_numbering(N: int) -> str:\n    \n    line = 1\n    while N > line:\n        N -= line\n        line += 1\n\n    if line % 2 == 0:\n        numerator = N\n        denominator = line - N\n    else:\n        numerator = line - N\n        denominator = N\n\n    return numerator/denominator", "bug_with_line_numbers": "   1 | def cantor_numbering(N: int) -> str:\n   2 |     line = 1\n   3 |     while N > line:\n   4 |         N -= line\n   5 |         line += 1\n   6 |     if line % 2 == 0:\n   7 |         numerator = N\n   8 |         denominator = line - N\n   9 |     else:\n  10 |         numerator = line - N\n  11 |         denominator = N\n  12 |     return numerator/denominator", "fragment_lines": [8, 12], "fragment_content": ["        denominator = line - N", "    return numerator/denominator"], "test": "def check():\n    # Test case 1: N = 1, the first element, should be \"1/1\"\n    assert cantor_numbering(1)==\"1/1\"\n\n    # Test case 2: N = 2, the second element, should be \"1/2\"\n    assert cantor_numbering(2)==\"1/2\"\n\n    # Test case 3: N = 6, the sixth element, should be \"1/3\"\n    assert cantor_numbering(6)==\"1/3\"\n\n    # Corrected test case: N = 7, the seventh element, should be \"1/4\"\n    assert cantor_numbering(7) == \"1/4\"\n\n    # Additional test case: N = 8, the eighth element, should be \"2/3\"\n    assert cantor_numbering(8) == \"2/3\"\n\n\ncheck()", "instruction": "Observe the following faulty Python code and its example\ncode:\n```python\ndef cantor_numbering(N: int) -> str:\n    \n    line = 1\n    while N > line:\n        N -= line\n        line += 1\n\n    if line % 2 == 0:\n        numerator = N\n        denominator = line - N\n    else:\n        numerator = line - N\n        denominator = N\n\n    return numerator/denominator\n```\ncode example:\ncantor_numbering(1)\n\"1/1\"\nFix bugs in the given code snippet. The fixed code must be placed between ```python```. Do not generate any test, main,example usage or check code!\n"}
{"question_id": "Python/52", "category": "Multiple", "subtype": "double_bug", "level": "hard", "example": "max_product(\"123\", 3, 1)\n# Expected: 36", "docstring": "Function name: max_product\n    Arguments:\n    num_str (str): A string representing the number string.\n    N (int): An integer representing the length of the number string.\n    K (int): An integer representing the number of multiplication signs to insert.\n    Return type: int (The function returns the maximum product that can be obtained by inserting Kmultiplication signs into the number string.)", "canonical_solution": "def max_product(num_str: str, N: int, K: int) -> int:\n    \n    digits = [int(num_str[i]) for i in range(N)]\n    dp = [[0] * (K+1) for _ in range(N+1)]\n\n    for i in range(1, N+1):\n        dp[i][0] = dp[i-1][0] * 10 + digits[i-1]\n\n    for i in range(1, N+1):\n        for k in range(1, min(i, K)+1):\n            for j in range(k, i+1): \n                dp[i][k] = max(dp[i][k], dp[j-1][k-1] * int(num_str[j-1:i]))\n\n    return dp[N][K]", "buggy_code": "def max_product(num_str: str, N: int, K: int) -> int:\n    \n    digits = [int(num_str[i]) for i in range(N)]\n    dp = [[0] * (K+1) for _ in range(N+1)]\n\n    for i in range(1, N+1):\n        dp[i][0] = dp[i-1][0] * 10 + digits[i-1]\n\n    for i in range(1, N+1):\n        for k in range(1, min(i, K)+1):\n            for j in range(k, i): \n                dp[i][k] = max(dp[i][k], dp[j-1][k-1] * int(num_str[j-1:i])\n\n    return dp[N][K]", "bug_with_line_numbers": "   1 | def max_product(num_str: str, N: int, K: int) -> int:\n   2 |     digits = [int(num_str[i]) for i in range(N)]\n   3 |     dp = [[0] * (K+1) for _ in range(N+1)]\n   4 |     for i in range(1, N+1):\n   5 |         dp[i][0] = dp[i-1][0] * 10 + digits[i-1]\n   6 |     for i in range(1, N+1):\n   7 |         for k in range(1, min(i, K)+1):\n   8 |             for j in range(k, i): \n   9 |                 dp[i][k] = max(dp[i][k], dp[j-1][k-1] * int(num_str[j-1:i])\n  10 |     return dp[N][K]", "fragment_lines": [8, 9], "fragment_content": ["            for j in range(k, i):", "                dp[i][k] = max(dp[i][k], dp[j-1][k-1] * int(num_str[j-1:i])"], "test": "def check():\n    # Test case 1\n    num_str1 = \"123\"\n    N1 = 3\n    K1 = 1\n    expected_result1 = 36  # Corrected expected result: 1*23 = 23 or 12*3 = 36, max is 36\n    assert max_product(num_str1, N1,\n                       K1) == expected_result1, f\"Test case 1 failed. Expected {expected_result1}, got {max_product(num_str1, N1, K1)}\"\n\n    # Test case 2\n    num_str2 = \"1234\"\n    N2 = 4\n    K2 = 2\n    expected_result2 = 144  # Corrected expected result: 1*2*34 = 68 or 12*3*4 = 144, max is 144\n    assert max_product(num_str2, N2,\n                       K2) == expected_result2, f\"Test case 2 failed. Expected {expected_result2}, got {max_product(num_str2, N2, K2)}\"\n\n    # Test case 3\n    num_str3 = \"051\"\n    N3 = 3\n    K3 = 1\n    expected_result3 = 5  # 0*51 = 0 or 05*1 = 5, max is 5\n    assert max_product(num_str3, N3,\n                       K3) == expected_result3, f\"Test case 3 failed. Expected {expected_result3}, got {max_product(num_str3, N3, K3)}\"\n\n    # If no assertion is raised, all test cases passed\n    print(\"All test cases passed!\")\ncheck()", "instruction": "Observe the following faulty Python code and its example\ncode:\n```python\ndef max_product(num_str: str, N: int, K: int) -> int:\n    \n    digits = [int(num_str[i]) for i in range(N)]\n    dp = [[0] * (K+1) for _ in range(N+1)]\n\n    for i in range(1, N+1):\n        dp[i][0] = dp[i-1][0] * 10 + digits[i-1]\n\n    for i in range(1, N+1):\n        for k in range(1, min(i, K)+1):\n            for j in range(k, i): \n                dp[i][k] = max(dp[i][k], dp[j-1][k-1] * int(num_str[j-1:i])\n\n    return dp[N][K]\n```\ncode example:\nmax_product(\"123\", 3, 1)\n# Expected: 36\nFix bugs in the given code snippet. The fixed code must be placed between ```python```. Do not generate any test, main,example usage or check code!\n"}
{"question_id": "Python/53", "category": "Multiple", "subtype": "triple_bug", "level": "medium", "example": "Example Cases:\n\n    >>> count_coprime_pairs(3, 60)\n    4\n    >>> count_coprime_pairs(2, 50)\n    0", "docstring": "Counts the number of pairs of positive integers (P, Q) such that P and Q have x0 as their greatest common divisor (GCD)\n    and y0 as their least common multiple (LCM).\n\n    Args:\n    x0 (int): The GCD that each pair (P, Q) must have.\n    y0 (int): The LCM that each pair (P, Q) must have.\n\n    Returns:\n    int: The count of all possible pairs (P, Q) that meet the specified criteria.\n\n    The function iterates through all possible factors 'a' of the quotient 'y0 / x0'. For each factor 'a',\n    it calculates the corresponding factor 'b' such that 'a * b = y0 / x0'. It then checks if 'a' and 'b'\n    are co-prime (their GCD is 1) because P and Q can only be multiples of 'x0' by co-prime factors to maintain\n    the GCD as 'x0'. If 'a' and 'b' are co-prime, the count is incremented by 1 if 'a' is the same as 'b',\n    else by 2 to account for both (P, Q) and (Q, P) pairs.\n\n    ", "canonical_solution": "from math import gcd\ndef count_coprime_pairs(x0: int, y0: int) -> int:\n    \n    if y0 % x0 != 0:\n        return 0\n\n    product = y0 // x0\n    count = 0\n    \n    for a in range(1, int(product**0.5) + 1):\n        if product % a == 0:\n            b = product // a\n            if gcd(a, b) == 1:\n                count += 1 if a == b else 2\n    \n    return count", "buggy_code": "from math import gcd\ndef count_coprime_pairs(x0: int, y0: int) -> int:\n    \n    if y0 % x0 != 0:\n        return 0\n\n    product = y0 * x0\n    count = 1\n    \n    for a in range(1, int(product**0.5) + 1):\n        if product % a == 0:\n            b = product // a\n            if gcd(a, b) == 1:\n                count += 1 if a == b else 2\n    \n    return count + 1", "bug_with_line_numbers": "   1 | from math import gcd\n   2 | def count_coprime_pairs(x0: int, y0: int) -> int:\n   3 |     if y0 % x0 != 0:\n   4 |         return 0\n   5 |     product = y0 * x0\n   6 |     count = 1\n   7 |     for a in range(1, int(product**0.5) + 1):\n   8 |         if product % a == 0:\n   9 |             b = product // a\n  10 |             if gcd(a, b) == 1:\n  11 |                 count += 1 if a == b else 2\n  12 |     return count + 1", "fragment_lines": [5, 6, 12], "fragment_content": ["    product = y0 * x0", "    count = 1", "    return count + 1"], "test": "def check():\n    test_cases = [\n        (3, 60, 4),   # The example from the problem statement\n        (2, 50, 2), \n        (6, 180, 8),  # 180/6 = 30, factors are (1, 30), (2, 15), (3, 10), (5, 6), (6, 5), (10, 3), (15, 2), (30, 1)\n    ]\n\n    for i, (x0, y0, expected) in enumerate(test_cases):\n        result = count_coprime_pairs(x0, y0)\n        assert result == expected, f\"Test case {i+1} failed: expected {expected}, got {result}\"\n        print(f\"Test case {i+1} passed: x0 = {x0}, y0 = {y0}, expected = {expected}, got = {result}\")\n\n# Call the test function\ncheck()", "instruction": "Observe the following faulty Python code and its example\ncode:\n```python\nfrom math import gcd\ndef count_coprime_pairs(x0: int, y0: int) -> int:\n    \n    if y0 % x0 != 0:\n        return 0\n\n    product = y0 * x0\n    count = 1\n    \n    for a in range(1, int(product**0.5) + 1):\n        if product % a == 0:\n            b = product // a\n            if gcd(a, b) == 1:\n                count += 1 if a == b else 2\n    \n    return count + 1\n```\ncode example:\nExample Cases:\n\n    >>> count_coprime_pairs(3, 60)\n    4\n    >>> count_coprime_pairs(2, 50)\n    0\nFix bugs in the given code snippet. The fixed code must be placed between ```python```. Do not generate any test, main,example usage or check code!\n"}
{"question_id": "Python/54", "category": "Multiple", "subtype": "triple_bug", "level": "medium", "example": "Examples:\n    >>> largest_prime_factor(21)\n    7\n    >>> largest_prime_factor(15)\n    5", "docstring": "Find the largest prime factor of a given positive integer.\n    \n    The integer is assumed to be the product of exactly two distinct prime numbers. \n    The function iterates through potential factors starting from the smallest prime (2) \n    and checks if they are a factor of 'n'. If a factor is found, the function returns \n    the division of 'n' by this factor, which is the larger prime factor. If no factors \n    are found up to the square root of 'n', then 'n' itself is a prime number and is \n    returned as the largest prime factor.\n    \n    Args:\n    n (int): The positive integer to factorize, which is the product of two distinct primes.\n    \n    Returns:\n    int: The larger of the two prime factors of 'n'.\n    \n    ", "canonical_solution": "def largest_prime_factor(n: int) -> int:\n    \n    factor = 2\n    last_factor = 1\n    while factor * factor <= n:\n        if n % factor == 0:\n            last_factor = factor\n            while n % factor == 0:\n                n //= factor\n        factor += 1\n    if n > 1:\n        last_factor = n\n    return last_factor", "buggy_code": "def largest_prime_factor(n: int) -> int:\n    \n    factor = 2\n    last_factor = 1\n    while factor * factor < n:\n        if n % factor == 0:\n            last_factor = factor\n            while n % factor == 0:\n                n //= factor\n        factor += 1\n    if n > 1:\n        last_factor = n\n    else:\n        last_factor = 1\n        \n    return factor", "bug_with_line_numbers": "   1 | def largest_prime_factor(n: int) -> int:\n   2 |     factor = 2\n   3 |     last_factor = 1\n   4 |     while factor * factor < n:\n   5 |         if n % factor == 0:\n   6 |             last_factor = factor\n   7 |             while n % factor == 0:\n   8 |                 n //= factor\n   9 |         factor += 1\n  10 |     if n > 1:\n  11 |         last_factor = n\n  12 |     else:\n  13 |         last_factor = 1\n  14 |     return factor", "fragment_lines": [4, 12, 13, 14], "fragment_content": ["    while factor * factor < n:", "    else:", "        last_factor = 1", "    return factor"], "test": "def check():\n    test_cases = [\n        # Test case 1: composite number\n        {\n            'n': 35,  # 5 * 7\n            'expected': 7\n        },\n        # Test case 2: prime number itself\n        {\n            'n': 29,\n            'expected': 29\n        },\n        # Test case 3: composite number with a square of a prime\n        {\n            'n': 49,  # 7 * 7\n            'expected': 7\n        },\n        # Test case 4: large composite number\n        {\n            'n': 2 * 2 * 3 * 3 * 7 * 11,  # prime factors are 2, 3, 7, 11\n            'expected': 11\n        },\n    ]\n\n    for i, test in enumerate(test_cases, 1):\n        result = largest_prime_factor(test['n'])\n        assert result == test['expected'], f\"Test case {i} failed: result {result} does not match expected {test['expected']}\"\n        print(f\"Test case {i} passed with result {result}.\")\n\n# Run the test function\ncheck()", "instruction": "Observe the following faulty Python code and its example\ncode:\n```python\ndef largest_prime_factor(n: int) -> int:\n    \n    factor = 2\n    last_factor = 1\n    while factor * factor < n:\n        if n % factor == 0:\n            last_factor = factor\n            while n % factor == 0:\n                n //= factor\n        factor += 1\n    if n > 1:\n        last_factor = n\n    else:\n        last_factor = 1\n        \n    return factor\n```\ncode example:\nExamples:\n    >>> largest_prime_factor(21)\n    7\n    >>> largest_prime_factor(15)\n    5\nFix bugs in the given code snippet. The fixed code must be placed between ```python```. Do not generate any test, main,example usage or check code!\n"}
{"question_id": "Python/55", "category": "Multiple", "subtype": "triple_bug", "level": "hard", "example": "Examples:\n    - optimize_seating(4, 5, 1, 2, 3, [(4, 2, 4, 3), (2, 3, 3, 3), (2, 5, 2, 4)])\n    Returns: ('2', '2 4')\n\n    - optimize_seating(3, 3, 1, 1, 2, [(1, 2, 1, 3), (2, 1, 3, 1)])\n    Returns: ('2', '2')", "docstring": "Optimize the placement of aisles in a classroom to minimize the amount of chatting between students.\n\n    Args:\n    M (int): The number of rows in the classroom.\n    N (int): The number of columns in the classroom.\n    K (int): The number of horizontal aisles to add.\n    L (int): The number of vertical aisles to add.\n    D (int): The number of chatting pairs in the classroom.\n    chatting_pairs (list of tuples): A list of tuples, each containing the positions (Xi, Yi) and (Pi, Qi) of a chatting pair.\n\n    Returns:\n    (str, str): Two space-separated strings representing the optimal row and column indices for the aisles.\n\n    The function works by counting the number of chatting pairs that can be separated by adding an aisle in each possible position.\n    It then selects the most effective positions for aisles, aiming to separate as many chatting pairs as possible.\n\n    ", "canonical_solution": "def optimize_seating(M: int, N: int, K: int, L: int, D: int, chatting_pairs: list) -> (str, str):\n    \n    row_counter = [0] * (M - 1)\n    col_counter = [0] * (N - 1)\n\n    for Xi, Yi, Pi, Qi in chatting_pairs:\n        if Xi == Pi:  \n            col_counter[min(Yi, Qi) - 1] += 1\n        elif Yi == Qi:  \n            row_counter[min(Xi, Pi) - 1] += 1\n\n    sorted_rows = sorted(range(M - 1), key=lambda i: row_counter[i], reverse=True)\n    sorted_cols = sorted(range(N - 1), key=lambda i: col_counter[i], reverse=True)\n\n    aisle_rows = sorted(sorted_rows[:K])\n    aisle_cols = sorted(sorted_cols[:L])\n\n    return ' '.join(str(row + 1) for row in aisle_rows), ' '.join(str(col + 1) for col in aisle_cols)", "buggy_code": "def optimize_seating(M: int, N: int, K: int, L: int, D: int, chatting_pairs: list) -> (str, str):\n    \n    row_counter = [0] * (M)\n    col_counter = [0] * (N)\n\n    for Xi, Yi, Pi, Qi in chatting_pairs:\n        if Xi == Pi:  \n            col_counter[min(Yi, Qi) - 1] += 1\n        elif Yi == Qi:  \n            row_counter[min(Xi, Pi) - 1] += 1\n\n    sorted_rows = sorted(range(M), key=lambda i: row_counter[i], reverse=True)\n    sorted_cols = sorted(range(N), key=lambda i: col_counter[i], reverse=True)\n\n    aisle_rows = sorted_rows[:K]\n    aisle_cols = sorted_cols[:L]\n\n    return ' '.join(str(row + 1) for row in aisle_rows), ' '.join(str(col + 1) for col in aisle_cols)", "bug_with_line_numbers": "   1 | def optimize_seating(M: int, N: int, K: int, L: int, D: int, chatting_pairs: list) -> (str, str):\n   2 |     row_counter = [0] * (M)\n   3 |     col_counter = [0] * (N)\n   4 |     for Xi, Yi, Pi, Qi in chatting_pairs:\n   5 |         if Xi == Pi:  \n   6 |             col_counter[min(Yi, Qi) - 1] += 1\n   7 |         elif Yi == Qi:  \n   8 |             row_counter[min(Xi, Pi) - 1] += 1\n   9 |     sorted_rows = sorted(range(M), key=lambda i: row_counter[i], reverse=True)\n  10 |     sorted_cols = sorted(range(N), key=lambda i: col_counter[i], reverse=True)\n  11 |     aisle_rows = sorted_rows[:K]\n  12 |     aisle_cols = sorted_cols[:L]\n  13 |     return ' '.join(str(row + 1) for row in aisle_rows), ' '.join(str(col + 1) for col in aisle_cols)", "fragment_lines": [2, 3, 9, 10, 11, 12], "fragment_content": ["    row_counter = [0] * (M)", "    col_counter = [0] * (N)", "    sorted_rows = sorted(range(M), key=lambda i: row_counter[i], reverse=True)", "    sorted_cols = sorted(range(N), key=lambda i: col_counter[i], reverse=True)", "    aisle_rows = sorted_rows[:K]", "    aisle_cols = sorted_cols[:L]"], "test": "def check():\n    test_cases = [\n        # Test case 1 from the provided example\n        {\n            'M': 4, 'N': 5, 'K': 1, 'L': 2, 'D': 3,\n            'chatting_pairs': [(4, 2, 4, 3), (2, 3, 3, 3), (2, 5, 2, 4)],\n            'expected': ('2', '2 4')\n        },\n        # Corrected Test case 2\n        {\n            'M': 5, 'N': 6, 'K': 2, 'L': 3, 'D': 4,\n            'chatting_pairs': [(1, 1, 1, 2), (2, 2, 3, 2), (4, 5, 4, 6), (5, 1, 5, 2)],\n            'expected': ('1 2', '1 2 5')  # Corrected expected output\n        },\n        # Test case 3\n        {\n            'M': 3, 'N': 3, 'K': 1, 'L': 1, 'D': 2,\n            'chatting_pairs': [(1, 2, 1, 3), (2, 1, 3, 1)],\n            'expected': ('2', '2')\n        },\n    ]\n\n    for i, test in enumerate(test_cases, 1):\n        row_output, col_output = optimize_seating(\n            test['M'], test['N'], test['K'], test['L'], test['D'], test['chatting_pairs']\n        )\n        assert row_output == test['expected'][0], f\"Test case {i} failed: row_output {row_output} does not match expected {test['expected'][0]}\"\n        assert col_output == test['expected'][1], f\"Test case {i} failed: col_output {col_output} does not match expected {test['expected'][1]}\"\n        print(f\"Test case {i} passed.\")\n\n# Run the test function\ncheck()", "instruction": "Observe the following faulty Python code and its example\ncode:\n```python\ndef optimize_seating(M: int, N: int, K: int, L: int, D: int, chatting_pairs: list) -> (str, str):\n    \n    row_counter = [0] * (M)\n    col_counter = [0] * (N)\n\n    for Xi, Yi, Pi, Qi in chatting_pairs:\n        if Xi == Pi:  \n            col_counter[min(Yi, Qi) - 1] += 1\n        elif Yi == Qi:  \n            row_counter[min(Xi, Pi) - 1] += 1\n\n    sorted_rows = sorted(range(M), key=lambda i: row_counter[i], reverse=True)\n    sorted_cols = sorted(range(N), key=lambda i: col_counter[i], reverse=True)\n\n    aisle_rows = sorted_rows[:K]\n    aisle_cols = sorted_cols[:L]\n\n    return ' '.join(str(row + 1) for row in aisle_rows), ' '.join(str(col + 1) for col in aisle_cols)\n```\ncode example:\nExamples:\n    - optimize_seating(4, 5, 1, 2, 3, [(4, 2, 4, 3), (2, 3, 3, 3), (2, 5, 2, 4)])\n    Returns: ('2', '2 4')\n\n    - optimize_seating(3, 3, 1, 1, 2, [(1, 2, 1, 3), (2, 1, 3, 1)])\n    Returns: ('2', '2')\nFix bugs in the given code snippet. The fixed code must be placed between ```python```. Do not generate any test, main,example usage or check code!\n"}
{"question_id": "Python/56", "category": "Multiple", "subtype": "quadruple_bug", "level": "medium", "example": "Examples:\n    >>> decode(\"AA\", \"AB\", \"EOWIE\")\n    'Failed'    \n    >>> decode(\"MSRTZCJKPFLQYVAWBINXUEDGHOOILSMIJFRCOPPQCEUNYDUMPP\", \"YIZSDWAHLNOVFUCERKJXQMGTBPPKOIYKANZWPLLVWMQJFGQYLL\", \"FLSO\")\n    'NOIP'", "docstring": "Decodes an encrypted message using a cipher derived from a known encoded-original pair.\n    \n    The function builds a mapping from encoded letters to their original letters and uses this\n    mapping to decode a given encrypted message. If a contradiction is found during mapping\n    construction, or not all letters are represented in the mapping, the function returns \"Failed\".\n    \n    Args:\n    encoded (str): A string representing the encoded information.\n    original (str): A string representing the original information corresponding to the encoded string.\n    message (str): A string representing the encrypted message to be decoded.\n    \n    Returns:\n    str: The decoded message if successful, or \"Failed\" if the decoding is not possible.\n    \n    ", "canonical_solution": "def decode(encoded: str, original: str, message: str) -> str:\n    \n    mapping = {}\n    reverse_mapping = {}\n    \n    for e, o in zip(encoded, original):\n        if e in mapping and mapping[e] != o:\n            return \"Failed\"\n        if o in reverse_mapping and reverse_mapping[o] != e:\n            return \"Failed\"\n        mapping[e] = o\n        reverse_mapping[o] = e\n    \n    if len(reverse_mapping) < 26:\n        return \"Failed\"\n    \n    decoded_message = \"\"\n    for char in message:\n        if char not in mapping:\n            return \"Failed\"\n        decoded_message += mapping[char]\n    \n    return decoded_message", "buggy_code": "def decode(encoded: str, original: str, message: str) -> str:\n    \n    mapping = {}\n    reverse_mapping = {}\n    \n    for e, o in zip(encoded, original):\n        if e in mapping and mapping[e] != o:\n            return \"Failed\"\n        if o in mapping and mapping[o] != e:\n            return \"Failed\"\n        mapping[e] = o\n        reverse_mapping[o] = e\n    \n    if len(reverse_mapping) < 26:\n        return False\n    \n    decoded_message = \"\"\n    for char in message:\n        #if char not in mapping\n            return \"Failed\n        decoded_message += mapping[char]\n    \n    return decoded_message", "bug_with_line_numbers": "   1 | def decode(encoded: str, original: str, message: str) -> str:\n   2 |     mapping = {}\n   3 |     reverse_mapping = {}\n   4 |     for e, o in zip(encoded, original):\n   5 |         if e in mapping and mapping[e] != o:\n   6 |             return \"Failed\"\n   7 |         if o in mapping and mapping[o] != e:\n   8 |             return \"Failed\"\n   9 |         mapping[e] = o\n  10 |         reverse_mapping[o] = e\n  11 |     if len(reverse_mapping) < 26:\n  12 |         return False\n  13 |     decoded_message = \"\"\n  14 |     for char in message:\n  15 |         #if char not in mapping\n  16 |             return \"Failed\n  17 |         decoded_message += mapping[char]\n  18 |     return decoded_message", "fragment_lines": [-1, 7, 8, 12, 15], "fragment_content": ["missing critical code snippet", "if o in mapping and mapping[o] != e:", "            return \"Failed\"", "        return False", "            return \"Failed"], "test": "def check():\n    # Test case 1: Contradiction in mapping\n    assert decode(\"AA\", \"AB\", \"EOWIE\") == \"Failed\", \"Test case 1 failed\"\n\n    # Test case 2: Not all letters are represented\n    assert decode(\"QWERTYUIOPLKJHGFDSAZXCVBN\", \"ABCDEFGHIJKLMNOPQRSTUVWXY\", \"DSLIEWO\") == \"Failed\", \"Test case 2 failed\"\n\n    # Test case 3: Successful decoding\n    assert decode(\"MSRTZCJKPFLQYVAWBINXUEDGHOOILSMIJFRCOPPQCEUNYDUMPP\", \"YIZSDWAHLNOVFUCERKJXQMGTBPPKOIYKANZWPLLVWMQJFGQYLL\", \"FLSO\") == \"NOIP\", \"Test case 3 failed\"\n    \n    # Test case 4: Character in message not in mapping\n    assert decode(\"ABCDEFGHIJKLM\", \"NOPQRSTUVWXYZ\", \"UVWXYZ\") == \"Failed\", \"Test case 4 failed\"\n\n    # Test case 5: Empty strings\n    assert decode(\"\", \"\", \"\") == \"Failed\", \"Test case 5 failed\"\n\n    print(\"All test cases passed!\")\n\n# Call the test function to run the test cases\ncheck()", "instruction": "Observe the following faulty Python code and its example\ncode:\n```python\ndef decode(encoded: str, original: str, message: str) -> str:\n    \n    mapping = {}\n    reverse_mapping = {}\n    \n    for e, o in zip(encoded, original):\n        if e in mapping and mapping[e] != o:\n            return \"Failed\"\n        if o in mapping and mapping[o] != e:\n            return \"Failed\"\n        mapping[e] = o\n        reverse_mapping[o] = e\n    \n    if len(reverse_mapping) < 26:\n        return False\n    \n    decoded_message = \"\"\n    for char in message:\n        #if char not in mapping\n            return \"Failed\n        decoded_message += mapping[char]\n    \n    return decoded_message\n```\ncode example:\nExamples:\n    >>> decode(\"AA\", \"AB\", \"EOWIE\")\n    'Failed'    \n    >>> decode(\"MSRTZCJKPFLQYVAWBINXUEDGHOOILSMIJFRCOPPQCEUNYDUMPP\", \"YIZSDWAHLNOVFUCERKJXQMGTBPPKOIYKANZWPLLVWMQJFGQYLL\", \"FLSO\")\n    'NOIP'\nFix bugs in the given code snippet. The fixed code must be placed between ```python```. Do not generate any test, main,example usage or check code!\n"}
{"question_id": "Python/57", "category": "Multiple", "subtype": "quadruple_bug", "level": "hard", "example": "Examples:\n    >>> select_volunteers(6, 3, [(1000, 90), (3239, 88), (2390, 95), (7231, 84), (1005, 95), (1001, 88)])\n    (88, [(1005, 95), (2390, 95), (1000, 90), (1001, 88), (3239, 88)])", "docstring": "Selects and determines the interview score cutoff and the list of applicants who qualify for the interview process.\n    \n    The function sorts the applicants based on their test scores in descending order. If multiple applicants have the same score,\n    they are then sorted by their registration number in ascending order. The interview score cutoff is calculated based on 150%\n    of the planned number of recruits, rounded down. All applicants with scores equal to or higher than the cutoff are considered\n    qualified for the interview.\n    \n    Args:\n    - n (int): The total number of applicants.\n    - m (int): The planned number of volunteers to be recruited.\n    - applicants (List[Tuple[int, int]]): A list of tuples where each tuple contains the registration number and test score of an applicant.\n    \n    Returns:\n    - Tuple[int, List[Tuple[int, int]]]: A tuple containing the interview score cutoff and a list of tuples, each of which includes\n      the registration number and test score of qualified applicants.\n    \n    ", "canonical_solution": "from typing import List, Tuple\ndef select_volunteers(n: int, m: int, applicants: List[Tuple[int, int]]) -> Tuple[int, List[Tuple[int, int]]]:\n    \n    sorted_applicants = sorted(applicants, key=lambda x: (-x[1], x[0]))\n    \n    interview_line_index = int(m * 1.5) - 1\n    interview_line_score = sorted_applicants[interview_line_index][1]\n    \n    final_applicants = [applicant for applicant in sorted_applicants if applicant[1] >= interview_line_score]\n    \n    return interview_line_score, final_applicants", "buggy_code": "from typing import List, Tuple\ndef select_volunteers(n: int, m: int, applicants: List[Tuple[int, int]]) -> Tuple[int, List[Tuple[int, int]]]:\n    \n    sorted_applicants = sorted(applicants, key=lambda x: (-x[0], x[1]))\n    \n    interview_line_index = m * 1.5 - 1\n    interview_line_score = sorted_applicants[interview_line_index][0]\n    \n    final_applicants = [applicant for applicant in sorted_applicants if applicant[1] > interview_line_score]\n    \n    return interview_line_score, final_applicants", "bug_with_line_numbers": "   1 | from typing import List, Tuple\n   2 | def select_volunteers(n: int, m: int, applicants: List[Tuple[int, int]]) -> Tuple[int, List[Tuple[int, int]]]:\n   3 |     sorted_applicants = sorted(applicants, key=lambda x: (-x[0], x[1]))\n   4 |     interview_line_index = m * 1.5 - 1\n   5 |     interview_line_score = sorted_applicants[interview_line_index][0]\n   6 |     final_applicants = [applicant for applicant in sorted_applicants if applicant[1] > interview_line_score]\n   7 |     return interview_line_score, final_applicants", "fragment_lines": [3, 4, 5, 6], "fragment_content": ["    sorted_applicants = sorted(applicants, key=lambda x: (-x[0], x[1]))", "    interview_line_index = m * 1.5 - 1", "    interview_line_score = sorted_applicants[interview_line_index][0]", "    final_applicants = [applicant for applicant in sorted_applicants if applicant[1] > interview_line_score]"], "test": "def check():\n    # Define test cases\n    test_cases = [\n        (6, 3, [(1000, 90), (3239, 88), (2390, 95), (7231, 84), (1005, 95), (1001, 88)],\n         (88, [(1005, 95), (2390, 95), (1000, 90), (1001, 88), (3239, 88)])),\n        (5, 3, [(2000, 70), (2001, 80), (2002, 90), (2003, 85), (2004, 90)],\n         (80, [(2002, 90), (2004, 90), (2003, 85), (2001, 80)])),\n        (8, 4, [(1234, 60), (2345, 75), (3456, 85), (4567, 85), (5678, 90), (6789, 100), (7890, 65), (8901, 70)],\n         (70, [(6789, 100), (5678, 90), (3456, 85), (4567, 85), (2345, 75), (8901, 70)])),\n    ]\n\n    # Run test cases\n    for i, (n, m, applicants, expected) in enumerate(test_cases):\n        interview_line_score, final_applicants = select_volunteers(n, m, applicants)\n        assert (interview_line_score, final_applicants) == expected, f\"Test case {i + 1} failed\"\n        print(f\"Test case {i + 1} passed\")\n\n# Run the test function\ncheck()", "instruction": "Observe the following faulty Python code and its example\ncode:\n```python\nfrom typing import List, Tuple\ndef select_volunteers(n: int, m: int, applicants: List[Tuple[int, int]]) -> Tuple[int, List[Tuple[int, int]]]:\n    \n    sorted_applicants = sorted(applicants, key=lambda x: (-x[0], x[1]))\n    \n    interview_line_index = m * 1.5 - 1\n    interview_line_score = sorted_applicants[interview_line_index][0]\n    \n    final_applicants = [applicant for applicant in sorted_applicants if applicant[1] > interview_line_score]\n    \n    return interview_line_score, final_applicants\n```\ncode example:\nExamples:\n    >>> select_volunteers(6, 3, [(1000, 90), (3239, 88), (2390, 95), (7231, 84), (1005, 95), (1001, 88)])\n    (88, [(1005, 95), (2390, 95), (1000, 90), (1001, 88), (3239, 88)])\nFix bugs in the given code snippet. The fixed code must be placed between ```python```. Do not generate any test, main,example usage or check code!\n"}
{"question_id": "Python/58", "category": "Special", "subtype": "illegal_indentation", "level": "easy", "example": "Example:\n        >>> find_number_combinations()\n        [(123, 246, 369), (124, 248, 372), ...]", "docstring": "Generate all unique combinations of three numbers, each formed from the digits 1 to 9 without repetition,\n    such that the second number is twice the first and the third is three times the first.\n\n    Returns:\n        list of tuples: A sorted list of tuples, where each tuple contains three integers representing the\n                        valid number combinations in ascending order based on the first number.\n\n    ", "canonical_solution": "from itertools import permutations\n\ndef find_number_combinations():\n    \n    valid_combinations = []\n\n    for perm in permutations(range(1, 10)):\n        num1 = perm[0] * 100 + perm[1] * 10 + perm[2]\n        num2 = perm[3] * 100 + perm[4] * 10 + perm[5]\n        num3 = perm[6] * 100 + perm[7] * 10 + perm[8]\n\n        if num2 == 2 * num1 and num3 == 3 * num1:\n            valid_combinations.append((num1, num2, num3))\n\n    valid_combinations.sort()\n\n    return valid_combinations", "buggy_code": "from itertools import permutations\n\ndef find_number_combinations():\n    \n    valid_combinations = []\n\n    for perm in permutations(range(1, 10)):\n        num1 = perm[0] * 100 + perm[1] * 10 + perm[2]\n        num2 = perm[3] * 100 + perm[4] * 10 + perm[5]\n        num3 = perm[6] * 100 + perm[7] * 10 + perm[8]\n\n        if num2 == 2 * num1 and num3 == 3 * num1:\n        valid_combinations.append((num1, num2, num3))\n\n    valid_combinations.sort()\n\n    return valid_combinations", "bug_with_line_numbers": "   1 | from itertools import permutations\n   2 | def find_number_combinations():\n   3 |     valid_combinations = []\n   4 |     for perm in permutations(range(1, 10)):\n   5 |         num1 = perm[0] * 100 + perm[1] * 10 + perm[2]\n   6 |         num2 = perm[3] * 100 + perm[4] * 10 + perm[5]\n   7 |         num3 = perm[6] * 100 + perm[7] * 10 + perm[8]\n   8 |         if num2 == 2 * num1 and num3 == 3 * num1:\n   9 |         valid_combinations.append((num1, num2, num3))\n  10 |     valid_combinations.sort()\n  11 |     return valid_combinations", "fragment_lines": [9], "fragment_content": ["        valid_combinations.append((num1, num2, num3))"], "test": "def check():\n    # Call the function to get the combinations\n    combinations = find_number_combinations()\n\n    # Check that we have at least one valid combination\n    assert len(combinations) > 0, \"There should be at least one valid combination.\"\n\n    # Iterate over each combination to perform further checks\n    for combo in combinations:\n        # Each combination should have exactly three numbers\n        assert len(combo) == 3, \"Each combination should have three numbers.\"\n\n        # Check if numbers are 3-digit numbers\n        for num in combo:\n            assert 100 <= num <= 999, f\"Each number should be a 3-digit number, got {num}.\"\n\n        # Check the 1:2:3 ratio\n        assert combo[1] == 2 * combo[0] and combo[2] == 3 * combo[0], \"The numbers should be in a 1:2:3 ratio.\"\n\n    print(\"All test cases passed!\")\n    \ncheck()", "instruction": "Observe the following faulty Python code and its example\ncode:\n```python\nfrom itertools import permutations\n\ndef find_number_combinations():\n    \n    valid_combinations = []\n\n    for perm in permutations(range(1, 10)):\n        num1 = perm[0] * 100 + perm[1] * 10 + perm[2]\n        num2 = perm[3] * 100 + perm[4] * 10 + perm[5]\n        num3 = perm[6] * 100 + perm[7] * 10 + perm[8]\n\n        if num2 == 2 * num1 and num3 == 3 * num1:\n        valid_combinations.append((num1, num2, num3))\n\n    valid_combinations.sort()\n\n    return valid_combinations\n```\ncode example:\nExample:\n        >>> find_number_combinations()\n        [(123, 246, 369), (124, 248, 372), ...]\nFix bugs in the given code snippet. The fixed code must be placed between ```python```. Do not generate any test, main,example usage or check code!\n"}
{"question_id": "Python/59", "category": "Special", "subtype": "illegal_indentation", "level": "easy", "example": "Examples:\n    - optimize_seating(4, 5, 1, 2, 3, [(4, 2, 4, 3), (2, 3, 3, 3), (2, 5, 2, 4)])\n    Returns: ('2', '2 4')\n\n    - optimize_seating(3, 3, 1, 1, 2, [(1, 2, 1, 3), (2, 1, 3, 1)])\n    Returns: ('2', '2')", "docstring": "Optimize the placement of aisles in a classroom to minimize the amount of chatting between students.\n\n    Args:\n    M (int): The number of rows in the classroom.\n    N (int): The number of columns in the classroom.\n    K (int): The number of horizontal aisles to add.\n    L (int): The number of vertical aisles to add.\n    D (int): The number of chatting pairs in the classroom.\n    chatting_pairs (list of tuples): A list of tuples, each containing the positions (Xi, Yi) and (Pi, Qi) of a chatting pair.\n\n    Returns:\n    (str, str): Two space-separated strings representing the optimal row and column indices for the aisles.\n\n    The function works by counting the number of chatting pairs that can be separated by adding an aisle in each possible position.\n    It then selects the most effective positions for aisles, aiming to separate as many chatting pairs as possible.\n\n    ", "canonical_solution": "def optimize_seating(M: int, N: int, K: int, L: int, D: int, chatting_pairs: list) -> (str, str):\n    \n    row_counter = [0] * (M - 1)\n    col_counter = [0] * (N - 1)\n\n    for Xi, Yi, Pi, Qi in chatting_pairs:\n        if Xi == Pi:  \n            col_counter[min(Yi, Qi) - 1] += 1\n        elif Yi == Qi:  \n            row_counter[min(Xi, Pi) - 1] += 1\n\n    sorted_rows = sorted(range(M - 1), key=lambda i: row_counter[i], reverse=True)\n    sorted_cols = sorted(range(N - 1), key=lambda i: col_counter[i], reverse=True)\n\n    aisle_rows = sorted(sorted_rows[:K])\n    aisle_cols = sorted(sorted_cols[:L])\n\n    return ' '.join(str(row + 1) for row in aisle_rows), ' '.join(str(col + 1) for col in aisle_cols)", "buggy_code": "def optimize_seating(M: int, N: int, K: int, L: int, D: int, chatting_pairs: list) -> (str, str):\n    \n    row_counter = [0] * (M - 1)\n    col_counter = [0] * (N - 1)\n\n    for Xi, Yi, Pi, Qi in chatting_pairs:\n        if Xi == Pi:  \n        col_counter[min(Yi, Qi) - 1] += 1\n        elif Yi == Qi:  \n            row_counter[min(Xi, Pi) - 1] += 1\n\n    sorted_rows = sorted(range(M - 1), key=lambda i: row_counter[i], reverse=True)\n    sorted_cols = sorted(range(N - 1), key=lambda i: col_counter[i], reverse=True)\n\n    aisle_rows = sorted(sorted_rows[:K])\n    aisle_cols = sorted(sorted_cols[:L])\n\n    return ' '.join(str(row + 1) for row in aisle_rows), ' '.join(str(col + 1) for col in aisle_cols)", "bug_with_line_numbers": "   1 | def optimize_seating(M: int, N: int, K: int, L: int, D: int, chatting_pairs: list) -> (str, str):\n   2 |     row_counter = [0] * (M - 1)\n   3 |     col_counter = [0] * (N - 1)\n   4 |     for Xi, Yi, Pi, Qi in chatting_pairs:\n   5 |         if Xi == Pi:  \n   6 |         col_counter[min(Yi, Qi) - 1] += 1\n   7 |         elif Yi == Qi:  \n   8 |             row_counter[min(Xi, Pi) - 1] += 1\n   9 |     sorted_rows = sorted(range(M - 1), key=lambda i: row_counter[i], reverse=True)\n  10 |     sorted_cols = sorted(range(N - 1), key=lambda i: col_counter[i], reverse=True)\n  11 |     aisle_rows = sorted(sorted_rows[:K])\n  12 |     aisle_cols = sorted(sorted_cols[:L])\n  13 |     return ' '.join(str(row + 1) for row in aisle_rows), ' '.join(str(col + 1) for col in aisle_cols)", "fragment_lines": [5, 6], "fragment_content": ["        if Xi == Pi:", "        col_counter[min(Yi, Qi) - 1] += 1"], "test": "def check():\n    test_cases = [\n        # Test case 1 from the provided example\n        {\n            'M': 4, 'N': 5, 'K': 1, 'L': 2, 'D': 3,\n            'chatting_pairs': [(4, 2, 4, 3), (2, 3, 3, 3), (2, 5, 2, 4)],\n            'expected': ('2', '2 4')\n        },\n        # Corrected Test case 2\n        {\n            'M': 5, 'N': 6, 'K': 2, 'L': 3, 'D': 4,\n            'chatting_pairs': [(1, 1, 1, 2), (2, 2, 3, 2), (4, 5, 4, 6), (5, 1, 5, 2)],\n            'expected': ('1 2', '1 2 5')  # Corrected expected output\n        },\n        # Test case 3\n        {\n            'M': 3, 'N': 3, 'K': 1, 'L': 1, 'D': 2,\n            'chatting_pairs': [(1, 2, 1, 3), (2, 1, 3, 1)],\n            'expected': ('2', '2')\n        },\n    ]\n\n    for i, test in enumerate(test_cases, 1):\n        row_output, col_output = optimize_seating(\n            test['M'], test['N'], test['K'], test['L'], test['D'], test['chatting_pairs']\n        )\n        assert row_output == test['expected'][0], f\"Test case {i} failed: row_output {row_output} does not match expected {test['expected'][0]}\"\n        assert col_output == test['expected'][1], f\"Test case {i} failed: col_output {col_output} does not match expected {test['expected'][1]}\"\n        print(f\"Test case {i} passed.\")\n\n# Run the test function\ncheck()", "instruction": "Observe the following faulty Python code and its example\ncode:\n```python\ndef optimize_seating(M: int, N: int, K: int, L: int, D: int, chatting_pairs: list) -> (str, str):\n    \n    row_counter = [0] * (M - 1)\n    col_counter = [0] * (N - 1)\n\n    for Xi, Yi, Pi, Qi in chatting_pairs:\n        if Xi == Pi:  \n        col_counter[min(Yi, Qi) - 1] += 1\n        elif Yi == Qi:  \n            row_counter[min(Xi, Pi) - 1] += 1\n\n    sorted_rows = sorted(range(M - 1), key=lambda i: row_counter[i], reverse=True)\n    sorted_cols = sorted(range(N - 1), key=lambda i: col_counter[i], reverse=True)\n\n    aisle_rows = sorted(sorted_rows[:K])\n    aisle_cols = sorted(sorted_cols[:L])\n\n    return ' '.join(str(row + 1) for row in aisle_rows), ' '.join(str(col + 1) for col in aisle_cols)\n```\ncode example:\nExamples:\n    - optimize_seating(4, 5, 1, 2, 3, [(4, 2, 4, 3), (2, 3, 3, 3), (2, 5, 2, 4)])\n    Returns: ('2', '2 4')\n\n    - optimize_seating(3, 3, 1, 1, 2, [(1, 2, 1, 3), (2, 1, 3, 1)])\n    Returns: ('2', '2')\nFix bugs in the given code snippet. The fixed code must be placed between ```python```. Do not generate any test, main,example usage or check code!\n"}
{"question_id": "Python/60", "category": "Special", "subtype": "illegal_indentation", "level": "easy", "example": "Cases:\n    >>> is_prime(2)\n    True\n    >>> is_prime(15)\n    False", "docstring": "Determine whether a given integer is a prime number.\n\n    A prime number is a natural number greater than 1 that has no positive divisors other than 1 and itself. The function checks for primality by eliminating non-prime numbers using several tests. First, it handles edge cases for numbers less than or equal to 1, which are not prime, and small numbers (2 and 3) which are prime. It then checks for divisibility by 2 and 3. For larger numbers, it uses a 6k +/- 1 optimization to test for factors up to the square root of the number.\n\n    Args:\n    num (int): The integer to check for primality.\n\n    Returns:\n    bool: True if `num` is a prime number, False otherwise.\n\n    ", "canonical_solution": "def is_prime(num: int) -> bool:\n    \n    \"\"\"Check if a number is a prime.\"\"\"\n    if num <= 1:\n        return False\n    if num <= 3:\n        return True\n    if num % 2 == 0 or num % 3 == 0:\n        return False\n    i = 5\n    while i * i <= num:\n        if num % i == 0 or num % (i + 2) == 0:\n            return False\n        i += 6\n    return True", "buggy_code": "def is_prime(num: int) -> bool:\n    \n    \"\"\"Check if a number is a prime.\"\"\"\n    if num <= 1:\n        return False\n    if num <= 3:\n        return True\n    if num % 2 == 0 or num % 3 == 0:\n        return False\n    i = 5\n    while i * i <= num:\n        if num % i == 0 or num % (i + 2) == 0:\n        return False\n        i += 6\n    return True", "bug_with_line_numbers": "   1 | def is_prime(num: int) -> bool:\n   2 |     \"\"\"Check if a number is a prime.\"\"\"\n   3 |     if num <= 1:\n   4 |         return False\n   5 |     if num <= 3:\n   6 |         return True\n   7 |     if num % 2 == 0 or num % 3 == 0:\n   8 |         return False\n   9 |     i = 5\n  10 |     while i * i <= num:\n  11 |         if num % i == 0 or num % (i + 2) == 0:\n  12 |         return False\n  13 |         i += 6\n  14 |     return True", "fragment_lines": [11, 4, 8, 12], "fragment_content": ["        if num % i == 0 or num % (i + 2) == 0:", "        return False", "        return False", "        return False"], "test": "def check():\n    # Test case 1: Test a prime number\n    prime_number = 29\n    assert is_prime(prime_number) == True, f\"Test case 1 failed: {prime_number} is a prime number.\"\n\n    # Test case 2: Test a non-prime number\n    non_prime_number = 21  # 21 = 3 * 7, so it's not prime\n    assert is_prime(non_prime_number) == False, f\"Test case 2 failed: {non_prime_number} is not a prime number.\"\n\n    # Test case 3: Test a number less than 2 (should not be prime)\n    less_than_two = 1\n    assert is_prime(less_than_two) == False, f\"Test case 3 failed: {less_than_two} is not a prime number.\"\n\n    # Test case 4: Test another prime number\n    another_prime_number = 97\n    assert is_prime(another_prime_number) == True, f\"Test case 4 failed: {another_prime_number} is a prime number.\"\n\n    # Test case 5: Test zero (should not be prime)\n    zero = 0\n    assert is_prime(zero) == False, f\"Test case 5 failed: {zero} is not a prime number.\"\n\n    print(\"All test cases passed.\")\n\n# Run the test function\ncheck()", "instruction": "Observe the following faulty Python code and its example\ncode:\n```python\ndef is_prime(num: int) -> bool:\n    \n    \"\"\"Check if a number is a prime.\"\"\"\n    if num <= 1:\n        return False\n    if num <= 3:\n        return True\n    if num % 2 == 0 or num % 3 == 0:\n        return False\n    i = 5\n    while i * i <= num:\n        if num % i == 0 or num % (i + 2) == 0:\n        return False\n        i += 6\n    return True\n```\ncode example:\nCases:\n    >>> is_prime(2)\n    True\n    >>> is_prime(15)\n    False\nFix bugs in the given code snippet. The fixed code must be placed between ```python```. Do not generate any test, main,example usage or check code!\n"}
{"question_id": "Python/61", "category": "Special", "subtype": "illegal_indentation", "level": "medium", "example": "Examples:\n        >>> polynomial_to_string(5, [100, -1, 1, -3, 0, 10])\n        '100x^5-x^4+x^3-3x^2+10'\n\n        >>> polynomial_to_string(3, [-50, 0, 0, 1])\n        '-50x^3+1'", "docstring": "Converts a list of polynomial coefficients into a formatted string representation.\n\n    The function takes in the highest degree `n` of the polynomial and a list of coefficients `coeffs`,\n    which are ordered from the highest degree term to the constant term. It returns a string that\n    represents the polynomial with the following rules:\n    - Terms with a coefficient of zero are omitted.\n    - The sign of each term is determined (+ for positive, - for negative), with no leading '+' for the first term.\n    - The absolute value of the coefficient is shown unless it's 1 and the term includes the variable `x`.\n    - The variable part is formatted based on its degree; `x^degree` for degree > 1, `x` for degree 1, and\n      nothing for degree 0 (constant term).\n    - Terms are joined without additional spaces, starting with the highest degree term.\n\n    Args:\n        n (int): The highest degree of the polynomial.\n        coeffs (List[int]): A list of coefficients, starting with the coefficient of the highest degree term.\n\n    Returns:\n        str: The string representation of the polynomial.\n\n    ", "canonical_solution": "from typing import List \ndef polynomial_to_string(n: int, coeffs: List[int]) -> str:\n    \n    result = []\n\n    for i in range(n + 1):\n        coeff = coeffs[i]\n        degree = n - i\n\n        if coeff == 0:\n            continue\n        sign = '-' if coeff < 0 else '+'\n        if i == 0:\n            sign = '-' if coeff < 0 else ''\n        \n        abs_coeff = abs(coeff)\n        if abs_coeff == 1 and degree != 0:\n            abs_coeff_str = ''\n        else:\n            abs_coeff_str = str(abs_coeff)\n        \n        if degree == 0:\n            term = abs_coeff_str\n        elif degree == 1:\n            term = f\"{abs_coeff_str}x\"\n        else:\n            term = f\"{abs_coeff_str}x^{degree}\"\n\n        result.append(f\"{sign}{term}\")\n\n    return ''.join(result)", "buggy_code": "from typing import List \ndef polynomial_to_string(n: int, coeffs: List[int]) -> str:\n    \n    result = []\n\n    for i in range(n + 1):\n        coeff = coeffs[i]\n        degree = n - i\n\n        if coeff == 0:\n            continue\n        sign = '-' if coeff < 0 else '+'\n        if i == 0:\n            sign = '-' if coeff < 0 else ''\n        \n        abs_coeff = abs(coeff)\n        if abs_coeff == 1 and degree != 0:\n            abs_coeff_str = ''\n        else:\n            abs_coeff_str = str(abs_coeff)\n        \n        if degree == 0:\n            term = abs_coeff_str\n        elif degree == 1:\n            term = f\"{abs_coeff_str}x\"\n        else:\n            term = f\"{abs_coeff_str}x^{degree}\"\n\n        result.append(f\"{sign}{term}\")\n\n        return ''.join(result)", "bug_with_line_numbers": "   1 | from typing import List \n   2 | def polynomial_to_string(n: int, coeffs: List[int]) -> str:\n   3 |     result = []\n   4 |     for i in range(n + 1):\n   5 |         coeff = coeffs[i]\n   6 |         degree = n - i\n   7 |         if coeff == 0:\n   8 |             continue\n   9 |         sign = '-' if coeff < 0 else '+'\n  10 |         if i == 0:\n  11 |             sign = '-' if coeff < 0 else ''\n  12 |         abs_coeff = abs(coeff)\n  13 |         if abs_coeff == 1 and degree != 0:\n  14 |             abs_coeff_str = ''\n  15 |         else:\n  16 |             abs_coeff_str = str(abs_coeff)\n  17 |         if degree == 0:\n  18 |             term = abs_coeff_str\n  19 |         elif degree == 1:\n  20 |             term = f\"{abs_coeff_str}x\"\n  21 |         else:\n  22 |             term = f\"{abs_coeff_str}x^{degree}\"\n  23 |         result.append(f\"{sign}{term}\")\n  24 |         return ''.join(result)", "fragment_lines": [24], "fragment_content": ["        return ''.join(result)"], "test": "def check():\n    test_cases = [\n        (4, [3, -2, 0, 1, -5], \"3x^4-2x^3+x-5\"),\n        (2, [0, 4, -1], \"+4x-1\"),\n        (0, [7], \"7\"),\n        (3, [1, -1, 0, 1], \"x^3-x^2+1\"),\n    ]\n\n    for i, (n, coeffs, expected) in enumerate(test_cases):\n        result = polynomial_to_string(n, coeffs)\n\n        assert result == expected, f\"Test case {i + 1} failed: expected {expected}, got {result}\"\n        print(f\"Test case {i + 1} passed: expected {expected}, got {result}\")\n\n\ncheck()", "instruction": "Observe the following faulty Python code and its example\ncode:\n```python\nfrom typing import List \ndef polynomial_to_string(n: int, coeffs: List[int]) -> str:\n    \n    result = []\n\n    for i in range(n + 1):\n        coeff = coeffs[i]\n        degree = n - i\n\n        if coeff == 0:\n            continue\n        sign = '-' if coeff < 0 else '+'\n        if i == 0:\n            sign = '-' if coeff < 0 else ''\n        \n        abs_coeff = abs(coeff)\n        if abs_coeff == 1 and degree != 0:\n            abs_coeff_str = ''\n        else:\n            abs_coeff_str = str(abs_coeff)\n        \n        if degree == 0:\n            term = abs_coeff_str\n        elif degree == 1:\n            term = f\"{abs_coeff_str}x\"\n        else:\n            term = f\"{abs_coeff_str}x^{degree}\"\n\n        result.append(f\"{sign}{term}\")\n\n        return ''.join(result)\n```\ncode example:\nExamples:\n        >>> polynomial_to_string(5, [100, -1, 1, -3, 0, 10])\n        '100x^5-x^4+x^3-3x^2+10'\n\n        >>> polynomial_to_string(3, [-50, 0, 0, 1])\n        '-50x^3+1'\nFix bugs in the given code snippet. The fixed code must be placed between ```python```. Do not generate any test, main,example usage or check code!\n"}
